//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package syncmap ;import _f "sync";type RuneByteMap struct{_eec map[rune ]byte ;_be _f .RWMutex ;};func (_fdg *RuneUint16Map )Read (r rune )(uint16 ,bool ){_fdg ._gbe .RLock ();defer _fdg ._gbe .RUnlock ();_eaa ,_gg :=_fdg ._dd [r ];return _eaa ,_gg ;};
func (_cc *RuneByteMap )Range (f func (_db rune ,_ea byte )(_bf bool )){_cc ._be .RLock ();defer _cc ._be .RUnlock ();for _beg ,_dfb :=range _cc ._eec {if f (_beg ,_dfb ){break ;};};};func (_gad *RuneByteMap )Read (r rune )(byte ,bool ){_gad ._be .RLock ();
defer _gad ._be .RUnlock ();_df ,_c :=_gad ._eec [r ];return _df ,_c ;};func NewRuneStringMap (m map[rune ]string )*RuneStringMap {return &RuneStringMap {_dag :m }};func (_fbg *StringsMap )Copy ()*StringsMap {_fbg ._cfb .RLock ();defer _fbg ._cfb .RUnlock ();
_ca :=map[string ]string {};for _ac ,_ggf :=range _fbg ._dbf {_ca [_ac ]=_ggf ;};return &StringsMap {_dbf :_ca };};func MakeRuneSet (length int )*RuneSet {return &RuneSet {_fdc :make (map[rune ]struct{},length )}};func (_da *RuneByteMap )Write (r rune ,b byte ){_da ._be .Lock ();
defer _da ._be .Unlock ();_da ._eec [r ]=b ;};func NewByteRuneMap (m map[byte ]rune )*ByteRuneMap {return &ByteRuneMap {_g :m }};func MakeByteRuneMap (length int )*ByteRuneMap {return &ByteRuneMap {_g :make (map[byte ]rune ,length )}};func (_gaf *RuneByteMap )Length ()int {_gaf ._be .RLock ();
defer _gaf ._be .RUnlock ();return len (_gaf ._eec );};func (_d *ByteRuneMap )Write (b byte ,r rune ){_d ._e .Lock ();defer _d ._e .Unlock ();_d ._g [b ]=r };type RuneUint16Map struct{_dd map[rune ]uint16 ;_gbe _f .RWMutex ;};func (_gec *StringRuneMap )Length ()int {_gec ._fg .RLock ();
defer _gec ._fg .RUnlock ();return len (_gec ._af );};func (_egc *StringsMap )Write (g1 ,g2 string ){_egc ._cfb .Lock ();defer _egc ._cfb .Unlock ();_egc ._dbf [g1 ]=g2 ;};func (_cb *RuneUint16Map )Delete (r rune ){_cb ._gbe .Lock ();defer _cb ._gbe .Unlock ();
delete (_cb ._dd ,r );};func (_dg *RuneSet )Range (f func (_bd rune )(_ag bool )){_dg ._cd .RLock ();defer _dg ._cd .RUnlock ();for _ab :=range _dg ._fdc {if f (_ab ){break ;};};};func (_gbc *ByteRuneMap )Length ()int {_gbc ._e .RLock ();defer _gbc ._e .RUnlock ();
return len (_gbc ._g )};func (_bbd *StringRuneMap )Read (g string )(rune ,bool ){_bbd ._fg .RLock ();defer _bbd ._fg .RUnlock ();_ff ,_faf :=_bbd ._af [g ];return _ff ,_faf ;};func (_agd *StringRuneMap )Write (g string ,r rune ){_agd ._fg .Lock ();defer _agd ._fg .Unlock ();
_agd ._af [g ]=r ;};func (_ebb *RuneStringMap )Length ()int {_ebb ._dgg .RLock ();defer _ebb ._dgg .RUnlock ();return len (_ebb ._dag );};type RuneStringMap struct{_dag map[rune ]string ;_dgg _f .RWMutex ;};func MakeRuneUint16Map (length int )*RuneUint16Map {return &RuneUint16Map {_dd :make (map[rune ]uint16 ,length )};
};func NewStringRuneMap (m map[string ]rune )*StringRuneMap {return &StringRuneMap {_af :m }};func NewStringsMap (tuples []StringsTuple )*StringsMap {_afc :=map[string ]string {};for _ ,_fe :=range tuples {_afc [_fe .Key ]=_fe .Value ;};return &StringsMap {_dbf :_afc };
};func (_gc *RuneUint16Map )Write (r rune ,g uint16 ){_gc ._gbe .Lock ();defer _gc ._gbe .Unlock ();_gc ._dd [r ]=g ;};func MakeRuneByteMap (length int )*RuneByteMap {_ge :=make (map[rune ]byte ,length );return &RuneByteMap {_eec :_ge };};func (_eb *ByteRuneMap )Range (f func (_fd byte ,_fb rune )(_ee bool )){_eb ._e .RLock ();
defer _eb ._e .RUnlock ();for _dc ,_bad :=range _eb ._g {if f (_dc ,_bad ){break ;};};};func (_fcf *RuneUint16Map )Range (f func (_ae rune ,_age uint16 )(_bc bool )){_fcf ._gbe .RLock ();defer _fcf ._gbe .RUnlock ();for _ddc ,_gab :=range _fcf ._dd {if f (_ddc ,_gab ){break ;
};};};func (_dcg *StringsMap )Range (f func (_deb ,_fcb string )(_gf bool )){_dcg ._cfb .RLock ();defer _dcg ._cfb .RUnlock ();for _aed ,_dbc :=range _dcg ._dbf {if f (_aed ,_dbc ){break ;};};};func (_baa *RuneUint16Map )Length ()int {_baa ._gbe .RLock ();
defer _baa ._gbe .RUnlock ();return len (_baa ._dd );};func (_fc *RuneStringMap )Write (r rune ,s string ){_fc ._dgg .Lock ();defer _fc ._dgg .Unlock ();_fc ._dag [r ]=s ;};func (_fcg *StringsMap )Read (g string )(string ,bool ){_fcg ._cfb .RLock ();defer _fcg ._cfb .RUnlock ();
_daf ,_dce :=_fcg ._dbf [g ];return _daf ,_dce ;};type ByteRuneMap struct{_g map[byte ]rune ;_e _f .RWMutex ;};type StringRuneMap struct{_af map[string ]rune ;_fg _f .RWMutex ;};func (_fcd *RuneUint16Map )RangeDelete (f func (_ec rune ,_dcaf uint16 )(_eg bool ,_ded bool )){_fcd ._gbe .Lock ();
defer _fcd ._gbe .Unlock ();for _ecg ,_fa :=range _fcd ._dd {_dfbd ,_ce :=f (_ecg ,_fa );if _dfbd {delete (_fcd ._dd ,_ecg );};if _ce {break ;};};};func (_dad *RuneSet )Write (r rune ){_dad ._cd .Lock ();defer _dad ._cd .Unlock ();_dad ._fdc [r ]=struct{}{};
};type StringsMap struct{_dbf map[string ]string ;_cfb _f .RWMutex ;};func (_dfe *RuneSet )Length ()int {_dfe ._cd .RLock ();defer _dfe ._cd .RUnlock ();return len (_dfe ._fdc )};type StringsTuple struct{Key ,Value string ;};type RuneSet struct{_fdc map[rune ]struct{};
_cd _f .RWMutex ;};func (_a *RuneSet )Exists (r rune )bool {_a ._cd .RLock ();defer _a ._cd .RUnlock ();_ ,_dca :=_a ._fdc [r ];return _dca ;};func (_fbb *RuneStringMap )Range (f func (_bdb rune ,_ebc string )(_de bool )){_fbb ._dgg .RLock ();defer _fbb ._dgg .RUnlock ();
for _ed ,_eegc :=range _fbb ._dag {if f (_ed ,_eegc ){break ;};};};func (_eeg *RuneStringMap )Read (r rune )(string ,bool ){_eeg ._dgg .RLock ();defer _eeg ._dgg .RUnlock ();_bb ,_aga :=_eeg ._dag [r ];return _bb ,_aga ;};func (_ba *ByteRuneMap )Read (b byte )(rune ,bool ){_ba ._e .RLock ();
defer _ba ._e .RUnlock ();_gb ,_ga :=_ba ._g [b ];return _gb ,_ga ;};func (_cca *StringRuneMap )Range (f func (_fgb string ,_bac rune )(_ad bool )){_cca ._fg .RLock ();defer _cca ._fg .RUnlock ();for _eaaf ,_cf :=range _cca ._af {if f (_eaaf ,_cf ){break ;
};};};