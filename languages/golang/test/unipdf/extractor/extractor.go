//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package extractor is used for quickly extracting PDF content through a simple interface.
// Currently offers functionality for extracting textual content.
package extractor

import (
	_f "bytes"
	_d "errors"
	_eb "fmt"
	_fe "golang.org/x/image/draw"
	_gg "golang.org/x/text/unicode/norm"
	_fd "golang.org/x/xerrors"
	_b "lgo/test/unipdf/common"
	_de "lgo/test/unipdf/contentstream"
	_fb "lgo/test/unipdf/core"
	_ac "lgo/test/unipdf/internal/license"
	_fa "lgo/test/unipdf/internal/textencoding"
	_cbc "lgo/test/unipdf/internal/transform"
	_ba "lgo/test/unipdf/model"
	_ga "image"
	_ea "image/color"
	_ge "io"
	_cc "math"
	_cb "reflect"
	_gf "regexp"
	_c "sort"
	_a "strings"
	_e "unicode"
	_dc "unicode/utf8"
)

func (_fgea *stateStack) push(_aac *textState) { _bdd := *_aac; *_fgea = append(*_fgea, &_bdd) }
func (_ecdg rulingList) secMinMax() (float64, float64) {
	_acaa, _baead := _ecdg[0]._bgbbf, _ecdg[0]._dffbe
	for _, _aacfb := range _ecdg[1:] {
		if _aacfb._bgbbf < _acaa {
			_acaa = _aacfb._bgbbf
		}
		if _aacfb._dffbe > _baead {
			_baead = _aacfb._dffbe
		}
	}
	return _acaa, _baead
}
func (_aadd *textObject) moveLP(_gedd, _adde float64) {
	_aadd._gfeb.Concat(_cbc.NewMatrix(1, 0, 0, 1, _gedd, _adde))
	_aadd._deb = _aadd._gfeb
}
func _gbec(_cfdd, _aegaa *textPara) bool { return _fgfea(_cfdd._geea, _aegaa._geea) }
func (_eebb *textPara) getListLines() []*textLine {
	var _ecab []*textLine
	_ecbg := _dggg(_eebb._eeedg)
	for _, _eefe := range _eebb._eeedg {
		_bcebg := _eefe._bcce[0]._cdfe[0]
		if _acgf(_bcebg) {
			_ecab = append(_ecab, _eefe)
		}
	}
	_ecab = append(_ecab, _ecbg...)
	return _ecab
}
func _egbb(_adbc, _ggfee _ba.PdfRectangle) bool {
	return _adbc.Llx <= _ggfee.Llx && _ggfee.Urx <= _adbc.Urx && _adbc.Lly <= _ggfee.Lly && _ggfee.Ury <= _adbc.Ury
}
func _cdad(_adf, _bebge bounded) float64 { return _bgca(_adf) - _bgca(_bebge) }

// String returns a string descibing `i`.
func (_eegc gridTile) String() string {
	_baabf := func(_gfee bool, _bdfee string) string {
		if _gfee {
			return _bdfee
		}
		return "\u005f"
	}
	return _eb.Sprintf("\u00256\u002e2\u0066\u0020\u0025\u0031\u0073%\u0031\u0073%\u0031\u0073\u0025\u0031\u0073", _eegc.PdfRectangle, _baabf(_eegc._cbaf, "\u004c"), _baabf(_eegc._ceead, "\u0052"), _baabf(_eegc._edddc, "\u0042"), _baabf(_eegc._begf, "\u0054"))
}
func _gcef(_cbe *textLine) bool {
	_abgfg := true
	_ebgb := -1
	for _, _fgad := range _cbe._bcce {
		for _, _ceb := range _fgad._ebca {
			_afag := _ceb._gcfa
			if _ebgb == -1 {
				_ebgb = _afag
			} else {
				if _ebgb != _afag {
					_abgfg = false
					break
				}
			}
		}
	}
	return _abgfg
}
func _bfebf(_cadg, _eaab float64) bool { return _cc.Abs(_cadg-_eaab) <= _beba }
func (_dadbc paraList) findGridTables(_aabfc []gridTiling) []*textTable {
	if _egdf {
		_b.Log.Info("\u0066i\u006e\u0064\u0047\u0072\u0069\u0064\u0054\u0061\u0062\u006c\u0065s\u003a\u0020\u0025\u0064\u0020\u0070\u0061\u0072\u0061\u0073", len(_dadbc))
		for _ccaf, _bcge := range _dadbc {
			_eb.Printf("\u0025\u0034\u0064\u003a\u0020\u0025\u0073\u000a", _ccaf, _bcge)
		}
	}
	var _cdda []*textTable
	for _fgeaeg, _decg := range _aabfc {
		_efgfc, _eaca := _dadbc.findTableGrid(_decg)
		if _efgfc != nil {
			_efgfc.log(_eb.Sprintf("\u0066\u0069\u006e\u0064Ta\u0062\u006c\u0065\u0057\u0069\u0074\u0068\u0047\u0072\u0069\u0064\u0073\u003a\u0020%\u0064", _fgeaeg))
			_cdda = append(_cdda, _efgfc)
			_efgfc.markCells()
		}
		for _dceec := range _eaca {
			_dceec._fcag = true
		}
	}
	if _egdf {
		_b.Log.Info("\u0066i\u006e\u0064\u0047\u0072i\u0064\u0054\u0061\u0062\u006ce\u0073:\u0020%\u0064\u0020\u0074\u0061\u0062\u006c\u0065s", len(_cdda))
	}
	return _cdda
}
func (_agea paraList) computeEBBoxes() {
	if _aedad {
		_b.Log.Info("\u0063o\u006dp\u0075\u0074\u0065\u0045\u0042\u0042\u006f\u0078\u0065\u0073\u003a")
	}
	for _, _fbag := range _agea {
		_fbag._geea = _fbag.PdfRectangle
	}
	_gfdd := _agea.yNeighbours(0)
	for _fegc, _gafc := range _agea {
		_fbcb := _gafc._geea
		_fdd, _afaef := -1.0e9, +1.0e9
		for _, _bdaf := range _gfdd[_gafc] {
			_dgge := _agea[_bdaf]._geea
			if _dgge.Urx < _fbcb.Llx {
				_fdd = _cc.Max(_fdd, _dgge.Urx)
			} else if _fbcb.Urx < _dgge.Llx {
				_afaef = _cc.Min(_afaef, _dgge.Llx)
			}
		}
		for _bacbf, _edcgcd := range _agea {
			_abagc := _edcgcd._geea
			if _fegc == _bacbf || _abagc.Ury > _fbcb.Lly {
				continue
			}
			if _fdd <= _abagc.Llx && _abagc.Llx < _fbcb.Llx {
				_fbcb.Llx = _abagc.Llx
			} else if _abagc.Urx <= _afaef && _fbcb.Urx < _abagc.Urx {
				_fbcb.Urx = _abagc.Urx
			}
		}
		if _aedad {
			_eb.Printf("\u0025\u0034\u0064\u003a %\u0036\u002e\u0032\u0066\u2192\u0025\u0036\u002e\u0032\u0066\u0020\u0025\u0071\u000a", _fegc, _gafc._geea, _fbcb, _eaacd(_gafc.text(), 50))
		}
		_gafc._geea = _fbcb
	}
	if _egba {
		for _, _daff := range _agea {
			_daff.PdfRectangle = _daff._geea
		}
	}
}
func _gea(_babf _cbc.Point) *subpath { return &subpath{_dgfd: []_cbc.Point{_babf}} }
func _cbda(_cgcf []*textLine, _ccebd map[float64][]*textLine, _gfae []float64, _ceec int, _dbbb, _dbgca float64) []*list {
	_fffe := []*list{}
	_ddfc := _ceec
	_ceec = _ceec + 1
	_cbec := _gfae[_ddfc]
	_ggea := _ccebd[_cbec]
	_bcee := _accc(_ggea, _dbgca, _dbbb)
	for _cffe, _gdcb := range _bcee {
		var _fgec float64
		_dbac := []*list{}
		_dgfc := _gdcb._gfeac
		_bbga := _dbgca
		if _cffe < len(_bcee)-1 {
			_bbga = _bcee[_cffe+1]._gfeac
		}
		if _ceec < len(_gfae) {
			_dbac = _cbda(_cgcf, _ccebd, _gfae, _ceec, _dgfc, _bbga)
		}
		_fgec = _bbga
		if len(_dbac) > 0 {
			_dcfd := _dbac[0]
			if len(_dcfd._fcda) > 0 {
				_fgec = _dcfd._fcda[0]._gfeac
			}
		}
		_afgeb := []*textLine{_gdcb}
		_adcb := _bgebc(_gdcb, _cgcf, _gfae, _dgfc, _fgec)
		_afgeb = append(_afgeb, _adcb...)
		_gfgg := _ded(_afgeb, "\u0062\u0075\u006c\u006c\u0065\u0074", _dbac)
		_gfgg._fagf = _fbcge(_afgeb, "")
		_fffe = append(_fffe, _gfgg)
	}
	return _fffe
}
func (_dfde rulingList) tidied(_fabae string) rulingList {
	_abfdc := _dfde.removeDuplicates()
	_abfdc.log("\u0075n\u0069\u0071\u0075\u0065\u0073")
	_cabbc := _abfdc.snapToGroups()
	if _cabbc == nil {
		return nil
	}
	_cabbc.sort()
	if _ccc {
		_b.Log.Info("\u0074\u0069\u0064i\u0065\u0064\u003a\u0020\u0025\u0071\u0020\u0076\u0065\u0063\u0073\u003d\u0025\u0064\u0020\u0075\u006e\u0069\u0071\u0075\u0065\u0073\u003d\u0025\u0064\u0020\u0063\u006f\u0061l\u0065\u0073\u0063\u0065\u0064\u003d\u0025\u0064", _fabae, len(_dfde), len(_abfdc), len(_cabbc))
	}
	_cabbc.log("\u0063o\u0061\u006c\u0065\u0073\u0063\u0065d")
	return _cabbc
}
func (_beaa *PageText) computeViews() {
	_dfad := _beaa.getParagraphs()
	_gdbd := new(_f.Buffer)
	_dfad.writeText(_gdbd)
	_beaa._bab = _gdbd.String()
	_beaa._bdbb = _dfad.toTextMarks()
	_beaa._efbd = _dfad.tables()
	if _egdf {
		_b.Log.Info("\u0063\u006f\u006dpu\u0074\u0065\u0056\u0069\u0065\u0077\u0073\u003a\u0020\u0074\u0061\u0062\u006c\u0065\u0073\u003d\u0025\u0064", len(_beaa._efbd))
	}
}
func (_dbfe paraList) lines() []*textLine {
	var _aeae []*textLine
	for _, _cafb := range _dbfe {
		_aeae = append(_aeae, _cafb._eeedg...)
	}
	return _aeae
}

type textPara struct {
	_ba.PdfRectangle
	_geea  _ba.PdfRectangle
	_eeedg []*textLine
	_beefb *textTable
	_fcag  bool
	_fcbg  bool
	_dcdd  *textPara
	_dfcb  *textPara
	_ebcc  *textPara
	_bfcbb *textPara
	_aedb  []list
}

func _ebac(_gdace, _ecdff int) int {
	if _gdace < _ecdff {
		return _gdace
	}
	return _ecdff
}
func _aeef(_cfgd float64) bool         { return _cc.Abs(_cfgd) < _ebbd }
func _aaega(_ddbed, _bddfe int) uint64 { return uint64(_ddbed)*0x1000000 + uint64(_bddfe) }
func (_dbgd *subpath) removeDuplicates() {
	if len(_dbgd._dgfd) == 0 {
		return
	}
	_bfa := []_cbc.Point{_dbgd._dgfd[0]}
	for _, _deca := range _dbgd._dgfd[1:] {
		if !_cggca(_deca, _bfa[len(_bfa)-1]) {
			_bfa = append(_bfa, _deca)
		}
	}
	_dbgd._dgfd = _bfa
}
func (_bceea *textWord) absorb(_gaabb *textWord) {
	_bceea.PdfRectangle = _eece(_bceea.PdfRectangle, _gaabb.PdfRectangle)
	_bceea._ebca = append(_bceea._ebca, _gaabb._ebca...)
}
func (_fdaa *wordBag) maxDepth() float64 { return _fdaa._agdfc - _fdaa.Lly }

// String returns a description of `w`.
func (_eddbb *textWord) String() string {
	return _eb.Sprintf("\u0025\u002e2\u0066\u0020\u0025\u0036\u002e\u0032\u0066\u0020\u0066\u006f\u006e\u0074\u0073\u0069\u007a\u0065\u003d\u0025\u002e\u0032\u0066\u0020\"%\u0073\u0022", _eddbb._gadaf, _eddbb.PdfRectangle, _eddbb._affe, _eddbb._cdfe)
}
func (_fgbda *textTable) computeBbox() _ba.PdfRectangle {
	var _gfagb _ba.PdfRectangle
	_eaacb := false
	for _bbbge := 0; _bbbge < _fgbda._ggeg; _bbbge++ {
		for _cggce := 0; _cggce < _fgbda._gdab; _cggce++ {
			_dedef := _fgbda.get(_cggce, _bbbge)
			if _dedef == nil {
				continue
			}
			if !_eaacb {
				_gfagb = _dedef.PdfRectangle
				_eaacb = true
			} else {
				_gfagb = _eece(_gfagb, _dedef.PdfRectangle)
			}
		}
	}
	return _gfagb
}
func _dce(_ebe []Font, _bea string) bool {
	for _, _dfg := range _ebe {
		if _dfg.FontName == _bea {
			return true
		}
	}
	return false
}
func (_ceaa *textObject) getFont(_cbd string) (*_ba.PdfFont, error) {
	if _ceaa._egff._dgg != nil {
		_gebg, _gec := _ceaa.getFontDict(_cbd)
		if _gec != nil {
			_b.Log.Debug("\u0045\u0052\u0052OR\u003a\u0020\u0067\u0065\u0074\u0046\u006f\u006e\u0074:\u0020n\u0061m\u0065=\u0025\u0073\u002c\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0073", _cbd, _gec.Error())
			return nil, _gec
		}
		_ceaa._egff._bce++
		_eedc, _cgff := _ceaa._egff._dgg[_gebg.String()]
		if _cgff {
			_eedc._gddg = _ceaa._egff._bce
			return _eedc._eeba, nil
		}
	}
	_abdd, _fcde := _ceaa.getFontDict(_cbd)
	if _fcde != nil {
		return nil, _fcde
	}
	_cedf, _fcde := _ceaa.getFontDirect(_cbd)
	if _fcde != nil {
		return nil, _fcde
	}
	if _ceaa._egff._dgg != nil {
		_daad := fontEntry{_cedf, _ceaa._egff._bce}
		if len(_ceaa._egff._dgg) >= _cab {
			var _ffgf []string
			for _bfge := range _ceaa._egff._dgg {
				_ffgf = append(_ffgf, _bfge)
			}
			_c.Slice(_ffgf, func(_daee, _gcae int) bool {
				return _ceaa._egff._dgg[_ffgf[_daee]]._gddg < _ceaa._egff._dgg[_ffgf[_gcae]]._gddg
			})
			delete(_ceaa._egff._dgg, _ffgf[0])
		}
		_ceaa._egff._dgg[_abdd.String()] = _daad
	}
	return _cedf, nil
}
func (_dcea paraList) merge() *textPara {
	_b.Log.Trace("\u006d\u0065\u0072\u0067\u0065:\u0020\u0070\u0061\u0072\u0061\u0073\u003d\u0025\u0064\u0020\u003d\u003d\u003d=\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u0078\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d", len(_dcea))
	if len(_dcea) == 0 {
		return nil
	}
	_dcea.sortReadingOrder()
	_afagb := _dcea[0].PdfRectangle
	_dcbe := _dcea[0]._eeedg
	for _, _gedb := range _dcea[1:] {
		_afagb = _eece(_afagb, _gedb.PdfRectangle)
		_dcbe = append(_dcbe, _gedb._eeedg...)
	}
	return _bggc(_afagb, _dcbe)
}
func _bbdg(_ggfeed, _edgd _cbc.Point) bool {
	_acafd := _cc.Abs(_ggfeed.X - _edgd.X)
	_bgab := _cc.Abs(_ggfeed.Y - _edgd.Y)
	return _bfff(_acafd, _bgab)
}
func (_aeg *stateStack) empty() bool { return len(*_aeg) == 0 }
func (_agba paraList) sortTopoOrder() {
	_dfdga := _agba.topoOrder()
	_agba.reorder(_dfdga)
}
func _bebb(_cdgg, _cgcb float64) string {
	_fdeb := !_gabfc(_cdgg - _cgcb)
	if _fdeb {
		return "\u000a"
	}
	return "\u0020"
}
func (_gfb *wordBag) scanBand(_bgc string, _cdd *wordBag, _gcg func(_bgbb *wordBag, _aggd *textWord) bool, _dccgd, _gabe, _cabd float64, _eaged, _bac bool) int {
	_gfea := _cdd._cdc
	var _eebe map[int]map[*textWord]struct{}
	if !_eaged {
		_eebe = _gfb.makeRemovals()
	}
	_aedf := _dcee * _gfea
	_ffeb := 0
	for _, _abba := range _gfb.depthBand(_dccgd-_aedf, _gabe+_aedf) {
		if len(_gfb._agfg[_abba]) == 0 {
			continue
		}
		for _, _fafed := range _gfb._agfg[_abba] {
			if !(_dccgd-_aedf <= _fafed._gadaf && _fafed._gadaf <= _gabe+_aedf) {
				continue
			}
			if !_gcg(_cdd, _fafed) {
				continue
			}
			_geded := 2.0 * _cc.Abs(_fafed._affe-_cdd._cdc) / (_fafed._affe + _cdd._cdc)
			_edcc := _cc.Max(_fafed._affe/_cdd._cdc, _cdd._cdc/_fafed._affe)
			_gcbg := _cc.Min(_geded, _edcc)
			if _cabd > 0 && _gcbg > _cabd {
				continue
			}
			if _cdd.blocked(_fafed) {
				continue
			}
			if !_eaged {
				_cdd.pullWord(_fafed, _abba, _eebe)
			}
			_ffeb++
			if !_bac {
				if _fafed._gadaf < _dccgd {
					_dccgd = _fafed._gadaf
				}
				if _fafed._gadaf > _gabe {
					_gabe = _fafed._gadaf
				}
			}
			if _eaged {
				break
			}
		}
	}
	if !_eaged {
		_gfb.applyRemovals(_eebe)
	}
	return _ffeb
}
func (_cca *wordBag) minDepth() float64 { return _cca._agdfc - (_cca.Ury - _cca._cdc) }
func _gecef(_feffd, _ccdg, _efcce float64) rulingKind {
	if _feffd >= _efcce && _bfff(_ccdg, _feffd) {
		return _deg
	}
	if _ccdg >= _efcce && _bfff(_feffd, _ccdg) {
		return _aagff
	}
	return _affd
}

type structTreeRoot struct {
	_cfag []structElement
	_cdaf string
}
type markKind int

func (_aacbb *textTable) toTextTable() TextTable {
	if _egdf {
		_b.Log.Info("t\u006fT\u0065\u0078\u0074\u0054\u0061\u0062\u006c\u0065:\u0020\u0025\u0064\u0020x \u0025\u0064", _aacbb._gdab, _aacbb._ggeg)
	}
	_gafe := make([][]TableCell, _aacbb._ggeg)
	for _dadd := 0; _dadd < _aacbb._ggeg; _dadd++ {
		_gafe[_dadd] = make([]TableCell, _aacbb._gdab)
		for _dgdf := 0; _dgdf < _aacbb._gdab; _dgdf++ {
			_dgegc := _aacbb.get(_dgdf, _dadd)
			if _dgegc == nil {
				continue
			}
			if _egdf {
				_eb.Printf("\u0025\u0034\u0064 \u0025\u0032\u0064\u003a\u0020\u0025\u0073\u000a", _dgdf, _dadd, _dgegc)
			}
			_gafe[_dadd][_dgdf].Text = _dgegc.text()
			_bfega := 0
			_gafe[_dadd][_dgdf].Marks._fcca = _dgegc.toTextMarks(&_bfega)
		}
	}
	_bgda := TextTable{W: _aacbb._gdab, H: _aacbb._ggeg, Cells: _gafe}
	_bgda.PdfRectangle = _aacbb.bbox()
	return _bgda
}

type structElement struct {
	_dfgd string
	_agcf []structElement
	_gdf  int64
	_ddbe _fb.PdfObject
}
type lineRuling struct {
	_cbgdb rulingKind
	_ccffc markKind
	_ea.Color
	_addc, _bfgab _cbc.Point
}

var _gdgcc = map[rulingKind]string{_affd: "\u006e\u006f\u006e\u0065", _deg: "\u0068\u006f\u0072\u0069\u007a\u006f\u006e\u0074\u0061\u006c", _aagff: "\u0076\u0065\u0072\u0074\u0069\u0063\u0061\u006c"}

func (_fae *TextMarkArray) exists(_ddg TextMark) bool {
	for _, _cbb := range _fae.Elements() {
		if _cb.DeepEqual(_ddg.DirectObject, _cbb.DirectObject) && _cb.DeepEqual(_ddg.BBox, _cbb.BBox) && _cbb.Text == _ddg.Text {
			return true
		}
	}
	return false
}

// Len returns the number of TextMarks in `ma`.
func (_bedd *TextMarkArray) Len() int {
	if _bedd == nil {
		return 0
	}
	return len(_bedd._fcca)
}
func (_gad *textObject) showTextAdjusted(_ebgg *_fb.PdfObjectArray, _bbfc int) error {
	_cadbg := false
	for _, _aada := range _ebgg.Elements() {
		switch _aada.(type) {
		case *_fb.PdfObjectFloat, *_fb.PdfObjectInteger:
			_deff, _bgg := _fb.GetNumberAsFloat(_aada)
			if _bgg != nil {
				_b.Log.Debug("\u0045\u0052\u0052\u004fR\u003a\u0020\u0073\u0068\u006f\u0077\u0054\u0065\u0078t\u0041\u0064\u006a\u0075\u0073\u0074\u0065\u0064\u002e\u0020\u0042\u0061\u0064\u0020\u006e\u0075\u006d\u0065r\u0069\u0063\u0061\u006c\u0020a\u0072\u0067\u002e\u0020\u006f\u003d\u0025\u0073\u0020\u0061\u0072\u0067\u0073\u003d\u0025\u002b\u0076", _aada, _ebgg)
				return _bgg
			}
			_fgag, _abg := -_deff*0.001*_gad._fggf._fgeg, 0.0
			if _cadbg {
				_abg, _fgag = _fgag, _abg
			}
			_eabc := _bcec(_cbc.Point{X: _fgag, Y: _abg})
			_gad._deb.Concat(_eabc)
		case *_fb.PdfObjectString:
			_ced := _fb.TraceToDirectObject(_aada)
			_ggcd, _dcg := _fb.GetStringBytes(_ced)
			if !_dcg {
				_b.Log.Trace("s\u0068\u006f\u0077\u0054\u0065\u0078\u0074\u0041\u0064j\u0075\u0073\u0074\u0065\u0064\u003a\u0020Ba\u0064\u0020\u0073\u0074r\u0069\u006e\u0067\u0020\u0061\u0072\u0067\u002e\u0020o=\u0025\u0073 \u0061\u0072\u0067\u0073\u003d\u0025\u002b\u0076", _aada, _ebgg)
				return _fb.ErrTypeError
			}
			_gad.renderText(_ced, _ggcd, _bbfc)
		default:
			_b.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0073\u0068\u006f\u0077\u0054\u0065\u0078\u0074A\u0064\u006a\u0075\u0073\u0074\u0065\u0064\u002e\u0020\u0055\u006e\u0065\u0078p\u0065\u0063\u0074\u0065\u0064\u0020\u0074\u0079\u0070\u0065\u0020\u0028%T\u0029\u0020\u0061\u0072\u0067\u0073\u003d\u0025\u002b\u0076", _aada, _ebgg)
			return _fb.ErrTypeError
		}
	}
	return nil
}
func (_dffb *textLine) pullWord(_badg *wordBag, _gcfd *textWord, _fcad int) {
	_dffb.appendWord(_gcfd)
	_badg.removeWord(_gcfd, _fcad)
}
func _bfff(_abcda, _dgegbd float64) bool { return _abcda/_cc.Max(_deag, _dgegbd) < _aca }
func (_fdae paraList) findTables(_dced []gridTiling) []*textTable {
	_fdae.addNeighbours()
	_c.Slice(_fdae, func(_deac, _cfdb int) bool { return _aacb(_fdae[_deac], _fdae[_cfdb]) < 0 })
	var _adfg []*textTable
	if _efgfg {
		_gbfe := _fdae.findGridTables(_dced)
		_adfg = append(_adfg, _gbfe...)
	}
	if _ebfe {
		_dabg := _fdae.findTextTables()
		_adfg = append(_adfg, _dabg...)
	}
	return _adfg
}
func (_adag *textLine) toTextMarks(_aecg *int) []TextMark {
	var _faba []TextMark
	for _, _dgcd := range _adag._bcce {
		if _dgcd._fggcb {
			_faba = _faacg(_faba, _aecg, "\u0020")
		}
		_cdff := _dgcd.toTextMarks(_aecg)
		_faba = append(_faba, _cdff...)
	}
	return _faba
}
func (_ad *imageExtractContext) extractInlineImage(_fec *_de.ContentStreamInlineImage, _aga _de.GraphicsState, _fecg *_ba.PdfPageResources) error {
	_gfdg, _aba := _fec.ToImage(_fecg)
	if _aba != nil {
		return _aba
	}
	_fbf, _aba := _fec.GetColorSpace(_fecg)
	if _aba != nil {
		return _aba
	}
	if _fbf == nil {
		_fbf = _ba.NewPdfColorspaceDeviceGray()
	}
	_gcd, _aba := _fbf.ImageToRGB(*_gfdg)
	if _aba != nil {
		return _aba
	}
	_ceg := ImageMark{Image: &_gcd, Width: _aga.CTM.ScalingFactorX(), Height: _aga.CTM.ScalingFactorY(), Angle: _aga.CTM.Angle()}
	_ceg.X, _ceg.Y = _aga.CTM.Translation()
	_ad._cgg = append(_ad._cgg, _ceg)
	_ad._gef++
	return nil
}

var _defb *_gf.Regexp = _gf.MustCompile(_fgfae + "\u007c" + _fega)

func _faacg(_aefe []TextMark, _ggeaf *int, _cbgb string) []TextMark {
	_gag := _dfae
	_gag.Text = _cbgb
	return _ebbde(_aefe, _ggeaf, _gag)
}
func _ded(_gccce []*textLine, _ggfg string, _egdb []*list) *list {
	return &list{_fcda: _gccce, _gfdb: _ggfg, _gfgd: _egdb}
}

// ExtractPageText returns the text contents of `e` (an Extractor for a page) as a PageText.
// TODO(peterwilliams97): The stats complicate this function signature and aren't very useful.
//
//	Replace with a function like Extract() (*PageText, error)
func (_gcf *Extractor) ExtractPageText() (*PageText, int, int, error) {
	_efe, _bgef, _dfd, _ebef := _gcf.extractPageText(_gcf._gb, _gcf._cd, _cbc.IdentityMatrix(), 0)
	if _ebef != nil && _ebef != _ba.ErrColorOutOfRange {
		return nil, 0, 0, _ebef
	}
	if _gcf._bg != nil {
		_efe._gadg._aeac = _gcf._bg.UseSimplerExtractionProcess
	}
	_efe.computeViews()
	_ebef = _agfgd(_efe)
	if _ebef != nil {
		return nil, 0, 0, _ebef
	}
	if _gcf._bg != nil {
		if _gcf._bg.ApplyCropBox && _gcf._bc != nil {
			_efe.ApplyArea(*_gcf._bc)
		}
		_efe._gadg._aeaa = _gcf._bg.DisableDocumentTags
	}
	return _efe, _bgef, _dfd, nil
}
func (_cedee *textTable) getComposite(_ccade, _ggdb int) (paraList, _ba.PdfRectangle) {
	_gcggf, _ddba := _cedee._bbgacd[_aaega(_ccade, _ggdb)]
	if _egdf {
		_eb.Printf("\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0067\u0065\u0074\u0043\u006f\u006d\u0070o\u0073i\u0074\u0065\u0028\u0025\u0064\u002c\u0025\u0064\u0029\u002d\u003e\u0025\u0073\u000a", _ccade, _ggdb, _gcggf.String())
	}
	if !_ddba {
		return nil, _ba.PdfRectangle{}
	}
	return _gcggf.parasBBox()
}
func _gbgfe(_ffefd *textLine, _ecc []*textLine, _dbab []float64) float64 {
	var _eeea float64 = -1
	for _, _fafg := range _ecc {
		if _fafg._gfeac > _ffefd._gfeac {
			if _cc.Round(_fafg.Llx) >= _cc.Round(_ffefd.Llx) {
				_eeea = _fafg._gfeac
			} else {
				break
			}
		}
	}
	return _eeea
}

const (
	_ecace markKind = iota
	_fdcb
	_bdec
	_cffeg
)

func (_baaa *subpath) close() {
	if !_cggca(_baaa._dgfd[0], _baaa.last()) {
		_baaa.add(_baaa._dgfd[0])
	}
	_baaa._eadff = true
	_baaa.removeDuplicates()
}
func (_dcbf *wordBag) makeRemovals() map[int]map[*textWord]struct{} {
	_ddeg := make(map[int]map[*textWord]struct{}, len(_dcbf._agfg))
	for _abaeb := range _dcbf._agfg {
		_ddeg[_abaeb] = make(map[*textWord]struct{})
	}
	return _ddeg
}
func _gabfc(_eddbc float64) bool { return _cc.Abs(_eddbc) < _gadf }
func _fgdb(_bgaafd []_fb.PdfObject) (_beca, _aggfa float64, _fccd error) {
	if len(_bgaafd) != 2 {
		return 0, 0, _eb.Errorf("\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066 \u0070\u0061\u0072\u0061\u006d\u0073\u003a \u0025\u0064", len(_bgaafd))
	}
	_gbba, _fccd := _fb.GetNumbersAsFloat(_bgaafd)
	if _fccd != nil {
		return 0, 0, _fccd
	}
	return _gbba[0], _gbba[1], nil
}

type textMark struct {
	_ba.PdfRectangle
	_dbd    int
	_abfc   string
	_bcbff  string
	_gbfa   *_ba.PdfFont
	_baea   float64
	_gbdg   float64
	_ggab   _cbc.Matrix
	_edaf   _cbc.Point
	_ebgaa  _ba.PdfRectangle
	_dgfdef _ea.Color
	_efbfe  _ea.Color
	_affgg  _fb.PdfObject
	_bgcc   []string
	Tw      float64
	Th      float64
	_gcfa   int
	_edeb   int
}

func (_ababge *textWord) toTextMarks(_dcgbdg *int) []TextMark {
	var _dacf []TextMark
	for _, _bggeg := range _ababge._ebca {
		_dacf = _ebbde(_dacf, _dcgbdg, _bggeg.ToTextMark())
	}
	return _dacf
}
func _bbea(_adga map[int][]float64) []int {
	_gecc := make([]int, len(_adga))
	_aegfe := 0
	for _cbfe := range _adga {
		_gecc[_aegfe] = _cbfe
		_aegfe++
	}
	_c.Ints(_gecc)
	return _gecc
}
func (_defbc *textTable) depth() float64 {
	_cbecd := 1e10
	for _adfge := 0; _adfge < _defbc._gdab; _adfge++ {
		_accg := _defbc.get(_adfge, 0)
		if _accg == nil || _accg._fcbg {
			continue
		}
		_cbecd = _cc.Min(_cbecd, _accg.depth())
	}
	return _cbecd
}
func (_fcacf rulingList) sortStrict() {
	_c.Slice(_fcacf, func(_bddcd, _cdbae int) bool {
		_fbbff, _bgfc := _fcacf[_bddcd], _fcacf[_cdbae]
		_aaab, _ffdd := _fbbff._adad, _bgfc._adad
		if _aaab != _ffdd {
			return _aaab > _ffdd
		}
		_edgba, _dagg := _fbbff._abfa, _bgfc._abfa
		if !_gabfc(_edgba - _dagg) {
			return _edgba < _dagg
		}
		_edgba, _dagg = _fbbff._bgbbf, _bgfc._bgbbf
		if _edgba != _dagg {
			return _edgba < _dagg
		}
		return _fbbff._dffbe < _bgfc._dffbe
	})
}
func (_bfeb *wordBag) removeDuplicates() {
	if _ccab {
		_b.Log.Info("r\u0065m\u006f\u0076\u0065\u0044\u0075\u0070\u006c\u0069c\u0061\u0074\u0065\u0073: \u0025\u0071", _bfeb.text())
	}
	for _, _gddgf := range _bfeb.depthIndexes() {
		if len(_bfeb._agfg[_gddgf]) == 0 {
			continue
		}
		_dgdb := _bfeb._agfg[_gddgf][0]
		_ebcge := _afdc * _dgdb._affe
		_fdab := _dgdb._gadaf
		for _, _dfadd := range _bfeb.depthBand(_fdab, _fdab+_ebcge) {
			_gadb := map[*textWord]struct{}{}
			_acgbg := _bfeb._agfg[_dfadd]
			for _, _gdfea := range _acgbg {
				if _, _ebfba := _gadb[_gdfea]; _ebfba {
					continue
				}
				for _, _deddd := range _acgbg {
					if _, _agbaf := _gadb[_deddd]; _agbaf {
						continue
					}
					if _deddd != _gdfea && _deddd._cdfe == _gdfea._cdfe && _cc.Abs(_deddd.Llx-_gdfea.Llx) < _ebcge && _cc.Abs(_deddd.Urx-_gdfea.Urx) < _ebcge && _cc.Abs(_deddd.Lly-_gdfea.Lly) < _ebcge && _cc.Abs(_deddd.Ury-_gdfea.Ury) < _ebcge {
						_gadb[_deddd] = struct{}{}
					}
				}
			}
			if len(_gadb) > 0 {
				_bfbeb := 0
				for _, _cbcag := range _acgbg {
					if _, _baag := _gadb[_cbcag]; !_baag {
						_acgbg[_bfbeb] = _cbcag
						_bfbeb++
					}
				}
				_bfeb._agfg[_dfadd] = _acgbg[:len(_acgbg)-len(_gadb)]
				if len(_bfeb._agfg[_dfadd]) == 0 {
					delete(_bfeb._agfg, _dfadd)
				}
			}
		}
	}
}
func (_eda *PageFonts) extractPageResourcesToFont(_gfd *_ba.PdfPageResources) error {
	_df, _fc := _fb.GetDict(_gfd.Font)
	if !_fc {
		return _d.New(_fbe)
	}
	for _, _bcb := range _df.Keys() {
		var (
			_gd   = true
			_ab   []byte
			_bcaa string
		)
		_egb, _ef := _gfd.GetFontByName(_bcb)
		if !_ef {
			return _d.New(_cf)
		}
		_gee, _cfa := _ba.NewPdfFontFromPdfObject(_egb)
		if _cfa != nil {
			return _cfa
		}
		_gdb := _gee.FontDescriptor()
		_bge := _gee.FontDescriptor().FontName.String()
		_ee := _gee.Subtype()
		if _dce(_eda.Fonts, _bge) {
			continue
		}
		if len(_gee.ToUnicode()) == 0 {
			_gd = false
		}
		if _gdb.FontFile != nil {
			if _gdg, _abd := _fb.GetStream(_gdb.FontFile); _abd {
				_ab, _cfa = _fb.DecodeStream(_gdg)
				if _cfa != nil {
					return _cfa
				}
				_bcaa = _bge + "\u002e\u0070\u0066\u0062"
			}
		} else if _gdb.FontFile2 != nil {
			if _aea, _gfg := _fb.GetStream(_gdb.FontFile2); _gfg {
				_ab, _cfa = _fb.DecodeStream(_aea)
				if _cfa != nil {
					return _cfa
				}
				_bcaa = _bge + "\u002e\u0074\u0074\u0066"
			}
		} else if _gdb.FontFile3 != nil {
			if _cfc, _faf := _fb.GetStream(_gdb.FontFile3); _faf {
				_ab, _cfa = _fb.DecodeStream(_cfc)
				if _cfa != nil {
					return _cfa
				}
				_bcaa = _bge + "\u002e\u0063\u0066\u0066"
			}
		}
		if len(_bcaa) < 1 {
			_b.Log.Debug(_bdg)
		}
		_fef := Font{FontName: _bge, PdfFont: _gee, IsCID: _gee.IsCID(), IsSimple: _gee.IsSimple(), ToUnicode: _gd, FontType: _ee, FontData: _ab, FontFileName: _bcaa, FontDescriptor: _gdb}
		_eda.Fonts = append(_eda.Fonts, _fef)
	}
	return nil
}

// String returns a human readable description of `ss`.
func (_cbfd *shapesState) String() string {
	return _eb.Sprintf("\u007b\u0025\u0064\u0020su\u0062\u0070\u0061\u0074\u0068\u0073\u0020\u0066\u0072\u0065\u0073\u0068\u003d\u0025t\u007d", len(_cbfd._cgfg), _cbfd._efa)
}
func _dgeab(_edcce map[int][]float64) {
	if len(_edcce) <= 1 {
		return
	}
	_dccee := _bbea(_edcce)
	if _egdf {
		_b.Log.Info("\u0066i\u0078C\u0065\u006c\u006c\u0073\u003a \u006b\u0065y\u0073\u003d\u0025\u002b\u0076", _dccee)
	}
	var _bbfcf, _bgee int
	for _bbfcf, _bgee = range _dccee {
		if _edcce[_bgee] != nil {
			break
		}
	}
	for _cgada, _cagg := range _dccee[_bbfcf:] {
		_eedgd := _edcce[_cagg]
		if _eedgd == nil {
			continue
		}
		if _egdf {
			_eb.Printf("\u0025\u0034\u0064\u003a\u0020\u006b\u0030\u003d\u0025\u0064\u0020\u006b1\u003d\u0025\u0064\u000a", _bbfcf+_cgada, _bgee, _cagg)
		}
		_cecb := _edcce[_cagg]
		if _cecb[len(_cecb)-1] > _eedgd[0] {
			_cecb[len(_cecb)-1] = _eedgd[0]
			_edcce[_bgee] = _cecb
		}
		_bgee = _cagg
	}
}
func (_adbd *shapesState) closePath() {
	if _adbd._efa {
		_adbd._cgfg = append(_adbd._cgfg, _gea(_adbd._efcbf))
		_adbd._efa = false
	} else if len(_adbd._cgfg) == 0 {
		if _adbb {
			_b.Log.Debug("\u0063\u006c\u006f\u0073eP\u0061\u0074\u0068\u0020\u0077\u0069\u0074\u0068\u0020\u006e\u006f\u0020\u0070\u0061t\u0068")
		}
		_adbd._efa = false
		return
	}
	_adbd._cgfg[len(_adbd._cgfg)-1].close()
	if _adbb {
		_b.Log.Info("\u0063\u006c\u006f\u0073\u0065\u0050\u0061\u0074\u0068\u003a\u0020\u0025\u0073", _adbd)
	}
}
func (_afdf *subpath) last() _cbc.Point  { return _afdf._dgfd[len(_afdf._dgfd)-1] }
func _bcec(_gacb _cbc.Point) _cbc.Matrix { return _cbc.TranslationMatrix(_gacb.X, _gacb.Y) }

// PageText represents the layout of text on a device page.
type PageText struct {
	_dafg []*textMark
	_bab  string
	_bdbb []TextMark
	_efbd []TextTable
	_bgaa _ba.PdfRectangle
	_fgaf []pathSection
	_fbce []pathSection
	_gfcf *_fb.PdfObject
	_ead  _fb.PdfObject
	_edfd *_de.ContentStreamOperations
	_gadg PageTextOptions
}

func (_geged rulingList) blocks(_baedf, _cbde *ruling) bool {
	if _baedf._bgbbf > _cbde._dffbe || _cbde._bgbbf > _baedf._dffbe {
		return false
	}
	_ggcgf := _cc.Max(_baedf._bgbbf, _cbde._bgbbf)
	_fddc := _cc.Min(_baedf._dffbe, _cbde._dffbe)
	if _baedf._abfa > _cbde._abfa {
		_baedf, _cbde = _cbde, _baedf
	}
	for _, _gcbd := range _geged {
		if _baedf._abfa <= _gcbd._abfa+_ebbd && _gcbd._abfa <= _cbde._abfa+_ebbd && _gcbd._bgbbf <= _fddc && _ggcgf <= _gcbd._dffbe {
			return true
		}
	}
	return false
}

type paraList []*textPara

func _added(_eadc []float64, _ddcd, _cbaca float64) []float64 {
	_bcecab, _dgfcd := _ddcd, _cbaca
	if _dgfcd < _bcecab {
		_bcecab, _dgfcd = _dgfcd, _bcecab
	}
	_bfcbe := make([]float64, 0, len(_eadc)+2)
	_bfcbe = append(_bfcbe, _ddcd)
	for _, _adeb := range _eadc {
		if _adeb <= _bcecab {
			continue
		} else if _adeb >= _dgfcd {
			break
		}
		_bfcbe = append(_bfcbe, _adeb)
	}
	_bfcbe = append(_bfcbe, _cbaca)
	return _bfcbe
}

type rulingKind int

func _ceea(_ddaa *list) []*list {
	var _bcca []*list
	for _, _daag := range _ddaa._gfgd {
		switch _daag._gfdb {
		case "\u004c\u0049":
			_feea := _gfdcc(_daag)
			_ccgcac := _ceea(_daag)
			_daeed := _ded(_feea, "\u0062\u0075\u006c\u006c\u0065\u0074", _ccgcac)
			_adfd := _fbcge(_feea, "")
			_daeed._fagf = _adfd
			_bcca = append(_bcca, _daeed)
		case "\u004c\u0042\u006fd\u0079":
			return _ceea(_daag)
		case "\u004c":
			_cbfa := _ceea(_daag)
			_bcca = append(_bcca, _cbfa...)
			return _bcca
		}
	}
	return _bcca
}
func (_eabd paraList) applyTables(_gdbcf []*textTable) paraList {
	var _fgbd paraList
	for _, _dddc := range _gdbcf {
		_fgbd = append(_fgbd, _dddc.newTablePara())
	}
	for _, _bfcfe := range _eabd {
		if _bfcfe._fcag {
			continue
		}
		_fgbd = append(_fgbd, _bfcfe)
	}
	return _fgbd
}
func _aagc(_acbg *paraList) map[int][]*textLine {
	_dccd := map[int][]*textLine{}
	for _, _aafd := range *_acbg {
		for _, _faege := range _aafd._eeedg {
			if !_gcef(_faege) {
				_b.Log.Debug("g\u0072\u006f\u0075p\u004c\u0069\u006e\u0065\u0073\u003a\u0020\u0054\u0068\u0065\u0020\u0074\u0065\u0078\u0074\u0020\u006c\u0069\u006e\u0065\u0020\u0063\u006f\u006e\u0074a\u0069\u006e\u0073 \u006d\u006f\u0072\u0065\u0020\u0074\u0068\u0061\u006e\u0020\u006f\u006e\u0065 \u006d\u0063\u0069\u0064 \u006e\u0075\u006d\u0062e\u0072\u002e\u0020\u0049\u0074\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0073p\u006c\u0069\u0074\u002e")
				continue
			}
			_ace := _faege._bcce[0]._ebca[0]._gcfa
			_dccd[_ace] = append(_dccd[_ace], _faege)
		}
		if _aafd._beefb != nil {
			_gabec := _aafd._beefb._gabega
			for _, _fdbf := range _gabec {
				for _, _fcgg := range _fdbf._eeedg {
					if !_gcef(_fcgg) {
						_b.Log.Debug("g\u0072\u006f\u0075p\u004c\u0069\u006e\u0065\u0073\u003a\u0020\u0054\u0068\u0065\u0020\u0074\u0065\u0078\u0074\u0020\u006c\u0069\u006e\u0065\u0020\u0063\u006f\u006e\u0074a\u0069\u006e\u0073 \u006d\u006f\u0072\u0065\u0020\u0074\u0068\u0061\u006e\u0020\u006f\u006e\u0065 \u006d\u0063\u0069\u0064 \u006e\u0075\u006d\u0062e\u0072\u002e\u0020\u0049\u0074\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0073p\u006c\u0069\u0074\u002e")
						continue
					}
					_cfcfb := _fcgg._bcce[0]._ebca[0]._gcfa
					_dccd[_cfcfb] = append(_dccd[_cfcfb], _fcgg)
				}
			}
		}
	}
	return _dccd
}
func (_gdbab *wordBag) depthRange(_affg, _afea int) []int {
	var _gedg []int
	for _fggfb := range _gdbab._agfg {
		if _affg <= _fggfb && _fggfb <= _afea {
			_gedg = append(_gedg, _fggfb)
		}
	}
	if len(_gedg) == 0 {
		return nil
	}
	_c.Ints(_gedg)
	return _gedg
}

const _gge = 20

// TextTable represents a table.
// Cells are ordered top-to-bottom, left-to-right.
// Cells[y] is the (0-offset) y'th row in the table.
// Cells[y][x] is the (0-offset) x'th column in the table.
type TextTable struct {
	_ba.PdfRectangle
	W, H  int
	Cells [][]TableCell
}

func (_ddga *ruling) alignsPrimary(_eebfg *ruling) bool {
	return _ddga._adad == _eebfg._adad && _cc.Abs(_ddga._abfa-_eebfg._abfa) < _ebbd*0.5
}

const (
	_gadf  = 1.0e-6
	_bcef  = 1.0e-4
	_bfda  = 10
	_bade  = 6
	_dcee  = 0.5
	_egac  = 0.12
	_eefd  = 0.19
	_gacbc = 0.04
	_gcgg  = 0.04
	_facea = 1.0
	_fbca  = 0.04
	_efgfe = 0.4
	_egbgb = 0.7
	_ddb   = 1.0
	_bcfcb = 0.1
	_bdgd  = 1.4
	_bbef  = 0.46
	_ccdaa = 0.02
	_afdc  = 0.2
	_dage  = 0.5
	_bacb  = 4
	_bba   = 4.0
	_deaa  = 6
	_dcda  = 0.3
	_ebgac = 0.01
	_faaa  = 0.02
	_afcf  = 2
	_ddf   = 2
	_dbfc  = 500
	_gada  = 4.0
	_bbee  = 4.0
	_aca   = 0.05
	_deag  = 0.1
	_beba  = 2.0
	_ebbd  = 2.0
	_abfd  = 1.5
	_agac  = 3.0
	_gcfc  = 0.25
)

func (_bgbe *structElement) parseStructElement(_aega _fb.PdfObject) {
	_bbgb, _egfed := _fb.GetDict(_aega)
	if !_egfed {
		_b.Log.Debug("\u0070\u0061\u0072\u0073\u0065\u0053\u0074\u0072u\u0063\u0074\u0045le\u006d\u0065\u006e\u0074\u003a\u0020d\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u002e")
		return
	}
	_ffga := _bbgb.Get("\u0053")
	_eecc := _bbgb.Get("\u0050\u0067")
	_gebd := ""
	if _ffga != nil {
		_gebd = _ffga.String()
	}
	_efaa := _bbgb.Get("\u004b")
	_bgbe._dfgd = _gebd
	_bgbe._ddbe = _eecc
	switch _ddag := _efaa.(type) {
	case *_fb.PdfObjectInteger:
		_bgbe._dfgd = _gebd
		_bgbe._gdf = int64(*_ddag)
		_bgbe._ddbe = _eecc
	case *_fb.PdfObjectReference:
		_aebe := *_fb.MakeArray(_ddag)
		var _abaf int64 = -1
		_bgbe._gdf = _abaf
		if _aebe.Len() == 1 {
			_dgfde := _aebe.Elements()[0]
			_cbcf, _eegb := _dgfde.(*_fb.PdfObjectInteger)
			if _eegb {
				_abaf = int64(*_cbcf)
				_bgbe._gdf = _abaf
				_bgbe._dfgd = _gebd
				_bgbe._ddbe = _eecc
				return
			}
		}
		_bcbd := []structElement{}
		for _, _cgaa := range _aebe.Elements() {
			_dgb, _cdea := _cgaa.(*_fb.PdfObjectInteger)
			if _cdea {
				_abaf = int64(*_dgb)
				_bgbe._gdf = _abaf
				_bgbe._dfgd = _gebd
			} else {
				_eddd := &structElement{}
				_eddd.parseStructElement(_cgaa)
				_bcbd = append(_bcbd, *_eddd)
			}
			_abaf = -1
		}
		_bgbe._agcf = _bcbd
	case *_fb.PdfObjectArray:
		_adae := _efaa.(*_fb.PdfObjectArray)
		var _fegd int64 = -1
		_bgbe._gdf = _fegd
		if _adae.Len() == 1 {
			_cbcbe := _adae.Elements()[0]
			_bgfge, _fabe := _cbcbe.(*_fb.PdfObjectInteger)
			if _fabe {
				_fegd = int64(*_bgfge)
				_bgbe._gdf = _fegd
				_bgbe._dfgd = _gebd
				_bgbe._ddbe = _eecc
				return
			}
		}
		_dfaeb := []structElement{}
		for _, _adef := range _adae.Elements() {
			_aeed, _cfda := _adef.(*_fb.PdfObjectInteger)
			if _cfda {
				_fegd = int64(*_aeed)
				_bgbe._gdf = _fegd
				_bgbe._dfgd = _gebd
				_bgbe._ddbe = _eecc
			} else {
				_fdea := &structElement{}
				_fdea.parseStructElement(_adef)
				_dfaeb = append(_dfaeb, *_fdea)
			}
			_fegd = -1
		}
		_bgbe._agcf = _dfaeb
	}
}

const (
	_gfbe  = true
	_aeffe = true
	_gfba  = true
	_egba  = false
	_ecbf  = false
	_acbcd = 6
	_cadd  = 3.0
	_eafd  = 200
	_efgfg = true
	_ebfe  = true
	_ebbb  = true
	_baacb = true
	_dfgf  = false
)

type textWord struct {
	_ba.PdfRectangle
	_gadaf float64
	_cdfe  string
	_ebca  []*textMark
	_affe  float64
	_fggcb bool
}

// List returns all the list objects detected on the page.
// It detects all the bullet point Lists from a given pdf page and builds a slice of bullet list objects.
// A given bullet list object has a tree structure.
// Each bullet point list is extracted with the text content it contains and all the sub lists found under it as children in the tree.
// The rest content of the pdf is ignored and only text in the bullet point lists are extracted.
// The list extraction is done in two ways.
// 1. If the document is tagged then the lists are extracted using the tags provided in the document.
// 2. Otherwise the bullet lists are extracted from the raw text using regex matching.
// By default the document tag is used if available.
// However this can be disabled using `DisableDocumentTags` in the `Options` object.
// Sometimes disabling document tags option might give a better bullet list extraction if the document was tagged incorrectly.
//
//	    options := &Options{
//		     DisableDocumentTags: false, // this means use document tag if available
//	    }
//	    ex, err := NewWithOptions(page, options)
//	    // handle error
//	    pageText, _, _, err := ex.ExtractPageText()
//	    // handle error
//	    lists := pageText.List()
//	    txt := lists.Text()
func (_adgc PageText) List() lists {
	_afgcf := !_adgc._gadg._aeaa
	_cbgd := _adgc.getParagraphs()
	_gcdge := true
	if _adgc._gfcf == nil || *_adgc._gfcf == nil {
		_gcdge = false
	}
	_febf := _cbgd.list()
	if _gcdge && _afgcf {
		_gdcd := _aagc(&_cbgd)
		_agcd := &structTreeRoot{}
		_agcd.parseStructTreeRoot(*_adgc._gfcf)
		if _agcd._cfag == nil {
			_b.Log.Debug("\u004c\u0069\u0073\u0074\u003a\u0020\u0073t\u0072\u0075\u0063\u0074\u0054\u0072\u0065\u0065\u0052\u006f\u006f\u0074\u0020\u0064\u006f\u0065\u0073\u006e'\u0074\u0020\u0068\u0061\u0076e\u0020\u0061\u006e\u0079\u0020\u0063\u006f\u006e\u0074e\u006e\u0074\u002c\u0020\u0075\u0073\u0069\u006e\u0067\u0020\u0074\u0065\u0078\u0074\u0020\u006d\u0061\u0074\u0063\u0068\u0069\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006f\u0064\u0020\u0069\u006e\u0073\u0074\u0065\u0061\u0064\u002e")
			return _febf
		}
		_febf = _agcd.buildList(_gdcd, _adgc._ead)
	}
	return _febf
}
func (_bfef rulingList) splitSec() []rulingList {
	_c.Slice(_bfef, func(_egbf, _fggd int) bool {
		_egaafe, _cfgda := _bfef[_egbf], _bfef[_fggd]
		if _egaafe._bgbbf != _cfgda._bgbbf {
			return _egaafe._bgbbf < _cfgda._bgbbf
		}
		return _egaafe._dffbe < _cfgda._dffbe
	})
	_aadc := make(map[*ruling]struct{}, len(_bfef))
	_ggagg := func(_cgdb *ruling) rulingList {
		_dgeae := rulingList{_cgdb}
		_aadc[_cgdb] = struct{}{}
		for _, _eaga := range _bfef {
			if _, _eddge := _aadc[_eaga]; _eddge {
				continue
			}
			for _, _gfdce := range _dgeae {
				if _eaga.alignsSec(_gfdce) {
					_dgeae = append(_dgeae, _eaga)
					_aadc[_eaga] = struct{}{}
					break
				}
			}
		}
		return _dgeae
	}
	_fafgf := []rulingList{_ggagg(_bfef[0])}
	for _, _gbabf := range _bfef[1:] {
		if _, _fccc := _aadc[_gbabf]; _fccc {
			continue
		}
		_fafgf = append(_fafgf, _ggagg(_gbabf))
	}
	return _fafgf
}
func _edgg(_cdab, _ddfd *textPara) bool {
	if _cdab._fcbg || _ddfd._fcbg {
		return true
	}
	return _gabfc(_cdab.depth() - _ddfd.depth())
}
func _bgebc(_eecb *textLine, _gffg []*textLine, _fcac []float64, _cefc, _badc float64) []*textLine {
	_dcfe := []*textLine{}
	for _, _cbfg := range _gffg {
		if _cbfg._gfeac >= _cefc {
			if _badc != -1 && _cbfg._gfeac < _badc {
				if _cbfg.text() != _eecb.text() {
					if _cc.Round(_cbfg.Llx) < _cc.Round(_eecb.Llx) {
						break
					}
					_dcfe = append(_dcfe, _cbfg)
				}
			} else if _badc == -1 {
				if _cbfg._gfeac == _eecb._gfeac {
					if _cbfg.text() != _eecb.text() {
						_dcfe = append(_dcfe, _cbfg)
					}
					continue
				}
				_gbe := _gbgfe(_eecb, _gffg, _fcac)
				if _gbe != -1 && _cbfg._gfeac <= _gbe {
					_dcfe = append(_dcfe, _cbfg)
				}
			}
		}
	}
	return _dcfe
}
func _dgeg(_gabb float64) int {
	var _bdcb int
	if _gabb >= 0 {
		_bdcb = int(_gabb / _bade)
	} else {
		_bdcb = int(_gabb/_bade) - 1
	}
	return _bdcb
}

var _eceb = map[markKind]string{_fdcb: "\u0073\u0074\u0072\u006f\u006b\u0065", _bdec: "\u0066\u0069\u006c\u006c", _cffeg: "\u0061u\u0067\u006d\u0065\u006e\u0074"}

type shapesState struct {
	_ggfc  _cbc.Matrix
	_dgcb  _cbc.Matrix
	_cgfg  []*subpath
	_efa   bool
	_efcbf _cbc.Point
	_dgcf  *textObject
}

func (_ffb *textObject) moveTextSetLeading(_bbe, _cadb float64) {
	_ffb._fggf._acdc = -_cadb
	_ffb.moveLP(_bbe, _cadb)
}
func _cbba(_beeaf map[float64]map[float64]gridTile) []float64 {
	_acafc := make([]float64, 0, len(_beeaf))
	for _dcac := range _beeaf {
		_acafc = append(_acafc, _dcac)
	}
	_c.Float64s(_acafc)
	_efcff := len(_acafc)
	for _bbdgd := 0; _bbdgd < _efcff/2; _bbdgd++ {
		_acafc[_bbdgd], _acafc[_efcff-1-_bbdgd] = _acafc[_efcff-1-_bbdgd], _acafc[_bbdgd]
	}
	return _acafc
}
func _egaeb(_bbcab _ba.PdfRectangle) *ruling {
	return &ruling{_adad: _aagff, _abfa: _bbcab.Urx, _bgbbf: _bbcab.Lly, _dffbe: _bbcab.Ury}
}

// ToText returns the page text as a single string.
// Deprecated: This function is deprecated and will be removed in a future major version. Please use
// Text() instead.
func (_acg PageText) ToText() string { return _acg.Text() }
func _bbbb(_bcbfa func(*wordBag, *textWord, float64) bool, _geag float64) func(*wordBag, *textWord) bool {
	return func(_ecaa *wordBag, _aece *textWord) bool { return _bcbfa(_ecaa, _aece, _geag) }
}
func (_bebfg compositeCell) hasLines(_bfec []*textLine) bool {
	for _ggcg, _dfcfa := range _bfec {
		_ebbce := _dfdg(_bebfg.PdfRectangle, _dfcfa.PdfRectangle)
		if _egdf {
			_eb.Printf("\u0020\u0020\u0020\u0020\u0020\u0020\u005e\u005e\u005e\u0069\u006e\u0074\u0065\u0072\u0073e\u0063t\u0073\u003d\u0025\u0074\u0020\u0025\u0064\u0020\u006f\u0066\u0020\u0025\u0064\u000a", _ebbce, _ggcg, len(_bfec))
			_eb.Printf("\u0020\u0020\u0020\u0020  \u005e\u005e\u005e\u0063\u006f\u006d\u0070\u006f\u0073\u0069\u0074\u0065\u003d\u0025s\u000a", _bebfg)
			_eb.Printf("\u0020 \u0020 \u0020\u0020\u0020\u006c\u0069\u006e\u0065\u003d\u0025\u0073\u000a", _dfcfa)
		}
		if _ebbce {
			return true
		}
	}
	return false
}

// Extractor stores and offers functionality for extracting content from PDF pages.
type Extractor struct {
	_gb  string
	_cd  *_ba.PdfPageResources
	_be  _ba.PdfRectangle
	_bc  *_ba.PdfRectangle
	_dgg map[string]fontEntry
	_eg  map[string]textResult
	_bce int64
	_af  int
	_bg  *Options
	_dd  *_fb.PdfObject
	_bd  _fb.PdfObject
}

func (_agefe rulingList) removeDuplicates() rulingList {
	if len(_agefe) == 0 {
		return nil
	}
	_agefe.sort()
	_dede := rulingList{_agefe[0]}
	for _, _gdfd := range _agefe[1:] {
		if _gdfd.equals(_dede[len(_dede)-1]) {
			continue
		}
		_dede = append(_dede, _gdfd)
	}
	return _dede
}
func _dbafc(_cfcff, _dgegb _ba.PdfRectangle) (_ba.PdfRectangle, bool) {
	if !_dfdg(_cfcff, _dgegb) {
		return _ba.PdfRectangle{}, false
	}
	return _ba.PdfRectangle{Llx: _cc.Max(_cfcff.Llx, _dgegb.Llx), Urx: _cc.Min(_cfcff.Urx, _dgegb.Urx), Lly: _cc.Max(_cfcff.Lly, _dgegb.Lly), Ury: _cc.Min(_cfcff.Ury, _dgegb.Ury)}, true
}

type imageExtractContext struct {
	_cgg  []ImageMark
	_gef  int
	_dgd  int
	_fbef int
	_bff  map[*_fb.PdfObjectStream]*cachedImage
	_ggf  *ImageExtractOptions
}

func (_eea *wordBag) firstReadingIndex(_fbaed int) int {
	_ggfec := _eea.firstWord(_fbaed)._affe
	_fbgfc := float64(_fbaed+1) * _bade
	_dbaf := _fbgfc + _bba*_ggfec
	_acda := _fbaed
	for _, _baaf := range _eea.depthBand(_fbgfc, _dbaf) {
		if _fdb(_eea.firstWord(_baaf), _eea.firstWord(_acda)) < 0 {
			_acda = _baaf
		}
	}
	return _acda
}

var _bdgg = []string{"\u2756", "\u27a2", "\u2713", "\u2022", "\uf0a7", "\u25a1", "\u2212", "\u25a0", "\u25aa", "\u006f"}

func _ebbde(_dgeb []TextMark, _dab *int, _aacbd TextMark) []TextMark {
	_aacbd.Offset = *_dab
	_dgeb = append(_dgeb, _aacbd)
	*_dab += len(_aacbd.Text)
	return _dgeb
}
func (_eegbb *textPara) bbox() _ba.PdfRectangle { return _eegbb.PdfRectangle }
func (_baab pathSection) bbox() _ba.PdfRectangle {
	_fbae := _baab._bbbga[0]._dgfd[0]
	_agdf := _ba.PdfRectangle{Llx: _fbae.X, Urx: _fbae.X, Lly: _fbae.Y, Ury: _fbae.Y}
	_cbag := func(_dbcfe _cbc.Point) {
		if _dbcfe.X < _agdf.Llx {
			_agdf.Llx = _dbcfe.X
		} else if _dbcfe.X > _agdf.Urx {
			_agdf.Urx = _dbcfe.X
		}
		if _dbcfe.Y < _agdf.Lly {
			_agdf.Lly = _dbcfe.Y
		} else if _dbcfe.Y > _agdf.Ury {
			_agdf.Ury = _dbcfe.Y
		}
	}
	for _, _egbg := range _baab._bbbga[0]._dgfd[1:] {
		_cbag(_egbg)
	}
	for _, _gbaf := range _baab._bbbga[1:] {
		for _, _ade := range _gbaf._dgfd {
			_cbag(_ade)
		}
	}
	return _agdf
}

// PageTextOptions holds various options available in extraction process.
type PageTextOptions struct {
	_aeaa bool
	_aeac bool
}

// PageImages represents extracted images on a PDF page with spatial information:
// display position and size.
type PageImages struct{ Images []ImageMark }

func (_edace *textTable) getRight() paraList {
	_bffa := make(paraList, _edace._ggeg)
	for _bfdaa := 0; _bfdaa < _edace._ggeg; _bfdaa++ {
		_abcc := _edace.get(_edace._gdab-1, _bfdaa)._dfcb
		if _abcc.taken() {
			return nil
		}
		_bffa[_bfdaa] = _abcc
	}
	for _cedcc := 0; _cedcc < _edace._ggeg-1; _cedcc++ {
		if _bffa[_cedcc]._bfcbb != _bffa[_cedcc+1] {
			return nil
		}
	}
	return _bffa
}
func (_bbfcb lineRuling) asRuling() (*ruling, bool) {
	_gfbg := ruling{_adad: _bbfcb._cbgdb, Color: _bbfcb.Color, _eead: _fdcb}
	switch _bbfcb._cbgdb {
	case _aagff:
		_gfbg._abfa = _bbfcb.xMean()
		_gfbg._bgbbf = _cc.Min(_bbfcb._addc.Y, _bbfcb._bfgab.Y)
		_gfbg._dffbe = _cc.Max(_bbfcb._addc.Y, _bbfcb._bfgab.Y)
	case _deg:
		_gfbg._abfa = _bbfcb.yMean()
		_gfbg._bgbbf = _cc.Min(_bbfcb._addc.X, _bbfcb._bfgab.X)
		_gfbg._dffbe = _cc.Max(_bbfcb._addc.X, _bbfcb._bfgab.X)
	default:
		_b.Log.Error("\u0062\u0061\u0064\u0020pr\u0069\u006d\u0061\u0072\u0079\u0020\u006b\u0069\u006e\u0064\u003d\u0025\u0064", _bbfcb._cbgdb)
		return nil, false
	}
	return &_gfbg, true
}
func (_aede paraList) readBefore(_dgbeb []int, _dafga, _gcac int) bool {
	_cgad, _dafd := _aede[_dafga], _aede[_gcac]
	if _gbec(_cgad, _dafd) && _cgad.Lly > _dafd.Lly {
		return true
	}
	if !(_cgad._geea.Urx < _dafd._geea.Llx) {
		return false
	}
	_dcgg, _egea := _cgad.Lly, _dafd.Lly
	if _dcgg > _egea {
		_egea, _dcgg = _dcgg, _egea
	}
	_aecb := _cc.Max(_cgad._geea.Llx, _dafd._geea.Llx)
	_agccd := _cc.Min(_cgad._geea.Urx, _dafd._geea.Urx)
	_cdfb := _aede.llyRange(_dgbeb, _dcgg, _egea)
	for _, _afdd := range _cdfb {
		if _afdd == _dafga || _afdd == _gcac {
			continue
		}
		_bdfd := _aede[_afdd]
		if _bdfd._geea.Llx <= _agccd && _aecb <= _bdfd._geea.Urx {
			return false
		}
	}
	return true
}
func (_deeb rulingList) isActualGrid() (rulingList, bool) {
	_afdb, _dcbd := _deeb.augmentGrid()
	if !(len(_afdb) >= _afcf+1 && len(_dcbd) >= _ddf+1) {
		if _ccc {
			_b.Log.Info("\u0069s\u0041\u0063t\u0075\u0061\u006c\u0047r\u0069\u0064\u003a \u004e\u006f\u0074\u0020\u0061\u006c\u0069\u0067\u006eed\u002e\u0020\u0025d\u0020\u0078 \u0025\u0064\u0020\u003c\u0020\u0025d\u0020\u0078 \u0025\u0064", len(_afdb), len(_dcbd), _afcf+1, _ddf+1)
		}
		return nil, false
	}
	if _ccc {
		_b.Log.Info("\u0069\u0073\u0041\u0063\u0074\u0075a\u006c\u0047\u0072\u0069\u0064\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025t\u0020\u0026\u0020\u0025\u0074\u0020\u2192 \u0025\u0074", _deeb, len(_afdb) >= 2, len(_dcbd) >= 2, len(_afdb) >= 2 && len(_dcbd) >= 2)
		for _gbabg, _cbdgg := range _deeb {
			_eb.Printf("\u0025\u0034\u0064\u003a\u0020\u0025\u0076\u000a", _gbabg, _cbdgg)
		}
	}
	if _dfgf {
		_gbfc, _acac := _afdb[0], _afdb[len(_afdb)-1]
		_bfde, _gcfaf := _dcbd[0], _dcbd[len(_dcbd)-1]
		if !(_aeef(_gbfc._abfa-_bfde._bgbbf) && _aeef(_acac._abfa-_bfde._dffbe) && _aeef(_bfde._abfa-_gbfc._dffbe) && _aeef(_gcfaf._abfa-_gbfc._bgbbf)) {
			if _ccc {
				_b.Log.Info("\u0069\u0073\u0041\u0063\u0074\u0075\u0061l\u0047\u0072\u0069d\u003a\u0020\u0020N\u006f\u0074 \u0061\u006c\u0069\u0067\u006e\u0065d\u002e\n\t\u0076\u0030\u003d\u0025\u0073\u000a\u0009\u0076\u0031\u003d\u0025\u0073\u000a\u0009\u0068\u0030\u003d\u0025\u0073\u000a\u0009\u0068\u0031\u003d\u0025\u0073", _gbfc, _acac, _bfde, _gcfaf)
			}
			return nil, false
		}
	} else {
		if !_afdb.aligned() {
			if _agcad {
				_b.Log.Info("i\u0073\u0041\u0063\u0074\u0075\u0061l\u0047\u0072\u0069\u0064\u003a\u0020N\u006f\u0074\u0020\u0061\u006c\u0069\u0067n\u0065\u0064\u0020\u0076\u0065\u0072\u0074\u0073\u002e\u0020%\u0064", len(_afdb))
			}
			return nil, false
		}
		if !_dcbd.aligned() {
			if _ccc {
				_b.Log.Info("i\u0073\u0041\u0063\u0074\u0075\u0061l\u0047\u0072\u0069\u0064\u003a\u0020N\u006f\u0074\u0020\u0061\u006c\u0069\u0067n\u0065\u0064\u0020\u0068\u006f\u0072\u007a\u0073\u002e\u0020%\u0064", len(_dcbd))
			}
			return nil, false
		}
	}
	_ecgb := append(_afdb, _dcbd...)
	return _ecgb, true
}
func (_afabf *textTable) emptyCompositeColumn(_edec int) bool {
	for _ggbe := 0; _ggbe < _afabf._ggeg; _ggbe++ {
		if _gadag, _aeaef := _afabf._bbgacd[_aaega(_edec, _ggbe)]; _aeaef {
			if len(_gadag.paraList) > 0 {
				return false
			}
		}
	}
	return true
}
func _geecc(_dgcbge *_ba.Image, _bdggag _ea.Color) _ga.Image {
	_fbcfc, _dffbc := int(_dgcbge.Width), int(_dgcbge.Height)
	_ebffa := _ga.NewRGBA(_ga.Rect(0, 0, _fbcfc, _dffbc))
	for _bbfag := 0; _bbfag < _dffbc; _bbfag++ {
		for _cdcdd := 0; _cdcdd < _fbcfc; _cdcdd++ {
			_geefc, _ddfgb := _dgcbge.ColorAt(_cdcdd, _bbfag)
			if _ddfgb != nil {
				_b.Log.Debug("\u0057\u0041\u0052\u004e\u003a\u0020\u0063o\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0072\u0065\u0074\u0072\u0069\u0065v\u0065 \u0069\u006d\u0061\u0067\u0065\u0020m\u0061\u0073\u006b\u0020\u0076\u0061\u006cu\u0065\u0020\u0061\u0074\u0020\u0028\u0025\u0064\u002c\u0020\u0025\u0064\u0029\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006da\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063t\u002e", _cdcdd, _bbfag)
				continue
			}
			_gdbag, _gbgd, _gcedbg, _ := _geefc.RGBA()
			var _dfab _ea.Color
			if _gdbag+_gbgd+_gcedbg == 0 {
				_dfab = _ea.Transparent
			} else {
				_dfab = _bdggag
			}
			_ebffa.Set(_cdcdd, _bbfag, _dfab)
		}
	}
	return _ebffa
}
func (_dgcc *textLine) text() string {
	var _ffca []string
	for _, _cabg := range _dgcc._bcce {
		if _cabg._fggcb {
			_ffca = append(_ffca, "\u0020")
		}
		_ffca = append(_ffca, _cabg._cdfe)
	}
	return _a.Join(_ffca, "")
}
func (_ceeg *textPara) toTextMarks(_ceda *int) []TextMark {
	if _ceeg._beefb == nil {
		return _ceeg.toCellTextMarks(_ceda)
	}
	var _ebdb []TextMark
	for _gfgf := 0; _gfgf < _ceeg._beefb._ggeg; _gfgf++ {
		for _dacab := 0; _dacab < _ceeg._beefb._gdab; _dacab++ {
			_bffb := _ceeg._beefb.get(_dacab, _gfgf)
			if _bffb == nil {
				_ebdb = _faacg(_ebdb, _ceda, "\u0009")
			} else {
				_aadac := _bffb.toCellTextMarks(_ceda)
				_ebdb = append(_ebdb, _aadac...)
			}
			_ebdb = _faacg(_ebdb, _ceda, "\u0020")
		}
		if _gfgf < _ceeg._beefb._ggeg-1 {
			_ebdb = _faacg(_ebdb, _ceda, "\u000a")
		}
	}
	_dcfeb := _ceeg._beefb
	if _dcfeb.isExportable() {
		_ecff := _dcfeb.toTextTable()
		_ebdb = _cfcgd(_ebdb, &_ecff)
	}
	return _ebdb
}
func _ccfg(_efcd string, _acge []rulingList) {
	_b.Log.Info("\u0024\u0024 \u0025\u0064\u0020g\u0072\u0069\u0064\u0073\u0020\u002d\u0020\u0025\u0073", len(_acge), _efcd)
	for _cbdab, _dgccg := range _acge {
		_eb.Printf("\u0025\u0034\u0064\u003a\u0020\u0025\u0073\u000a", _cbdab, _dgccg.String())
	}
}

// String returns a string describing `ma`.
func (_aacf TextMarkArray) String() string {
	_afge := len(_aacf._fcca)
	if _afge == 0 {
		return "\u0045\u004d\u0050T\u0059"
	}
	_efba := _aacf._fcca[0]
	_fece := _aacf._fcca[_afge-1]
	return _eb.Sprintf("\u007b\u0054\u0045\u0058\u0054\u004d\u0041\u0052K\u0041\u0052\u0052AY\u003a\u0020\u0025\u0064\u0020\u0065l\u0065\u006d\u0065\u006e\u0074\u0073\u000a\u0009\u0066\u0069\u0072\u0073\u0074\u003d\u0025s\u000a\u0009\u0020\u006c\u0061\u0073\u0074\u003d%\u0073\u007d", _afge, _efba, _fece)
}
func (_fbge *textTable) getDown() paraList {
	_gdeb := make(paraList, _fbge._gdab)
	for _dcedd := 0; _dcedd < _fbge._gdab; _dcedd++ {
		_fcee := _fbge.get(_dcedd, _fbge._ggeg-1)._bfcbb
		if _fcee.taken() {
			return nil
		}
		_gdeb[_dcedd] = _fcee
	}
	for _gdcf := 0; _gdcf < _fbge._gdab-1; _gdcf++ {
		if _gdeb[_gdcf]._dfcb != _gdeb[_gdcf+1] {
			return nil
		}
	}
	return _gdeb
}
func (_acga *textTable) newTablePara() *textPara {
	_bbbc := _acga.computeBbox()
	_abea := &textPara{PdfRectangle: _bbbc, _geea: _bbbc, _beefb: _acga}
	if _egdf {
		_b.Log.Info("\u006e\u0065w\u0054\u0061\u0062l\u0065\u0050\u0061\u0072\u0061\u003a\u0020\u0025\u0073", _abea)
	}
	return _abea
}
func (_dfaa *structTreeRoot) parseStructTreeRoot(_cacag _fb.PdfObject) {
	if _cacag != nil {
		_bbfe, _dgdg := _fb.GetDict(_cacag)
		if !_dgdg {
			_b.Log.Debug("\u0070\u0061\u0072s\u0065\u0053\u0074\u0072\u0075\u0063\u0074\u0054\u0072\u0065\u0065\u0052\u006f\u006f\u0074\u003a\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006eo\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u002e")
		}
		K := _bbfe.Get("\u004b")
		_eace := _bbfe.Get("\u0054\u0079\u0070\u0065").String()
		var _aeee *_fb.PdfObjectArray
		switch _gddd := K.(type) {
		case *_fb.PdfObjectArray:
			_aeee = _gddd
		case *_fb.PdfObjectReference:
			_aeee = _fb.MakeArray(K)
		}
		_acf := []structElement{}
		for _, _cecc := range _aeee.Elements() {
			_cceeg := &structElement{}
			_cceeg.parseStructElement(_cecc)
			_acf = append(_acf, *_cceeg)
		}
		_dfaa._cfag = _acf
		_dfaa._cdaf = _eace
	}
}
func (_bgdb compositeCell) split(_abgfb, _efceb []float64) *textTable {
	_dcbea := len(_abgfb) + 1
	_ecbfg := len(_efceb) + 1
	if _egdf {
		_b.Log.Info("\u0063\u006f\u006d\u0070\u006f\u0073\u0069t\u0065\u0043\u0065l\u006c\u002e\u0073\u0070l\u0069\u0074\u003a\u0020\u0025\u0064\u0020\u0078\u0020\u0025\u0064\u000a\u0009\u0063\u006f\u006d\u0070\u006f\u0073\u0069\u0074\u0065\u003d\u0025\u0073\u000a"+"\u0009\u0072\u006f\u0077\u0043\u006f\u0072\u0072\u0069\u0064\u006f\u0072\u0073=\u0025\u0036\u002e\u0032\u0066\u000a\t\u0063\u006f\u006c\u0043\u006f\u0072\u0072\u0069\u0064\u006f\u0072\u0073\u003d%\u0036\u002e\u0032\u0066", _ecbfg, _dcbea, _bgdb, _abgfb, _efceb)
		_eb.Printf("\u0020\u0020\u0020\u0020\u0025\u0064\u0020\u0070\u0061\u0072\u0061\u0073\u000a", len(_bgdb.paraList))
		for _fgde, _ggfge := range _bgdb.paraList {
			_eb.Printf("\u0025\u0034\u0064\u003a\u0020\u0025\u0073\u000a", _fgde, _ggfge.String())
		}
		_eb.Printf("\u0020\u0020\u0020\u0020\u0025\u0064\u0020\u006c\u0069\u006e\u0065\u0073\u000a", len(_bgdb.lines()))
		for _fcfa, _eagb := range _bgdb.lines() {
			_eb.Printf("\u0025\u0034\u0064\u003a\u0020\u0025\u0073\u000a", _fcfa, _eagb)
		}
	}
	_abgfb = _added(_abgfb, _bgdb.Ury, _bgdb.Lly)
	_efceb = _added(_efceb, _bgdb.Llx, _bgdb.Urx)
	_ccgce := make(map[uint64]*textPara, _ecbfg*_dcbea)
	_abgb := textTable{_gdab: _ecbfg, _ggeg: _dcbea, _gabega: _ccgce}
	_fdfgf := _bgdb.paraList
	_c.Slice(_fdfgf, func(_afede, _bceca int) bool {
		_babfc, _dacb := _fdfgf[_afede], _fdfgf[_bceca]
		_cgfgd, _fbgfea := _babfc.Lly, _dacb.Lly
		if _cgfgd != _fbgfea {
			return _cgfgd < _fbgfea
		}
		return _babfc.Llx < _dacb.Llx
	})
	_ccec := make(map[uint64]_ba.PdfRectangle, _ecbfg*_dcbea)
	for _gfdfc, _gafd := range _abgfb[1:] {
		_dfca := _abgfb[_gfdfc]
		for _gda, _begb := range _efceb[1:] {
			_dgeba := _efceb[_gda]
			_ccec[_aaega(_gda, _gfdfc)] = _ba.PdfRectangle{Llx: _dgeba, Urx: _begb, Lly: _gafd, Ury: _dfca}
		}
	}
	if _egdf {
		_b.Log.Info("\u0063\u006f\u006d\u0070\u006f\u0073\u0069\u0074\u0065\u0043\u0065l\u006c\u002e\u0073\u0070\u006c\u0069\u0074\u003a\u0020\u0072e\u0063\u0074\u0073")
		_eb.Printf("\u0020\u0020\u0020\u0020")
		for _fafgc := 0; _fafgc < _ecbfg; _fafgc++ {
			_eb.Printf("\u0025\u0033\u0030\u0064\u002c\u0020", _fafgc)
		}
		_eb.Println()
		for _gaad := 0; _gaad < _dcbea; _gaad++ {
			_eb.Printf("\u0020\u0020\u0025\u0032\u0064\u003a", _gaad)
			for _cece := 0; _cece < _ecbfg; _cece++ {
				_eb.Printf("\u00256\u002e\u0032\u0066\u002c\u0020", _ccec[_aaega(_cece, _gaad)])
			}
			_eb.Println()
		}
	}
	_acdf := func(_bgbee *textLine) (int, int) {
		for _fabeb := 0; _fabeb < _dcbea; _fabeb++ {
			for _gega := 0; _gega < _ecbfg; _gega++ {
				if _egbb(_ccec[_aaega(_gega, _fabeb)], _bgbee.PdfRectangle) {
					return _gega, _fabeb
				}
			}
		}
		return -1, -1
	}
	_gadc := make(map[uint64][]*textLine, _ecbfg*_dcbea)
	for _, _eccf := range _fdfgf.lines() {
		_caccf, _fbfg := _acdf(_eccf)
		if _caccf < 0 {
			continue
		}
		_gadc[_aaega(_caccf, _fbfg)] = append(_gadc[_aaega(_caccf, _fbfg)], _eccf)
	}
	for _ageff := 0; _ageff < len(_abgfb)-1; _ageff++ {
		_fafdf := _abgfb[_ageff]
		_fbgb := _abgfb[_ageff+1]
		for _eddb := 0; _eddb < len(_efceb)-1; _eddb++ {
			_dgcbg := _efceb[_eddb]
			_fbegg := _efceb[_eddb+1]
			_cbdg := _ba.PdfRectangle{Llx: _dgcbg, Urx: _fbegg, Lly: _fbgb, Ury: _fafdf}
			_eaee := _gadc[_aaega(_eddb, _ageff)]
			if len(_eaee) == 0 {
				continue
			}
			_gbgg := _bggc(_cbdg, _eaee)
			_abgb.put(_eddb, _ageff, _gbgg)
		}
	}
	return &_abgb
}
func (_begfd *textTable) growTable() {
	_abfcf := func(_dfbbf paraList) {
		_begfd._ggeg++
		for _acdbd := 0; _acdbd < _begfd._gdab; _acdbd++ {
			_bdcbg := _dfbbf[_acdbd]
			_begfd.put(_acdbd, _begfd._ggeg-1, _bdcbg)
		}
	}
	_acdff := func(_fadea paraList) {
		_begfd._gdab++
		for _cbfgd := 0; _cbfgd < _begfd._ggeg; _cbfgd++ {
			_aeacg := _fadea[_cbfgd]
			_begfd.put(_begfd._gdab-1, _cbfgd, _aeacg)
		}
	}
	if _baef {
		_begfd.log("\u0067r\u006f\u0077\u0054\u0061\u0062\u006ce")
	}
	for _dceb := 0; ; _dceb++ {
		_gdbeg := false
		_fggce := _begfd.getDown()
		_faef := _begfd.getRight()
		if _baef {
			_eb.Printf("\u0025\u0034\u0064\u003a\u0020\u0025\u0073\u000a", _dceb, _begfd)
			_eb.Printf("\u0020\u0020 \u0020\u0020\u0020 \u0020\u0064\u006f\u0077\u006e\u003d\u0025\u0073\u000a", _fggce)
			_eb.Printf("\u0020\u0020 \u0020\u0020\u0020 \u0072\u0069\u0067\u0068\u0074\u003d\u0025\u0073\u000a", _faef)
		}
		if _fggce != nil && _faef != nil {
			_dbbd := _fggce[len(_fggce)-1]
			if !_dbbd.taken() && _dbbd == _faef[len(_faef)-1] {
				_abfcf(_fggce)
				if _faef = _begfd.getRight(); _faef != nil {
					_acdff(_faef)
					_begfd.put(_begfd._gdab-1, _begfd._ggeg-1, _dbbd)
				}
				_gdbeg = true
			}
		}
		if !_gdbeg && _fggce != nil {
			_abfcf(_fggce)
			_gdbeg = true
		}
		if !_gdbeg && _faef != nil {
			_acdff(_faef)
			_gdbeg = true
		}
		if !_gdbeg {
			break
		}
	}
}
func (_fbcg *shapesState) clearPath() {
	_fbcg._cgfg = nil
	_fbcg._efa = false
	if _adbb {
		_b.Log.Info("\u0043\u004c\u0045A\u0052\u003a\u0020\u0073\u0073\u003d\u0025\u0073", _fbcg)
	}
}
func _bdf(_bbcc *wordBag, _cbca *textWord, _abeb float64) bool {
	return _bbcc.Urx <= _cbca.Llx && _cbca.Llx < _bbcc.Urx+_abeb
}
func (_ceaab rulingList) primaries() []float64 {
	_caed := make(map[float64]struct{}, len(_ceaab))
	for _, _aagg := range _ceaab {
		_caed[_aagg._abfa] = struct{}{}
	}
	_acca := make([]float64, len(_caed))
	_dfee := 0
	for _cbgge := range _caed {
		_acca[_dfee] = _cbgge
		_dfee++
	}
	_c.Float64s(_acca)
	return _acca
}
func _fbcdf(_gbaed _ba.PdfColorspace, _feafa _ba.PdfColor) _ea.Color {
	if _gbaed == nil || _feafa == nil {
		return _ea.Black
	}
	_cgdab, _cfccbb := _gbaed.ColorToRGB(_feafa)
	if _cfccbb != nil {
		_b.Log.Debug("\u0057\u0041\u0052\u004e\u003a\u0020\u0063\u006fu\u006c\u0064\u0020no\u0074\u0020\u0063\u006f\u006e\u0076e\u0072\u0074\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0025\u0076\u0020\u0028\u0025\u0076)\u0020\u0074\u006f\u0020\u0052\u0047\u0042\u003a \u0025\u0073", _feafa, _gbaed, _cfccbb)
		return _ea.Black
	}
	_dfbdc, _bdfdge := _cgdab.(*_ba.PdfColorDeviceRGB)
	if !_bdfdge {
		_b.Log.Debug("\u0057\u0041\u0052\u004e\u003a\u0020\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0065\u0064 \u0063\u006f\u006c\u006f\u0072\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020i\u006e\u0020\u0074\u0068\u0065\u0020\u0052\u0047\u0042\u0020\u0063\u006flo\u0072\u0073\u0070\u0061\u0063\u0065\u003a\u0020\u0025\u0076", _cgdab)
		return _ea.Black
	}
	return _ea.NRGBA{R: uint8(_dfbdc.R() * 255), G: uint8(_dfbdc.G() * 255), B: uint8(_dfbdc.B() * 255), A: uint8(255)}
}
func _gaab(_gdbc _cbc.Matrix) _cbc.Point {
	_beg, _aeff := _gdbc.Translation()
	return _cbc.Point{X: _beg, Y: _aeff}
}
func _bdba(_dbefc, _bcac _cbc.Point, _baede _ea.Color) (*ruling, bool) {
	_aaeg := lineRuling{_addc: _dbefc, _bfgab: _bcac, _cbgdb: _gebb(_dbefc, _bcac), Color: _baede}
	if _aaeg._cbgdb == _affd {
		return nil, false
	}
	return _aaeg.asRuling()
}
func (_ffea rulingList) mergePrimary() float64 {
	_bgefa := _ffea[0]._abfa
	for _, _badgg := range _ffea[1:] {
		_bgefa += _badgg._abfa
	}
	return _bgefa / float64(len(_ffea))
}
func _dgfb(_bdcg _ba.PdfRectangle, _aadg, _ecdae, _dedg, _baba *ruling) gridTile {
	_afdcc := _bdcg.Llx
	_gefc := _bdcg.Urx
	_ccebgd := _bdcg.Lly
	_abafe := _bdcg.Ury
	return gridTile{PdfRectangle: _bdcg, _cbaf: _aadg != nil && _aadg.encloses(_ccebgd, _abafe), _ceead: _ecdae != nil && _ecdae.encloses(_ccebgd, _abafe), _edddc: _dedg != nil && _dedg.encloses(_afdcc, _gefc), _begf: _baba != nil && _baba.encloses(_afdcc, _gefc)}
}
func (_gbaeb *textPara) text() string {
	_cade := new(_f.Buffer)
	_gbaeb.writeText(_cade)
	return _cade.String()
}
func (_abf *textObject) setTextRenderMode(_cfcc int) {
	if _abf == nil {
		return
	}
	_abf._fggf._bffe = RenderMode(_cfcc)
}

type stateStack []*textState

func (_eeag *ruling) equals(_gbea *ruling) bool {
	return _eeag._adad == _gbea._adad && _bfebf(_eeag._abfa, _gbea._abfa) && _bfebf(_eeag._bgbbf, _gbea._bgbbf) && _bfebf(_eeag._dffbe, _gbea._dffbe)
}
func (_cdae *shapesState) quadraticTo(_gaag, _dcgb, _cacg, _cfgb float64) {
	if _adbb {
		_b.Log.Info("\u0071\u0075\u0061d\u0072\u0061\u0074\u0069\u0063\u0054\u006f\u003a")
	}
	_cdae.addPoint(_cacg, _cfgb)
}
func (_gfda rulingList) aligned() bool {
	if len(_gfda) < 2 {
		return false
	}
	_fcce := make(map[*ruling]int)
	_fcce[_gfda[0]] = 0
	for _, _gbgfb := range _gfda[1:] {
		_fbdb := false
		for _aead := range _fcce {
			if _gbgfb.gridIntersecting(_aead) {
				_fcce[_aead]++
				_fbdb = true
				break
			}
		}
		if !_fbdb {
			_fcce[_gbgfb] = 0
		}
	}
	_abbaa := 0
	for _, _bdagb := range _fcce {
		if _bdagb == 0 {
			_abbaa++
		}
	}
	_fffda := float64(_abbaa) / float64(len(_gfda))
	_dggabe := _fffda <= 1.0-_gcfc
	if _ccc {
		_b.Log.Info("\u0061\u006c\u0069\u0067\u006e\u0065\u0064\u003d\u0025\u0074\u0020\u0075\u006em\u0061\u0074\u0063\u0068\u0065\u0064=\u0025\u002e\u0032\u0066\u003d\u0025\u0064\u002f\u0025\u0064\u0020\u0076\u0065c\u0073\u003d\u0025\u0073", _dggabe, _fffda, _abbaa, len(_gfda), _gfda.String())
	}
	return _dggabe
}
func (_dade *textObject) setWordSpacing(_gcbb float64) {
	if _dade == nil {
		return
	}
	_dade._fggf._ega = _gcbb
}

// String returns a description of `l`.
func (_caff *textLine) String() string {
	return _eb.Sprintf("\u0025\u002e2\u0066\u0020\u0025\u0036\u002e\u0032\u0066\u0020\u0066\u006f\u006e\u0074\u0073\u0069\u007a\u0065\u003d\u0025\u002e\u0032\u0066\u0020\"%\u0073\u0022", _caff._gfeac, _caff.PdfRectangle, _caff._gdca, _caff.text())
}
func (_gcfcg rulingList) vertsHorzs() (rulingList, rulingList) {
	var _cbdgga, _dbgf rulingList
	for _, _gaafa := range _gcfcg {
		switch _gaafa._adad {
		case _aagff:
			_cbdgga = append(_cbdgga, _gaafa)
		case _deg:
			_dbgf = append(_dbgf, _gaafa)
		}
	}
	return _cbdgga, _dbgf
}
func (_aedba rulingList) toGrids() []rulingList {
	if _ccc {
		_b.Log.Info("t\u006f\u0047\u0072\u0069\u0064\u0073\u003a\u0020\u0025\u0073", _aedba)
	}
	_afde := _aedba.intersections()
	if _ccc {
		_b.Log.Info("\u0074\u006f\u0047r\u0069\u0064\u0073\u003a \u0076\u0065\u0063\u0073\u003d\u0025\u0064 \u0069\u006e\u0074\u0065\u0072\u0073\u0065\u0063\u0074\u0073\u003d\u0025\u0064\u0020", len(_aedba), len(_afde))
		for _, _ggdg := range _aaddc(_afde) {
			_eb.Printf("\u00254\u0064\u003a\u0020\u0025\u002b\u0076\n", _ggdg, _afde[_ggdg])
		}
	}
	_dgegbe := make(map[int]intSet, len(_aedba))
	for _ecbd := range _aedba {
		_ccbfe := _aedba.connections(_afde, _ecbd)
		if len(_ccbfe) > 0 {
			_dgegbe[_ecbd] = _ccbfe
		}
	}
	if _ccc {
		_b.Log.Info("t\u006fG\u0072\u0069\u0064\u0073\u003a\u0020\u0063\u006fn\u006e\u0065\u0063\u0074s=\u0025\u0064", len(_dgegbe))
		for _, _adec := range _aaddc(_dgegbe) {
			_eb.Printf("\u00254\u0064\u003a\u0020\u0025\u002b\u0076\n", _adec, _dgegbe[_adec])
		}
	}
	_egaaf := _gcedb(len(_aedba), func(_fgfg, _egcf int) bool {
		_abfdf, _bfeg := len(_dgegbe[_fgfg]), len(_dgegbe[_egcf])
		if _abfdf != _bfeg {
			return _abfdf > _bfeg
		}
		return _aedba.comp(_fgfg, _egcf)
	})
	if _ccc {
		_b.Log.Info("t\u006fG\u0072\u0069\u0064\u0073\u003a\u0020\u006f\u0072d\u0065\u0072\u0069\u006eg=\u0025\u0076", _egaaf)
	}
	_cefd := [][]int{{_egaaf[0]}}
_dcfc:
	for _, _adcd := range _egaaf[1:] {
		for _ddcf, _dcdg := range _cefd {
			for _, _abgde := range _dcdg {
				if _dgegbe[_abgde].has(_adcd) {
					_cefd[_ddcf] = append(_dcdg, _adcd)
					continue _dcfc
				}
			}
		}
		_cefd = append(_cefd, []int{_adcd})
	}
	if _ccc {
		_b.Log.Info("\u0074o\u0047r\u0069\u0064\u0073\u003a\u0020i\u0067\u0072i\u0064\u0073\u003d\u0025\u0076", _cefd)
	}
	_c.SliceStable(_cefd, func(_dcdga, _fbda int) bool { return len(_cefd[_dcdga]) > len(_cefd[_fbda]) })
	for _, _fcdg := range _cefd {
		_c.Slice(_fcdg, func(_cbgff, _bfgcc int) bool { return _aedba.comp(_fcdg[_cbgff], _fcdg[_bfgcc]) })
	}
	_agfea := make([]rulingList, len(_cefd))
	for _fbgd, _ffdfa := range _cefd {
		_ddabf := make(rulingList, len(_ffdfa))
		for _gdfef, _cgdea := range _ffdfa {
			_ddabf[_gdfef] = _aedba[_cgdea]
		}
		_agfea[_fbgd] = _ddabf
	}
	if _ccc {
		_b.Log.Info("\u0074o\u0047r\u0069\u0064\u0073\u003a\u0020g\u0072\u0069d\u0073\u003d\u0025\u002b\u0076", _agfea)
	}
	var _dgdbb []rulingList
	for _, _gdddb := range _agfea {
		if _cbac, _bgfa := _gdddb.isActualGrid(); _bgfa {
			_gdddb = _cbac
			_gdddb = _gdddb.snapToGroups()
			_dgdbb = append(_dgdbb, _gdddb)
		}
	}
	if _ccc {
		_ccfg("t\u006fG\u0072\u0069\u0064\u0073\u003a\u0020\u0061\u0063t\u0075\u0061\u006c\u0047ri\u0064\u0073", _dgdbb)
		_b.Log.Info("\u0074\u006f\u0047\u0072\u0069\u0064\u0073\u003a\u0020\u0067\u0072\u0069\u0064\u0073\u003d%\u0064 \u0061\u0063\u0074\u0075\u0061\u006c\u0047\u0072\u0069\u0064\u0073\u003d\u0025\u0064", len(_agfea), len(_dgdbb))
	}
	return _dgdbb
}
func _fgcf(_bbac, _aacgc _cbc.Point) rulingKind {
	_gcccb := _cc.Abs(_bbac.X - _aacgc.X)
	_dccga := _cc.Abs(_bbac.Y - _aacgc.Y)
	return _gecef(_gcccb, _dccga, _aca)
}

// String returns a string describing `pt`.
func (_fbcee PageText) String() string {
	_fbed := _eb.Sprintf("P\u0061\u0067\u0065\u0054ex\u0074:\u0020\u0025\u0064\u0020\u0065l\u0065\u006d\u0065\u006e\u0074\u0073", len(_fbcee._dafg))
	_bbcg := []string{"\u002d" + _fbed}
	for _, _dccg := range _fbcee._dafg {
		_bbcg = append(_bbcg, _dccg.String())
	}
	_bbcg = append(_bbcg, "\u002b"+_fbed)
	return _a.Join(_bbcg, "\u000a")
}
func _ggcgc(_bddf _ba.PdfRectangle) *ruling {
	return &ruling{_adad: _deg, _abfa: _bddf.Lly, _bgbbf: _bddf.Llx, _dffbe: _bddf.Urx}
}

// String returns a string describing the current state of the textState stack.
func (_fdc *stateStack) String() string {
	_baae := []string{_eb.Sprintf("\u002d\u002d\u002d\u002d f\u006f\u006e\u0074\u0020\u0073\u0074\u0061\u0063\u006b\u003a\u0020\u0025\u0064", len(*_fdc))}
	for _cdec, _fadc := range *_fdc {
		_gbab := "\u003c\u006e\u0069l\u003e"
		if _fadc != nil {
			_gbab = _fadc.String()
		}
		_baae = append(_baae, _eb.Sprintf("\u0009\u0025\u0032\u0064\u003a\u0020\u0025\u0073", _cdec, _gbab))
	}
	return _a.Join(_baae, "\u000a")
}
func (_aeda *shapesState) stroke(_bfd *[]pathSection) {
	_ecgf := pathSection{_bbbga: _aeda._cgfg, Color: _aeda._dgcf.getStrokeColor()}
	*_bfd = append(*_bfd, _ecgf)
	if _ccc {
		_eb.Printf("\u0020 \u0020\u0020S\u0054\u0052\u004fK\u0045\u003a\u0020\u0025\u0064\u0020\u0073t\u0072\u006f\u006b\u0065\u0073\u0020s\u0073\u003d\u0025\u0073\u0020\u0063\u006f\u006c\u006f\u0072\u003d%\u002b\u0076\u0020\u0025\u0036\u002e\u0032\u0066\u000a", len(*_bfd), _aeda, _aeda._dgcf.getStrokeColor(), _ecgf.bbox())
		if _adeg {
			for _face, _cgbe := range _aeda._cgfg {
				_eb.Printf("\u0025\u0038\u0064\u003a\u0020\u0025\u0073\u000a", _face, _cgbe)
				if _face == 10 {
					break
				}
			}
		}
	}
}

// ExtractFonts returns all font information from the page extractor, including
// font name, font type, the raw data of the embedded font file (if embedded), font descriptor and more.
//
// The argument `previousPageFonts` is used when trying to build a complete font catalog for multiple pages or the entire document.
// The entries from `previousPageFonts` are added to the returned result unless already included in the page, i.e. no duplicate entries.
//
// NOTE: If previousPageFonts is nil, all fonts from the page will be returned. Use it when building up a full list of fonts for a document or page range.
func (_cg *Extractor) ExtractFonts(previousPageFonts *PageFonts) (*PageFonts, error) {
	_dcf := PageFonts{}
	_gc := _dcf.extractPageResourcesToFont(_cg._cd)
	if _gc != nil {
		return nil, _gc
	}
	if previousPageFonts != nil {
		for _, _bad := range previousPageFonts.Fonts {
			if !_dce(_dcf.Fonts, _bad.FontName) {
				_dcf.Fonts = append(_dcf.Fonts, _bad)
			}
		}
	}
	return &PageFonts{Fonts: _dcf.Fonts}, nil
}
func _dcbb(_fbeg, _gade _ba.PdfRectangle) bool {
	return _fbeg.Lly <= _gade.Ury && _gade.Lly <= _fbeg.Ury
}

type ruling struct {
	_adad rulingKind
	_eead markKind
	_ea.Color
	_abfa  float64
	_bgbbf float64
	_dffbe float64
	_fbcfe float64
}

func (_ggcgd *ruling) encloses(_aeggd, _fdead float64) bool {
	return _ggcgd._bgbbf-_beba <= _aeggd && _fdead <= _ggcgd._dffbe+_beba
}
func (_eebg rulingList) augmentGrid() (rulingList, rulingList) {
	_egca, _aafa := _eebg.vertsHorzs()
	if len(_egca) == 0 || len(_aafa) == 0 {
		return _egca, _aafa
	}
	_efcf, _efgdc := _egca, _aafa
	_dfdfc := _egca.bbox()
	_bfgac := _aafa.bbox()
	if _ccc {
		_b.Log.Info("\u0061u\u0067\u006d\u0065\u006e\u0074\u0047\u0072\u0069\u0064\u003a\u0020b\u0062\u006f\u0078\u0056\u003d\u0025\u0036\u002e\u0032\u0066", _dfdfc)
		_b.Log.Info("\u0061u\u0067\u006d\u0065\u006e\u0074\u0047\u0072\u0069\u0064\u003a\u0020b\u0062\u006f\u0078\u0048\u003d\u0025\u0036\u002e\u0032\u0066", _bfgac)
	}
	var _ccgd, _efae, _bgce, _eggcb *ruling
	if _bfgac.Llx < _dfdfc.Llx-_beba {
		_ccgd = &ruling{_eead: _cffeg, _adad: _aagff, _abfa: _bfgac.Llx, _bgbbf: _dfdfc.Lly, _dffbe: _dfdfc.Ury}
		_egca = append(rulingList{_ccgd}, _egca...)
	}
	if _bfgac.Urx > _dfdfc.Urx+_beba {
		_efae = &ruling{_eead: _cffeg, _adad: _aagff, _abfa: _bfgac.Urx, _bgbbf: _dfdfc.Lly, _dffbe: _dfdfc.Ury}
		_egca = append(_egca, _efae)
	}
	if _dfdfc.Lly < _bfgac.Lly-_beba {
		_bgce = &ruling{_eead: _cffeg, _adad: _deg, _abfa: _dfdfc.Lly, _bgbbf: _bfgac.Llx, _dffbe: _bfgac.Urx}
		_aafa = append(rulingList{_bgce}, _aafa...)
	}
	if _dfdfc.Ury > _bfgac.Ury+_beba {
		_eggcb = &ruling{_eead: _cffeg, _adad: _deg, _abfa: _dfdfc.Ury, _bgbbf: _bfgac.Llx, _dffbe: _bfgac.Urx}
		_aafa = append(_aafa, _eggcb)
	}
	if len(_egca)+len(_aafa) == len(_eebg) {
		return _efcf, _efgdc
	}
	_ccgcg := append(_egca, _aafa...)
	_eebg.log("u\u006e\u0061\u0075\u0067\u006d\u0065\u006e\u0074\u0065\u0064")
	_ccgcg.log("\u0061u\u0067\u006d\u0065\u006e\u0074\u0065d")
	return _egca, _aafa
}
func _cddc(_ggg *wordBag, _fedb float64, _fcgc, _ccdb rulingList) []*wordBag {
	var _cbeb []*wordBag
	for _, _ddagd := range _ggg.depthIndexes() {
		_ccaed := false
		for !_ggg.empty(_ddagd) {
			_dedd := _ggg.firstReadingIndex(_ddagd)
			_bggee := _ggg.firstWord(_dedd)
			_dddf := _bbba(_bggee, _fedb, _fcgc, _ccdb)
			_ggg.removeWord(_bggee, _dedd)
			if _gdee {
				_b.Log.Info("\u0066\u0069\u0072\u0073\u0074\u0057\u006f\u0072\u0064\u0020\u005e\u005e^\u005e\u0020\u0025\u0073", _bggee.String())
			}
			for _daed := true; _daed; _daed = _ccaed {
				_ccaed = false
				_eecf := _ddb * _dddf._cdc
				_baeaa := _efgfe * _dddf._cdc
				_dbbbd := _facea * _dddf._cdc
				if _gdee {
					_b.Log.Info("\u0070a\u0072a\u0057\u006f\u0072\u0064\u0073\u0020\u0064\u0065\u0070\u0074\u0068 \u0025\u002e\u0032\u0066 \u002d\u0020\u0025\u002e\u0032f\u0020\u006d\u0061\u0078\u0049\u006e\u0074\u0072\u0061\u0044\u0065\u0070\u0074\u0068\u0047\u0061\u0070\u003d\u0025\u002e\u0032\u0066\u0020\u006d\u0061\u0078\u0049\u006e\u0074\u0072\u0061R\u0065\u0061\u0064\u0069\u006e\u0067\u0047\u0061p\u003d\u0025\u002e\u0032\u0066", _dddf.minDepth(), _dddf.maxDepth(), _dbbbd, _baeaa)
				}
				if _ggg.scanBand("\u0076\u0065\u0072\u0074\u0069\u0063\u0061\u006c", _dddf, _bbbb(_abaeg, 0), _dddf.minDepth()-_dbbbd, _dddf.maxDepth()+_dbbbd, _fbca, false, false) > 0 {
					_ccaed = true
				}
				if _ggg.scanBand("\u0068\u006f\u0072\u0069\u007a\u006f\u006e\u0074\u0061\u006c", _dddf, _bbbb(_abaeg, _baeaa), _dddf.minDepth(), _dddf.maxDepth(), _egbgb, false, false) > 0 {
					_ccaed = true
				}
				if _ccaed {
					continue
				}
				_agff := _ggg.scanBand("", _dddf, _bbbb(_bdf, _eecf), _dddf.minDepth(), _dddf.maxDepth(), _bcfcb, true, false)
				if _agff > 0 {
					_ffbc := (_dddf.maxDepth() - _dddf.minDepth()) / _dddf._cdc
					if (_agff > 1 && float64(_agff) > 0.3*_ffbc) || _agff <= 10 {
						if _ggg.scanBand("\u006f\u0074\u0068e\u0072", _dddf, _bbbb(_bdf, _eecf), _dddf.minDepth(), _dddf.maxDepth(), _bcfcb, false, true) > 0 {
							_ccaed = true
						}
					}
				}
			}
			_cbeb = append(_cbeb, _dddf)
		}
	}
	return _cbeb
}

var _fgfae string = "\u0028\u003f\u0069\u0029\u005e\u0028\u004d\u007b\u0030\u002c\u0033\u007d\u0029\u0028\u0043\u0028?\u003a\u0044\u007cM\u0029\u007c\u0044\u003f\u0043{\u0030\u002c\u0033\u007d\u0029\u0028\u0058\u0028\u003f\u003a\u004c\u007c\u0043\u0029\u007cL\u003f\u0058\u007b\u0030\u002c\u0033}\u0029\u0028\u0049\u0028\u003f\u003a\u0056\u007c\u0058\u0029\u007c\u0056\u003f\u0049\u007b\u0030\u002c\u0033\u007d\u0029\u0028\u005c\u0029\u007c\u005c\u002e\u0029\u007c\u005e\u005c\u0028\u0028\u004d\u007b\u0030\u002c\u0033\u007d\u0029\u0028\u0043\u0028\u003f\u003aD\u007cM\u0029\u007c\u0044\u003f\u0043\u007b\u0030\u002c\u0033\u007d\u0029\u0028\u0058\u0028?\u003a\u004c\u007c\u0043\u0029\u007c\u004c?\u0058\u007b0\u002c\u0033\u007d\u0029(\u0049\u0028\u003f\u003a\u0056|\u0058\u0029\u007c\u0056\u003f\u0049\u007b\u0030\u002c\u0033\u007d\u0029\u005c\u0029"

type gridTiling struct {
	_ba.PdfRectangle
	_gegbb []float64
	_cbab  []float64
	_fbgfa map[float64]map[float64]gridTile
}

// Text returns the extracted page text.
func (_cdeca PageText) Text() string { return _cdeca._bab }
func _eegg(_agec []structElement, _gcde map[int][]*textLine, _aeabe _fb.PdfObject) []*list {
	_dfcf := []*list{}
	for _, _dcbfd := range _agec {
		_dfdgc := _dcbfd._agcf
		_egeg := int(_dcbfd._gdf)
		_daded := _dcbfd._dfgd
		_gbca := []*textLine{}
		_cfaf := []*list{}
		_dbcfd := _dcbfd._ddbe
		_caeg, _beef := (_dbcfd.(*_fb.PdfObjectReference))
		if !_beef {
			_b.Log.Debug("\u0066\u0061\u0069l\u0065\u0064\u0020\u006f\u0074\u0020\u0063\u0061\u0073\u0074\u0020\u0074\u006f\u0020\u002a\u0063\u006f\u0072\u0065\u002e\u0050\u0064\u0066\u004f\u0062\u006a\u0065\u0063\u0074R\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065")
		}
		if _egeg != -1 && _caeg != nil {
			if _fdge, _fded := _gcde[_egeg]; _fded {
				if _abgfe, _cbgg := _aeabe.(*_fb.PdfIndirectObject); _cbgg {
					_fgef := _abgfe.PdfObjectReference
					if _cb.DeepEqual(*_caeg, _fgef) {
						_gbca = _fdge
					}
				}
			}
		}
		if _dfdgc != nil {
			_cfaf = _eegg(_dfdgc, _gcde, _aeabe)
		}
		_cbaaa := _ded(_gbca, _daded, _cfaf)
		_dfcf = append(_dfcf, _cbaaa)
	}
	return _dfcf
}
func (_gcff *textTable) get(_gedge, _ffde int) *textPara { return _gcff._gabega[_aaega(_gedge, _ffde)] }
func _dcaf(_aabed map[int][]float64) string {
	_bfca := _bbea(_aabed)
	_accgd := make([]string, len(_aabed))
	for _gabf, _gbcba := range _bfca {
		_accgd[_gabf] = _eb.Sprintf("\u0025\u0064\u003a\u0020\u0025\u002e\u0032\u0066", _gbcba, _aabed[_gbcba])
	}
	return _eb.Sprintf("\u007b\u0025\u0073\u007d", _a.Join(_accgd, "\u002c\u0020"))
}

type lists []*list

func (_bbc *stateStack) pop() *textState {
	if _bbc.empty() {
		return nil
	}
	_fag := *(*_bbc)[len(*_bbc)-1]
	*_bbc = (*_bbc)[:len(*_bbc)-1]
	return &_fag
}

type fontEntry struct {
	_eeba *_ba.PdfFont
	_gddg int64
}
type textResult struct {
	_bee  PageText
	_bdc  int
	_aabc int
}

// ToTextMark returns the public view of `tm`.
func (_ggef *textMark) ToTextMark() TextMark {
	return TextMark{Text: _ggef._abfc, Original: _ggef._bcbff, BBox: _ggef._ebgaa, Font: _ggef._gbfa, FontSize: _ggef._baea, FillColor: _ggef._dgfdef, StrokeColor: _ggef._efbfe, Orientation: _ggef._dbd, DirectObject: _ggef._affgg, ObjString: _ggef._bgcc, Tw: _ggef.Tw, Th: _ggef.Th, Tc: _ggef._gbdg, Index: _ggef._edeb}
}
func _cbbb(_gaaf []*textLine) map[float64][]*textLine {
	_c.Slice(_gaaf, func(_ecfd, _ccae int) bool { return _gaaf[_ecfd]._gfeac < _gaaf[_ccae]._gfeac })
	_dfbaf := map[float64][]*textLine{}
	for _, _gfdf := range _gaaf {
		_cfccb := _bfed(_gfdf)
		_cfccb = _cc.Round(_cfccb)
		_dfbaf[_cfccb] = append(_dfbaf[_cfccb], _gfdf)
	}
	return _dfbaf
}
func (_bcea rulingList) connections(_aabcb map[int]intSet, _eegd int) intSet {
	_dfbd := make(intSet)
	_ebbg := make(intSet)
	var _cbebc func(int)
	_cbebc = func(_dggab int) {
		if !_ebbg.has(_dggab) {
			_ebbg.add(_dggab)
			for _ecef := range _bcea {
				if _aabcb[_ecef].has(_dggab) {
					_dfbd.add(_ecef)
				}
			}
			for _ddbc := range _bcea {
				if _dfbd.has(_ddbc) {
					_cbebc(_ddbc)
				}
			}
		}
	}
	_cbebc(_eegd)
	return _dfbd
}
func (_gdcab paraList) addNeighbours() {
	_acfd := func(_aage []int, _eaec *textPara) ([]*textPara, []*textPara) {
		_ffdc := make([]*textPara, 0, len(_aage)-1)
		_feaa := make([]*textPara, 0, len(_aage)-1)
		for _, _gacdc := range _aage {
			_efde := _gdcab[_gacdc]
			if _efde.Urx <= _eaec.Llx {
				_ffdc = append(_ffdc, _efde)
			} else if _efde.Llx >= _eaec.Urx {
				_feaa = append(_feaa, _efde)
			}
		}
		return _ffdc, _feaa
	}
	_gbcgg := func(_gbaec []int, _ccefd *textPara) ([]*textPara, []*textPara) {
		_ddaf := make([]*textPara, 0, len(_gbaec)-1)
		_bcfcd := make([]*textPara, 0, len(_gbaec)-1)
		for _, _egfecb := range _gbaec {
			_bedg := _gdcab[_egfecb]
			if _bedg.Ury <= _ccefd.Lly {
				_bcfcd = append(_bcfcd, _bedg)
			} else if _bedg.Lly >= _ccefd.Ury {
				_ddaf = append(_ddaf, _bedg)
			}
		}
		return _ddaf, _bcfcd
	}
	_efcg := _gdcab.yNeighbours(_faaa)
	for _, _cggbea := range _gdcab {
		_egfb := _efcg[_cggbea]
		if len(_egfb) == 0 {
			continue
		}
		_dcega, _ggba := _acfd(_egfb, _cggbea)
		if len(_dcega) == 0 && len(_ggba) == 0 {
			continue
		}
		if len(_dcega) > 0 {
			_bdcff := _dcega[0]
			for _, _cfbe := range _dcega[1:] {
				if _cfbe.Urx >= _bdcff.Urx {
					_bdcff = _cfbe
				}
			}
			for _, _dedgf := range _dcega {
				if _dedgf != _bdcff && _dedgf.Urx > _bdcff.Llx {
					_bdcff = nil
					break
				}
			}
			if _bdcff != nil && _dcbb(_cggbea.PdfRectangle, _bdcff.PdfRectangle) {
				_cggbea._dcdd = _bdcff
			}
		}
		if len(_ggba) > 0 {
			_acfcb := _ggba[0]
			for _, _bfac := range _ggba[1:] {
				if _bfac.Llx <= _acfcb.Llx {
					_acfcb = _bfac
				}
			}
			for _, _fdffe := range _ggba {
				if _fdffe != _acfcb && _fdffe.Llx < _acfcb.Urx {
					_acfcb = nil
					break
				}
			}
			if _acfcb != nil && _dcbb(_cggbea.PdfRectangle, _acfcb.PdfRectangle) {
				_cggbea._dfcb = _acfcb
			}
		}
	}
	_efcg = _gdcab.xNeighbours(_ebgac)
	for _, _cbgfg := range _gdcab {
		_gdggb := _efcg[_cbgfg]
		if len(_gdggb) == 0 {
			continue
		}
		_beega, _dfef := _gbcgg(_gdggb, _cbgfg)
		if len(_beega) == 0 && len(_dfef) == 0 {
			continue
		}
		if len(_dfef) > 0 {
			_facge := _dfef[0]
			for _, _dgdbd := range _dfef[1:] {
				if _dgdbd.Ury >= _facge.Ury {
					_facge = _dgdbd
				}
			}
			for _, _ccba := range _dfef {
				if _ccba != _facge && _ccba.Ury > _facge.Lly {
					_facge = nil
					break
				}
			}
			if _facge != nil && _fgfea(_cbgfg.PdfRectangle, _facge.PdfRectangle) {
				_cbgfg._bfcbb = _facge
			}
		}
		if len(_beega) > 0 {
			_cgeaa := _beega[0]
			for _, _abed := range _beega[1:] {
				if _abed.Lly <= _cgeaa.Lly {
					_cgeaa = _abed
				}
			}
			for _, _gegedb := range _beega {
				if _gegedb != _cgeaa && _gegedb.Lly < _cgeaa.Ury {
					_cgeaa = nil
					break
				}
			}
			if _cgeaa != nil && _fgfea(_cbgfg.PdfRectangle, _cgeaa.PdfRectangle) {
				_cbgfg._ebcc = _cgeaa
			}
		}
	}
	for _, _fgdee := range _gdcab {
		if _fgdee._dcdd != nil && _fgdee._dcdd._dfcb != _fgdee {
			_fgdee._dcdd = nil
		}
		if _fgdee._ebcc != nil && _fgdee._ebcc._bfcbb != _fgdee {
			_fgdee._ebcc = nil
		}
		if _fgdee._dfcb != nil && _fgdee._dfcb._dcdd != _fgdee {
			_fgdee._dfcb = nil
		}
		if _fgdee._bfcbb != nil && _fgdee._bfcbb._ebcc != _fgdee {
			_fgdee._bfcbb = nil
		}
	}
}
func (_fafd *wordBag) blocked(_egfd *textWord) bool {
	if _egfd.Urx < _fafd.Llx {
		_cbbc := _egaeb(_egfd.PdfRectangle)
		_egfg := _bdge(_fafd.PdfRectangle)
		if _fafd._cfegb.blocks(_cbbc, _egfg) {
			if _aae {
				_b.Log.Info("\u0062\u006c\u006f\u0063ke\u0064\u0020\u2190\u0078\u003a\u0020\u0025\u0073\u0020\u0025\u0073", _egfd, _fafd)
			}
			return true
		}
	} else if _fafd.Urx < _egfd.Llx {
		_bgbd := _egaeb(_fafd.PdfRectangle)
		_cfeee := _bdge(_egfd.PdfRectangle)
		if _fafd._cfegb.blocks(_bgbd, _cfeee) {
			if _aae {
				_b.Log.Info("b\u006co\u0063\u006b\u0065\u0064\u0020\u0078\u2192\u0020:\u0020\u0025\u0073\u0020%s", _egfd, _fafd)
			}
			return true
		}
	}
	if _egfd.Ury < _fafd.Lly {
		_fgfe := _fefb(_egfd.PdfRectangle)
		_dbcgc := _ggcgc(_fafd.PdfRectangle)
		if _fafd._dffc.blocks(_fgfe, _dbcgc) {
			if _aae {
				_b.Log.Info("\u0062\u006c\u006f\u0063ke\u0064\u0020\u2190\u0079\u003a\u0020\u0025\u0073\u0020\u0025\u0073", _egfd, _fafd)
			}
			return true
		}
	} else if _fafd.Ury < _egfd.Lly {
		_afc := _fefb(_fafd.PdfRectangle)
		_abae := _ggcgc(_egfd.PdfRectangle)
		if _fafd._dffc.blocks(_afc, _abae) {
			if _aae {
				_b.Log.Info("b\u006co\u0063\u006b\u0065\u0064\u0020\u0079\u2192\u0020:\u0020\u0025\u0073\u0020%s", _egfd, _fafd)
			}
			return true
		}
	}
	return false
}

// NewFromContents creates a new extractor from contents and page resources.
func NewFromContents(contents string, resources *_ba.PdfPageResources) (*Extractor, error) {
	const _gga = "\u0065x\u0074\u0072\u0061\u0063t\u006f\u0072\u002e\u004e\u0065w\u0046r\u006fm\u0043\u006f\u006e\u0074\u0065\u006e\u0074s"
	_eaf := &Extractor{_gb: contents, _cd: resources, _dgg: map[string]fontEntry{}, _eg: map[string]textResult{}}
	_ac.TrackUse(_gga)
	return _eaf, nil
}
func (_fbffg rulingList) asTiling() gridTiling {
	if _ceac {
		_b.Log.Info("r\u0075\u006ci\u006e\u0067\u004c\u0069\u0073\u0074\u002e\u0061\u0073\u0054\u0069\u006c\u0069\u006e\u0067\u003a\u0020\u0076\u0065\u0063s\u003d\u0025\u0064\u0020\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d=\u003d\u003d\u003d\u003d\u003d\u002b\u002b\u002b\u0020\u003d\u003d\u003d\u003d=\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d=\u003d", len(_fbffg))
	}
	for _geec, _dbbfg := range _fbffg[1:] {
		_eaeg := _fbffg[_geec]
		if _eaeg.alignsPrimary(_dbbfg) && _eaeg.alignsSec(_dbbfg) {
			_b.Log.Error("a\u0073\u0054\u0069\u006c\u0069\u006e\u0067\u003a\u0020\u0044\u0075\u0070\u006c\u0069\u0063\u0061\u0074\u0065 \u0072\u0075\u006c\u0069\u006e\u0067\u0073\u002e\u000a\u0009v=\u0025\u0073\u000a\t\u0077=\u0025\u0073", _dbbfg, _eaeg)
		}
	}
	_fbffg.sortStrict()
	_fbffg.log("\u0073n\u0061\u0070\u0070\u0065\u0064")
	_becff, _gggf := _fbffg.vertsHorzs()
	_dgab := _becff.primaries()
	_dege := _gggf.primaries()
	_dabb := len(_dgab) - 1
	_facg := len(_dege) - 1
	if _dabb == 0 || _facg == 0 {
		return gridTiling{}
	}
	_adbcd := _ba.PdfRectangle{Llx: _dgab[0], Urx: _dgab[_dabb], Lly: _dege[0], Ury: _dege[_facg]}
	if _ceac {
		_b.Log.Info("\u0072\u0075l\u0069\u006e\u0067\u004c\u0069\u0073\u0074\u002e\u0061\u0073\u0054\u0069\u006c\u0069\u006e\u0067\u003a\u0020\u0076\u0065\u0072\u0074s=\u0025\u0064", len(_becff))
		for _cccg, _eggb := range _becff {
			_eb.Printf("\u0025\u0034\u0064\u003a\u0020\u0025\u0073\u000a", _cccg, _eggb)
		}
		_b.Log.Info("\u0072\u0075l\u0069\u006e\u0067\u004c\u0069\u0073\u0074\u002e\u0061\u0073\u0054\u0069\u006c\u0069\u006e\u0067\u003a\u0020\u0068\u006f\u0072\u007as=\u0025\u0064", len(_gggf))
		for _addf, _acdbe := range _gggf {
			_eb.Printf("\u0025\u0034\u0064\u003a\u0020\u0025\u0073\u000a", _addf, _acdbe)
		}
		_b.Log.Info("\u0072\u0075\u006c\u0069\u006eg\u004c\u0069\u0073\u0074\u002e\u0061\u0073\u0054\u0069\u006c\u0069\u006e\u0067:\u0020\u0020\u0077\u0078\u0068\u003d\u0025\u0064\u0078\u0025\u0064\u000a\u0009\u006c\u006c\u0078\u003d\u0025\u002e\u0032\u0066\u000a\u0009\u006c\u006c\u0079\u003d\u0025\u002e\u0032f", _dabb, _facg, _dgab, _dege)
	}
	_gced := make([]gridTile, _dabb*_facg)
	for _ggfd := _facg - 1; _ggfd >= 0; _ggfd-- {
		_gbfd := _dege[_ggfd]
		_dbddg := _dege[_ggfd+1]
		for _bgggf := 0; _bgggf < _dabb; _bgggf++ {
			_cgacf := _dgab[_bgggf]
			_gecefa := _dgab[_bgggf+1]
			_gbcf := _becff.findPrimSec(_cgacf, _gbfd)
			_egggeb := _becff.findPrimSec(_gecefa, _gbfd)
			_cdcc := _gggf.findPrimSec(_gbfd, _cgacf)
			_efege := _gggf.findPrimSec(_dbddg, _cgacf)
			_gabc := _ba.PdfRectangle{Llx: _cgacf, Urx: _gecefa, Lly: _gbfd, Ury: _dbddg}
			_eeeg := _dgfb(_gabc, _gbcf, _egggeb, _cdcc, _efege)
			_gced[_ggfd*_dabb+_bgggf] = _eeeg
			if _ceac {
				_eb.Printf("\u0020\u0020\u0078\u003d\u0025\u0032\u0064\u0020\u0079\u003d\u0025\u0032\u0064\u003a\u0020%\u0073 \u0025\u0036\u002e\u0032\u0066\u0020\u0078\u0020\u0025\u0036\u002e\u0032\u0066\u000a", _bgggf, _ggfd, _eeeg.String(), _eeeg.Width(), _eeeg.Height())
			}
		}
	}
	if _ceac {
		_b.Log.Info("r\u0075\u006c\u0069\u006e\u0067\u004c\u0069\u0073\u0074.\u0061\u0073\u0054\u0069\u006c\u0069\u006eg:\u0020\u0063\u006f\u0061l\u0065\u0073\u0063\u0065\u0020\u0068\u006f\u0072\u0069zo\u006e\u0074a\u006c\u002e\u0020\u0025\u0036\u002e\u0032\u0066", _adbcd)
	}
	_fdfd := make([]map[float64]gridTile, _facg)
	for _ceaaf := _facg - 1; _ceaaf >= 0; _ceaaf-- {
		if _ceac {
			_eb.Printf("\u0020\u0020\u0079\u003d\u0025\u0032\u0064\u000a", _ceaaf)
		}
		_fdfd[_ceaaf] = make(map[float64]gridTile, _dabb)
		for _ababg := 0; _ababg < _dabb; _ababg++ {
			_cddbc := _gced[_ceaaf*_dabb+_ababg]
			if _ceac {
				_eb.Printf("\u0020\u0020\u0025\u0034\u0064\u003a\u0020\u0025\u0073\u000a", _ababg, _cddbc)
			}
			if !_cddbc._cbaf {
				continue
			}
			_ccaa := _ababg
			for _cgfd := _ababg + 1; !_cddbc._ceead && _cgfd < _dabb; _cgfd++ {
				_eeggc := _gced[_ceaaf*_dabb+_cgfd]
				_cddbc.Urx = _eeggc.Urx
				_cddbc._begf = _cddbc._begf || _eeggc._begf
				_cddbc._edddc = _cddbc._edddc || _eeggc._edddc
				_cddbc._ceead = _eeggc._ceead
				if _ceac {
					_eb.Printf("\u0020 \u0020%\u0034\u0064\u003a\u0020\u0025s\u0020\u2192 \u0025\u0073\u000a", _cgfd, _eeggc, _cddbc)
				}
				_ccaa = _cgfd
			}
			if _ceac {
				_eb.Printf(" \u0020 \u0025\u0032\u0064\u0020\u002d\u0020\u0025\u0032d\u0020\u2192\u0020\u0025s\n", _ababg, _ccaa, _cddbc)
			}
			_ababg = _ccaa
			_fdfd[_ceaaf][_cddbc.Llx] = _cddbc
		}
	}
	_dfdb := make(map[float64]map[float64]gridTile, _facg)
	_badcf := make(map[float64]map[float64]struct{}, _facg)
	for _ecgcd := _facg - 1; _ecgcd >= 0; _ecgcd-- {
		_dbeff := _gced[_ecgcd*_dabb].Lly
		_dfdb[_dbeff] = make(map[float64]gridTile, _dabb)
		_badcf[_dbeff] = make(map[float64]struct{}, _dabb)
	}
	if _ceac {
		_b.Log.Info("\u0072u\u006c\u0069n\u0067\u004c\u0069s\u0074\u002e\u0061\u0073\u0054\u0069\u006ci\u006e\u0067\u003a\u0020\u0063\u006fa\u006c\u0065\u0073\u0063\u0065\u0020\u0076\u0065\u0072\u0074\u0069c\u0061\u006c\u002e\u0020\u0025\u0036\u002e\u0032\u0066", _adbcd)
	}
	for _bcda := _facg - 1; _bcda >= 0; _bcda-- {
		_bgcd := _gced[_bcda*_dabb].Lly
		_acgbgd := _fdfd[_bcda]
		if _ceac {
			_eb.Printf("\u0020\u0020\u0079\u003d\u0025\u0032\u0064\u000a", _bcda)
		}
		for _, _fddcd := range _efag(_acgbgd) {
			if _, _aabaf := _badcf[_bgcd][_fddcd]; _aabaf {
				continue
			}
			_beea := _acgbgd[_fddcd]
			if _ceac {
				_eb.Printf(" \u0020\u0020\u0020\u0020\u0076\u0030\u003d\u0025\u0073\u000a", _beea.String())
			}
			for _deefc := _bcda - 1; _deefc >= 0; _deefc-- {
				if _beea._edddc {
					break
				}
				_ddac := _fdfd[_deefc]
				_gcafg, _effg := _ddac[_fddcd]
				if !_effg {
					break
				}
				if _gcafg.Urx != _beea.Urx {
					break
				}
				_beea._edddc = _gcafg._edddc
				_beea.Lly = _gcafg.Lly
				if _ceac {
					_eb.Printf("\u0020\u0020\u0020\u0020  \u0020\u0020\u0076\u003d\u0025\u0073\u0020\u0076\u0030\u003d\u0025\u0073\u000a", _gcafg.String(), _beea.String())
				}
				_badcf[_gcafg.Lly][_gcafg.Llx] = struct{}{}
			}
			if _bcda == 0 {
				_beea._edddc = true
			}
			if _beea.complete() {
				_dfdb[_bgcd][_fddcd] = _beea
			}
		}
	}
	_gdedd := gridTiling{PdfRectangle: _adbcd, _gegbb: _dcga(_dfdb), _cbab: _cbba(_dfdb), _fbgfa: _dfdb}
	_gdedd.log("\u0043r\u0065\u0061\u0074\u0065\u0064")
	return _gdedd
}

// TableCell is a cell in a TextTable.
type TableCell struct {
	_ba.PdfRectangle

	// Text is the extracted text.
	Text string

	// Marks returns the TextMarks corresponding to the text in Text.
	Marks TextMarkArray
}

const (
	RenderModeStroke RenderMode = 1 << iota
	RenderModeFill
	RenderModeClip
)

type intSet map[int]struct{}

// New returns an Extractor instance for extracting content from the input PDF page.
func New(page *_ba.PdfPage) (*Extractor, error) { return NewWithOptions(page, nil) }

var _dfae = TextMark{Text: "\u005b\u0058\u005d", Original: "\u0020", Meta: true, FillColor: _ea.White, StrokeColor: _ea.White}

func (_bfgae paraList) xNeighbours(_efbg float64) map[*textPara][]int {
	_feeaf := make([]event, 2*len(_bfgae))
	if _efbg == 0 {
		for _cafa, _bcgaa := range _bfgae {
			_feeaf[2*_cafa] = event{_bcgaa.Llx, true, _cafa}
			_feeaf[2*_cafa+1] = event{_bcgaa.Urx, false, _cafa}
		}
	} else {
		for _aeedg, _bbde := range _bfgae {
			_feeaf[2*_aeedg] = event{_bbde.Llx - _efbg*_bbde.fontsize(), true, _aeedg}
			_feeaf[2*_aeedg+1] = event{_bbde.Urx + _efbg*_bbde.fontsize(), false, _aeedg}
		}
	}
	return _bfgae.eventNeighbours(_feeaf)
}
func (_aed *textObject) showText(_eedg _fb.PdfObject, _gcaf []byte, _fabd int) error {
	return _aed.renderText(_eedg, _gcaf, _fabd)
}

// String returns a description of `tm`.
func (_cbgdg *textMark) String() string {
	return _eb.Sprintf("\u0025\u002e\u0032f \u0066\u006f\u006e\u0074\u0073\u0069\u007a\u0065\u003d\u0025\u002e\u0032\u0066\u0020\u0022\u0025\u0073\u0022", _cbgdg.PdfRectangle, _cbgdg._baea, _cbgdg._abfc)
}

type rulingList []*ruling

func (_ddde intSet) add(_efff int) { _ddde[_efff] = struct{}{} }
func (_bdef *textWord) addDiacritic(_ccdfc string) {
	_agbcc := _bdef._ebca[len(_bdef._ebca)-1]
	_agbcc._abfc += _ccdfc
	_agbcc._abfc = _gg.NFKC.String(_agbcc._abfc)
}
func _fcbb(_ddgg []int) []int {
	_afcga := make([]int, len(_ddgg))
	for _ddae, _ebd := range _ddgg {
		_afcga[len(_ddgg)-1-_ddae] = _ebd
	}
	return _afcga
}
func (_adega *textTable) bbox() _ba.PdfRectangle { return _adega.PdfRectangle }

// String returns a human readable description of `s`.
func (_bdga intSet) String() string {
	var _ebdfb []int
	for _badaf := range _bdga {
		if _bdga.has(_badaf) {
			_ebdfb = append(_ebdfb, _badaf)
		}
	}
	_c.Ints(_ebdfb)
	return _eb.Sprintf("\u0025\u002b\u0076", _ebdfb)
}
func _daddg(_faae []*textMark, _dggd _ba.PdfRectangle) *textWord {
	_bgfb := _faae[0].PdfRectangle
	_ddee := _faae[0]._baea
	for _, _bedec := range _faae[1:] {
		_bgfb = _eece(_bgfb, _bedec.PdfRectangle)
		if _bedec._baea > _ddee {
			_ddee = _bedec._baea
		}
	}
	return &textWord{PdfRectangle: _bgfb, _ebca: _faae, _gadaf: _dggd.Ury - _bgfb.Lly, _affe: _ddee}
}
func _fgbcg(_efeea []*textLine, _addb map[float64][]*textLine) []*list {
	_gabg := _aegae(_addb)
	_gfgdf := []*list{}
	if len(_gabg) == 0 {
		return _gfgdf
	}
	_egbd := _gabg[0]
	_ccfcg := 1
	_efec := _addb[_egbd]
	for _eceg, _ffef := range _efec {
		var _acgbc float64
		_bffea := []*list{}
		_dbgc := _ffef._gfeac
		_edg := -1.0
		if _eceg < len(_efec)-1 {
			_edg = _efec[_eceg+1]._gfeac
		}
		if _ccfcg < len(_gabg) {
			_bffea = _cbda(_efeea, _addb, _gabg, _ccfcg, _dbgc, _edg)
		}
		_acgbc = _edg
		if len(_bffea) > 0 {
			_bcdc := _bffea[0]
			if len(_bcdc._fcda) > 0 {
				_acgbc = _bcdc._fcda[0]._gfeac
			}
		}
		_ecda := []*textLine{_ffef}
		_gaaba := _bgebc(_ffef, _efeea, _gabg, _dbgc, _acgbc)
		_ecda = append(_ecda, _gaaba...)
		_cgac := _ded(_ecda, "\u0062\u0075\u006c\u006c\u0065\u0074", _bffea)
		_cgac._fagf = _fbcge(_ecda, "")
		_gfgdf = append(_gfgdf, _cgac)
	}
	return _gfgdf
}
func _abgd(_fafe *_de.ContentStreamOperation) (float64, error) {
	if len(_fafe.Params) != 1 {
		_dbaa := _d.New("\u0069n\u0063\u006f\u0072\u0072e\u0063\u0074\u0020\u0070\u0061r\u0061m\u0065t\u0065\u0072\u0020\u0063\u006f\u0075\u006et")
		_b.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0025\u0023\u0071\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020h\u0061\u0076\u0065\u0020\u0025\u0064\u0020i\u006e\u0070\u0075\u0074\u0020\u0070\u0061\u0072\u0061\u006d\u0073,\u0020\u0067\u006f\u0074\u0020\u0025\u0064\u0020\u0025\u002b\u0076", _fafe.Operand, 1, len(_fafe.Params), _fafe.Params)
		return 0.0, _dbaa
	}
	return _fb.GetNumberAsFloat(_fafe.Params[0])
}
func (_daece *textPara) writeText(_dcfg _ge.Writer) {
	if _daece._beefb == nil {
		_daece.writeCellText(_dcfg)
		return
	}
	for _dcfee := 0; _dcfee < _daece._beefb._ggeg; _dcfee++ {
		for _cdba := 0; _cdba < _daece._beefb._gdab; _cdba++ {
			_beed := _daece._beefb.get(_cdba, _dcfee)
			if _beed == nil {
				_dcfg.Write([]byte("\u0009"))
			} else {
				_beed.writeCellText(_dcfg)
			}
			_dcfg.Write([]byte("\u0020"))
		}
		if _dcfee < _daece._beefb._ggeg-1 {
			_dcfg.Write([]byte("\u000a"))
		}
	}
}
func (_dbcdf paraList) sortReadingOrder() {
	_b.Log.Trace("\u0073\u006fr\u0074\u0052\u0065\u0061\u0064i\u006e\u0067\u004f\u0072\u0064e\u0072\u003a\u0020\u0070\u0061\u0072\u0061\u0073\u003d\u0025\u0064\u0020\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u0078\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d", len(_dbcdf))
	if len(_dbcdf) <= 1 {
		return
	}
	_dbcdf.computeEBBoxes()
	_c.Slice(_dbcdf, func(_aggf, _dgde int) bool { return _daca(_dbcdf[_aggf], _dbcdf[_dgde]) <= 0 })
}
func (_ccgc *textObject) reset() {
	_ccgc._deb = _cbc.IdentityMatrix()
	_ccgc._gfeb = _cbc.IdentityMatrix()
	_ccgc._cag = nil
}
func (_dfdc *shapesState) fill(_gcda *[]pathSection) {
	_abga := pathSection{_bbbga: _dfdc._cgfg, Color: _dfdc._dgcf.getFillColor()}
	*_gcda = append(*_gcda, _abga)
	if _ccc {
		_ecaf := _abga.bbox()
		_eb.Printf("\u0020 \u0020\u0020\u0046\u0049\u004c\u004c\u003a %\u0032\u0064\u0020\u0066\u0069\u006c\u006c\u0073\u0020\u0028\u0025\u0064\u0020\u006ee\u0077\u0029 \u0073\u0073\u003d%\u0073\u0020\u0063\u006f\u006c\u006f\u0072\u003d\u0025\u0033\u0076\u0020\u0025\u0036\u002e\u0032f\u003d\u00256.\u0032\u0066\u0078%\u0036\u002e\u0032\u0066\u000a", len(*_gcda), len(_abga._bbbga), _dfdc, _abga.Color, _ecaf, _ecaf.Width(), _ecaf.Height())
		if _adeg {
			for _bcbf, _faac := range _abga._bbbga {
				_eb.Printf("\u0025\u0038\u0064\u003a\u0020\u0025\u0073\u000a", _bcbf, _faac)
				if _bcbf == 10 {
					break
				}
			}
		}
	}
}
func _dcga(_afded map[float64]map[float64]gridTile) []float64 {
	_dcaa := make([]float64, 0, len(_afded))
	_eebf := make(map[float64]struct{}, len(_afded))
	for _, _cefb := range _afded {
		for _dfda := range _cefb {
			if _, _fdaf := _eebf[_dfda]; _fdaf {
				continue
			}
			_dcaa = append(_dcaa, _dfda)
			_eebf[_dfda] = struct{}{}
		}
	}
	_c.Float64s(_dcaa)
	return _dcaa
}
func _cedd(_gecb *wordBag, _gbae int) *textLine {
	_bddc := _gecb.firstWord(_gbae)
	_dfdca := textLine{PdfRectangle: _bddc.PdfRectangle, _gdca: _bddc._affe, _gfeac: _bddc._gadaf}
	_dfdca.pullWord(_gecb, _bddc, _gbae)
	return &_dfdca
}
func (_cgefe rulingList) log(_bdgf string) {
	if !_ccc {
		return
	}
	_b.Log.Info("\u0023\u0023\u0023\u0020\u0025\u0031\u0030\u0073\u003a\u0020\u0076\u0065c\u0073\u003d\u0025\u0073", _bdgf, _cgefe.String())
	for _gegc, _effd := range _cgefe {
		_eb.Printf("\u0025\u0034\u0064\u003a\u0020\u0025\u0073\u000a", _gegc, _effd.String())
	}
}
func (_abag *textObject) nextLine() { _abag.moveLP(0, -_abag._fggf._acdc) }

type bounded interface{ bbox() _ba.PdfRectangle }

func (_ffcd *textWord) appendMark(_fgdeec *textMark, _dbaaa _ba.PdfRectangle) {
	_ffcd._ebca = append(_ffcd._ebca, _fgdeec)
	_ffcd.PdfRectangle = _eece(_ffcd.PdfRectangle, _fgdeec.PdfRectangle)
	if _fgdeec._baea > _ffcd._affe {
		_ffcd._affe = _fgdeec._baea
	}
	_ffcd._gadaf = _dbaaa.Ury - _ffcd.PdfRectangle.Lly
}

// NewWithOptions an Extractor instance for extracting content from the input PDF page with options.
func NewWithOptions(page *_ba.PdfPage, options *Options) (*Extractor, error) {
	const _bb = "\u0065x\u0074\u0072\u0061\u0063\u0074\u006f\u0072\u002e\u004e\u0065\u0077W\u0069\u0074\u0068\u004f\u0070\u0074\u0069\u006f\u006e\u0073"
	_fg, _eaa := page.GetAllContentStreams()
	if _eaa != nil {
		return nil, _eaa
	}
	_da, _ae := page.GetStructTreeRoot()
	if !_ae {
		_b.Log.Info("T\u0068\u0065\u0020\u0070\u0064\u0066\u0020\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0074\u0061\u0067g\u0065d\u002e\u0020\u0053\u0074r\u0075\u0063t\u0054\u0072\u0065\u0065\u0052\u006f\u006f\u0074\u0020\u0064\u006f\u0065\u0073\u006e\u0027\u0074\u0020\u0065\u0078\u0069\u0073\u0074\u002e")
	}
	_bf := page.GetContainingPdfObject()
	_bca, _eaa := page.GetMediaBox()
	if _eaa != nil {
		return nil, _eb.Errorf("\u0065\u0078\u0074r\u0061\u0063\u0074\u006fr\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u006d\u0065\u0064\u0069\u0061\u0042\u006f\u0078\u002e\u0020\u0025\u0076", _eaa)
	}
	_ed := &Extractor{_gb: _fg, _cd: page.Resources, _be: *_bca, _bc: page.CropBox, _dgg: map[string]fontEntry{}, _eg: map[string]textResult{}, _bg: options, _dd: _da, _bd: _bf}
	if _ed._be.Llx > _ed._be.Urx {
		_b.Log.Info("\u004d\u0065\u0064\u0069\u0061\u0042o\u0078\u0020\u0068\u0061\u0073\u0020\u0058\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006e\u0061\u0074\u0065\u0073\u0020r\u0065\u0076\u0065\u0072\u0073\u0065\u0064\u002e\u0020\u0025\u002e\u0032\u0066\u0020F\u0069x\u0069\u006e\u0067\u002e", _ed._be)
		_ed._be.Llx, _ed._be.Urx = _ed._be.Urx, _ed._be.Llx
	}
	if _ed._be.Lly > _ed._be.Ury {
		_b.Log.Info("\u004d\u0065\u0064\u0069\u0061\u0042o\u0078\u0020\u0068\u0061\u0073\u0020\u0059\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006e\u0061\u0074\u0065\u0073\u0020r\u0065\u0076\u0065\u0072\u0073\u0065\u0064\u002e\u0020\u0025\u002e\u0032\u0066\u0020F\u0069x\u0069\u006e\u0067\u002e", _ed._be)
		_ed._be.Lly, _ed._be.Ury = _ed._be.Ury, _ed._be.Lly
	}
	_ac.TrackUse(_bb)
	return _ed, nil
}
func _dfce(_ecgcf, _eadg, _addcg, _dcdcg *textPara) *textTable {
	_fgce := &textTable{_gdab: 2, _ggeg: 2, _gabega: make(map[uint64]*textPara, 4)}
	_fgce.put(0, 0, _ecgcf)
	_fgce.put(1, 0, _eadg)
	_fgce.put(0, 1, _addcg)
	_fgce.put(1, 1, _dcdcg)
	return _fgce
}
func (_efge compositeCell) String() string {
	_cdfbf := ""
	if len(_efge.paraList) > 0 {
		_cdfbf = _eaacd(_efge.paraList.merge().text(), 50)
	}
	return _eb.Sprintf("\u0025\u0036\u002e\u0032\u0066\u0020\u0025\u0064\u0020\u0070\u0061\u0072a\u0073\u0020\u0025\u0071", _efge.PdfRectangle, len(_efge.paraList), _cdfbf)
}
func (_dad *textObject) setTextLeading(_dbf float64) {
	if _dad == nil {
		return
	}
	_dad._fggf._acdc = _dbf
}
func _eece(_ffdf, _gedda _ba.PdfRectangle) _ba.PdfRectangle {
	return _ba.PdfRectangle{Llx: _cc.Min(_ffdf.Llx, _gedda.Llx), Lly: _cc.Min(_ffdf.Lly, _gedda.Lly), Urx: _cc.Max(_ffdf.Urx, _gedda.Urx), Ury: _cc.Max(_ffdf.Ury, _gedda.Ury)}
}
func (_fba *imageExtractContext) extractXObjectImage(_abab *_fb.PdfObjectName, _ec _de.GraphicsState, _ged *_ba.PdfPageResources) error {
	_fbeb, _ := _ged.GetXObjectByName(*_abab)
	if _fbeb == nil {
		return nil
	}
	_gfdc, _cae := _fba._bff[_fbeb]
	if !_cae {
		_gbf, _cff := _ged.GetXObjectImageByName(*_abab)
		if _cff != nil {
			return _cff
		}
		if _gbf == nil {
			return nil
		}
		_beb, _cff := _gbf.ToImage()
		if _cff != nil {
			return _cff
		}
		var _dda _ga.Image
		if _gbf.SMask != nil {
			_dda, _cff = _dafe(_gbf.SMask, _ea.Opaque)
			if _cff != nil {
				_b.Log.Debug("W\u0041\u0052\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0073\u006f\u0066\u0074\u0020\u0069\u006da\u0067e\u0020\u006d\u0061\u0073k\u002e\u0020O\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u002e")
			}
		}
		if _dda != nil {
			_eafc, _age := _beb.ToGoImage()
			if _age != nil {
				return _age
			}
			_eafc = _gaeg(_eafc, _dda)
			switch _gbf.ColorSpace.String() {
			case "\u0044\u0065\u0076\u0069\u0063\u0065\u0047\u0072\u0061\u0079", "\u0049n\u0064\u0065\u0078\u0065\u0064":
				_beb, _age = _ba.ImageHandling.NewGrayImageFromGoImage(_eafc)
				if _age != nil {
					return _age
				}
			default:
				_beb, _age = _ba.ImageHandling.NewImageFromGoImage(_eafc)
				if _age != nil {
					return _age
				}
			}
		}
		_gfdc = &cachedImage{_fgb: _beb, _cec: _gbf.ColorSpace}
		_fba._bff[_fbeb] = _gfdc
	}
	_dge := _gfdc._fgb
	_ggcb := _gfdc._cec
	_dfgb, _acb := _ggcb.ImageToRGB(*_dge)
	if _acb != nil {
		return _acb
	}
	_b.Log.Debug("@\u0044\u006f\u0020\u0043\u0054\u004d\u003a\u0020\u0025\u0073", _ec.CTM.String())
	_dbc := ImageMark{Image: &_dfgb, Width: _ec.CTM.ScalingFactorX(), Height: _ec.CTM.ScalingFactorY(), Angle: _ec.CTM.Angle()}
	_dbc.X, _dbc.Y = _ec.CTM.Translation()
	_fba._cgg = append(_fba._cgg, _dbc)
	_fba._dgd++
	return nil
}
func (_ddegf gridTile) numBorders() int {
	_afdde := 0
	if _ddegf._cbaf {
		_afdde++
	}
	if _ddegf._ceead {
		_afdde++
	}
	if _ddegf._edddc {
		_afdde++
	}
	if _ddegf._begf {
		_afdde++
	}
	return _afdde
}
func (_egbdc *compositeCell) updateBBox() {
	for _, _gfcc := range _egbdc.paraList {
		_egbdc.PdfRectangle = _eece(_egbdc.PdfRectangle, _gfcc.PdfRectangle)
	}
}

// String returns a description of `b`.
func (_gcbc *wordBag) String() string {
	var _bccg []string
	for _, _ccgg := range _gcbc.depthIndexes() {
		_aebd := _gcbc._agfg[_ccgg]
		for _, _bgge := range _aebd {
			_bccg = append(_bccg, _bgge._cdfe)
		}
	}
	return _eb.Sprintf("\u0025.\u0032\u0066\u0020\u0066\u006f\u006e\u0074\u0073\u0069\u007a\u0065=\u0025\u002e\u0032\u0066\u0020\u0025\u0064\u0020\u0025\u0071", _gcbc.PdfRectangle, _gcbc._cdc, len(_bccg), _bccg)
}
func (_bgebe paraList) eventNeighbours(_fgbdd []event) map[*textPara][]int {
	_c.Slice(_fgbdd, func(_dfbg, _cbef int) bool {
		_dbfcf, _defg := _fgbdd[_dfbg], _fgbdd[_cbef]
		_ebdf, _eccfd := _dbfcf._ecgg, _defg._ecgg
		if _ebdf != _eccfd {
			return _ebdf < _eccfd
		}
		if _dbfcf._bcecb != _defg._bcecb {
			return _dbfcf._bcecb
		}
		return _dfbg < _cbef
	})
	_dffcg := make(map[int]intSet)
	_dacbb := make(intSet)
	for _, _cdge := range _fgbdd {
		if _cdge._bcecb {
			_dffcg[_cdge._eade] = make(intSet)
			for _bcefa := range _dacbb {
				if _bcefa != _cdge._eade {
					_dffcg[_cdge._eade].add(_bcefa)
					_dffcg[_bcefa].add(_cdge._eade)
				}
			}
			_dacbb.add(_cdge._eade)
		} else {
			_dacbb.del(_cdge._eade)
		}
	}
	_ffce := map[*textPara][]int{}
	for _befee, _ceadg := range _dffcg {
		_cccbg := _bgebe[_befee]
		if len(_ceadg) == 0 {
			_ffce[_cccbg] = nil
			continue
		}
		_bbgbc := make([]int, len(_ceadg))
		_cfcb := 0
		for _gace := range _ceadg {
			_bbgbc[_cfcb] = _gace
			_cfcb++
		}
		_ffce[_cccbg] = _bbgbc
	}
	return _ffce
}
func _acgf(_cfea byte) bool {
	for _, _gffd := range _bdgg {
		if []byte(_gffd)[0] == _cfea {
			return true
		}
	}
	return false
}
func _bggc(_cfcgc _ba.PdfRectangle, _ebag []*textLine) *textPara {
	return &textPara{PdfRectangle: _cfcgc, _eeedg: _ebag}
}
func _dcgc(_cdbg _ba.PdfRectangle) rulingKind {
	_adce := _cdbg.Width()
	_dcef := _cdbg.Height()
	if _adce > _dcef {
		if _adce >= _gada {
			return _deg
		}
	} else {
		if _dcef >= _gada {
			return _aagff
		}
	}
	return _affd
}

type compositeCell struct {
	_ba.PdfRectangle
	paraList
}

const (
	_fbe = "\u0045\u0052R\u004f\u0052\u003a\u0020\u0043\u0061\u006e\u0027\u0074\u0020\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0020\u0066\u006f\u006e\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u002c\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0074\u0079\u0070\u0065"
	_cf  = "\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043a\u006e\u0027\u0074 g\u0065\u0074\u0020\u0066\u006f\u006et\u0020\u0070\u0072\u006f\u0070\u0065\u0072\u0074\u0069\u0065\u0073\u002c\u0020\u0066\u006fn\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u006fu\u006e\u0064"
	_bdg = "\u0045\u0052\u0052O\u0052\u003a\u0020\u0043\u0061\u006e\u0027\u0074\u0020\u0067\u0065\u0074\u0020\u0066\u006f\u006e\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u002c\u0020\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0074\u0079\u0070\u0065"
)

// Append appends `mark` to the mark array.
func (_ffcf *TextMarkArray) Append(mark TextMark) { _ffcf._fcca = append(_ffcf._fcca, mark) }

// String returns a string describing `tm`.
func (_fcgb TextMark) String() string {
	_fgege := _fcgb.BBox
	var _bgaf string
	if _fcgb.Font != nil {
		_bgaf = _fcgb.Font.String()
		if len(_bgaf) > 50 {
			_bgaf = _bgaf[:50] + "\u002e\u002e\u002e"
		}
	}
	var _ffd string
	if _fcgb.Meta {
		_ffd = "\u0020\u002a\u004d\u002a"
	}
	return _eb.Sprintf("\u007b\u0054\u0065\u0078t\u004d\u0061\u0072\u006b\u003a\u0020\u0025\u0064\u0020%\u0071\u003d\u0025\u0030\u0032\u0078\u0020\u0028\u0025\u0036\u002e\u0032\u0066\u002c\u0020\u0025\u0036\u002e2\u0066\u0029\u0020\u0028\u00256\u002e\u0032\u0066\u002c\u0020\u0025\u0036\u002e\u0032\u0066\u0029\u0020\u0025\u0073\u0025\u0073\u007d", _fcgb.Offset, _fcgb.Text, []rune(_fcgb.Text), _fgege.Llx, _fgege.Lly, _fgege.Urx, _fgege.Ury, _bgaf, _ffd)
}

// String returns a description of `state`.
func (_ffff *textState) String() string {
	_afgf := "\u005bN\u004f\u0054\u0020\u0053\u0045\u0054]"
	if _ffff._edd != nil {
		_afgf = _ffff._edd.BaseFont()
	}
	return _eb.Sprintf("\u0074\u0063\u003d\u0025\u002e\u0032\u0066\u0020\u0074\u0077\u003d\u0025\u002e\u0032\u0066 \u0074f\u0073\u003d\u0025\u002e\u0032\u0066\u0020\u0066\u006f\u006e\u0074\u003d\u0025\u0071", _ffff._bdag, _ffff._ega, _ffff._fgeg, _afgf)
}

// PageFonts represents extracted fonts on a PDF page.
type PageFonts struct{ Fonts []Font }

func _fbcge(_bcgg []*textLine, _ecgc string) string {
	var _gbgf _a.Builder
	_cbggd := 0.0
	for _adfc, _ccebg := range _bcgg {
		_fdac := _ccebg.text()
		_egdg := _ccebg._gfeac
		if _adfc < len(_bcgg)-1 {
			_cbggd = _bcgg[_adfc+1]._gfeac
		} else {
			_cbggd = 0.0
		}
		_gbgf.WriteString(_ecgc)
		_gbgf.WriteString(_fdac)
		if _cbggd != _egdg {
			_gbgf.WriteString("\u000a")
		} else {
			_gbgf.WriteString("\u0020")
		}
	}
	return _gbgf.String()
}

var (
	_eeggcb = map[rune]string{0x0060: "\u0300", 0x02CB: "\u0300", 0x0027: "\u0301", 0x00B4: "\u0301", 0x02B9: "\u0301", 0x02CA: "\u0301", 0x005E: "\u0302", 0x02C6: "\u0302", 0x007E: "\u0303", 0x02DC: "\u0303", 0x00AF: "\u0304", 0x02C9: "\u0304", 0x02D8: "\u0306", 0x02D9: "\u0307", 0x00A8: "\u0308", 0x00B0: "\u030a", 0x02DA: "\u030a", 0x02BA: "\u030b", 0x02DD: "\u030b", 0x02C7: "\u030c", 0x02C8: "\u030d", 0x0022: "\u030e", 0x02BB: "\u0312", 0x02BC: "\u0313", 0x0486: "\u0313", 0x055A: "\u0313", 0x02BD: "\u0314", 0x0485: "\u0314", 0x0559: "\u0314", 0x02D4: "\u031d", 0x02D5: "\u031e", 0x02D6: "\u031f", 0x02D7: "\u0320", 0x02B2: "\u0321", 0x00B8: "\u0327", 0x02CC: "\u0329", 0x02B7: "\u032b", 0x02CD: "\u0331", 0x005F: "\u0332", 0x204E: "\u0359"}
)

func (_gbbc paraList) extractTables(_aaabg []gridTiling) paraList {
	if _egdf {
		_b.Log.Debug("\u0065\u0078\u0074r\u0061\u0063\u0074\u0054\u0061\u0062\u006c\u0065\u0073\u003d\u0025\u0064\u0020\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u0078\u003d\u003d\u003d\u003d=\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d", len(_gbbc))
	}
	if len(_gbbc) < _deaa {
		return _gbbc
	}
	_gacgf := _gbbc.findTables(_aaabg)
	if _egdf {
		_b.Log.Info("c\u006f\u006d\u0062\u0069\u006e\u0065d\u0020\u0074\u0061\u0062\u006c\u0065s\u0020\u0025\u0064\u0020\u003d\u003d\u003d=\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d=\u003d", len(_gacgf))
		for _fcceb, _agaa := range _gacgf {
			_agaa.log(_eb.Sprintf("c\u006f\u006d\u0062\u0069\u006e\u0065\u0064\u0020\u0025\u0064", _fcceb))
		}
	}
	return _gbbc.applyTables(_gacgf)
}
func (_gde *imageExtractContext) processOperand(_cdb *_de.ContentStreamOperation, _ca _de.GraphicsState, _geg *_ba.PdfPageResources) error {
	if _cdb.Operand == "\u0042\u0049" && len(_cdb.Params) == 1 {
		_db, _ag := _cdb.Params[0].(*_de.ContentStreamInlineImage)
		if !_ag {
			return nil
		}
		if _fgf, _gba := _fb.GetBoolVal(_db.ImageMask); _gba {
			if _fgf && !_gde._ggf.IncludeInlineStencilMasks {
				return nil
			}
		}
		return _gde.extractInlineImage(_db, _ca, _geg)
	} else if _cdb.Operand == "\u0044\u006f" && len(_cdb.Params) == 1 {
		_cfe, _aa := _fb.GetName(_cdb.Params[0])
		if !_aa {
			_b.Log.Debug("E\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0079\u0070\u0065")
			return _bag
		}
		_, _ff := _geg.GetXObjectByName(*_cfe)
		switch _ff {
		case _ba.XObjectTypeImage:
			return _gde.extractXObjectImage(_cfe, _ca, _geg)
		case _ba.XObjectTypeForm:
			return _gde.extractFormImages(_cfe, _ca, _geg)
		}
	}
	return nil
}
func (_dagb paraList) writeText(_dbdd _ge.Writer) {
	for _abcf, _efgd := range _dagb {
		if _efgd._fcbg {
			continue
		}
		_efgd.writeText(_dbdd)
		if _abcf != len(_dagb)-1 {
			if _edgg(_efgd, _dagb[_abcf+1]) {
				_dbdd.Write([]byte("\u0020"))
			} else {
				_dbdd.Write([]byte("\u000a"))
				_dbdd.Write([]byte("\u000a"))
			}
		}
	}
	_dbdd.Write([]byte("\u000a"))
	_dbdd.Write([]byte("\u000a"))
}
func _aegae(_ecbfa map[float64][]*textLine) []float64 {
	_eddc := []float64{}
	for _fcgge := range _ecbfa {
		_eddc = append(_eddc, _fcgge)
	}
	_c.Float64s(_eddc)
	return _eddc
}
func (_dffe *shapesState) devicePoint(_bedea, _gacd float64) _cbc.Point {
	_cggbg := _dffe._dgcb.Mult(_dffe._ggfc)
	_bedea, _gacd = _cggbg.Transform(_bedea, _gacd)
	return _cbc.NewPoint(_bedea, _gacd)
}
func (_eafad intSet) has(_dgbbc int) bool {
	_, _fedcc := _eafad[_dgbbc]
	return _fedcc
}

// ApplyArea processes the page text only within the specified area `bbox`.
// Each time ApplyArea is called, it updates the result set in `pt`.
// Can be called multiple times in a row with different bounding boxes.
func (_daa *PageText) ApplyArea(bbox _ba.PdfRectangle) {
	_edfc := make([]*textMark, 0, len(_daa._dafg))
	for _, _bfb := range _daa._dafg {
		if _dfdg(_bfb.bbox(), bbox) {
			_edfc = append(_edfc, _bfb)
		}
	}
	var _fabda paraList
	_gbg := len(_edfc)
	for _ccfc := 0; _ccfc < 360 && _gbg > 0; _ccfc += 90 {
		_aebc := make([]*textMark, 0, len(_edfc)-_gbg)
		for _, _ggfb := range _edfc {
			if _ggfb._dbd == _ccfc {
				_aebc = append(_aebc, _ggfb)
			}
		}
		if len(_aebc) > 0 {
			_fce := _bfea(_aebc, _daa._bgaa, nil, nil, _daa._gadg._aeac)
			_fabda = append(_fabda, _fce...)
			_gbg -= len(_aebc)
		}
	}
	_geb := new(_f.Buffer)
	_fabda.writeText(_geb)
	_daa._bab = _geb.String()
	_daa._bdbb = _fabda.toTextMarks()
	_daa._efbd = _fabda.tables()
}
func (_edcg *stateStack) size() int            { return len(*_edcg) }
func (_cacc *textMark) bbox() _ba.PdfRectangle { return _cacc.PdfRectangle }
func (_eagg rectRuling) checkWidth(_ccbf, _ecgfe float64) (float64, bool) {
	_dbfeg := _ecgfe - _ccbf
	_edcb := _dbfeg <= _ebbd
	return _dbfeg, _edcb
}
func _gaeg(_dfbag, _fefc _ga.Image) _ga.Image {
	_eedca, _bgfae := _fefc.Bounds().Size(), _dfbag.Bounds().Size()
	_cbbba, _egcc := _eedca.X, _eedca.Y
	if _bgfae.X > _cbbba {
		_cbbba = _bgfae.X
	}
	if _bgfae.Y > _egcc {
		_egcc = _bgfae.Y
	}
	_bafa := _ga.Rect(0, 0, _cbbba, _egcc)
	if _eedca.X != _cbbba || _eedca.Y != _egcc {
		_bgedc := _ga.NewRGBA(_bafa)
		_fe.BiLinear.Scale(_bgedc, _bafa, _dfbag, _fefc.Bounds(), _fe.Over, nil)
		_fefc = _bgedc
	}
	if _bgfae.X != _cbbba || _bgfae.Y != _egcc {
		_adaa := _ga.NewRGBA(_bafa)
		_fe.BiLinear.Scale(_adaa, _bafa, _dfbag, _dfbag.Bounds(), _fe.Over, nil)
		_dfbag = _adaa
	}
	_gbad := _ga.NewRGBA(_bafa)
	_fe.DrawMask(_gbad, _bafa, _dfbag, _ga.Point{}, _fefc, _ga.Point{}, _fe.Over)
	return _gbad
}

const _cab = 10

func _gcedb(_gegcf int, _gfcad func(int, int) bool) []int {
	_fbggc := make([]int, _gegcf)
	for _bebac := range _fbggc {
		_fbggc[_bebac] = _bebac
	}
	_c.Slice(_fbggc, func(_bbdb, _deafc int) bool { return _gfcad(_fbggc[_bbdb], _fbggc[_deafc]) })
	return _fbggc
}
func _dfdg(_fbbf, _ffcg _ba.PdfRectangle) bool { return _fgfea(_fbbf, _ffcg) && _dcbb(_fbbf, _ffcg) }
func (_efcebf rulingList) sort()               { _c.Slice(_efcebf, _efcebf.comp) }

// String returns a human readable description of `vecs`.
func (_cdaa rulingList) String() string {
	if len(_cdaa) == 0 {
		return "\u007b \u0045\u004d\u0050\u0054\u0059\u0020}"
	}
	_dfbda, _fcbba := _cdaa.vertsHorzs()
	_bggeae := len(_dfbda)
	_cbbg := len(_fcbba)
	if _bggeae == 0 || _cbbg == 0 {
		return _eb.Sprintf("\u007b%\u0064\u0020\u0078\u0020\u0025\u0064}", _bggeae, _cbbg)
	}
	_cbagf := _ba.PdfRectangle{Llx: _dfbda[0]._abfa, Urx: _dfbda[_bggeae-1]._abfa, Lly: _fcbba[_cbbg-1]._abfa, Ury: _fcbba[0]._abfa}
	return _eb.Sprintf("\u007b\u0025d\u0020\u0078\u0020%\u0064\u003a\u0020\u0025\u0036\u002e\u0032\u0066\u007d", _bggeae, _cbbg, _cbagf)
}
func (_dcba *wordBag) text() string {
	_adda := _dcba.allWords()
	_efce := make([]string, len(_adda))
	for _gfce, _bfcd := range _adda {
		_efce[_gfce] = _bfcd._cdfe
	}
	return _a.Join(_efce, "\u0020")
}
func _bgbg(_cbcb []*wordBag) []*wordBag {
	if len(_cbcb) <= 1 {
		return _cbcb
	}
	if _dga {
		_b.Log.Info("\u006d\u0065\u0072\u0067\u0065\u0057\u006f\u0072\u0064B\u0061\u0067\u0073\u003a")
	}
	_c.Slice(_cbcb, func(_gabeg, _ggcc int) bool {
		_fadb, _bace := _cbcb[_gabeg], _cbcb[_ggcc]
		_fdce := _fadb.Width() * _fadb.Height()
		_cbaad := _bace.Width() * _bace.Height()
		if _fdce != _cbaad {
			return _fdce > _cbaad
		}
		if _fadb.Height() != _bace.Height() {
			return _fadb.Height() > _bace.Height()
		}
		return _gabeg < _ggcc
	})
	var _cdef []*wordBag
	_bbg := make(intSet)
	for _gfaa := 0; _gfaa < len(_cbcb); _gfaa++ {
		if _bbg.has(_gfaa) {
			continue
		}
		_effa := _cbcb[_gfaa]
		for _efeed := _gfaa + 1; _efeed < len(_cbcb); _efeed++ {
			if _bbg.has(_gfaa) {
				continue
			}
			_gbb := _cbcb[_efeed]
			_bbfac := _effa.PdfRectangle
			_bbfac.Llx -= _effa._cdc
			if _egbb(_bbfac, _gbb.PdfRectangle) {
				_effa.absorb(_gbb)
				_bbg.add(_efeed)
			}
		}
		_cdef = append(_cdef, _effa)
	}
	if len(_cbcb) != len(_cdef)+len(_bbg) {
		_b.Log.Error("\u006d\u0065\u0072ge\u0057\u006f\u0072\u0064\u0042\u0061\u0067\u0073\u003a \u0025d\u2192%\u0064 \u0061\u0062\u0073\u006f\u0072\u0062\u0065\u0064\u003d\u0025\u0064", len(_cbcb), len(_cdef), len(_bbg))
	}
	return _cdef
}
func (_cedg *textObject) newTextMark(_ecbfb string, _abac _cbc.Matrix, _cbdc _cbc.Point, _bbfb float64, _gged *_ba.PdfFont, _fcdd float64, _abfce, _fcddb _ea.Color, _ccad _fb.PdfObject, _bccae []string, _gafa int, _adbf int) (textMark, bool) {
	_bcgd := _abac.Angle()
	_eeac := _abfg(_bcgd, _bfda)
	var _bgaaf float64
	if _eeac%180 != 90 {
		_bgaaf = _abac.ScalingFactorY()
	} else {
		_bgaaf = _abac.ScalingFactorX()
	}
	_fdfg := _gaab(_abac)
	_faec := _ba.PdfRectangle{Llx: _fdfg.X, Lly: _fdfg.Y, Urx: _cbdc.X, Ury: _cbdc.Y}
	switch _eeac % 360 {
	case 90:
		_faec.Urx -= _bgaaf
	case 180:
		_faec.Ury -= _bgaaf
	case 270:
		_faec.Urx += _bgaaf
	case 0:
		_faec.Ury += _bgaaf
	default:
		_eeac = 0
		_faec.Ury += _bgaaf
	}
	if _faec.Llx > _faec.Urx {
		_faec.Llx, _faec.Urx = _faec.Urx, _faec.Llx
	}
	if _faec.Lly > _faec.Ury {
		_faec.Lly, _faec.Ury = _faec.Ury, _faec.Lly
	}
	_cgde := true
	if _cedg._egff._be.Width() > 0 {
		_dgfg, _bdace := _dbafc(_faec, _cedg._egff._be)
		if !_bdace {
			_cgde = false
			_b.Log.Debug("\u0054\u0065\u0078\u0074\u0020m\u0061\u0072\u006b\u0020\u006f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0070a\u0067\u0065\u002e\u0020\u0062\u0062\u006f\u0078\u003d\u0025\u0067\u0020\u006d\u0065\u0064\u0069\u0061\u0042\u006f\u0078\u003d\u0025\u0067\u0020\u0074\u0065\u0078\u0074\u003d\u0025q", _faec, _cedg._egff._be, _ecbfb)
		}
		_faec = _dgfg
	}
	_cacb := _faec
	_fbcga := _cedg._egff._be
	switch _eeac % 360 {
	case 90:
		_fbcga.Urx, _fbcga.Ury = _fbcga.Ury, _fbcga.Urx
		_cacb = _ba.PdfRectangle{Llx: _fbcga.Urx - _faec.Ury, Urx: _fbcga.Urx - _faec.Lly, Lly: _faec.Llx, Ury: _faec.Urx}
	case 180:
		_cacb = _ba.PdfRectangle{Llx: _fbcga.Urx - _faec.Llx, Urx: _fbcga.Urx - _faec.Urx, Lly: _fbcga.Ury - _faec.Lly, Ury: _fbcga.Ury - _faec.Ury}
	case 270:
		_fbcga.Urx, _fbcga.Ury = _fbcga.Ury, _fbcga.Urx
		_cacb = _ba.PdfRectangle{Llx: _faec.Ury, Urx: _faec.Lly, Lly: _fbcga.Ury - _faec.Llx, Ury: _fbcga.Ury - _faec.Urx}
	}
	if _cacb.Llx > _cacb.Urx {
		_cacb.Llx, _cacb.Urx = _cacb.Urx, _cacb.Llx
	}
	if _cacb.Lly > _cacb.Ury {
		_cacb.Lly, _cacb.Ury = _cacb.Ury, _cacb.Lly
	}
	_ccbg := textMark{_abfc: _ecbfb, PdfRectangle: _cacb, _ebgaa: _faec, _gbfa: _gged, _baea: _bgaaf, _gbdg: _fcdd, _ggab: _abac, _edaf: _cbdc, _dbd: _eeac, _dgfdef: _abfce, _efbfe: _fcddb, _affgg: _ccad, _bgcc: _bccae, Th: _cedg._fggf._gaff, Tw: _cedg._fggf._ega, _gcfa: _adbf, _edeb: _gafa}
	if _fcec {
		_b.Log.Info("n\u0065\u0077\u0054\u0065\u0078\u0074M\u0061\u0072\u006b\u003a\u0020\u0073t\u0061\u0072\u0074\u003d\u0025\u002e\u0032f\u0020\u0065\u006e\u0064\u003d\u0025\u002e\u0032\u0066\u0020%\u0073", _fdfg, _cbdc, _ccbg.String())
	}
	return _ccbg, _cgde
}
func (_ecg *textObject) checkOp(_gce *_de.ContentStreamOperation, _dde int, _eec bool) (_gaf bool, _fbc error) {
	if _ecg == nil {
		var _dccf []_fb.PdfObject
		if _dde > 0 {
			_dccf = _gce.Params
			if len(_dccf) > _dde {
				_dccf = _dccf[:_dde]
			}
		}
		_b.Log.Debug("\u0025\u0023q \u006f\u0070\u0065r\u0061\u006e\u0064\u0020out\u0073id\u0065\u0020\u0074\u0065\u0078\u0074\u002e p\u0061\u0072\u0061\u006d\u0073\u003d\u0025+\u0076", _gce.Operand, _dccf)
	}
	if _dde >= 0 {
		if len(_gce.Params) != _dde {
			if _eec {
				_fbc = _d.New("\u0069n\u0063\u006f\u0072\u0072e\u0063\u0074\u0020\u0070\u0061r\u0061m\u0065t\u0065\u0072\u0020\u0063\u006f\u0075\u006et")
			}
			_b.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0025\u0023\u0071\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020h\u0061\u0076\u0065\u0020\u0025\u0064\u0020i\u006e\u0070\u0075\u0074\u0020\u0070\u0061\u0072\u0061\u006d\u0073,\u0020\u0067\u006f\u0074\u0020\u0025\u0064\u0020\u0025\u002b\u0076", _gce.Operand, _dde, len(_gce.Params), _gce.Params)
			return false, _fbc
		}
	}
	return true, nil
}

// String returns a description of `p`.
func (_bbd *textPara) String() string {
	if _bbd._fcbg {
		return _eb.Sprintf("\u0025\u0036\u002e\u0032\u0066\u0020\u005b\u0045\u004d\u0050\u0054\u0059\u005d", _bbd.PdfRectangle)
	}
	_cfef := ""
	if _bbd._beefb != nil {
		_cfef = _eb.Sprintf("\u005b\u0025\u0064\u0078\u0025\u0064\u005d\u0020", _bbd._beefb._gdab, _bbd._beefb._ggeg)
	}
	return _eb.Sprintf("\u0025\u0036\u002e\u0032f \u0025\u0073\u0025\u0064\u0020\u006c\u0069\u006e\u0065\u0073\u0020\u0025\u0071", _bbd.PdfRectangle, _cfef, len(_bbd._eeedg), _eaacd(_bbd.text(), 50))
}
func (_fdga *textTable) reduceTiling(_bdbf gridTiling, _cdbdf float64) *textTable {
	_cffb := make([]int, 0, _fdga._ggeg)
	_gacgc := make([]int, 0, _fdga._gdab)
	_bgadd := _bdbf._gegbb
	_gdac := _bdbf._cbab
	for _cadeg := 0; _cadeg < _fdga._ggeg; _cadeg++ {
		_cedb := _cadeg > 0 && _cc.Abs(_gdac[_cadeg-1]-_gdac[_cadeg]) < _cdbdf && _fdga.emptyCompositeRow(_cadeg)
		if !_cedb {
			_cffb = append(_cffb, _cadeg)
		}
	}
	for _adecf := 0; _adecf < _fdga._gdab; _adecf++ {
		_cdcd := _adecf < _fdga._gdab-1 && _cc.Abs(_bgadd[_adecf+1]-_bgadd[_adecf]) < _cdbdf && _fdga.emptyCompositeColumn(_adecf)
		if !_cdcd {
			_gacgc = append(_gacgc, _adecf)
		}
	}
	if len(_cffb) == _fdga._ggeg && len(_gacgc) == _fdga._gdab {
		return _fdga
	}
	_gcdeb := textTable{_dggfe: _fdga._dggfe, _gdab: len(_gacgc), _ggeg: len(_cffb), _bbgacd: make(map[uint64]compositeCell, len(_gacgc)*len(_cffb))}
	if _egdf {
		_b.Log.Info("\u0072\u0065\u0064\u0075c\u0065\u0054\u0069\u006c\u0069\u006e\u0067\u003a\u0020\u0025d\u0078%\u0064\u0020\u002d\u003e\u0020\u0025\u0064x\u0025\u0064", _fdga._gdab, _fdga._ggeg, len(_gacgc), len(_cffb))
		_b.Log.Info("\u0072\u0065d\u0075\u0063\u0065d\u0043\u006f\u006c\u0073\u003a\u0020\u0025\u002b\u0076", _gacgc)
		_b.Log.Info("\u0072\u0065d\u0075\u0063\u0065d\u0052\u006f\u0077\u0073\u003a\u0020\u0025\u002b\u0076", _cffb)
	}
	for _fffebg, _bgcgd := range _cffb {
		for _adgd, _dcff := range _gacgc {
			_cbdd, _becbd := _fdga.getComposite(_dcff, _bgcgd)
			if len(_cbdd) == 0 {
				continue
			}
			if _egdf {
				_eb.Printf("\u0020 \u0025\u0032\u0064\u002c \u0025\u0032\u0064\u0020\u0028%\u0032d\u002c \u0025\u0032\u0064\u0029\u0020\u0025\u0071\n", _adgd, _fffebg, _dcff, _bgcgd, _eaacd(_cbdd.merge().text(), 50))
			}
			_gcdeb.putComposite(_adgd, _fffebg, _cbdd, _becbd)
		}
	}
	return &_gcdeb
}

type cachedImage struct {
	_fgb *_ba.Image
	_cec _ba.PdfColorspace
}

// String returns a description of `k`.
func (_bbbae rulingKind) String() string {
	_febd, _ecbgd := _gdgcc[_bbbae]
	if !_ecbgd {
		return _eb.Sprintf("\u004e\u006ft\u0020\u0061\u0020r\u0075\u006c\u0069\u006e\u0067\u003a\u0020\u0025\u0064", _bbbae)
	}
	return _febd
}
func (_bbacg paraList) findTableGrid(_ccecd gridTiling) (*textTable, map[*textPara]struct{}) {
	_fbdae := len(_ccecd._gegbb)
	_bfgd := len(_ccecd._cbab)
	_cddba := textTable{_dggfe: true, _gdab: _fbdae, _ggeg: _bfgd, _gabega: make(map[uint64]*textPara, _fbdae*_bfgd), _bbgacd: make(map[uint64]compositeCell, _fbdae*_bfgd)}
	_cddba.PdfRectangle = _ccecd.PdfRectangle
	_agcb := make(map[*textPara]struct{})
	_cbebg := int((1.0 - _dcda) * float64(_fbdae*_bfgd))
	_cccf := 0
	if _ceac {
		_b.Log.Info("\u0066\u0069\u006e\u0064Ta\u0062\u006c\u0065\u0047\u0072\u0069\u0064\u003a\u0020\u0025\u0064\u0020\u0078\u0020%\u0064", _fbdae, _bfgd)
	}
	for _agcg, _agfef := range _ccecd._cbab {
		_gfcea, _cgddg := _ccecd._fbgfa[_agfef]
		if !_cgddg {
			continue
		}
		for _acdcf, _bgfe := range _ccecd._gegbb {
			_efdg, _dcbfca := _gfcea[_bgfe]
			if !_dcbfca {
				continue
			}
			_adgg := _bbacg.inTile(_efdg)
			if len(_adgg) == 0 {
				_cccf++
				if _cccf > _cbebg {
					if _ceac {
						_b.Log.Info("\u0021\u006e\u0075m\u0045\u006d\u0070\u0074\u0079\u003d\u0025\u0064", _cccf)
					}
					return nil, nil
				}
			} else {
				_cddba.putComposite(_acdcf, _agcg, _adgg, _efdg.PdfRectangle)
				for _, _bfeda := range _adgg {
					_agcb[_bfeda] = struct{}{}
				}
			}
		}
	}
	_gcec := 0
	for _bece := 0; _bece < _fbdae; _bece++ {
		_cbeea := _cddba.get(_bece, 0)
		if _cbeea == nil || !_cbeea._fcbg {
			_gcec++
		}
	}
	if _gcec == 0 {
		if _ceac {
			_b.Log.Info("\u0021\u006e\u0075m\u0048\u0065\u0061\u0064\u0065\u0072\u003d\u0030")
		}
		return nil, nil
	}
	_gcce := _cddba.reduceTiling(_ccecd, _agac)
	_gcce = _gcce.subdivide()
	return _gcce, _agcb
}
func (_cgffg *shapesState) moveTo(_efbaa, _fecc float64) {
	_cgffg._efa = true
	_cgffg._efcbf = _cgffg.devicePoint(_efbaa, _fecc)
	if _adbb {
		_b.Log.Info("\u006d\u006fv\u0065\u0054\u006f\u003a\u0020\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0020\u0064\u0065\u0076\u0069\u0063\u0065\u003d%.\u0032\u0066", _efbaa, _fecc, _cgffg._efcbf)
	}
}
func _bgca(_dcd bounded) float64 { return -_dcd.bbox().Lly }
func (_dggf *textObject) setFont(_befb string, _adba float64) error {
	if _dggf == nil {
		return nil
	}
	_dggf._fggf._fgeg = _adba
	_fcc, _cdag := _dggf.getFont(_befb)
	if _cdag != nil {
		return _cdag
	}
	_dggf._fggf._edd = _fcc
	return nil
}
func (_dfbb paraList) reorder(_cafd []int) {
	_aaad := make(paraList, len(_dfbb))
	for _gddde, _gabbg := range _cafd {
		_aaad[_gddde] = _dfbb[_gabbg]
	}
	copy(_dfbb, _aaad)
}
func (_bfe *textObject) getFontDict(_afef string) (_bebg _fb.PdfObject, _cede error) {
	_efbf := _bfe._adg
	if _efbf == nil {
		_b.Log.Debug("g\u0065\u0074\u0046\u006f\u006e\u0074D\u0069\u0063\u0074\u002e\u0020\u004eo\u0020\u0072\u0065\u0073\u006f\u0075\u0072c\u0065\u0073\u002e\u0020\u006e\u0061\u006d\u0065\u003d\u0025#\u0071", _afef)
		return nil, nil
	}
	_bebg, _cggb := _efbf.GetFontByName(_fb.PdfObjectName(_afef))
	if !_cggb {
		_b.Log.Debug("\u0045R\u0052\u004fR\u003a\u0020\u0067\u0065t\u0046\u006f\u006et\u0044\u0069\u0063\u0074\u003a\u0020\u0046\u006f\u006et \u006e\u006f\u0074 \u0066\u006fu\u006e\u0064\u003a\u0020\u006e\u0061m\u0065\u003d%\u0023\u0071", _afef)
		return nil, _d.New("f\u006f\u006e\u0074\u0020no\u0074 \u0069\u006e\u0020\u0072\u0065s\u006f\u0075\u0072\u0063\u0065\u0073")
	}
	return _bebg, nil
}
func (_ccebgc *textTable) isExportable() bool {
	if _ccebgc._dggfe {
		return true
	}
	_egfdb := func(_cadbgb int) bool {
		_cfcdc := _ccebgc.get(0, _cadbgb)
		if _cfcdc == nil {
			return false
		}
		_bedb := _cfcdc.text()
		_fdgd := _dc.RuneCountInString(_bedb)
		_ceeb := _cgggc.MatchString(_bedb)
		return _fdgd <= 1 || _ceeb
	}
	for _aedac := 0; _aedac < _ccebgc._ggeg; _aedac++ {
		if !_egfdb(_aedac) {
			return true
		}
	}
	return false
}
func (_bebf *wordBag) depthIndexes() []int {
	if len(_bebf._agfg) == 0 {
		return nil
	}
	_bdbg := make([]int, len(_bebf._agfg))
	_fdcc := 0
	for _acgb := range _bebf._agfg {
		_bdbg[_fdcc] = _acgb
		_fdcc++
	}
	_c.Ints(_bdbg)
	return _bdbg
}
func _bdge(_bcdca _ba.PdfRectangle) *ruling {
	return &ruling{_adad: _aagff, _abfa: _bcdca.Llx, _bgbbf: _bcdca.Lly, _dffbe: _bcdca.Ury}
}

// String returns a description of `t`.
func (_faegf *textTable) String() string {
	return _eb.Sprintf("\u0025\u0064\u0020\u0078\u0020\u0025\u0064\u0020\u0025\u0074", _faegf._gdab, _faegf._ggeg, _faegf._dggfe)
}

type rectRuling struct {
	_afcb rulingKind
	_bfce markKind
	_ea.Color
	_ba.PdfRectangle
}

func (_effc gridTiling) log(_cebc string) {
	if !_ceac {
		return
	}
	_b.Log.Info("\u0074i\u006ci\u006e\u0067\u003a\u0020\u0025d\u0020\u0078 \u0025\u0064\u0020\u0025\u0071", len(_effc._gegbb), len(_effc._cbab), _cebc)
	_eb.Printf("\u0020\u0020\u0020l\u006c\u0078\u003d\u0025\u002e\u0032\u0066\u000a", _effc._gegbb)
	_eb.Printf("\u0020\u0020\u0020l\u006c\u0079\u003d\u0025\u002e\u0032\u0066\u000a", _effc._cbab)
	for _dfac, _egbae := range _effc._cbab {
		_afggd, _edbda := _effc._fbgfa[_egbae]
		if !_edbda {
			continue
		}
		_eb.Printf("%\u0034\u0064\u003a\u0020\u0025\u0036\u002e\u0032\u0066\u000a", _dfac, _egbae)
		for _fagb, _bgbea := range _effc._gegbb {
			_ddacg, _ggagc := _afggd[_bgbea]
			if !_ggagc {
				continue
			}
			_eb.Printf("\u0025\u0038\u0064\u003a\u0020\u0025\u0073\u000a", _fagb, _ddacg.String())
		}
	}
}
func (_baec rulingList) intersections() map[int]intSet {
	var _abec, _bgbbc []int
	for _bcgdcg, _fbcea := range _baec {
		switch _fbcea._adad {
		case _aagff:
			_abec = append(_abec, _bcgdcg)
		case _deg:
			_bgbbc = append(_bgbbc, _bcgdcg)
		}
	}
	if len(_abec) < _afcf+1 || len(_bgbbc) < _ddf+1 {
		return nil
	}
	if len(_abec)+len(_bgbbc) > _dbfc {
		_b.Log.Debug("\u0069\u006e\u0074\u0065\u0072\u0073e\u0063\u0074\u0069\u006f\u006e\u0073\u003a\u0020\u0054\u004f\u004f\u0020\u004d\u0041\u004e\u0059\u0020\u0072\u0075\u006ci\u006e\u0067\u0073\u0020\u0076\u0065\u0063\u0073\u003d\u0025\u0064\u0020\u003d\u0020%\u0064 \u0078\u0020\u0025\u0064", len(_baec), len(_abec), len(_bgbbc))
		return nil
	}
	_cfac := make(map[int]intSet, len(_abec)+len(_bgbbc))
	for _, _bggea := range _abec {
		for _, _dgcbb := range _bgbbc {
			if _baec[_bggea].intersects(_baec[_dgcbb]) {
				if _, _ddgfc := _cfac[_bggea]; !_ddgfc {
					_cfac[_bggea] = make(intSet)
				}
				if _, _beeg := _cfac[_dgcbb]; !_beeg {
					_cfac[_dgcbb] = make(intSet)
				}
				_cfac[_bggea].add(_dgcbb)
				_cfac[_dgcbb].add(_bggea)
			}
		}
	}
	return _cfac
}

type list struct {
	_fcda []*textLine
	_gfdb string
	_gfgd []*list
	_fagf string
}

func (_gdbce paraList) yNeighbours(_afgad float64) map[*textPara][]int {
	_agbc := make([]event, 2*len(_gdbce))
	if _afgad == 0 {
		for _acbd, _ggff := range _gdbce {
			_agbc[2*_acbd] = event{_ggff.Lly, true, _acbd}
			_agbc[2*_acbd+1] = event{_ggff.Ury, false, _acbd}
		}
	} else {
		for _gabfb, _cccga := range _gdbce {
			_agbc[2*_gabfb] = event{_cccga.Lly - _afgad*_cccga.fontsize(), true, _gabfb}
			_agbc[2*_gabfb+1] = event{_cccga.Ury + _afgad*_cccga.fontsize(), false, _gabfb}
		}
	}
	return _gdbce.eventNeighbours(_agbc)
}
func _aaddc(_bcfa map[int]intSet) []int {
	_fdbd := make([]int, 0, len(_bcfa))
	for _cegg := range _bcfa {
		_fdbd = append(_fdbd, _cegg)
	}
	_c.Ints(_fdbd)
	return _fdbd
}
func _ddcb(_egda []*textWord, _fcge int) []*textWord {
	_gbgge := len(_egda)
	copy(_egda[_fcge:], _egda[_fcge+1:])
	return _egda[:_gbgge-1]
}

// TextMark represents extracted text on a page with information regarding both textual content,
// formatting (font and size) and positioning.
// It is the smallest unit of text on a PDF page, typically a single character.
//
// getBBox() in test_text.go shows how to compute bounding boxes of substrings of extracted text.
// The following code extracts the text on PDF page `page` into `text` then finds the bounding box
// `bbox` of substring `term` in `text`.
//
//	ex, _ := New(page)
//	// handle errors
//	pageText, _, _, err := ex.ExtractPageText()
//	// handle errors
//	text := pageText.Text()
//	textMarks := pageText.Marks()
//
//		start := strings.Index(text, term)
//	 end := start + len(term)
//	 spanMarks, err := textMarks.RangeOffset(start, end)
//	 // handle errors
//	 bbox, ok := spanMarks.BBox()
//	 // handle errors
type TextMark struct {

	// Text is the extracted text.
	Text string

	// Original is the text in the PDF. It has not been decoded like `Text`.
	Original string

	// BBox is the bounding box of the text.
	BBox _ba.PdfRectangle

	// Font is the font the text was drawn with.
	Font *_ba.PdfFont

	// FontSize is the font size the text was drawn with.
	FontSize float64

	// Offset is the offset of the start of TextMark.Text in the extracted text. If you do this
	//
	//	text, textMarks := pageText.Text(), pageText.Marks()
	//	marks := textMarks.Elements()
	//
	// then marks[i].Offset is the offset of marks[i].Text in text.
	Offset int

	// Meta is set true for spaces and line breaks that we insert in the extracted text. We insert
	// spaces (line breaks) when we see characters that are over a threshold horizontal (vertical)
	//
	//	distance  apart. See wordJoiner (lineJoiner) in PageText.computeViews().
	Meta bool

	// FillColor is the fill color of the text.
	// The color is nil for spaces and line breaks (i.e. the Meta field is true).
	FillColor _ea.Color

	// StrokeColor is the stroke color of the text.
	// The color is nil for spaces and line breaks (i.e. the Meta field is true).
	StrokeColor _ea.Color

	// Orientation is the text orientation
	Orientation int

	// DirectObject is the underlying PdfObject (Text Object) that represents the visible texts. This is introduced to get
	// a simple access to the TextObject in case editing or replacment of some text is needed. E.g during redaction.
	DirectObject _fb.PdfObject

	// ObjString is a decoded string operand of a text-showing operator. It has the same value as `Text` attribute except
	// when many glyphs are represented with the same Text Object that contains multiple length string operand in which case
	// ObjString spans more than one character string that falls in different TextMark objects.
	ObjString []string
	Tw        float64
	Th        float64
	Tc        float64
	Index     int
	_bcg      bool
	_ecga     *TextTable
}

func (_faea rectRuling) asRuling() (*ruling, bool) {
	_abbgc := ruling{_adad: _faea._afcb, Color: _faea.Color, _eead: _bdec}
	switch _faea._afcb {
	case _aagff:
		_abbgc._abfa = 0.5 * (_faea.Llx + _faea.Urx)
		_abbgc._bgbbf = _faea.Lly
		_abbgc._dffbe = _faea.Ury
		_cfce, _addce := _faea.checkWidth(_faea.Llx, _faea.Urx)
		if !_addce {
			if _daga {
				_b.Log.Error("\u0072\u0065\u0063\u0074\u0052\u0075l\u0069\u006e\u0067\u002e\u0061\u0073\u0052\u0075\u006c\u0069\u006e\u0067\u003a\u0020\u0072\u0075\u006c\u0069\u006e\u0067V\u0065\u0072\u0074\u0020\u0021\u0063\u0068\u0065\u0063\u006b\u0057\u0069\u0064\u0074h\u0020v\u003d\u0025\u002b\u0076", _faea)
			}
			return nil, false
		}
		_abbgc._fbcfe = _cfce
	case _deg:
		_abbgc._abfa = 0.5 * (_faea.Lly + _faea.Ury)
		_abbgc._bgbbf = _faea.Llx
		_abbgc._dffbe = _faea.Urx
		_ccca, _gcdcc := _faea.checkWidth(_faea.Lly, _faea.Ury)
		if !_gcdcc {
			if _daga {
				_b.Log.Error("\u0072\u0065\u0063\u0074\u0052\u0075l\u0069\u006e\u0067\u002e\u0061\u0073\u0052\u0075\u006c\u0069\u006e\u0067\u003a\u0020\u0072\u0075\u006c\u0069\u006e\u0067H\u006f\u0072\u007a\u0020\u0021\u0063\u0068\u0065\u0063\u006b\u0057\u0069\u0064\u0074h\u0020v\u003d\u0025\u002b\u0076", _faea)
			}
			return nil, false
		}
		_abbgc._fbcfe = _ccca
	default:
		_b.Log.Error("\u0062\u0061\u0064\u0020pr\u0069\u006d\u0061\u0072\u0079\u0020\u006b\u0069\u006e\u0064\u003d\u0025\u0064", _faea._afcb)
		return nil, false
	}
	return &_abbgc, true
}
func _fgfea(_fagc, _aabd _ba.PdfRectangle) bool {
	return _aabd.Llx <= _fagc.Urx && _fagc.Llx <= _aabd.Urx
}
func (_eee *textObject) setHorizScaling(_eeb float64) {
	if _eee == nil {
		return
	}
	_eee._fggf._gaff = _eeb
}

var (
	_bag = _d.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
	_dg  = _d.New("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072")
)

type subpath struct {
	_dgfd  []_cbc.Point
	_eadff bool
}

func (_cafe *subpath) clear()                        { *_cafe = subpath{} }
func (_decf *wordBag) firstWord(_gcad int) *textWord { return _decf._agfg[_gcad][0] }
func (_edgb lineRuling) xMean() float64              { return 0.5 * (_edgb._addc.X + _edgb._bfgab.X) }
func (_bcfc *textObject) renderText(_bbfg _fb.PdfObject, _afe []byte, _ggda int) error {
	if _bcfc._ggcbf {
		_b.Log.Debug("\u0072\u0065\u006e\u0064\u0065r\u0054\u0065\u0078\u0074\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064 \u0066\u006f\u006e\u0074\u002e\u0020\u004e\u006f\u0074\u0020\u0070\u0072\u006f\u0063\u0065\u0073\u0073\u0069\u006e\u0067\u002e")
		return nil
	}
	_eef := _bcfc.getCurrentFont()
	_gede := _eef.BytesToCharcodes(_afe)
	_cfg, _eca, _bggg := _eef.CharcodesToStrings(_gede)
	if _bggg > 0 {
		_b.Log.Debug("\u0072\u0065nd\u0065\u0072\u0054e\u0078\u0074\u003a\u0020num\u0043ha\u0072\u0073\u003d\u0025\u0064\u0020\u006eum\u004d\u0069\u0073\u0073\u0065\u0073\u003d%\u0064", _eca, _bggg)
	}
	_bcfc._fggf._ggec += _eca
	_bcfc._fggf._eeg += _bggg
	_deffe := _bcfc._fggf
	_agc := _deffe._fgeg
	_cgb := _deffe._gaff / 100.0
	_cbcd := _eabg
	if _eef.Subtype() == "\u0054\u0079\u0070e\u0033" {
		_cbcd = 1
	}
	_cac, _agf := _eef.GetRuneMetrics(' ')
	if !_agf {
		_cac, _agf = _eef.GetCharMetrics(32)
	}
	if !_agf {
		_cac, _ = _ba.DefaultFont().GetRuneMetrics(' ')
	}
	_edf := _cac.Wx * _cbcd
	_b.Log.Trace("\u0073p\u0061\u0063e\u0057\u0069\u0064t\u0068\u003d\u0025\u002e\u0032\u0066\u0020t\u0065\u0078\u0074\u003d\u0025\u0071 \u0066\u006f\u006e\u0074\u003d\u0025\u0073\u0020\u0066\u006f\u006et\u0053\u0069\u007a\u0065\u003d\u0025\u002e\u0032\u0066", _edf, _cfg, _eef, _agc)
	_aecf := _cbc.NewMatrix(_agc*_cgb, 0, 0, _agc, 0, _deffe._cce)
	if _bbca {
		_b.Log.Info("\u0072\u0065\u006e\u0064\u0065\u0072T\u0065\u0078\u0074\u003a\u0020\u0025\u0064\u0020\u0063\u006f\u0064\u0065\u0073=\u0025\u002b\u0076\u0020\u0074\u0065\u0078t\u0073\u003d\u0025\u0071", len(_gede), _gede, _cfg)
	}
	_b.Log.Trace("\u0072\u0065\u006e\u0064\u0065\u0072T\u0065\u0078\u0074\u003a\u0020\u0025\u0064\u0020\u0063\u006f\u0064\u0065\u0073=\u0025\u002b\u0076\u0020\u0072\u0075\u006ee\u0073\u003d\u0025\u0071", len(_gede), _gede, len(_cfg))
	_eae := _bcfc.getFillColor()
	_ffa := _bcfc.getStrokeColor()
	for _fcd, _ebcg := range _cfg {
		_dae := []rune(_ebcg)
		if len(_dae) == 1 && _dae[0] == '\x00' {
			continue
		}
		_bbb := _gede[_fcd]
		_deffa := _bcfc._bffd.CTM.Mult(_bcfc._deb).Mult(_aecf)
		_fbff := 0.0
		if len(_dae) == 1 && _dae[0] == 32 {
			_fbff = _deffe._ega
		}
		_dbfg, _bgfg := _eef.GetCharMetrics(_bbb)
		if !_bgfg {
			_b.Log.Debug("\u0045R\u0052\u004fR\u003a\u0020\u004e\u006f \u006d\u0065\u0074r\u0069\u0063\u0020\u0066\u006f\u0072\u0020\u0063\u006fde\u003d\u0025\u0064 \u0072\u003d0\u0078\u0025\u0030\u0034\u0078\u003d%\u002b\u0071 \u0025\u0073", _bbb, _dae, _dae, _eef)
			return _eb.Errorf("\u006e\u006f\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073:\u0020f\u006f\u006e\u0074\u003d\u0025\u0073\u0020\u0063\u006f\u0064\u0065\u003d\u0025\u0064", _eef.String(), _bbb)
		}
		_gdbb := _cbc.Point{X: _dbfg.Wx * _cbcd, Y: _dbfg.Wy * _cbcd}
		_edbb := _cbc.Point{X: (_gdbb.X*_agc + _fbff) * _cgb}
		_cba := _cbc.Point{X: (_gdbb.X*_agc + _deffe._bdag + _fbff) * _cgb}
		if _bbca {
			_b.Log.Info("\u0074\u0066\u0073\u003d\u0025\u002e\u0032\u0066\u0020\u0074\u0063\u003d\u0025\u002e\u0032f\u0020t\u0077\u003d\u0025\u002e\u0032\u0066\u0020\u0074\u0068\u003d\u0025\u002e\u0032\u0066", _agc, _deffe._bdag, _deffe._ega, _cgb)
			_b.Log.Info("\u0064x\u002c\u0064\u0079\u003d%\u002e\u0033\u0066\u0020\u00740\u003d%\u002e3\u0066\u0020\u0074\u003d\u0025\u002e\u0033f", _gdbb, _edbb, _cba)
		}
		_agca := _bcec(_edbb)
		_bgag := _bcec(_cba)
		_dcb := _bcfc._bffd.CTM.Mult(_bcfc._deb).Mult(_agca)
		if _efeg {
			_b.Log.Info("e\u006e\u0064\u003a\u000a\tC\u0054M\u003d\u0025\u0073\u000a\u0009 \u0074\u006d\u003d\u0025\u0073\u000a"+"\u0009\u0020t\u0064\u003d\u0025s\u0020\u0078\u006c\u0061\u0074\u003d\u0025\u0073\u000a"+"\u0009t\u0064\u0030\u003d\u0025s\u000a\u0009\u0020\u0020\u2192 \u0025s\u0020x\u006c\u0061\u0074\u003d\u0025\u0073", _bcfc._bffd.CTM, _bcfc._deb, _bgag, _gaab(_bcfc._bffd.CTM.Mult(_bcfc._deb).Mult(_bgag)), _agca, _dcb, _gaab(_dcb))
		}
		_ddd, _bagg := _bcfc.newTextMark(_fa.ExpandLigatures(_dae), _deffa, _gaab(_dcb), _cc.Abs(_edf*_deffa.ScalingFactorX()), _eef, _bcfc._fggf._bdag, _eae, _ffa, _bbfg, _cfg, _fcd, _ggda)
		if !_bagg {
			_b.Log.Debug("\u0054\u0065\u0078\u0074\u0020\u006d\u0061\u0072\u006b\u0020\u006f\u0075\u0074\u0073\u0069d\u0065 \u0070\u0061\u0067\u0065\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067")
			continue
		}
		if _eef == nil {
			_b.Log.Debug("\u0045R\u0052O\u0052\u003a\u0020\u004e\u006f\u0020\u0066\u006f\u006e\u0074\u002e")
		} else if _eef.Encoder() == nil {
			_b.Log.Debug("E\u0052\u0052\u004f\u0052\u003a\u0020N\u006f\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006eg\u002e\u0020\u0066o\u006et\u003d\u0025\u0073", _eef)
		} else {
			if _egge, _aaf := _eef.Encoder().CharcodeToRune(_bbb); _aaf {
				_ddd._bcbff = string(_egge)
			}
		}
		_b.Log.Trace("i\u003d\u0025\u0064\u0020\u0063\u006fd\u0065\u003d\u0025\u0064\u0020\u006d\u0061\u0072\u006b=\u0025\u0073\u0020t\u0072m\u003d\u0025\u0073", _fcd, _bbb, _ddd, _deffa)
		_bcfc._cag = append(_bcfc._cag, &_ddd)
		_bcfc._deb.Concat(_bgag)
	}
	return nil
}
func (_aefg *textPara) isAtom() *textTable {
	_dbgg := _aefg
	_geecf := _aefg._dfcb
	_aagcd := _aefg._bfcbb
	if _geecf.taken() || _aagcd.taken() {
		return nil
	}
	_gcdgc := _geecf._bfcbb
	if _gcdgc.taken() || _gcdgc != _aagcd._dfcb {
		return nil
	}
	return _dfce(_dbgg, _geecf, _aagcd, _gcdgc)
}

// RenderMode specifies the text rendering mode (Tmode), which determines whether showing text shall cause
// glyph outlines to be  stroked, filled, used as a clipping boundary, or some combination of the three.
// Stroking, filling, and clipping shall have the same effects for a text object as they do for a path object
// (see 8.5.3, "Path-Painting Operators" and 8.5.4, "Clipping Path Operators").
type RenderMode int

// BBox returns the smallest axis-aligned rectangle that encloses all the TextMarks in `ma`.
func (_badb *TextMarkArray) BBox() (_ba.PdfRectangle, bool) {
	var _gbda _ba.PdfRectangle
	_cdbd := false
	for _, _ccge := range _badb._fcca {
		if _ccge.Meta || _geccc(_ccge.Text) {
			continue
		}
		if _cdbd {
			_gbda = _eece(_gbda, _ccge.BBox)
		} else {
			_gbda = _ccge.BBox
			_cdbd = true
		}
	}
	return _gbda, _cdbd
}
func (_gccc *textObject) setCharSpacing(_ggd float64) {
	if _gccc == nil {
		return
	}
	_gccc._fggf._bdag = _ggd
	if _bbca {
		_b.Log.Info("\u0073\u0065t\u0043\u0068\u0061\u0072\u0053\u0070\u0061\u0063\u0069\u006e\u0067\u003a\u0020\u0025\u002e\u0032\u0066\u0020\u0073\u0074\u0061\u0074e=\u0025\u0073", _ggd, _gccc._fggf.String())
	}
}
func (_cedc rulingList) merge() *ruling {
	_effaf := _cedc[0]._abfa
	_gdad := _cedc[0]._bgbbf
	_aabee := _cedc[0]._dffbe
	for _, _eeec := range _cedc[1:] {
		_effaf += _eeec._abfa
		if _eeec._bgbbf < _gdad {
			_gdad = _eeec._bgbbf
		}
		if _eeec._dffbe > _aabee {
			_aabee = _eeec._dffbe
		}
	}
	_cfdg := &ruling{_adad: _cedc[0]._adad, _eead: _cedc[0]._eead, Color: _cedc[0].Color, _abfa: _effaf / float64(len(_cedc)), _bgbbf: _gdad, _dffbe: _aabee}
	if _agcad {
		_b.Log.Info("\u006de\u0072g\u0065\u003a\u0020\u0025\u0032d\u0020\u0076e\u0063\u0073\u0020\u0025\u0073", len(_cedc), _cfdg)
		for _gadfg, _caee := range _cedc {
			_eb.Printf("\u0025\u0034\u0064\u003a\u0020\u0025\u0073\u000a", _gadfg, _caee)
		}
	}
	return _cfdg
}
func (_gdfg *textWord) computeText() string {
	_cbgbf := make([]string, len(_gdfg._ebca))
	for _bgec, _abfb := range _gdfg._ebca {
		_cbgbf[_bgec] = _abfb._abfc
	}
	return _a.Join(_cbgbf, "")
}
func (_fecba *textTable) reduce() *textTable {
	_cgefea := make([]int, 0, _fecba._ggeg)
	_cegb := make([]int, 0, _fecba._gdab)
	for _ggbdb := 0; _ggbdb < _fecba._ggeg; _ggbdb++ {
		if !_fecba.emptyCompositeRow(_ggbdb) {
			_cgefea = append(_cgefea, _ggbdb)
		}
	}
	for _gggb := 0; _gggb < _fecba._gdab; _gggb++ {
		if !_fecba.emptyCompositeColumn(_gggb) {
			_cegb = append(_cegb, _gggb)
		}
	}
	if len(_cgefea) == _fecba._ggeg && len(_cegb) == _fecba._gdab {
		return _fecba
	}
	_cbdad := textTable{_dggfe: _fecba._dggfe, _gdab: len(_cegb), _ggeg: len(_cgefea), _gabega: make(map[uint64]*textPara, len(_cegb)*len(_cgefea))}
	if _egdf {
		_b.Log.Info("\u0072\u0065\u0064\u0075ce\u003a\u0020\u0025\u0064\u0078\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0064\u0078%\u0064", _fecba._gdab, _fecba._ggeg, len(_cegb), len(_cgefea))
		_b.Log.Info("\u0072\u0065d\u0075\u0063\u0065d\u0043\u006f\u006c\u0073\u003a\u0020\u0025\u002b\u0076", _cegb)
		_b.Log.Info("\u0072\u0065d\u0075\u0063\u0065d\u0052\u006f\u0077\u0073\u003a\u0020\u0025\u002b\u0076", _cgefea)
	}
	for _egfde, _fbfbdc := range _cgefea {
		for _eeccg, _fabdc := range _cegb {
			_debb, _efgdf := _fecba.getComposite(_fabdc, _fbfbdc)
			if _debb == nil {
				continue
			}
			if _egdf {
				_eb.Printf("\u0020 \u0025\u0032\u0064\u002c \u0025\u0032\u0064\u0020\u0028%\u0032d\u002c \u0025\u0032\u0064\u0029\u0020\u0025\u0071\n", _eeccg, _egfde, _fabdc, _fbfbdc, _eaacd(_debb.merge().text(), 50))
			}
			_cbdad.putComposite(_eeccg, _egfde, _debb, _efgdf)
		}
	}
	return &_cbdad
}
func _gebb(_bdeca, _agccc _cbc.Point) rulingKind {
	_becfg := _cc.Abs(_bdeca.X - _agccc.X)
	_cddd := _cc.Abs(_bdeca.Y - _agccc.Y)
	return _gecef(_becfg, _cddd, _gada)
}
func (_ccfd *stateStack) top() *textState {
	if _ccfd.empty() {
		return nil
	}
	return (*_ccfd)[_ccfd.size()-1]
}
func (_bafe rulingList) toTilings() (rulingList, []gridTiling) {
	_bafe.log("\u0074o\u0054\u0069\u006c\u0069\u006e\u0067s")
	if len(_bafe) == 0 {
		return nil, nil
	}
	_bafe = _bafe.tidied("\u0061\u006c\u006c")
	_bafe.log("\u0074\u0069\u0064\u0069\u0065\u0064")
	_fgdg := _bafe.toGrids()
	_dcdcf := make([]gridTiling, len(_fgdg))
	for _cgdc, _fegf := range _fgdg {
		_dcdcf[_cgdc] = _fegf.asTiling()
	}
	return _bafe, _dcdcf
}
func (_cedef *wordBag) arrangeText() *textPara {
	_cedef.sort()
	if _aeffe {
		_cedef.removeDuplicates()
	}
	var _aabf []*textLine
	for _, _aegg := range _cedef.depthIndexes() {
		for !_cedef.empty(_aegg) {
			_cgbf := _cedef.firstReadingIndex(_aegg)
			_ebdbe := _cedef.firstWord(_cgbf)
			_dcdf := _cedd(_cedef, _cgbf)
			_cddb := _ebdbe._affe
			_fcfba := _ebdbe._gadaf - _dcee*_cddb
			_fccf := _ebdbe._gadaf + _dcee*_cddb
			_egbba := _bdgd * _cddb
			_ecdf := _bbef * _cddb
		_fbd:
			for {
				var _bbgg *textWord
				_abfea := 0
				for _, _gfcd := range _cedef.depthBand(_fcfba, _fccf) {
					_fbcf := _cedef.highestWord(_gfcd, _fcfba, _fccf)
					if _fbcf == nil {
						continue
					}
					_cfbd := _fdfe(_fbcf, _dcdf._bcce[len(_dcdf._bcce)-1])
					if _cfbd < -_ecdf {
						break _fbd
					}
					if _cfbd > _egbba {
						continue
					}
					if _bbgg != nil && _fdb(_fbcf, _bbgg) >= 0 {
						continue
					}
					_bbgg = _fbcf
					_abfea = _gfcd
				}
				if _bbgg == nil {
					break
				}
				_dcdf.pullWord(_cedef, _bbgg, _abfea)
			}
			_dcdf.markWordBoundaries()
			_aabf = append(_aabf, _dcdf)
		}
	}
	if len(_aabf) == 0 {
		return nil
	}
	_c.Slice(_aabf, func(_afce, _ggcbb int) bool { return _daca(_aabf[_afce], _aabf[_ggcbb]) < 0 })
	_egfa := _bggc(_cedef.PdfRectangle, _aabf)
	if _dga {
		_b.Log.Info("\u0061\u0072\u0072an\u0067\u0065\u0054\u0065\u0078\u0074\u0020\u0021\u0021\u0021\u0020\u0070\u0061\u0072\u0061\u003d\u0025\u0073", _egfa.String())
		if _fdfef {
			for _caa, _dbeed := range _egfa._eeedg {
				_eb.Printf("\u0025\u0034\u0064\u003a\u0020\u0025\u0073\u000a", _caa, _dbeed.String())
				if _aeeb {
					for _bcgdc, _fffa := range _dbeed._bcce {
						_eb.Printf("\u0025\u0038\u0064\u003a\u0020\u0025\u0073\u000a", _bcgdc, _fffa.String())
						for _ccddd, _eafe := range _fffa._ebca {
							_eb.Printf("\u00251\u0032\u0064\u003a\u0020\u0025\u0073\n", _ccddd, _eafe.String())
						}
					}
				}
			}
		}
	}
	return _egfa
}
func (_dffg *textObject) setTextMatrix(_acdb []float64) {
	if len(_acdb) != 6 {
		_b.Log.Debug("\u0045\u0052\u0052OR\u003a\u0020\u006c\u0065\u006e\u0028\u0066\u0029\u0020\u0021\u003d\u0020\u0036\u0020\u0028\u0025\u0064\u0029", len(_acdb))
		return
	}
	_cfd, _gdec, _dcce, _agd, _fegb, _afa := _acdb[0], _acdb[1], _acdb[2], _acdb[3], _acdb[4], _acdb[5]
	_dffg._deb = _cbc.NewMatrix(_cfd, _gdec, _dcce, _agd, _fegb, _afa)
	_dffg._gfeb = _dffg._deb
}
func _bbccb(_fgbdg int, _egaef map[int][]float64) ([]int, int) {
	_ecea := make([]int, _fgbdg)
	_decb := 0
	for _deda := 0; _deda < _fgbdg; _deda++ {
		_ecea[_deda] = _decb
		_decb += len(_egaef[_deda]) + 1
	}
	return _ecea, _decb
}
func (_eeedf lineRuling) yMean() float64 { return 0.5 * (_eeedf._addc.Y + _eeedf._bfgab.Y) }
func _fbbdd(_afae *list, _ebbc *_a.Builder, _beee *string) {
	_cggc := _dfcg(_afae, _beee)
	_ebbc.WriteString(_cggc)
	for _, _ffgc := range _afae._gfgd {
		_dbad := *_beee + "\u0020\u0020\u0020"
		_fbbdd(_ffgc, _ebbc, &_dbad)
	}
}
func (_ecgfa *wordBag) absorb(_gccd *wordBag) {
	_cdgbf := _gccd.makeRemovals()
	for _egae, _agcc := range _gccd._agfg {
		for _, _ddgf := range _agcc {
			_ecgfa.pullWord(_ddgf, _egae, _cdgbf)
		}
	}
	_gccd.applyRemovals(_cdgbf)
}
func (_egf *Extractor) extractPageText(_feca string, _fgc *_ba.PdfPageResources, _cea _cbc.Matrix, _eag int) (*PageText, int, int, error) {
	_b.Log.Trace("\u0065x\u0074\u0072\u0061\u0063t\u0050\u0061\u0067\u0065\u0054e\u0078t\u003a \u006c\u0065\u0076\u0065\u006c\u003d\u0025d", _eag)
	_aef := &PageText{_bgaa: _egf._be, _gfcf: _egf._dd, _ead: _egf._bd}
	_bdb := _cfab(_egf._be)
	var _cfcf stateStack
	_dfc := _edcf(_egf, _fgc, _de.GraphicsState{}, &_bdb, &_cfcf)
	_gfc := shapesState{_dgcb: _cea, _ggfc: _cbc.IdentityMatrix(), _dgcf: _dfc}
	var _fbg bool
	_cdbc := -1
	if _eag > _gge {
		_ggbd := _d.New("\u0066\u006f\u0072\u006d s\u0074\u0061\u0063\u006b\u0020\u006f\u0076\u0065\u0072\u0066\u006c\u006f\u0077")
		_b.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0065\u0078\u0074\u0072\u0061\u0063\u0074\u0050\u0061\u0067\u0065\u0054\u0065\u0078\u0074\u002e\u0020\u0072\u0065\u0063u\u0072\u0073\u0069\u006f\u006e\u0020\u006c\u0065\u0076\u0065\u006c\u003d\u0025\u0064 \u0065r\u0072\u003d\u0025\u0076", _eag, _ggbd)
		return _aef, _bdb._ggec, _bdb._eeg, _ggbd
	}
	_cgf := _de.NewContentStreamParser(_feca)
	_eed, _dba := _cgf.Parse()
	if _dba != nil {
		_b.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020e\u0078\u0074\u0072a\u0063\u0074\u0050\u0061g\u0065\u0054\u0065\u0078\u0074\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u002e\u0020\u0065\u0072\u0072\u003d\u0025\u0076", _dba)
		return _aef, _bdb._ggec, _bdb._eeg, _dba
	}
	_aef._edfd = _eed
	_gcc := _de.NewContentStreamProcessor(*_eed)
	_gcc.AddHandler(_de.HandlerConditionEnumAllOperands, "", func(_fab *_de.ContentStreamOperation, _dgef _de.GraphicsState, _aec *_ba.PdfPageResources) error {
		_afg := _fab.Operand
		if _gece {
			_b.Log.Info("\u0026&\u0026\u0020\u006f\u0070\u003d\u0025s", _fab)
		}
		switch _afg {
		case "\u0071":
			if _adbb {
				_b.Log.Info("\u0063\u0074\u006d\u003d\u0025\u0073", _gfc._ggfc)
			}
			_cfcf.push(&_bdb)
		case "\u0051":
			if !_cfcf.empty() {
				_bdb = *_cfcf.pop()
			}
			_gfc._ggfc = _dgef.CTM
			if _adbb {
				_b.Log.Info("\u0063\u0074\u006d\u003d\u0025\u0073", _gfc._ggfc)
			}
		case "\u0042\u0044\u0043":
			_bede, _ccb := _fb.GetDict(_fab.Params[1])
			if !_ccb {
				_b.Log.Debug("\u0045\u0052\u0052O\u0052\u003a\u0020\u0042D\u0043\u0020\u006f\u0070\u003d\u0025\u0073 \u0047\u0065\u0074\u0044\u0069\u0063\u0074\u0020\u0066\u0061\u0069\u006c\u0065\u0064", _fab)
				return _dba
			}
			_dcc := _bede.Get("\u004d\u0043\u0049\u0044")
			if _dcc != nil {
				_ggag, _aeb := _fb.GetIntVal(_dcc)
				if !_aeb {
					_b.Log.Debug("\u0045R\u0052\u004fR\u003a\u0020\u0042\u0044C\u0020\u006f\u0070=\u0025\u0073\u002e\u0020\u0042\u0061\u0064\u0020\u006eum\u0065\u0072\u0069c\u0061\u006c \u006f\u0062\u006a\u0065\u0063\u0074.\u0020\u006f=\u0025\u0073", _fab, _dcc)
				}
				_cdbc = _ggag
			} else {
				_cdbc = -1
			}
		case "\u0045\u004d\u0043":
			_cdbc = -1
		case "\u0042\u0054":
			if _fbg {
				_b.Log.Debug("\u0042\u0054\u0020\u0063\u0061\u006c\u006c\u0065\u0064\u0020\u0077\u0068\u0069\u006c\u0065 \u0069n\u0020\u0061\u0020\u0074\u0065\u0078\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074")
				_aef._dafg = append(_aef._dafg, _dfc._cag...)
			}
			_fbg = true
			_dfa := _dgef
			_dfa.CTM = _cea.Mult(_dfa.CTM)
			_dfc = _edcf(_egf, _aec, _dfa, &_bdb, &_cfcf)
			_gfc._dgcf = _dfc
		case "\u0045\u0054":
			if !_fbg {
				_b.Log.Debug("\u0045\u0054\u0020ca\u006c\u006c\u0065\u0064\u0020\u006f\u0075\u0074\u0073i\u0064e\u0020o\u0066 \u0061\u0020\u0074\u0065\u0078\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074")
			}
			_fbg = false
			_aef._dafg = append(_aef._dafg, _dfc._cag...)
			_dfc.reset()
		case "\u0054\u002a":
			_dfc.nextLine()
		case "\u0054\u0064":
			if _cdf, _fff := _dfc.checkOp(_fab, 2, true); !_cdf {
				_b.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u0072\u0072\u003d\u0025\u0076", _fff)
				return _fff
			}
			_gff, _fbgf, _fefe := _fgdb(_fab.Params)
			if _fefe != nil {
				return _fefe
			}
			_dfc.moveText(_gff, _fbgf)
		case "\u0054\u0044":
			if _aff, _dee := _dfc.checkOp(_fab, 2, true); !_aff {
				_b.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u0072\u0072\u003d\u0025\u0076", _dee)
				return _dee
			}
			_efb, _ecb, _eaac := _fgdb(_fab.Params)
			if _eaac != nil {
				_b.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u0072\u0072\u003d\u0025\u0076", _eaac)
				return _eaac
			}
			_dfc.moveTextSetLeading(_efb, _ecb)
		case "\u0054\u006a":
			if _fac, _gcdb := _dfc.checkOp(_fab, 1, true); !_fac {
				_b.Log.Debug("\u0045\u0052\u0052\u004fR:\u0020\u0054\u006a\u0020\u006f\u0070\u003d\u0025\u0073\u0020\u0065\u0072\u0072\u003d%\u0076", _fab, _gcdb)
				return _gcdb
			}
			_cef := _fb.TraceToDirectObject(_fab.Params[0])
			_fgbc, _cdbe := _fb.GetStringBytes(_cef)
			if !_cdbe {
				_b.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020T\u006a\u0020o\u0070\u003d\u0025\u0073\u0020\u0047\u0065\u0074S\u0074\u0072\u0069\u006e\u0067\u0042\u0079\u0074\u0065\u0073\u0020\u0066a\u0069\u006c\u0065\u0064", _fab)
				return _fb.ErrTypeError
			}
			return _dfc.showText(_cef, _fgbc, _cdbc)
		case "\u0054\u004a":
			if _fca, _fcg := _dfc.checkOp(_fab, 1, true); !_fca {
				_b.Log.Debug("\u0045\u0052R\u004f\u0052\u003a \u0054\u004a\u0020\u0065\u0072\u0072\u003d\u0025\u0076", _fcg)
				return _fcg
			}
			_cda, _fge := _fb.GetArray(_fab.Params[0])
			if !_fge {
				_b.Log.Debug("\u0045\u0052\u0052OR\u003a\u0020\u0054\u004a\u0020\u006f\u0070\u003d\u0025s\u0020G\u0065t\u0041r\u0072\u0061\u0079\u0056\u0061\u006c\u0020\u0066\u0061\u0069\u006c\u0065\u0064", _fab)
				return _dba
			}
			return _dfc.showTextAdjusted(_cda, _cdbc)
		case "\u0027":
			if _bdbc, _eba := _dfc.checkOp(_fab, 1, true); !_bdbc {
				_b.Log.Debug("\u0045R\u0052O\u0052\u003a\u0020\u0027\u0020\u0065\u0072\u0072\u003d\u0025\u0076", _eba)
				return _eba
			}
			_gac := _fb.TraceToDirectObject(_fab.Params[0])
			_cead, _dggb := _fb.GetStringBytes(_gac)
			if !_dggb {
				_b.Log.Debug("\u0045\u0052RO\u0052\u003a\u0020'\u0020\u006f\u0070\u003d%s \u0047et\u0053\u0074\u0072\u0069\u006e\u0067\u0042yt\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064", _fab)
				return _fb.ErrTypeError
			}
			_dfc.nextLine()
			return _dfc.showText(_gac, _cead, _cdbc)
		case "\u0022":
			if _bef, _ffe := _dfc.checkOp(_fab, 3, true); !_bef {
				_b.Log.Debug("\u0045R\u0052O\u0052\u003a\u0020\u0022\u0020\u0065\u0072\u0072\u003d\u0025\u0076", _ffe)
				return _ffe
			}
			_egfe, _dgga, _ece := _fgdb(_fab.Params[:2])
			if _ece != nil {
				return _ece
			}
			_dbcf := _fb.TraceToDirectObject(_fab.Params[2])
			_fbaa, _fga := _fb.GetStringBytes(_dbcf)
			if !_fga {
				_b.Log.Debug("\u0045\u0052RO\u0052\u003a\u0020\"\u0020\u006f\u0070\u003d%s \u0047et\u0053\u0074\u0072\u0069\u006e\u0067\u0042yt\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064", _fab)
				return _fb.ErrTypeError
			}
			_dfc.setCharSpacing(_egfe)
			_dfc.setWordSpacing(_dgga)
			_dfc.nextLine()
			return _dfc.showText(_dbcf, _fbaa, _cdbc)
		case "\u0054\u004c":
			_bged, _efeb := _abgd(_fab)
			if _efeb != nil {
				_b.Log.Debug("\u0045\u0052R\u004f\u0052\u003a \u0054\u004c\u0020\u0065\u0072\u0072\u003d\u0025\u0076", _efeb)
				return _efeb
			}
			_dfc.setTextLeading(_bged)
		case "\u0054\u0063":
			_baa, _eff := _abgd(_fab)
			if _eff != nil {
				_b.Log.Debug("\u0045\u0052R\u004f\u0052\u003a \u0054\u0063\u0020\u0065\u0072\u0072\u003d\u0025\u0076", _eff)
				return _eff
			}
			_dfc.setCharSpacing(_baa)
		case "\u0054\u0066":
			if _bgb, _ccg := _dfc.checkOp(_fab, 2, true); !_bgb {
				_b.Log.Debug("\u0045\u0052R\u004f\u0052\u003a \u0054\u0066\u0020\u0065\u0072\u0072\u003d\u0025\u0076", _ccg)
				return _ccg
			}
			_bbf, _gae := _fb.GetNameVal(_fab.Params[0])
			if !_gae {
				_b.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0054\u0066\u0020\u006f\u0070\u003d\u0025\u0073\u0020\u0047\u0065\u0074\u004ea\u006d\u0065\u0056\u0061\u006c\u0020\u0066a\u0069\u006c\u0065\u0064", _fab)
				return _fb.ErrTypeError
			}
			_gcb, _daf := _fb.GetNumberAsFloat(_fab.Params[1])
			if !_gae {
				_b.Log.Debug("\u0045\u0052\u0052O\u0052\u003a\u0020\u0054\u0066\u0020\u006f\u0070\u003d\u0025\u0073\u0020\u0047\u0065\u0074\u0046\u006c\u006f\u0061\u0074\u0056\u0061\u006c\u0020\u0066\u0061\u0069\u006c\u0065d\u002e\u0020\u0065\u0072\u0072\u003d\u0025\u0076", _fab, _daf)
				return _daf
			}
			_daf = _dfc.setFont(_bbf, _gcb)
			_dfc._ggcbf = _fd.Is(_daf, _fb.ErrNotSupported)
			if _daf != nil && !_dfc._ggcbf {
				return _daf
			}
		case "\u0054\u006d":
			if _aab, _caf := _dfc.checkOp(_fab, 6, true); !_aab {
				_b.Log.Debug("\u0045\u0052R\u004f\u0052\u003a \u0054\u006d\u0020\u0065\u0072\u0072\u003d\u0025\u0076", _caf)
				return _caf
			}
			_abbg, _ccd := _fb.GetNumbersAsFloat(_fab.Params)
			if _ccd != nil {
				_b.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u0072\u0072\u003d\u0025\u0076", _ccd)
				return _ccd
			}
			_dfc.setTextMatrix(_abbg)
		case "\u0054\u0072":
			if _dec, _def := _dfc.checkOp(_fab, 1, true); !_dec {
				_b.Log.Debug("\u0045\u0052R\u004f\u0052\u003a \u0054\u0072\u0020\u0065\u0072\u0072\u003d\u0025\u0076", _def)
				return _def
			}
			_gca, _fed := _fb.GetIntVal(_fab.Params[0])
			if !_fed {
				_b.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0072\u0020\u006f\u0070\u003d\u0025\u0073 \u0047e\u0074\u0049\u006e\u0074\u0056\u0061\u006c\u0020\u0066\u0061\u0069\u006c\u0065\u0064", _fab)
				return _fb.ErrTypeError
			}
			_dfc.setTextRenderMode(_gca)
		case "\u0054\u0073":
			if _cgge, _fad := _dfc.checkOp(_fab, 1, true); !_cgge {
				_b.Log.Debug("\u0045\u0052R\u004f\u0052\u003a \u0054\u0073\u0020\u0065\u0072\u0072\u003d\u0025\u0076", _fad)
				return _fad
			}
			_acd, _bgd := _fb.GetNumberAsFloat(_fab.Params[0])
			if _bgd != nil {
				_b.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u0072\u0072\u003d\u0025\u0076", _bgd)
				return _bgd
			}
			_dfc.setTextRise(_acd)
		case "\u0054\u0077":
			if _bgf, _aeba := _dfc.checkOp(_fab, 1, true); !_bgf {
				_b.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u0072\u0072\u003d\u0025\u0076", _aeba)
				return _aeba
			}
			_bde, _adc := _fb.GetNumberAsFloat(_fab.Params[0])
			if _adc != nil {
				_b.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u0072\u0072\u003d\u0025\u0076", _adc)
				return _adc
			}
			_dfc.setWordSpacing(_bde)
		case "\u0054\u007a":
			if _aad, _agg := _dfc.checkOp(_fab, 1, true); !_aad {
				_b.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u0072\u0072\u003d\u0025\u0076", _agg)
				return _agg
			}
			_fgg, _acdg := _fb.GetNumberAsFloat(_fab.Params[0])
			if _acdg != nil {
				_b.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u0072\u0072\u003d\u0025\u0076", _acdg)
				return _acdg
			}
			_dfc.setHorizScaling(_fgg)
		case "\u0063\u006d":
			_gfc._ggfc = _dgef.CTM
			if _gfc._ggfc.Singular() {
				_dff := _cbc.IdentityMatrix().Translate(_gfc._ggfc.Translation())
				_b.Log.Debug("S\u0069n\u0067\u0075\u006c\u0061\u0072\u0020\u0063\u0074m\u003d\u0025\u0073\u2192%s", _gfc._ggfc, _dff)
				_gfc._ggfc = _dff
			}
			if _adbb {
				_b.Log.Info("\u0063\u0074\u006d\u003d\u0025\u0073", _gfc._ggfc)
			}
		case "\u006d":
			if len(_fab.Params) != 2 {
				_b.Log.Debug("\u0057\u0041\u0052\u004e\u003a\u0020\u0065\u0072\u0072o\u0072\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u0070\u0072\u006f\u0063\u0065\u0073\u0073\u0069\u006e\u0067\u0020\u0060\u006d\u0060\u0020o\u0070\u0065r\u0061\u0074o\u0072\u003a\u0020\u0025\u0076\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074 m\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063o\u0072\u0072\u0065\u0063\u0074\u002e", _dg)
				return nil
			}
			_cfcg, _ecf := _fb.GetNumbersAsFloat(_fab.Params)
			if _ecf != nil {
				return _ecf
			}
			_gfc.moveTo(_cfcg[0], _cfcg[1])
		case "\u006c":
			if len(_fab.Params) != 2 {
				_b.Log.Debug("\u0057\u0041\u0052\u004e\u003a\u0020\u0065\u0072\u0072o\u0072\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u0070\u0072\u006f\u0063\u0065\u0073\u0073\u0069\u006e\u0067\u0020\u0060\u006c\u0060\u0020o\u0070\u0065r\u0061\u0074o\u0072\u003a\u0020\u0025\u0076\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074 m\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063o\u0072\u0072\u0065\u0063\u0074\u002e", _dg)
				return nil
			}
			_geefe, _egg := _fb.GetNumbersAsFloat(_fab.Params)
			if _egg != nil {
				return _egg
			}
			_gfc.lineTo(_geefe[0], _geefe[1])
		case "\u0063":
			if len(_fab.Params) != 6 {
				return _dg
			}
			_ggfa, _gbd := _fb.GetNumbersAsFloat(_fab.Params)
			if _gbd != nil {
				return _gbd
			}
			_b.Log.Debug("\u0043u\u0062\u0069\u0063\u0020b\u0065\u007a\u0069\u0065\u0072 \u0070a\u0072a\u006d\u0073\u003a\u0020\u0025\u002e\u0032f", _ggfa)
			_gfc.cubicTo(_ggfa[0], _ggfa[1], _ggfa[2], _ggfa[3], _ggfa[4], _ggfa[5])
		case "\u0076", "\u0079":
			if len(_fab.Params) != 4 {
				return _dg
			}
			_edba, _fabf := _fb.GetNumbersAsFloat(_fab.Params)
			if _fabf != nil {
				return _fabf
			}
			_b.Log.Debug("\u0043u\u0062\u0069\u0063\u0020b\u0065\u007a\u0069\u0065\u0072 \u0070a\u0072a\u006d\u0073\u003a\u0020\u0025\u002e\u0032f", _edba)
			_gfc.quadraticTo(_edba[0], _edba[1], _edba[2], _edba[3])
		case "\u0068":
			_gfc.closePath()
		case "\u0072\u0065":
			if len(_fab.Params) != 4 {
				return _dg
			}
			_abbe, _fea := _fb.GetNumbersAsFloat(_fab.Params)
			if _fea != nil {
				return _fea
			}
			_gfc.drawRectangle(_abbe[0], _abbe[1], _abbe[2], _abbe[3])
			_gfc.closePath()
		case "\u0053":
			_gfc.stroke(&_aef._fgaf)
			_gfc.clearPath()
		case "\u0073":
			_gfc.closePath()
			_gfc.stroke(&_aef._fgaf)
			_gfc.clearPath()
		case "\u0046":
			_gfc.fill(&_aef._fbce)
			_gfc.clearPath()
		case "\u0066", "\u0066\u002a":
			_gfc.closePath()
			_gfc.fill(&_aef._fbce)
			_gfc.clearPath()
		case "\u0042", "\u0042\u002a":
			_gfc.fill(&_aef._fbce)
			_gfc.stroke(&_aef._fgaf)
			_gfc.clearPath()
		case "\u0062", "\u0062\u002a":
			_gfc.closePath()
			_gfc.fill(&_aef._fbce)
			_gfc.stroke(&_aef._fgaf)
			_gfc.clearPath()
		case "\u006e":
			_gfc.clearPath()
		case "\u0044\u006f":
			if len(_fab.Params) == 0 {
				_b.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0058\u004fbj\u0065c\u0074\u0020\u006e\u0061\u006d\u0065\u0020\u006f\u0070\u0065\u0072\u0061n\u0064\u0020\u0066\u006f\u0072\u0020\u0044\u006f\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072.\u0020\u0047\u006f\u0074\u0020\u0025\u002b\u0076\u002e", _fab.Params)
				return _fb.ErrRangeError
			}
			_aaa, _gdc := _fb.GetName(_fab.Params[0])
			if !_gdc {
				_b.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0044\u006f\u0020\u006f\u0070e\u0072a\u0074\u006f\u0072\u0020\u0058\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u0061\u006d\u0065\u0020\u006fp\u0065\u0072\u0061\u006e\u0064\u003a\u0020\u0025\u002b\u0076\u002e", _fab.Params[0])
				return _fb.ErrTypeError
			}
			_, _gdgd := _aec.GetXObjectByName(*_aaa)
			if _gdgd != _ba.XObjectTypeForm {
				break
			}
			_afgc, _gdc := _egf._eg[_aaa.String()]
			if !_gdc {
				_gdba, _ada := _aec.GetXObjectFormByName(*_aaa)
				if _ada != nil {
					_b.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _ada)
					return _ada
				}
				_cad, _ada := _gdba.GetContentStream()
				if _ada != nil {
					_b.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _ada)
					return _ada
				}
				_eab := _gdba.Resources
				if _eab == nil {
					_eab = _aec
				}
				_cgdd := _dgef.CTM
				if _geeg, _edbd := _fb.GetArray(_gdba.Matrix); _edbd {
					_agef, _cde := _geeg.GetAsFloat64Slice()
					if _cde != nil {
						return _cde
					}
					if len(_agef) != 6 {
						return _dg
					}
					_gaa := _cbc.NewMatrix(_agef[0], _agef[1], _agef[2], _agef[3], _agef[4], _agef[5])
					_cgdd = _dgef.CTM.Mult(_gaa)
				}
				_gfe, _bgba, _bga, _ada := _egf.extractPageText(string(_cad), _eab, _cea.Mult(_cgdd), _eag+1)
				if _ada != nil {
					_b.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _ada)
					return _ada
				}
				_afgc = textResult{*_gfe, _bgba, _bga}
				_egf._eg[_aaa.String()] = _afgc
			}
			_gfc._ggfc = _dgef.CTM
			if _adbb {
				_b.Log.Info("\u0063\u0074\u006d\u003d\u0025\u0073", _gfc._ggfc)
			}
			_aef._dafg = append(_aef._dafg, _afgc._bee._dafg...)
			_aef._fgaf = append(_aef._fgaf, _afgc._bee._fgaf...)
			_aef._fbce = append(_aef._fbce, _afgc._bee._fbce...)
			_bdb._ggec += _afgc._bdc
			_bdb._eeg += _afgc._aabc
		case "\u0072\u0067", "\u0067", "\u006b", "\u0063\u0073", "\u0073\u0063", "\u0073\u0063\u006e":
			_dfc._bffd.ColorspaceNonStroking = _dgef.ColorspaceNonStroking
			_dfc._bffd.ColorNonStroking = _dgef.ColorNonStroking
		case "\u0052\u0047", "\u0047", "\u004b", "\u0043\u0053", "\u0053\u0043", "\u0053\u0043\u004e":
			_dfc._bffd.ColorspaceStroking = _dgef.ColorspaceStroking
			_dfc._bffd.ColorStroking = _dgef.ColorStroking
		}
		return nil
	})
	_dba = _gcc.Process(_fgc)
	return _aef, _bdb._ggec, _bdb._eeg, _dba
}
func _bgdbf(_cdafd, _cfcd _cbc.Point) bool {
	_fdcea := _cc.Abs(_cdafd.X - _cfcd.X)
	_dagf := _cc.Abs(_cdafd.Y - _cfcd.Y)
	return _bfff(_dagf, _fdcea)
}
func (_bgdcb gridTile) complete() bool { return _bgdcb.numBorders() == 4 }
func (_agcadf *textPara) toCellTextMarks(_dgbb *int) []TextMark {
	var _bfbe []TextMark
	for _dcgbd, _feeg := range _agcadf._eeedg {
		_dbeg := _feeg.toTextMarks(_dgbb)
		_gccdg := _gfbe && _feeg.endsInHyphen() && _dcgbd != len(_agcadf._eeedg)-1
		if _gccdg {
			_dbeg = _abfca(_dbeg, _dgbb)
		}
		_bfbe = append(_bfbe, _dbeg...)
		if !(_gccdg || _dcgbd == len(_agcadf._eeedg)-1) {
			_bfbe = _faacg(_bfbe, _dgbb, _bebb(_feeg._gfeac, _agcadf._eeedg[_dcgbd+1]._gfeac))
		}
	}
	return _bfbe
}

type textObject struct {
	_egff  *Extractor
	_adg   *_ba.PdfPageResources
	_bffd  _de.GraphicsState
	_fggf  *textState
	_agdg  *stateStack
	_deb   _cbc.Matrix
	_gfeb  _cbc.Matrix
	_cag   []*textMark
	_ggcbf bool
}

func _bdgc(_faaf []compositeCell) []float64 {
	var _cgea []*textLine
	_adeae := 0
	for _, _aecd := range _faaf {
		_adeae += len(_aecd.paraList)
		_cgea = append(_cgea, _aecd.lines()...)
	}
	_c.Slice(_cgea, func(_gdge, _dfgfb int) bool {
		_affa, _gcdgg := _cgea[_gdge], _cgea[_dfgfb]
		_aced, _cbfca := _affa._gfeac, _gcdgg._gfeac
		if !_gabfc(_aced - _cbfca) {
			return _aced < _cbfca
		}
		return _affa.Llx < _gcdgg.Llx
	})
	if _egdf {
		_eb.Printf("\u0020\u0020\u0020 r\u006f\u0077\u0042\u006f\u0072\u0064\u0065\u0072\u0073:\u0020%\u0064 \u0070a\u0072\u0061\u0073\u0020\u0025\u0064\u0020\u006c\u0069\u006e\u0065\u0073\u000a", _adeae, len(_cgea))
		for _bbbac, _ffcaa := range _cgea {
			_eb.Printf("\u0025\u0038\u0064\u003a\u0020\u0025\u0073\u000a", _bbbac, _ffcaa)
		}
	}
	var _edbbb []float64
	_acbgf := _cgea[0]
	var _fdaac [][]*textLine
	_caegd := []*textLine{_acbgf}
	for _bcde, _geddbd := range _cgea[1:] {
		if _geddbd.Ury < _acbgf.Lly {
			_ggac := 0.5 * (_geddbd.Ury + _acbgf.Lly)
			if _egdf {
				_eb.Printf("\u0025\u0034\u0064\u003a\u0020\u0025\u0036\u002e\u0032\u0066\u0020\u003c\u0020\u0025\u0036.\u0032f\u0020\u0062\u006f\u0072\u0064\u0065\u0072\u003d\u0025\u0036\u002e\u0032\u0066\u000a"+"\u0009\u0020\u0071\u003d\u0025\u0073\u000a\u0009\u0020p\u003d\u0025\u0073\u000a", _bcde, _geddbd.Ury, _acbgf.Lly, _ggac, _acbgf, _geddbd)
			}
			_edbbb = append(_edbbb, _ggac)
			_fdaac = append(_fdaac, _caegd)
			_caegd = nil
		}
		_caegd = append(_caegd, _geddbd)
		if _geddbd.Lly < _acbgf.Lly {
			_acbgf = _geddbd
		}
	}
	if len(_caegd) > 0 {
		_fdaac = append(_fdaac, _caegd)
	}
	if _egdf {
		_eb.Printf(" \u0020\u0020\u0020\u0020\u0020\u0020 \u0072\u006f\u0077\u0043\u006f\u0072\u0072\u0069\u0064o\u0072\u0073\u003d%\u0036.\u0032\u0066\u000a", _edbbb)
	}
	if _egdf {
		_b.Log.Info("\u0072\u006f\u0077\u003d\u0025\u0064", len(_faaf))
		for _adcf, _aaec := range _faaf {
			_eb.Printf("\u0025\u0034\u0064\u003a\u0020\u0025\u0073\u000a", _adcf, _aaec)
		}
		_b.Log.Info("\u0067r\u006f\u0075\u0070\u0073\u003d\u0025d", len(_fdaac))
		for _cebd, _fbcd := range _fdaac {
			_eb.Printf("\u0025\u0034\u0064\u003a\u0020\u0025\u0064\u000a", _cebd, len(_fbcd))
			for _febg, _ebad := range _fbcd {
				_eb.Printf("\u0025\u0038\u0064\u003a\u0020\u0025\u0073\u000a", _febg, _ebad)
			}
		}
	}
	_deaf := true
	for _fcegb, _dagd := range _fdaac {
		_bbab := true
		for _ceag, _acgfbg := range _faaf {
			if _egdf {
				_eb.Printf("\u0020\u0020\u0020\u007e\u007e\u007e\u0067\u0072\u006f\u0075\u0070\u0020\u0025\u0064\u0020\u006f\u0066\u0020\u0025\u0064\u0020\u0063\u0065\u006cl\u0020\u0025\u0064\u0020\u006ff\u0020\u0025d\u0020\u0025\u0073\u000a", _fcegb, len(_fdaac), _ceag, len(_faaf), _acgfbg)
			}
			if !_acgfbg.hasLines(_dagd) {
				if _egdf {
					_eb.Printf("\u0020\u0020\u0020\u0021\u0021\u0021\u0067\u0072\u006f\u0075\u0070\u0020\u0025d\u0020\u006f\u0066\u0020\u0025\u0064 \u0063\u0065\u006c\u006c\u0020\u0025\u0064\u0020\u006f\u0066\u0020\u0025\u0064 \u004f\u0055\u0054\u000a", _fcegb, len(_fdaac), _ceag, len(_faaf))
				}
				_bbab = false
				break
			}
		}
		if !_bbab {
			_deaf = false
			break
		}
	}
	if !_deaf {
		if _egdf {
			_b.Log.Info("\u0072\u006f\u0077\u0020\u0063o\u0072\u0072\u0069\u0064\u006f\u0072\u0073\u0020\u0064\u006f\u006e\u0027\u0074 \u0073\u0070\u0061\u006e\u0020\u0061\u006c\u006c\u0020\u0063\u0065\u006c\u006c\u0073\u0020\u0069\u006e\u0020\u0072\u006f\u0077\u002e\u0020\u0069\u0067\u006e\u006f\u0072\u0069\u006eg")
		}
		_edbbb = nil
	}
	if _egdf && _edbbb != nil {
		_eb.Printf("\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u002a\u002a*\u0072\u006f\u0077\u0043\u006f\u0072\u0072i\u0064\u006f\u0072\u0073\u003d\u0025\u0036\u002e\u0032\u0066\u000a", _edbbb)
	}
	return _edbbb
}
func (_abda *subpath) add(_egd ..._cbc.Point) { _abda._dgfd = append(_abda._dgfd, _egd...) }
func _gacg(_cggg []rulingList) (rulingList, rulingList) {
	var _dcbfc rulingList
	for _, _dace := range _cggg {
		_dcbfc = append(_dcbfc, _dace...)
	}
	return _dcbfc.vertsHorzs()
}
func _bfed(_dgbe *textLine) float64 { return _dgbe._bcce[0].Llx }
func _cfab(_abef _ba.PdfRectangle) textState {
	return textState{_gaff: 100, _bffe: RenderModeFill, _cbff: _abef}
}
func _efag(_ddbde map[float64]gridTile) []float64 {
	_afcc := make([]float64, 0, len(_ddbde))
	for _bdgda := range _ddbde {
		_afcc = append(_afcc, _bdgda)
	}
	_c.Float64s(_afcc)
	return _afcc
}
func (_ggaf rulingList) bbox() _ba.PdfRectangle {
	var _efbe _ba.PdfRectangle
	if len(_ggaf) == 0 {
		_b.Log.Error("r\u0075\u006c\u0069\u006e\u0067\u004ci\u0073\u0074\u002e\u0062\u0062\u006f\u0078\u003a\u0020n\u006f\u0020\u0072u\u006ci\u006e\u0067\u0073")
		return _ba.PdfRectangle{}
	}
	if _ggaf[0]._adad == _deg {
		_efbe.Llx, _efbe.Urx = _ggaf.secMinMax()
		_efbe.Lly, _efbe.Ury = _ggaf.primMinMax()
	} else {
		_efbe.Llx, _efbe.Urx = _ggaf.primMinMax()
		_efbe.Lly, _efbe.Ury = _ggaf.secMinMax()
	}
	return _efbe
}
func (_bada *textTable) compositeColCorridors() map[int][]float64 {
	_ggdf := make(map[int][]float64, _bada._gdab)
	if _egdf {
		_b.Log.Info("\u0063\u006f\u006d\u0070o\u0073\u0069\u0074\u0065\u0043\u006f\u006c\u0043\u006f\u0072r\u0069d\u006f\u0072\u0073\u003a\u0020\u0077\u003d%\u0064\u0020", _bada._gdab)
	}
	for _afcge := 0; _afcge < _bada._gdab; _afcge++ {
		_ggdf[_afcge] = nil
	}
	return _ggdf
}
func _dfcg(_geagc *list, _bdfe *string) string {
	_eaed := _a.Split(_geagc._fagf, "\u000a")
	_gdgc := &_a.Builder{}
	for _, _gbcg := range _eaed {
		if _gbcg != "" {
			_gdgc.WriteString(*_bdfe)
			_gdgc.WriteString(_gbcg)
			_gdgc.WriteString("\u000a")
		}
	}
	return _gdgc.String()
}

// TableInfo gets table information of the textmark `tm`.
func (_abgf *TextMark) TableInfo() (*TextTable, [][]int) {
	if !_abgf._bcg {
		return nil, nil
	}
	_ebf := _abgf._ecga
	_dbe := _ebf.getCellInfo(*_abgf)
	return _ebf, _dbe
}
func (_eggg *textMark) inDiacriticArea(_bgcg *textMark) bool {
	_acgfb := _eggg.Llx - _bgcg.Llx
	_befd := _eggg.Urx - _bgcg.Urx
	_ccead := _eggg.Lly - _bgcg.Lly
	return _cc.Abs(_acgfb+_befd) < _eggg.Width()*_dage && _cc.Abs(_ccead) < _eggg.Height()*_dage
}

// String returns a human readable description of `path`.
func (_afb *subpath) String() string {
	_befc := _afb._dgfd
	_dbee := len(_befc)
	if _dbee <= 5 {
		return _eb.Sprintf("\u0025d\u003a\u0020\u0025\u0036\u002e\u0032f", _dbee, _befc)
	}
	return _eb.Sprintf("\u0025d\u003a\u0020\u0025\u0036.\u0032\u0066\u0020\u0025\u0036.\u0032f\u0020.\u002e\u002e\u0020\u0025\u0036\u002e\u0032f", _dbee, _befc[0], _befc[1], _befc[_dbee-1])
}

// TextMarkArray is a collection of TextMarks.
type TextMarkArray struct{ _fcca []TextMark }

func _gaca(_aeebe string) bool {
	if _dc.RuneCountInString(_aeebe) < _bacb {
		return false
	}
	_ffbf, _cega := _dc.DecodeLastRuneInString(_aeebe)
	if _cega <= 0 || !_e.Is(_e.Hyphen, _ffbf) {
		return false
	}
	_ffbf, _cega = _dc.DecodeLastRuneInString(_aeebe[:len(_aeebe)-_cega])
	return _cega > 0 && !_e.IsSpace(_ffbf)
}

type gridTile struct {
	_ba.PdfRectangle
	_begf, _cbaf, _edddc, _ceead bool
}

func (_fgaag *textTable) emptyCompositeRow(_afab int) bool {
	for _adfgg := 0; _adfgg < _fgaag._gdab; _adfgg++ {
		if _egdfe, _cbafg := _fgaag._bbgacd[_aaega(_adfgg, _afab)]; _cbafg {
			if len(_egdfe.paraList) > 0 {
				return false
			}
		}
	}
	return true
}
func (_dbcd *wordBag) sort() {
	for _, _agdc := range _dbcd._agfg {
		_c.Slice(_agdc, func(_cedff, _ggbb int) bool { return _fdb(_agdc[_cedff], _agdc[_ggbb]) < 0 })
	}
}
func (_aadaf *shapesState) lineTo(_fdgf, _efgf float64) {
	if _adbb {
		_b.Log.Info("\u006c\u0069\u006eeT\u006f\u0028\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0020\u0070\u003d\u0025\u002e\u0032\u0066", _fdgf, _efgf, _aadaf.devicePoint(_fdgf, _efgf))
	}
	_aadaf.addPoint(_fdgf, _efgf)
}
func _abfg(_baggd float64, _adcc int) int {
	if _adcc == 0 {
		_adcc = 1
	}
	_cefg := float64(_adcc)
	return int(_cc.Round(_baggd/_cefg) * _cefg)
}
func (_fedd intSet) del(_abgbc int) { delete(_fedd, _abgbc) }
func (_aafb rulingList) snapToGroups() rulingList {
	_aeefb, _dbbe := _aafb.vertsHorzs()
	if len(_aeefb) > 0 {
		_aeefb = _aeefb.snapToGroupsDirection()
	}
	if len(_dbbe) > 0 {
		_dbbe = _dbbe.snapToGroupsDirection()
	}
	_gfaeg := append(_aeefb, _dbbe...)
	_gfaeg.log("\u0073\u006e\u0061p\u0054\u006f\u0047\u0072\u006f\u0075\u0070\u0073")
	return _gfaeg
}
func _ecfgc(_cbggf []*textWord, _cdca *textWord) []*textWord {
	for _gfggag, _deffb := range _cbggf {
		if _deffb == _cdca {
			return _ddcb(_cbggf, _gfggag)
		}
	}
	_b.Log.Error("\u0072\u0065\u006d\u006f\u0076e\u0057\u006f\u0072\u0064\u003a\u0020\u0077\u006f\u0072\u0064\u0073\u0020\u0064o\u0065\u0073\u006e\u0027\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0020\u0077\u006f\u0072\u0064\u003d\u0025\u0073", _cdca)
	return nil
}
func (_fggb *textObject) getFontDirect(_ggdaa string) (*_ba.PdfFont, error) {
	_aag, _bgff := _fggb.getFontDict(_ggdaa)
	if _bgff != nil {
		return nil, _bgff
	}
	_efcb, _bgff := _ba.NewPdfFontFromPdfObject(_aag)
	if _bgff != nil {
		_b.Log.Debug("\u0067\u0065\u0074\u0046\u006f\u006e\u0074\u0044\u0069\u0072\u0065\u0063\u0074\u003a\u0020\u004e\u0065\u0077Pd\u0066F\u006f\u006e\u0074\u0046\u0072\u006f\u006d\u0050\u0064\u0066\u004f\u0062j\u0065\u0063\u0074\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u002e\u0020\u006e\u0061\u006d\u0065\u003d%\u0023\u0071\u0020\u0065\u0072\u0072\u003d\u0025\u0076", _ggdaa, _bgff)
	}
	return _efcb, _bgff
}
func (_add *textObject) moveText(_dgc, _ccff float64) { _add.moveLP(_dgc, _ccff) }
func (_eagea rulingList) comp(_beaf, _dabf int) bool {
	_geae, _dgcbe := _eagea[_beaf], _eagea[_dabf]
	_afcd, _gcgd := _geae._adad, _dgcbe._adad
	if _afcd != _gcgd {
		return _afcd > _gcgd
	}
	if _afcd == _affd {
		return false
	}
	_ebccb := func(_ccgf bool) bool {
		if _afcd == _deg {
			return _ccgf
		}
		return !_ccgf
	}
	_dgfa, _aabe := _geae._abfa, _dgcbe._abfa
	if _dgfa != _aabe {
		return _ebccb(_dgfa > _aabe)
	}
	_dgfa, _aabe = _geae._bgbbf, _dgcbe._bgbbf
	if _dgfa != _aabe {
		return _ebccb(_dgfa < _aabe)
	}
	return _ebccb(_geae._dffbe < _dgcbe._dffbe)
}
func (_gcfafg gridTile) contains(_egffd _ba.PdfRectangle) bool {
	if _gcfafg.numBorders() < 3 {
		return false
	}
	if _gcfafg._cbaf && _egffd.Llx < _gcfafg.Llx-_abfd {
		return false
	}
	if _gcfafg._ceead && _egffd.Urx > _gcfafg.Urx+_abfd {
		return false
	}
	if _gcfafg._edddc && _egffd.Lly < _gcfafg.Lly-_abfd {
		return false
	}
	if _gcfafg._begf && _egffd.Ury > _gcfafg.Ury+_abfd {
		return false
	}
	return true
}

type textTable struct {
	_ba.PdfRectangle
	_gdab, _ggeg int
	_dggfe       bool
	_gabega      map[uint64]*textPara
	_bbgacd      map[uint64]compositeCell
}

func _bbba(_egaa *textWord, _bfaf float64, _cbgf, _bcae rulingList) *wordBag {
	_gdbae := _dgeg(_egaa._gadaf)
	_abagb := []*textWord{_egaa}
	_afdfg := wordBag{_agfg: map[int][]*textWord{_gdbae: _abagb}, PdfRectangle: _egaa.PdfRectangle, _cdc: _egaa._affe, _agdfc: _bfaf, _cfegb: _cbgf, _dffc: _bcae}
	return &_afdfg
}
func _ebgga(_aadf structElement) []structElement {
	_bgfd := []structElement{}
	for _, _abge := range _aadf._agcf {
		for _, _facef := range _abge._agcf {
			for _, _affgc := range _facef._agcf {
				if _affgc._dfgd == "\u004c" {
					_bgfd = append(_bgfd, _affgc)
				}
			}
		}
	}
	return _bgfd
}
func _agfe(_gbcb _ba.PdfRectangle, _fade bounded) float64 { return _gbcb.Ury - _fade.bbox().Lly }
func (_aee *textObject) getCurrentFont() *_ba.PdfFont {
	_bdagd := _aee._fggf._edd
	if _bdagd == nil {
		_b.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u004e\u006f\u0020\u0066\u006f\u006e\u0074\u0020\u0064\u0065\u0066\u0069\u006e\u0065\u0064\u002e\u0020U\u0073\u0069\u006e\u0067\u0020d\u0065\u0066a\u0075\u006c\u0074\u002e")
		return _ba.DefaultFont()
	}
	return _bdagd
}
func _fadaa(_gbbcb, _abggd int) int {
	if _gbbcb > _abggd {
		return _gbbcb
	}
	return _abggd
}
func (_fdg TextTable) getCellInfo(_gfca TextMark) [][]int {
	for _agb, _abc := range _fdg.Cells {
		for _dbcb, _efg := range _abc {
			_dbeb := &_efg.Marks
			if _dbeb.exists(_gfca) {
				return [][]int{{_agb}, {_dbcb}}
			}
		}
	}
	return nil
}

type event struct {
	_ecgg  float64
	_bcecb bool
	_eade  int
}

const (
	_affd rulingKind = iota
	_deg
	_aagff
)

func _dafe(_gafde _fb.PdfObject, _edfg _ea.Color) (_ga.Image, error) {
	_dccce, _cedfd := _fb.GetStream(_gafde)
	if !_cedfd {
		return nil, nil
	}
	_fgda, _fbaag := _ba.NewXObjectImageFromStream(_dccce)
	if _fbaag != nil {
		return nil, _fbaag
	}
	_facc, _fbaag := _fgda.ToImage()
	if _fbaag != nil {
		return nil, _fbaag
	}
	return _geecc(_facc, _edfg), nil
}

// ExtractPageImages returns the image contents of the page extractor, including data
// and position, size information for each image.
// A set of options to control page image extraction can be passed in. The options
// parameter can be nil for the default options. By default, inline stencil masks
// are not extracted.
func (_abb *Extractor) ExtractPageImages(options *ImageExtractOptions) (*PageImages, error) {
	_ebg := &imageExtractContext{_ggf: options}
	_edc := _ebg.extractContentStreamImages(_abb._gb, _abb._cd)
	if _edc != nil {
		return nil, _edc
	}
	return &PageImages{Images: _ebg._cgg}, nil
}
func _gfdcc(_adfdd *list) []*textLine {
	for _, _bbec := range _adfdd._gfgd {
		switch _bbec._gfdb {
		case "\u004c\u0042\u006fd\u0079":
			if len(_bbec._fcda) != 0 {
				return _bbec._fcda
			}
			return _gfdcc(_bbec)
		case "\u0053\u0070\u0061\u006e":
			return _bbec._fcda
		case "I\u006e\u006c\u0069\u006e\u0065\u0053\u0068\u0061\u0070\u0065":
			return _bbec._fcda
		}
	}
	return nil
}
func _fdb(_bfgc, _cfb bounded) float64 { return _bfgc.bbox().Llx - _cfb.bbox().Llx }
func _cfcgd(_fcbgc []TextMark, _bdde *TextTable) []TextMark {
	var _agge []TextMark
	for _, _bcceb := range _fcbgc {
		_bcceb._bcg = true
		_bcceb._ecga = _bdde
		_agge = append(_agge, _bcceb)
	}
	return _agge
}
func (_beede *subpath) isQuadrilateral() bool {
	if len(_beede._dgfd) < 4 || len(_beede._dgfd) > 5 {
		return false
	}
	if len(_beede._dgfd) == 5 {
		_adagf := _beede._dgfd[0]
		_gdbe := _beede._dgfd[4]
		if _adagf.X != _gdbe.X || _adagf.Y != _gdbe.Y {
			return false
		}
	}
	return true
}
func (_cbdac paraList) findTextTables() []*textTable {
	var _fggc []*textTable
	for _, _caeb := range _cbdac {
		if _caeb.taken() || _caeb.Width() == 0 {
			continue
		}
		_befga := _caeb.isAtom()
		if _befga == nil {
			continue
		}
		_befga.growTable()
		if _befga._gdab*_befga._ggeg < _deaa {
			continue
		}
		_befga.markCells()
		_befga.log("\u0067\u0072\u006fw\u006e")
		_fggc = append(_fggc, _befga)
	}
	return _fggc
}
func (_fbec compositeCell) parasBBox() (paraList, _ba.PdfRectangle) {
	return _fbec.paraList, _fbec.PdfRectangle
}

type textLine struct {
	_ba.PdfRectangle
	_gfeac float64
	_bcce  []*textWord
	_gdca  float64
}

func (_egdef *ruling) alignsSec(_efac *ruling) bool {
	const _cbafe = _ebbd + 1.0
	return _egdef._bgbbf-_cbafe <= _efac._dffbe && _efac._bgbbf-_cbafe <= _egdef._dffbe
}
func (_gbfab *ruling) gridIntersecting(_agecc *ruling) bool {
	return _bfebf(_gbfab._bgbbf, _agecc._bgbbf) && _bfebf(_gbfab._dffbe, _agecc._dffbe)
}

var _fega string = "\u005e\u005b\u0061\u002d\u007a\u0041\u002dZ\u005d\u0028\u005c)\u007c\u005c\u002e)\u007c\u005e[\u005c\u0064\u005d\u002b\u0028\u005c)\u007c\\.\u0029\u007c\u005e\u005c\u0028\u005b\u0061\u002d\u007a\u0041\u002d\u005a\u005d\u005c\u0029\u007c\u005e\u005c\u0028\u005b\u005c\u0064\u005d\u002b\u005c\u0029"

func (_ebec *textObject) getFillColor() _ea.Color {
	return _fbcdf(_ebec._bffd.ColorspaceNonStroking, _ebec._bffd.ColorNonStroking)
}

// GetContentStreamOps returns the contentStreamOps field of `pt`.
func (_dbb *PageText) GetContentStreamOps() *_de.ContentStreamOperations { return _dbb._edfd }
func _daca(_adea, _gfbd bounded) float64 {
	_eadb := _cdad(_adea, _gfbd)
	if !_gabfc(_eadb) {
		return _eadb
	}
	return _fdb(_adea, _gfbd)
}
func (_aggc *textPara) fontsize() float64 { return _aggc._eeedg[0]._gdca }
func (_gegac *textTable) logComposite(_cgeb string) {
	if !_egdf {
		return
	}
	_b.Log.Info("\u007e~\u007eP\u0061\u0072\u0061\u0020\u0025d\u0020\u0078 \u0025\u0064\u0020\u0025\u0073", _gegac._gdab, _gegac._ggeg, _cgeb)
	_eb.Printf("\u0025\u0035\u0073 \u007c", "")
	for _cdde := 0; _cdde < _gegac._gdab; _cdde++ {
		_eb.Printf("\u0025\u0033\u0064 \u007c", _cdde)
	}
	_eb.Println("")
	_eb.Printf("\u0025\u0035\u0073 \u002b", "")
	for _egec := 0; _egec < _gegac._gdab; _egec++ {
		_eb.Printf("\u0025\u0033\u0073 \u002b", "\u002d\u002d\u002d")
	}
	_eb.Println("")
	for _aeafe := 0; _aeafe < _gegac._ggeg; _aeafe++ {
		_eb.Printf("\u0025\u0035\u0064 \u007c", _aeafe)
		for _gbece := 0; _gbece < _gegac._gdab; _gbece++ {
			_facgb, _ := _gegac._bbgacd[_aaega(_gbece, _aeafe)].parasBBox()
			_eb.Printf("\u0025\u0033\u0064 \u007c", len(_facgb))
		}
		_eb.Println("")
	}
	_b.Log.Info("\u007e~\u007eT\u0065\u0078\u0074\u0020\u0025d\u0020\u0078 \u0025\u0064\u0020\u0025\u0073", _gegac._gdab, _gegac._ggeg, _cgeb)
	_eb.Printf("\u0025\u0035\u0073 \u007c", "")
	for _fabff := 0; _fabff < _gegac._gdab; _fabff++ {
		_eb.Printf("\u0025\u0031\u0032\u0064\u0020\u007c", _fabff)
	}
	_eb.Println("")
	_eb.Printf("\u0025\u0035\u0073 \u002b", "")
	for _dafdc := 0; _dafdc < _gegac._gdab; _dafdc++ {
		_eb.Print("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d-\u002d\u002d\u002d\u002b")
	}
	_eb.Println("")
	for _cdefa := 0; _cdefa < _gegac._ggeg; _cdefa++ {
		_eb.Printf("\u0025\u0035\u0064 \u007c", _cdefa)
		for _bbcd := 0; _bbcd < _gegac._gdab; _bbcd++ {
			_dbfd, _ := _gegac._bbgacd[_aaega(_bbcd, _cdefa)].parasBBox()
			_egeca := ""
			_cadbf := _dbfd.merge()
			if _cadbf != nil {
				_egeca = _cadbf.text()
			}
			_egeca = _eb.Sprintf("\u0025\u0071", _eaacd(_egeca, 12))
			_egeca = _egeca[1 : len(_egeca)-1]
			_eb.Printf("\u0025\u0031\u0032\u0073\u0020\u007c", _egeca)
		}
		_eb.Println("")
	}
}
func (_fcf paraList) list() []*list {
	var _abdaa []*textLine
	var _eaag []*textLine
	for _, _adegc := range _fcf {
		_ddc := _adegc.getListLines()
		_abdaa = append(_abdaa, _ddc...)
		_eaag = append(_eaag, _adegc._eeedg...)
	}
	_gfad := _cbbb(_abdaa)
	_fcfb := _fgbcg(_eaag, _gfad)
	return _fcfb
}

// Elements returns the TextMarks in `ma`.
func (_dgea *TextMarkArray) Elements() []TextMark { return _dgea._fcca }
func (_fadd paraList) toTextMarks() []TextMark {
	_dddb := 0
	var _fffdg []TextMark
	for _aegc, _gefg := range _fadd {
		if _gefg._fcbg {
			continue
		}
		_fbgfe := _gefg.toTextMarks(&_dddb)
		_fffdg = append(_fffdg, _fbgfe...)
		if _aegc != len(_fadd)-1 {
			if _edgg(_gefg, _fadd[_aegc+1]) {
				_fffdg = _faacg(_fffdg, &_dddb, "\u0020")
			} else {
				_fffdg = _faacg(_fffdg, &_dddb, "\u000a")
				_fffdg = _faacg(_fffdg, &_dddb, "\u000a")
			}
		}
	}
	_fffdg = _faacg(_fffdg, &_dddb, "\u000a")
	_fffdg = _faacg(_fffdg, &_dddb, "\u000a")
	return _fffdg
}
func _bbgaf(_begca []*textMark, _cfdba _ba.PdfRectangle) []*textWord {
	var _gfgga []*textWord
	var _beaag *textWord
	if _fcec {
		_b.Log.Info("\u006d\u0061\u006beT\u0065\u0078\u0074\u0057\u006f\u0072\u0064\u0073\u003a\u0020\u0025\u0064\u0020\u006d\u0061\u0072\u006b\u0073", len(_begca))
	}
	_adecd := func() {
		if _beaag != nil {
			_gbgfba := _beaag.computeText()
			if !_geccc(_gbgfba) {
				_beaag._cdfe = _gbgfba
				_gfgga = append(_gfgga, _beaag)
				if _fcec {
					_b.Log.Info("\u0061\u0064\u0064Ne\u0077\u0057\u006f\u0072\u0064\u003a\u0020\u0025\u0064\u003a\u0020\u0077\u006f\u0072\u0064\u003d\u0025\u0073", len(_gfgga)-1, _beaag.String())
					for _ddcc, _edbfd := range _beaag._ebca {
						_eb.Printf("\u0025\u0034\u0064\u003a\u0020\u0025\u0073\u000a", _ddcc, _edbfd.String())
					}
				}
			}
			_beaag = nil
		}
	}
	for _, _gcacc := range _begca {
		if _gfba && _beaag != nil && len(_beaag._ebca) > 0 {
			_bcbfg := _beaag._ebca[len(_beaag._ebca)-1]
			_ddad, _bgccg := _aeage(_gcacc._abfc)
			_egce, _cdac := _aeage(_bcbfg._abfc)
			if _bgccg && !_cdac && _bcbfg.inDiacriticArea(_gcacc) {
				_beaag.addDiacritic(_ddad)
				continue
			}
			if _cdac && !_bgccg && _gcacc.inDiacriticArea(_bcbfg) {
				_beaag._ebca = _beaag._ebca[:len(_beaag._ebca)-1]
				_beaag.appendMark(_gcacc, _cfdba)
				_beaag.addDiacritic(_egce)
				continue
			}
		}
		_gdga := _geccc(_gcacc._abfc)
		if _gdga {
			_adecd()
			continue
		}
		if _beaag == nil && !_gdga {
			_beaag = _daddg([]*textMark{_gcacc}, _cfdba)
			continue
		}
		_badea := _beaag._affe
		_befcf := _cc.Abs(_agfe(_cfdba, _gcacc)-_beaag._gadaf) / _badea
		_fecbc := _fdfe(_gcacc, _beaag) / _badea
		if _fecbc >= _egac || !(-_eefd <= _fecbc && _befcf <= _gacbc) {
			_adecd()
			_beaag = _daddg([]*textMark{_gcacc}, _cfdba)
			continue
		}
		_beaag.appendMark(_gcacc, _cfdba)
	}
	_adecd()
	return _gfgga
}

type textState struct {
	_bdag float64
	_ega  float64
	_gaff float64
	_acdc float64
	_fgeg float64
	_bffe RenderMode
	_cce  float64
	_edd  *_ba.PdfFont
	_cbff _ba.PdfRectangle
	_ggec int
	_eeg  int
}

func (_afgg *textPara) writeCellText(_edddf _ge.Writer) {
	for _ecfa, _edfcc := range _afgg._eeedg {
		_cgdda := _edfcc.text()
		_ffbba := _gfbe && _edfcc.endsInHyphen() && _ecfa != len(_afgg._eeedg)-1
		if _ffbba {
			_cgdda = _ebfb(_cgdda)
		}
		_edddf.Write([]byte(_cgdda))
		if !(_ffbba || _ecfa == len(_afgg._eeedg)-1) {
			_edddf.Write([]byte(_bebb(_edfcc._gfeac, _afgg._eeedg[_ecfa+1]._gfeac)))
		}
	}
}
func (_defe paraList) inTile(_ccecb gridTile) paraList {
	var _cdccf paraList
	for _, _agee := range _defe {
		if _ccecb.contains(_agee.PdfRectangle) {
			_cdccf = append(_cdccf, _agee)
		}
	}
	if _egdf {
		_eb.Printf("\u0020 \u0020\u0069\u006e\u0054i\u006c\u0065\u003a\u0020\u0020%\u0073 \u0069n\u0073\u0069\u0064\u0065\u003d\u0025\u0064\n", _ccecb, len(_cdccf))
		for _dfbf, _addg := range _cdccf {
			_eb.Printf("\u0025\u0034\u0064\u003a\u0020\u0025\u0073\u000a", _dfbf, _addg)
		}
		_eb.Println("")
	}
	return _cdccf
}
func (_fdf *shapesState) drawRectangle(_dfeg, _dbcg, _gcdg, _dgf float64) {
	if _adbb {
		_acbf := _fdf.devicePoint(_dfeg, _dbcg)
		_bbfa := _fdf.devicePoint(_dfeg+_gcdg, _dbcg+_dgf)
		_cfee := _ba.PdfRectangle{Llx: _acbf.X, Lly: _acbf.Y, Urx: _bbfa.X, Ury: _bbfa.Y}
		_b.Log.Info("d\u0072a\u0077\u0052\u0065\u0063\u0074\u0061\u006e\u0067l\u0065\u003a\u0020\u00256.\u0032\u0066", _cfee)
	}
	_fdf.newSubPath()
	_fdf.moveTo(_dfeg, _dbcg)
	_fdf.lineTo(_dfeg+_gcdg, _dbcg)
	_fdf.lineTo(_dfeg+_gcdg, _dbcg+_dgf)
	_fdf.lineTo(_dfeg, _dbcg+_dgf)
	_fdf.closePath()
}
func _bfea(_aceg []*textMark, _cbcfe _ba.PdfRectangle, _gadea rulingList, _aecef []gridTiling, _aaba bool) paraList {
	_b.Log.Trace("\u006d\u0061\u006b\u0065\u0054\u0065\u0078\u0074\u0050\u0061\u0067\u0065\u003a \u0025\u0064\u0020\u0065\u006c\u0065m\u0065\u006e\u0074\u0073\u0020\u0070\u0061\u0067\u0065\u0053\u0069\u007a\u0065=\u0025\u002e\u0032\u0066", len(_aceg), _cbcfe)
	if len(_aceg) == 0 {
		return nil
	}
	_bbgac := _bbgaf(_aceg, _cbcfe)
	if len(_bbgac) == 0 {
		return nil
	}
	_gadea.log("\u006d\u0061\u006be\u0054\u0065\u0078\u0074\u0050\u0061\u0067\u0065")
	_fada, _feba := _gadea.vertsHorzs()
	_fccbc := _ecfg(_bbgac, _cbcfe.Ury, _fada, _feba)
	_fbbfd := _cddc(_fccbc, _cbcfe.Ury, _fada, _feba)
	_fbbfd = _bgbg(_fbbfd)
	_gadeg := make(paraList, 0, len(_fbbfd))
	for _, _beda := range _fbbfd {
		_feccg := _beda.arrangeText()
		if _feccg != nil {
			_gadeg = append(_gadeg, _feccg)
		}
	}
	if !_aaba && len(_gadeg) >= _deaa {
		_gadeg = _gadeg.extractTables(_aecef)
	}
	_gadeg.sortReadingOrder()
	if !_aaba {
		_gadeg.sortTopoOrder()
	}
	_gadeg.log("\u0073\u006f\u0072te\u0064\u0020\u0069\u006e\u0020\u0072\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u006f\u0072\u0064\u0065\u0072")
	return _gadeg
}
func (_fdgb *textTable) markCells() {
	for _dfec := 0; _dfec < _fdgb._ggeg; _dfec++ {
		for _fceg := 0; _fceg < _fdgb._gdab; _fceg++ {
			_ffac := _fdgb.get(_fceg, _dfec)
			if _ffac != nil {
				_ffac._fcag = true
			}
		}
	}
}
func _abaeg(_ebga *wordBag, _ege *textWord, _gdbg float64) bool {
	return _ege.Llx < _ebga.Urx+_gdbg && _ebga.Llx-_gdbg < _ege.Urx
}
func (_eac *wordBag) getDepthIdx(_efcc float64) int {
	_ede := _eac.depthIndexes()
	_fged := _dgeg(_efcc)
	if _fged < _ede[0] {
		return _ede[0]
	}
	if _fged > _ede[len(_ede)-1] {
		return _ede[len(_ede)-1]
	}
	return _fged
}
func (_bcgde *textPara) taken() bool { return _bcgde == nil || _bcgde._fcag }
func (_ebb *wordBag) applyRemovals(_fccb map[int]map[*textWord]struct{}) {
	for _fbbd, _eggc := range _fccb {
		if len(_eggc) == 0 {
			continue
		}
		_gbafg := _ebb._agfg[_fbbd]
		_bebc := len(_gbafg) - len(_eggc)
		if _bebc == 0 {
			delete(_ebb._agfg, _fbbd)
			continue
		}
		_dag := make([]*textWord, _bebc)
		_ebbe := 0
		for _, _cbagg := range _gbafg {
			if _, _befg := _eggc[_cbagg]; !_befg {
				_dag[_ebbe] = _cbagg
				_ebbe++
			}
		}
		_ebb._agfg[_fbbd] = _dag
	}
}
func (_fdag *textLine) markWordBoundaries() {
	_fecbg := _ccdaa * _fdag._gdca
	for _cbfdb, _cee := range _fdag._bcce[1:] {
		if _fdfe(_cee, _fdag._bcce[_cbfdb]) >= _fecbg {
			_cee._fggcb = true
		}
	}
}
func _accc(_gdcac []*textLine, _afagg, _eafb float64) []*textLine {
	var _dceg []*textLine
	for _, _ddef := range _gdcac {
		if _afagg == -1 {
			if _ddef._gfeac > _eafb {
				_dceg = append(_dceg, _ddef)
			}
		} else {
			if _ddef._gfeac > _eafb && _ddef._gfeac < _afagg {
				_dceg = append(_dceg, _ddef)
			}
		}
	}
	return _dceg
}

const (
	_aedad = false
	_fcec  = false
	_gece  = false
	_efeg  = false
	_adbb  = false
	_bbca  = false
	_gdee  = false
	_fcefe = false
	_dga   = false
	_fdfef = _dga && true
	_aeeb  = _fdfef && false
	_ccab  = _dga && true
	_egdf  = false
	_baef  = _egdf && false
	_ecad  = _egdf && true
	_ccc   = false
	_adeg  = _ccc && false
	_agcad = _ccc && false
	_ceac  = _ccc && true
	_daga  = _ccc && false
	_aae   = _ccc && false
)

func (_ccdf paraList) tables() []TextTable {
	var _bdeb []TextTable
	if _egdf {
		_b.Log.Info("\u0070\u0061\u0072\u0061\u0073\u002e\u0074\u0061\u0062\u006c\u0065\u0073\u003a")
	}
	for _, _dgec := range _ccdf {
		_edbf := _dgec._beefb
		if _edbf != nil && _edbf.isExportable() {
			_bdeb = append(_bdeb, _edbf.toTextTable())
		}
	}
	return _bdeb
}
func (_bgga *textLine) endsInHyphen() bool {
	_dfba := _bgga._bcce[len(_bgga._bcce)-1]
	_cdgbd := _dfba._cdfe
	_cfaa, _ecae := _dc.DecodeLastRuneInString(_cdgbd)
	if _ecae <= 0 || !_e.Is(_e.Hyphen, _cfaa) {
		return false
	}
	if _dfba._fggcb && _gaca(_cdgbd) {
		return true
	}
	return _gaca(_bgga.text())
}

// Font represents the font properties on a PDF page.
type Font struct {
	PdfFont *_ba.PdfFont

	// FontName represents Font Name from font properties.
	FontName string

	// FontType represents Font Subtype entry in the font dictionary inside page resources.
	// Examples : type0, Type1, MMType1, Type3, TrueType, CIDFont.
	FontType string

	// ToUnicode is true if font provides a `ToUnicode` mapping.
	ToUnicode bool

	// IsCID is true if underlying font is a composite font.
	// Composite font is represented by a font dictionary whose Subtype is `Type0`
	IsCID bool

	// IsSimple is true if font is simple font.
	// A simple font is limited to only 8 bit (255) character codes.
	IsSimple bool

	// FontData represents the raw data of the embedded font file.
	// It can have format TrueType (TTF), PostScript Font (PFB) or Compact Font Format (CCF).
	// FontData value can be indicates from `FontFile`, `FontFile2` or `FontFile3` inside Font Descriptor.
	// At most, only one of `FontFile`, `FontFile2` or `FontFile3` will be FontData value.
	FontData []byte

	// FontFileName is a name representing the font. it has format:
	// (Font Name) + (Font Type Extension), example: helvetica.ttf.
	FontFileName string

	// FontDescriptor represents metrics and other attributes inside font properties from PDF Structure (Font Descriptor).
	FontDescriptor *_ba.PdfFontDescriptor
}

func (_fcef *wordBag) allWords() []*textWord {
	var _efgg []*textWord
	for _, _fde := range _fcef._agfg {
		_efgg = append(_efgg, _fde...)
	}
	return _efgg
}
func _fdfe(_edcgc, _gdgb bounded) float64 { return _edcgc.bbox().Llx - _gdgb.bbox().Urx }
func (_fgaa rulingList) findPrimSec(_eaaba, _edfb float64) *ruling {
	for _, _gebgf := range _fgaa {
		if _gabfc(_gebgf._abfa-_eaaba) && _gebgf._bgbbf-_beba <= _edfb && _edfb <= _gebgf._dffbe+_beba {
			return _gebgf
		}
	}
	return nil
}
func (_gcbbd *textTable) put(_gfdcf, _fcbf int, _ebcfd *textPara) {
	_gcbbd._gabega[_aaega(_gfdcf, _fcbf)] = _ebcfd
}

// Marks returns the TextMark collection for a page. It represents all the text on the page.
func (_dbba PageText) Marks() *TextMarkArray { return &TextMarkArray{_fcca: _dbba._bdbb} }
func (_ggbg *shapesState) lastpointEstablished() (_cbc.Point, bool) {
	if _ggbg._efa {
		return _ggbg._efcbf, false
	}
	_bdbbc := len(_ggbg._cgfg)
	if _bdbbc > 0 && _ggbg._cgfg[_bdbbc-1]._eadff {
		return _ggbg._cgfg[_bdbbc-1].last(), false
	}
	return _cbc.Point{}, true
}
func (_cabb *shapesState) cubicTo(_ebcf, _ffbb, _ccgca, _fbfb, _dfe, _bbbg float64) {
	if _adbb {
		_b.Log.Info("\u0063\u0075\u0062\u0069\u0063\u0054\u006f\u003a")
	}
	_cabb.addPoint(_dfe, _bbbg)
}

type pathSection struct {
	_bbbga []*subpath
	_ea.Color
}

func (_ccf *imageExtractContext) extractFormImages(_cbf *_fb.PdfObjectName, _efd _de.GraphicsState, _ggfe *_ba.PdfPageResources) error {
	_bcf, _dbg := _ggfe.GetXObjectFormByName(*_cbf)
	if _dbg != nil {
		return _dbg
	}
	if _bcf == nil {
		return nil
	}
	_ggb, _dbg := _bcf.GetContentStream()
	if _dbg != nil {
		return _dbg
	}
	_bda := _bcf.Resources
	if _bda == nil {
		_bda = _ggfe
	}
	_dbg = _ccf.extractContentStreamImages(string(_ggb), _bda)
	if _dbg != nil {
		return _dbg
	}
	_ccf._fbef++
	return nil
}

type wordBag struct {
	_ba.PdfRectangle
	_cdc          float64
	_cfegb, _dffc rulingList
	_agdfc        float64
	_agfg         map[int][]*textWord
}

func (_eeff *textWord) bbox() _ba.PdfRectangle { return _eeff.PdfRectangle }
func _abaa(_geega []pathSection) rulingList {
	_egecab(_geega)
	if _ccc {
		_b.Log.Info("\u006d\u0061k\u0065\u0053\u0074\u0072\u006f\u006b\u0065\u0052\u0075\u006c\u0069\u006e\u0067\u0073\u003a\u0020\u0025\u0064\u0020\u0073\u0074\u0072ok\u0065\u0073", len(_geega))
	}
	var _acdd rulingList
	for _, _edcd := range _geega {
		for _, _edbg := range _edcd._bbbga {
			if len(_edbg._dgfd) < 2 {
				continue
			}
			_gaed := _edbg._dgfd[0]
			for _, _afga := range _edbg._dgfd[1:] {
				if _abaef, _gefgf := _bdba(_gaed, _afga, _edcd.Color); _gefgf {
					_acdd = append(_acdd, _abaef)
				}
				_gaed = _afga
			}
		}
	}
	if _ccc {
		_b.Log.Info("m\u0061\u006b\u0065\u0053tr\u006fk\u0065\u0052\u0075\u006c\u0069n\u0067\u0073\u003a\u0020\u0025\u0073", _acdd)
	}
	return _acdd
}
func _ecfg(_egc []*textWord, _fefd float64, _bcc, _cdgb rulingList) *wordBag {
	_dggc := _bbba(_egc[0], _fefd, _bcc, _cdgb)
	for _, _ebeg := range _egc[1:] {
		_efee := _dgeg(_ebeg._gadaf)
		_dggc._agfg[_efee] = append(_dggc._agfg[_efee], _ebeg)
		_dggc.PdfRectangle = _eece(_dggc.PdfRectangle, _ebeg.PdfRectangle)
	}
	_dggc.sort()
	return _dggc
}
func (_gfgbe *shapesState) addPoint(_fabc, _caga float64) {
	_cbfc := _gfgbe.establishSubpath()
	_bfcf := _gfgbe.devicePoint(_fabc, _caga)
	if _cbfc == nil {
		_gfgbe._efa = true
		_gfgbe._efcbf = _bfcf
	} else {
		_cbfc.add(_bfcf)
	}
}
func (_ebaf *textTable) log(_bgae string) {
	if !_egdf {
		return
	}
	_b.Log.Info("~\u007e\u007e\u0020\u0025\u0073\u003a \u0025\u0064\u0020\u0078\u0020\u0025d\u0020\u0067\u0072\u0069\u0064\u003d\u0025t\u000a\u0020\u0020\u0020\u0020\u0020\u0020\u0025\u0036\u002e2\u0066", _bgae, _ebaf._gdab, _ebaf._ggeg, _ebaf._dggfe, _ebaf.PdfRectangle)
	for _fbcac := 0; _fbcac < _ebaf._ggeg; _fbcac++ {
		for _eedgf := 0; _eedgf < _ebaf._gdab; _eedgf++ {
			_fdff := _ebaf.get(_eedgf, _fbcac)
			if _fdff == nil {
				continue
			}
			_eb.Printf("%\u0034\u0064\u0020\u00252d\u003a \u0025\u0036\u002e\u0032\u0066 \u0025\u0071\u0020\u0025\u0064\u000a", _eedgf, _fbcac, _fdff.PdfRectangle, _eaacd(_fdff.text(), 50), _dc.RuneCountInString(_fdff.text()))
		}
	}
}
func (_afee gridTiling) complete() bool {
	for _, _adgf := range _afee._fbgfa {
		for _, _cbgga := range _adgf {
			if !_cbgga.complete() {
				return false
			}
		}
	}
	return true
}
func (_acfc *subpath) makeRectRuling(_fgee _ea.Color) (*ruling, bool) {
	if _daga {
		_b.Log.Info("\u006d\u0061\u006beR\u0065\u0063\u0074\u0052\u0075\u006c\u0069\u006e\u0067\u003a\u0020\u0070\u0061\u0074\u0068\u003d\u0025\u0076", _acfc)
	}
	_abcg := _acfc._dgfd[:4]
	_fgeae := make(map[int]rulingKind, len(_abcg))
	for _dbade, _faecg := range _abcg {
		_acdda := _acfc._dgfd[(_dbade+1)%4]
		_fgeae[_dbade] = _fgcf(_faecg, _acdda)
		if _daga {
			_eb.Printf("\u0025\u0034\u0064: \u0025\u0073\u0020\u003d\u0020\u0025\u0036\u002e\u0032\u0066\u0020\u002d\u0020\u0025\u0036\u002e\u0032\u0066", _dbade, _fgeae[_dbade], _faecg, _acdda)
		}
	}
	if _daga {
		_eb.Printf("\u0020\u0020\u0020\u006b\u0069\u006e\u0064\u0073\u003d\u0025\u002b\u0076\u000a", _fgeae)
	}
	var _ceab, _bbfge []int
	for _eccfa, _egad := range _fgeae {
		switch _egad {
		case _deg:
			_bbfge = append(_bbfge, _eccfa)
		case _aagff:
			_ceab = append(_ceab, _eccfa)
		}
	}
	if _daga {
		_eb.Printf("\u0020\u0020 \u0068\u006f\u0072z\u0073\u003d\u0025\u0064\u0020\u0025\u002b\u0076\u000a", len(_bbfge), _bbfge)
		_eb.Printf("\u0020\u0020 \u0076\u0065\u0072t\u0073\u003d\u0025\u0064\u0020\u0025\u002b\u0076\u000a", len(_ceab), _ceab)
	}
	_bdcbc := (len(_bbfge) == 2 && len(_ceab) == 2) || (len(_bbfge) == 2 && len(_ceab) == 0 && _bgdbf(_abcg[_bbfge[0]], _abcg[_bbfge[1]])) || (len(_ceab) == 2 && len(_bbfge) == 0 && _bbdg(_abcg[_ceab[0]], _abcg[_ceab[1]]))
	if _daga {
		_eb.Printf(" \u0020\u0020\u0068\u006f\u0072\u007as\u003d\u0025\u0064\u0020\u0076\u0065\u0072\u0074\u0073=\u0025\u0064\u0020o\u006b=\u0025\u0074\u000a", len(_bbfge), len(_ceab), _bdcbc)
	}
	if !_bdcbc {
		if _daga {
			_b.Log.Error("\u0021!\u006d\u0061\u006b\u0065R\u0065\u0063\u0074\u0052\u0075l\u0069n\u0067:\u0020\u0070\u0061\u0074\u0068\u003d\u0025v", _acfc)
			_eb.Printf(" \u0020\u0020\u0068\u006f\u0072\u007as\u003d\u0025\u0064\u0020\u0076\u0065\u0072\u0074\u0073=\u0025\u0064\u0020o\u006b=\u0025\u0074\u000a", len(_bbfge), len(_ceab), _bdcbc)
		}
		return &ruling{}, false
	}
	if len(_ceab) == 0 {
		for _fbffe, _cfbf := range _fgeae {
			if _cfbf != _deg {
				_ceab = append(_ceab, _fbffe)
			}
		}
	}
	if len(_bbfge) == 0 {
		for _bgeg, _becf := range _fgeae {
			if _becf != _aagff {
				_bbfge = append(_bbfge, _bgeg)
			}
		}
	}
	if _daga {
		_b.Log.Info("\u006da\u006b\u0065R\u0065\u0063\u0074\u0052u\u006c\u0069\u006eg\u003a\u0020\u0068\u006f\u0072\u007a\u0073\u003d\u0025d \u0076\u0065\u0072t\u0073\u003d%\u0064\u0020\u0070\u006f\u0069\u006et\u0073\u003d%\u0064\u000a"+"\u0009\u0020\u0068o\u0072\u007a\u0073\u003d\u0025\u002b\u0076\u000a"+"\u0009\u0020\u0076e\u0072\u0074\u0073\u003d\u0025\u002b\u0076\u000a"+"\t\u0070\u006f\u0069\u006e\u0074\u0073\u003d\u0025\u002b\u0076", len(_bbfge), len(_ceab), len(_abcg), _bbfge, _ceab, _abcg)
	}
	var _cged, _dggac, _befba, _cbee _cbc.Point
	if _abcg[_bbfge[0]].Y > _abcg[_bbfge[1]].Y {
		_befba, _cbee = _abcg[_bbfge[0]], _abcg[_bbfge[1]]
	} else {
		_befba, _cbee = _abcg[_bbfge[1]], _abcg[_bbfge[0]]
	}
	if _abcg[_ceab[0]].X > _abcg[_ceab[1]].X {
		_cged, _dggac = _abcg[_ceab[0]], _abcg[_ceab[1]]
	} else {
		_cged, _dggac = _abcg[_ceab[1]], _abcg[_ceab[0]]
	}
	_aeag := _ba.PdfRectangle{Llx: _cged.X, Urx: _dggac.X, Lly: _cbee.Y, Ury: _befba.Y}
	if _aeag.Llx > _aeag.Urx {
		_aeag.Llx, _aeag.Urx = _aeag.Urx, _aeag.Llx
	}
	if _aeag.Lly > _aeag.Ury {
		_aeag.Lly, _aeag.Ury = _aeag.Ury, _aeag.Lly
	}
	_gfag := rectRuling{PdfRectangle: _aeag, _afcb: _dcgc(_aeag), Color: _fgee}
	if _gfag._afcb == _affd {
		if _daga {
			_b.Log.Error("\u006da\u006b\u0065\u0052\u0065\u0063\u0074\u0052\u0075\u006c\u0069\u006eg\u003a\u0020\u006b\u0069\u006e\u0064\u003d\u006e\u0069\u006c")
		}
		return nil, false
	}
	_becb, _agace := _gfag.asRuling()
	if !_agace {
		if _daga {
			_b.Log.Error("\u006da\u006b\u0065\u0052\u0065c\u0074\u0052\u0075\u006c\u0069n\u0067:\u0020!\u0069\u0073\u0052\u0075\u006c\u0069\u006eg")
		}
		return nil, false
	}
	if _ccc {
		_eb.Printf("\u0020\u0020\u0020\u0072\u003d\u0025\u0073\u000a", _becb.String())
	}
	return _becb, true
}
func (_edfdg *TextMarkArray) getTextMarkAtOffset(_fbceec int) *TextMark {
	for _, _baac := range _edfdg._fcca {
		if _baac.Offset == _fbceec {
			return &_baac
		}
	}
	return nil
}
func (_fead *wordBag) removeWord(_fbfa *textWord, _bffg int) {
	_cfgf := _fead._agfg[_bffg]
	_cfgf = _ecfgc(_cfgf, _fbfa)
	if len(_cfgf) == 0 {
		delete(_fead._agfg, _bffg)
	} else {
		_fead._agfg[_bffg] = _cfgf
	}
}
func (_fbdf *textTable) subdivide() *textTable {
	_fbdf.logComposite("\u0073u\u0062\u0064\u0069\u0076\u0069\u0064e")
	_ffgcc := _fbdf.compositeRowCorridors()
	_decc := _fbdf.compositeColCorridors()
	if _egdf {
		_b.Log.Info("\u0073u\u0062\u0064i\u0076\u0069\u0064\u0065:\u000a\u0009\u0072o\u0077\u0043\u006f\u0072\u0072\u0069\u0064\u006f\u0072s=\u0025\u0073\u000a\t\u0063\u006fl\u0043\u006f\u0072\u0072\u0069\u0064o\u0072\u0073=\u0025\u0073", _dcaf(_ffgcc), _dcaf(_decc))
	}
	if len(_ffgcc) == 0 || len(_decc) == 0 {
		return _fbdf
	}
	_dgeab(_ffgcc)
	_dgeab(_decc)
	if _egdf {
		_b.Log.Info("\u0073\u0075\u0062\u0064\u0069\u0076\u0069\u0064\u0065\u0020\u0066\u0069\u0078\u0065\u0064\u003a\u000a\u0009r\u006f\u0077\u0043\u006f\u0072\u0072\u0069d\u006f\u0072\u0073\u003d\u0025\u0073\u000a\u0009\u0063\u006f\u006cC\u006f\u0072\u0072\u0069\u0064\u006f\u0072\u0073\u003d\u0025\u0073", _dcaf(_ffgcc), _dcaf(_decc))
	}
	_ggccf, _dcge := _bbccb(_fbdf._ggeg, _ffgcc)
	_dfccd, _bfeba := _bbccb(_fbdf._gdab, _decc)
	_agffc := make(map[uint64]*textPara, _bfeba*_dcge)
	_ggaef := &textTable{PdfRectangle: _fbdf.PdfRectangle, _dggfe: _fbdf._dggfe, _ggeg: _dcge, _gdab: _bfeba, _gabega: _agffc}
	if _egdf {
		_b.Log.Info("\u0073\u0075b\u0064\u0069\u0076\u0069\u0064\u0065\u003a\u0020\u0063\u006f\u006d\u0070\u006f\u0073\u0069\u0074\u0065\u0020\u003d\u0020\u0025\u0064\u0020\u0078\u0020\u0025\u0064\u0020\u0063\u0065\u006c\u006c\u0073\u003d\u0020\u0025\u0064\u0020\u0078\u0020\u0025\u0064\u000a"+"\u0009\u0072\u006f\u0077\u0043\u006f\u0072\u0072\u0069\u0064\u006f\u0072s\u003d\u0025\u0073\u000a"+"\u0009\u0063\u006f\u006c\u0043\u006f\u0072\u0072\u0069\u0064\u006f\u0072s\u003d\u0025\u0073\u000a"+"\u0009\u0079\u004f\u0066\u0066\u0073\u0065\u0074\u0073=\u0025\u002b\u0076\u000a"+"\u0009\u0078\u004f\u0066\u0066\u0073\u0065\u0074\u0073\u003d\u0025\u002b\u0076", _fbdf._gdab, _fbdf._ggeg, _bfeba, _dcge, _dcaf(_ffgcc), _dcaf(_decc), _ggccf, _dfccd)
	}
	for _agdgb := 0; _agdgb < _fbdf._ggeg; _agdgb++ {
		_ggaa := _ggccf[_agdgb]
		for _dadg := 0; _dadg < _fbdf._gdab; _dadg++ {
			_ccgdf := _dfccd[_dadg]
			if _egdf {
				_eb.Printf("\u0025\u0036\u0064\u002c %\u0032\u0064\u003a\u0020\u0078\u0030\u003d\u0025\u0064\u0020\u0079\u0030\u003d\u0025d\u000a", _dadg, _agdgb, _ccgdf, _ggaa)
			}
			_fbfbd, _eaea := _fbdf._bbgacd[_aaega(_dadg, _agdgb)]
			if !_eaea {
				continue
			}
			_fegg := _fbfbd.split(_ffgcc[_agdgb], _decc[_dadg])
			for _dcca := 0; _dcca < _fegg._ggeg; _dcca++ {
				for _bdfdg := 0; _bdfdg < _fegg._gdab; _bdfdg++ {
					_abgaf := _fegg.get(_bdfdg, _dcca)
					_ggaef.put(_ccgdf+_bdfdg, _ggaa+_dcca, _abgaf)
					if _egdf {
						_eb.Printf("\u0025\u0038\u0064\u002c\u0020\u0025\u0032\u0064\u003a\u0020\u0025\u0073\u000a", _ccgdf+_bdfdg, _ggaa+_dcca, _abgaf)
					}
				}
			}
		}
	}
	return _ggaef
}
func _ebfb(_aecfc string) string {
	_gfdfg := []rune(_aecfc)
	return string(_gfdfg[:len(_gfdfg)-1])
}
func (_gggdf rulingList) snapToGroupsDirection() rulingList {
	_gggdf.sortStrict()
	_ccef := make(map[*ruling]rulingList, len(_gggdf))
	_bddfd := _gggdf[0]
	_bdfa := func(_deeg *ruling) { _bddfd = _deeg; _ccef[_bddfd] = rulingList{_deeg} }
	_bdfa(_gggdf[0])
	for _, _bdded := range _gggdf[1:] {
		if _bdded._abfa < _bddfd._abfa-_gadf {
			_b.Log.Error("\u0073\u006e\u0061\u0070T\u006f\u0047\u0072\u006f\u0075\u0070\u0073\u0044\u0069r\u0065\u0063\u0074\u0069\u006f\u006e\u003a\u0020\u0057\u0072\u006f\u006e\u0067\u0020\u0070\u0072\u0069\u006da\u0072\u0079\u0020\u006f\u0072d\u0065\u0072\u002e\u000a\u0009\u0076\u0030\u003d\u0025\u0073\u000a\u0009\u0020\u0076\u003d\u0025\u0073", _bddfd, _bdded)
		}
		if _bdded._abfa > _bddfd._abfa+_ebbd {
			_bdfa(_bdded)
		} else {
			_ccef[_bddfd] = append(_ccef[_bddfd], _bdded)
		}
	}
	_gcgeg := make(map[*ruling]float64, len(_ccef))
	_abbd := make(map[*ruling]*ruling, len(_gggdf))
	for _agdgg, _ceae := range _ccef {
		_gcgeg[_agdgg] = _ceae.mergePrimary()
		for _, _fcaa := range _ceae {
			_abbd[_fcaa] = _agdgg
		}
	}
	for _, _aefb := range _gggdf {
		_aefb._abfa = _gcgeg[_abbd[_aefb]]
	}
	_becg := make(rulingList, 0, len(_gggdf))
	for _, _cffed := range _ccef {
		_fbga := _cffed.splitSec()
		for _cedae, _eabf := range _fbga {
			_afefd := _eabf.merge()
			if len(_becg) > 0 {
				_bebae := _becg[len(_becg)-1]
				if _bebae.alignsPrimary(_afefd) && _bebae.alignsSec(_afefd) {
					_b.Log.Error("\u0073\u006e\u0061\u0070\u0054\u006fG\u0072\u006f\u0075\u0070\u0073\u0044\u0069\u0072\u0065\u0063\u0074\u0069\u006f\u006e\u003a\u0020\u0044\u0075\u0070\u006ci\u0063\u0061\u0074\u0065\u0020\u0069\u003d\u0025\u0064\u000a\u0009\u0077\u003d\u0025s\u000a\t\u0076\u003d\u0025\u0073", _cedae, _bebae, _afefd)
					continue
				}
			}
			_becg = append(_becg, _afefd)
		}
	}
	_becg.sortStrict()
	return _becg
}
func _dggg(_eeaf []*textLine) []*textLine {
	_cfgc := []*textLine{}
	for _, _feb := range _eeaf {
		_fcba := _feb.text()
		_eddg := _defb.Find([]byte(_fcba))
		if _eddg != nil {
			_cfgc = append(_cfgc, _feb)
		}
	}
	return _cfgc
}
func (_afed *textPara) depth() float64 {
	if _afed._fcbg {
		return -1.0
	}
	if len(_afed._eeedg) > 0 {
		return _afed._eeedg[0]._gfeac
	}
	return _afed._beefb.depth()
}

var _ggc = false

func (_deae *textLine) appendWord(_adbba *textWord) {
	_deae._bcce = append(_deae._bcce, _adbba)
	_deae.PdfRectangle = _eece(_deae.PdfRectangle, _adbba.PdfRectangle)
	if _adbba._affe > _deae._gdca {
		_deae._gdca = _adbba._affe
	}
	if _adbba._gadaf > _deae._gfeac {
		_deae._gfeac = _adbba._gadaf
	}
}
func (_fbbc *shapesState) newSubPath() {
	_fbbc.clearPath()
	if _adbb {
		_b.Log.Info("\u006e\u0065\u0077\u0053\u0075\u0062\u0050\u0061\u0074h\u003a\u0020\u0025\u0073", _fbbc)
	}
}
func (_gdef *wordBag) depthBand(_abcd, _aeaf float64) []int {
	if len(_gdef._agfg) == 0 {
		return nil
	}
	return _gdef.depthRange(_gdef.getDepthIdx(_abcd), _gdef.getDepthIdx(_aeaf))
}
func _egfec(_aegca float64) float64 { return _bcef * _cc.Round(_aegca/_bcef) }
func (_gecg rulingList) primMinMax() (float64, float64) {
	_cced, _gdcae := _gecg[0]._abfa, _gecg[0]._abfa
	for _, _bffebf := range _gecg[1:] {
		if _bffebf._abfa < _cced {
			_cced = _bffebf._abfa
		} else if _bffebf._abfa > _gdcae {
			_gdcae = _bffebf._abfa
		}
	}
	return _cced, _gdcae
}
func (_cafc *textObject) setTextRise(_gegg float64) {
	if _cafc == nil {
		return
	}
	_cafc._fggf._cce = _gegg
}

// String returns a description of `k`.
func (_edge markKind) String() string {
	_dcdc, _cagd := _eceb[_edge]
	if !_cagd {
		return _eb.Sprintf("\u004e\u006f\u0074\u0020\u0061\u0020\u006d\u0061\u0072k\u003a\u0020\u0025\u0064", _edge)
	}
	return _dcdc
}

// ImageMark represents an image drawn on a page and its position in device coordinates.
// All coordinates are in device coordinates.
type ImageMark struct {
	Image *_ba.Image

	// Dimensions of the image as displayed in the PDF.
	Width  float64
	Height float64

	// Position of the image in PDF coordinates (lower left corner).
	X float64
	Y float64

	// Angle in degrees, if rotated.
	Angle float64
}

func _agfgd(_bbcgf *PageText) error {
	return nil
	_ddff := _ac.GetLicenseKey()
	if _ddff != nil && _ddff.IsLicensed() || _ggc {
		return nil
	}
	_eb.Printf("\u0055\u006e\u006c\u0069\u0063\u0065\u006e\u0073\u0065\u0064\u0020c\u006f\u0070\u0079\u0020\u006f\u0066\u0020\u0055\u006e\u0069P\u0044\u0046\u000a")
	_eb.Println("-\u0020\u0047\u0065\u0074\u0020\u0061\u0020\u0066\u0072e\u0065\u0020\u0074\u0072\u0069\u0061\u006c l\u0069\u0063\u0065\u006es\u0065\u0020\u006f\u006e\u0020\u0068\u0074\u0074\u0070s:\u002f\u002fu\u006e\u0069\u0064\u006f\u0063\u002e\u0069\u006f")
	return _d.New("\u0075\u006e\u0069\u0070d\u0066\u0020\u006c\u0069\u0063\u0065\u006e\u0073\u0065\u0020c\u006fd\u0065\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0064")
}
func (_cbg *PageText) getParagraphs() paraList {
	var _cdeb rulingList
	if _ebbb {
		_bec := _abaa(_cbg._fgaf)
		_cdeb = append(_cdeb, _bec...)
	}
	if _baacb {
		_dfcc := _bcggd(_cbg._fbce)
		_cdeb = append(_cdeb, _dfcc...)
	}
	_cdeb, _gddb := _cdeb.toTilings()
	var _bae paraList
	_fecb := len(_cbg._dafg)
	for _fbb := 0; _fbb < 360 && _fecb > 0; _fbb += 90 {
		_eadf := make([]*textMark, 0, len(_cbg._dafg)-_fecb)
		for _, _cbaa := range _cbg._dafg {
			if _cbaa._dbd == _fbb {
				_eadf = append(_eadf, _cbaa)
			}
		}
		if len(_eadf) > 0 {
			_gdgg := _bfea(_eadf, _cbg._bgaa, _cdeb, _gddb, _cbg._gadg._aeac)
			_bae = append(_bae, _gdgg...)
			_fecb -= len(_eadf)
		}
	}
	return _bae
}

// Tables returns the tables extracted from the page.
func (_cgee PageText) Tables() []TextTable {
	if _egdf {
		_b.Log.Info("\u0054\u0061\u0062\u006c\u0065\u0073\u003a\u0020\u0025\u0064", len(_cgee._efbd))
	}
	return _cgee._efbd
}

// ExtractTextWithStats works like ExtractText but returns the number of characters in the output
// (`numChars`) and the number of characters that were not decoded (`numMisses`).
func (_cfeg *Extractor) ExtractTextWithStats() (_fgfa string, _geef int, _cggf int, _faa error) {
	_cgef, _geef, _cggf, _faa := _cfeg.ExtractPageText()
	if _faa != nil {
		return "", _geef, _cggf, _faa
	}
	return _cgef.Text(), _geef, _cggf, nil
}
func _aeage(_bbbgf string) (string, bool) {
	_ccdef := []rune(_bbbgf)
	if len(_ccdef) != 1 {
		return "", false
	}
	_abcb, _bgcee := _eeggcb[_ccdef[0]]
	return _abcb, _bgcee
}

// Options extractor options.
type Options struct {

	// DisableDocumentTags specifies whether to use the document tags during list extraction.
	DisableDocumentTags bool

	// ApplyCropBox will extract page text based on page cropbox if set to `true`.
	ApplyCropBox bool

	// UseSimplerExtractionProcess will skip topological text ordering and table processing.
	//
	// NOTE: While normally the extra processing is beneficial, it can also lead to problems when it does not work.
	// Thus it is a flag to allow the user to control this process.
	//
	// Skipping some extraction processes would also lead to the reduced processing time.
	UseSimplerExtractionProcess bool
}

// ImageExtractOptions contains options for controlling image extraction from
// PDF pages.
type ImageExtractOptions struct{ IncludeInlineStencilMasks bool }

func (_bdfdc *ruling) intersects(_gded *ruling) bool {
	_addag := (_bdfdc._adad == _aagff && _gded._adad == _deg) || (_gded._adad == _aagff && _bdfdc._adad == _deg)
	_bacd := func(_edfce, _faaca *ruling) bool {
		return _edfce._bgbbf-_beba <= _faaca._abfa && _faaca._abfa <= _edfce._dffbe+_beba
	}
	_gfdbf := _bacd(_bdfdc, _gded)
	_dcbdc := _bacd(_gded, _bdfdc)
	if _ccc {
		_eb.Printf("\u0020\u0020\u0020\u0020\u0069\u006e\u0074\u0065\u0072\u0073\u0065\u0063\u0074\u0073\u003a\u0020\u0020\u006fr\u0074\u0068\u006f\u0067\u006f\u006e\u0061l\u003d\u0025\u0074\u0020\u006f\u0031\u003d\u0025\u0074\u0020\u006f2\u003d\u0025\u0074\u0020\u2192\u0020\u0025\u0074\u000a"+"\u0020\u0020\u0020 \u0020\u0020\u0020\u0076\u003d\u0025\u0073\u000a"+" \u0020\u0020\u0020\u0020\u0020\u0077\u003d\u0025\u0073\u000a", _addag, _gfdbf, _dcbdc, _addag && _gfdbf && _dcbdc, _bdfdc, _gded)
	}
	return _addag && _gfdbf && _dcbdc
}

var _cgggc = _gf.MustCompile("\u005e\u005c\u0073\u002a\u0028\u005c\u0064\u002b\u005c\u002e\u003f|\u005b\u0049\u0069\u0076\u005d\u002b\u0029\u005c\u0073\u002a\\\u0029\u003f\u0024")

func _bcggd(_cdafe []pathSection) rulingList {
	_egecab(_cdafe)
	if _ccc {
		_b.Log.Info("\u006da\u006b\u0065\u0046\u0069l\u006c\u0052\u0075\u006c\u0069n\u0067s\u003a \u0025\u0064\u0020\u0066\u0069\u006c\u006cs", len(_cdafe))
	}
	var _eaceb rulingList
	for _, _acae := range _cdafe {
		for _, _bggb := range _acae._bbbga {
			if !_bggb.isQuadrilateral() {
				if _ccc {
					_b.Log.Error("!\u0069s\u0051\u0075\u0061\u0064\u0072\u0069\u006c\u0061t\u0065\u0072\u0061\u006c: \u0025\u0073", _bggb)
				}
				continue
			}
			if _egaag, _bdcf := _bggb.makeRectRuling(_acae.Color); _bdcf {
				_eaceb = append(_eaceb, _egaag)
			} else {
				if _daga {
					_b.Log.Error("\u0021\u006d\u0061\u006beR\u0065\u0063\u0074\u0052\u0075\u006c\u0069\u006e\u0067\u003a\u0020\u0025\u0073", _bggb)
				}
			}
		}
	}
	if _ccc {
		_b.Log.Info("\u006d\u0061\u006b\u0065Fi\u006c\u006c\u0052\u0075\u006c\u0069\u006e\u0067\u0073\u003a\u0020\u0025\u0073", _eaceb.String())
	}
	return _eaceb
}

// Text gets the extracted text contained in `l`.
func (_gdfe *list) Text() string {
	_ccgb := &_a.Builder{}
	_ddbd := ""
	_fbbdd(_gdfe, _ccgb, &_ddbd)
	return _ccgb.String()
}
func _edcf(_dea *Extractor, _ffg *_ba.PdfPageResources, _cagb _de.GraphicsState, _fadf *textState, _cgc *stateStack) *textObject {
	return &textObject{_egff: _dea, _adg: _ffg, _bffd: _cagb, _agdg: _cgc, _fggf: _fadf, _deb: _cbc.IdentityMatrix(), _gfeb: _cbc.IdentityMatrix()}
}
func (_bagge paraList) log(_beff string) {
	if !_fcefe {
		return
	}
	_b.Log.Info("%\u0038\u0073\u003a\u0020\u0025\u0064 \u0070\u0061\u0072\u0061\u0073\u0020=\u003d\u003d\u003d\u003d\u003d\u003d\u002d-\u002d\u002d\u002d\u002d\u002d\u003d\u003d\u003d\u003d\u003d=\u003d", _beff, len(_bagge))
	for _dcfgf, _dcec := range _bagge {
		if _dcec == nil {
			continue
		}
		_aeafg := _dcec.text()
		_cabdf := "\u0020\u0020"
		if _dcec._beefb != nil {
			_cabdf = _eb.Sprintf("\u005b%\u0064\u0078\u0025\u0064\u005d", _dcec._beefb._gdab, _dcec._beefb._ggeg)
		}
		_eb.Printf("\u0025\u0034\u0064\u003a\u0020\u0025\u0036\u002e\u0032\u0066\u0020\u0025s\u0020\u0025\u0071\u000a", _dcfgf, _dcec.PdfRectangle, _cabdf, _eaacd(_aeafg, 50))
	}
}

const _eabg = 1.0 / 1000.0

// Text returns the text content of the `bulletLists`.
func (_ceef *lists) Text() string {
	_cace := &_a.Builder{}
	for _, _ggecf := range *_ceef {
		_gddba := _ggecf.Text()
		_cace.WriteString(_gddba)
	}
	return _cace.String()
}
func (_egee *textTable) compositeRowCorridors() map[int][]float64 {
	_gaded := make(map[int][]float64, _egee._ggeg)
	if _egdf {
		_b.Log.Info("c\u006f\u006d\u0070\u006f\u0073\u0069t\u0065\u0052\u006f\u0077\u0043\u006f\u0072\u0072\u0069d\u006f\u0072\u0073:\u0020h\u003d\u0025\u0064", _egee._ggeg)
	}
	for _geee := 1; _geee < _egee._ggeg; _geee++ {
		var _bfae []compositeCell
		for _cgfgde := 0; _cgfgde < _egee._gdab; _cgfgde++ {
			if _dbbfa, _cebf := _egee._bbgacd[_aaega(_cgfgde, _geee)]; _cebf {
				_bfae = append(_bfae, _dbbfa)
			}
		}
		if len(_bfae) == 0 {
			continue
		}
		_adbg := _bdgc(_bfae)
		_gaded[_geee] = _adbg
		if _egdf {
			_eb.Printf("\u0020\u0020\u0020\u0025\u0032\u0064\u003a\u0020\u00256\u002e\u0032\u0066\u000a", _geee, _adbg)
		}
	}
	return _gaded
}
func (_fcb *wordBag) highestWord(_edaa int, _bffeb, _ggde float64) *textWord {
	for _, _abad := range _fcb._agfg[_edaa] {
		if _bffeb <= _abad._gadaf && _abad._gadaf <= _ggde {
			return _abad
		}
	}
	return nil
}
func (_eaacg *wordBag) empty(_eecd int) bool {
	_, _begc := _eaacg._agfg[_eecd]
	return !_begc
}
func _geccc(_ecfc string) bool {
	for _, _efea := range _ecfc {
		if !_e.IsSpace(_efea) {
			return false
		}
	}
	return true
}
func (_begd *structTreeRoot) buildList(_dfgg map[int][]*textLine, _ebecg _fb.PdfObject) []*list {
	if _begd == nil {
		_b.Log.Debug("\u0062\u0075\u0069\u006c\u0064\u004c\u0069\u0073\u0074\u003a\u0020t\u0072\u0065\u0065\u0052\u006f\u006f\u0074\u0020\u0069\u0073 \u006e\u0069\u006c")
		return nil
	}
	var _cgbeb *structElement
	_gbdb := []structElement{}
	if len(_begd._cfag) == 1 {
		_gcfg := _begd._cfag[0]._dfgd
		if _gcfg == "\u0044\u006f\u0063\u0075\u006d\u0065\u006e\u0074" || _gcfg == "\u0053\u0065\u0063\u0074" || _gcfg == "\u0050\u0061\u0072\u0074" || _gcfg == "\u0044\u0069\u0076" || _gcfg == "\u0041\u0072\u0074" {
			_cgbeb = &_begd._cfag[0]
		}
	} else {
		_cgbeb = &structElement{_agcf: _begd._cfag, _dfgd: _begd._cdaf}
	}
	if _cgbeb == nil {
		_b.Log.Debug("\u0062\u0075\u0069\u006cd\u004c\u0069\u0073\u0074\u003a\u0020\u0074\u006f\u0070\u0045l\u0065m\u0065\u006e\u0074\u0020\u0069\u0073\u0020n\u0069\u006c")
		return nil
	}
	for _, _bdac := range _cgbeb._agcf {
		if _bdac._dfgd == "\u004c" {
			_gbdb = append(_gbdb, _bdac)
		} else if _bdac._dfgd == "\u0054\u0061\u0062l\u0065" {
			_acbcf := _ebgga(_bdac)
			_gbdb = append(_gbdb, _acbcf...)
		}
	}
	_eedd := _eegg(_gbdb, _dfgg, _ebecg)
	var _bgdc []*list
	for _, _ggdd := range _eedd {
		_ccdd := _ceea(_ggdd)
		_bgdc = append(_bgdc, _ccdd...)
	}
	return _bgdc
}
func (_addbg paraList) topoOrder() []int {
	if _fcefe {
		_b.Log.Info("\u0074\u006f\u0070\u006f\u004f\u0072\u0064\u0065\u0072\u003a")
	}
	_deef := len(_addbg)
	_fffeb := make([]bool, _deef)
	_abbed := make([]int, 0, _deef)
	_bbad := _addbg.llyOrdering()
	var _gfebc func(_eeaa int)
	_gfebc = func(_fadeb int) {
		_fffeb[_fadeb] = true
		for _gddf := 0; _gddf < _deef; _gddf++ {
			if !_fffeb[_gddf] {
				if _addbg.readBefore(_bbad, _fadeb, _gddf) {
					_gfebc(_gddf)
				}
			}
		}
		_abbed = append(_abbed, _fadeb)
	}
	for _bggeb := 0; _bggeb < _deef; _bggeb++ {
		if !_fffeb[_bggeb] {
			_gfebc(_bggeb)
		}
	}
	return _fcbb(_abbed)
}
func (_ccea *shapesState) establishSubpath() *subpath {
	_efab, _ccda := _ccea.lastpointEstablished()
	if !_ccda {
		_ccea._cgfg = append(_ccea._cgfg, _gea(_efab))
	}
	if len(_ccea._cgfg) == 0 {
		return nil
	}
	_ccea._efa = false
	return _ccea._cgfg[len(_ccea._cgfg)-1]
}
func (_acaf *textLine) bbox() _ba.PdfRectangle { return _acaf.PdfRectangle }
func _cggca(_fgfeb, _bgac _cbc.Point) bool     { return _fgfeb.X == _bgac.X && _fgfeb.Y == _bgac.Y }

// RangeOffset returns the TextMarks in `ma` that overlap text[start:end] in the extracted text.
// These are tm: `start` <= tm.Offset + len(tm.Text) && tm.Offset < `end` where
// `start` and `end` are offsets in the extracted text.
// NOTE: TextMarks can contain multiple characters. e.g. "ffi" for the ﬃ ligature so the first and
// last elements of the returned TextMarkArray may only partially overlap text[start:end].
func (_baad *TextMarkArray) RangeOffset(start, end int) (*TextMarkArray, error) {
	if _baad == nil {
		return nil, _d.New("\u006da\u003d\u003d\u006e\u0069\u006c")
	}
	if end < start {
		return nil, _eb.Errorf("\u0065\u006e\u0064\u0020\u003c\u0020\u0073\u0074\u0061\u0072\u0074\u002e\u0020\u0052\u0061n\u0067\u0065\u004f\u0066\u0066\u0073\u0065\u0074\u0020\u006e\u006f\u0074\u0020d\u0065\u0066\u0069\u006e\u0065\u0064\u002e\u0020\u0073\u0074\u0061\u0072t=\u0025\u0064\u0020\u0065\u006e\u0064\u003d\u0025\u0064\u0020", start, end)
	}
	_gfgb := len(_baad._fcca)
	if _gfgb == 0 {
		return _baad, nil
	}
	if start < _baad._fcca[0].Offset {
		start = _baad._fcca[0].Offset
	}
	if end > _baad._fcca[_gfgb-1].Offset+1 {
		end = _baad._fcca[_gfgb-1].Offset + 1
	}
	_cdecd := _c.Search(_gfgb, func(_dca int) bool { return _baad._fcca[_dca].Offset+len(_baad._fcca[_dca].Text)-1 >= start })
	if !(0 <= _cdecd && _cdecd < _gfgb) {
		_fgd := _eb.Errorf("\u004f\u0075\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u002e\u0020\u0073\u0074\u0061\u0072\u0074\u003d%\u0064\u0020\u0069\u0053\u0074\u0061\u0072\u0074\u003d\u0025\u0064\u0020\u006c\u0065\u006e\u003d\u0025\u0064\u000a\u0009\u0066\u0069\u0072\u0073\u0074\u003d\u0025\u0076\u000a\u0009 \u006c\u0061\u0073\u0074\u003d%\u0076", start, _cdecd, _gfgb, _baad._fcca[0], _baad._fcca[_gfgb-1])
		return nil, _fgd
	}
	_afd := _c.Search(_gfgb, func(_caca int) bool { return _baad._fcca[_caca].Offset > end-1 })
	if !(0 <= _afd && _afd < _gfgb) {
		_befe := _eb.Errorf("\u004f\u0075\u0074\u0020\u006f\u0066\u0020r\u0061\u006e\u0067e\u002e\u0020\u0065n\u0064\u003d%\u0064\u0020\u0069\u0045\u006e\u0064=\u0025d \u006c\u0065\u006e\u003d\u0025\u0064\u000a\u0009\u0066\u0069\u0072\u0073\u0074\u003d\u0025\u0076\u000a\u0009\u0020\u006c\u0061\u0073\u0074\u003d\u0025\u0076", end, _afd, _gfgb, _baad._fcca[0], _baad._fcca[_gfgb-1])
		return nil, _befe
	}
	if _afd <= _cdecd {
		return nil, _eb.Errorf("\u0069\u0045\u006e\u0064\u0020\u003c=\u0020\u0069\u0053\u0074\u0061\u0072\u0074\u003a\u0020\u0073\u0074\u0061\u0072\u0074\u003d\u0025\u0064\u0020\u0065\u006ed\u003d\u0025\u0064\u0020\u0069\u0053\u0074\u0061\u0072\u0074\u003d\u0025\u0064\u0020i\u0045n\u0064\u003d\u0025\u0064", start, end, _cdecd, _afd)
	}
	return &TextMarkArray{_fcca: _baad._fcca[_cdecd:_afd]}, nil
}
func _abfca(_cggbe []TextMark, _eedcb *int) []TextMark {
	_bdgga := _cggbe[len(_cggbe)-1]
	_dafc := []rune(_bdgga.Text)
	if len(_dafc) == 1 {
		_cggbe = _cggbe[:len(_cggbe)-1]
		_fgae := _cggbe[len(_cggbe)-1]
		*_eedcb = _fgae.Offset + len(_fgae.Text)
	} else {
		_defd := _ebfb(_bdgga.Text)
		*_eedcb += len(_defd) - len(_bdgga.Text)
		_bdgga.Text = _defd
	}
	return _cggbe
}
func (_cabf paraList) llyOrdering() []int {
	_cbbca := make([]int, len(_cabf))
	for _ccbc := range _cabf {
		_cbbca[_ccbc] = _ccbc
	}
	_c.SliceStable(_cbbca, func(_ceaca, _ebff int) bool {
		_agfgg, _cebb := _cbbca[_ceaca], _cbbca[_ebff]
		return _cabf[_agfgg].Lly < _cabf[_cebb].Lly
	})
	return _cbbca
}

// ExtractText processes and extracts all text data in content streams and returns as a string.
// It takes into account character encodings in the PDF file, which are decoded by
// CharcodeBytesToUnicode.
// Characters that can't be decoded are replaced with MissingCodeRune ('\ufffd' = �).
func (_acbc *Extractor) ExtractText() (string, error) {
	_cga, _, _, _gdd := _acbc.ExtractTextWithStats()
	return _cga, _gdd
}
func (_dac *imageExtractContext) extractContentStreamImages(_dfb string, _edb *_ba.PdfPageResources) error {
	_bcd := _de.NewContentStreamParser(_dfb)
	_gab, _cge := _bcd.Parse()
	if _cge != nil {
		return _cge
	}
	if _dac._bff == nil {
		_dac._bff = map[*_fb.PdfObjectStream]*cachedImage{}
	}
	if _dac._ggf == nil {
		_dac._ggf = &ImageExtractOptions{}
	}
	_cgd := _de.NewContentStreamProcessor(*_gab)
	_cgd.AddHandler(_de.HandlerConditionEnumAllOperands, "", _dac.processOperand)
	return _cgd.Process(_edb)
}
func _eaacd(_fgbddd string, _agfge int) string {
	if len(_fgbddd) < _agfge {
		return _fgbddd
	}
	return _fgbddd[:_agfge]
}
func (_afaba *textTable) putComposite(_gadd, _gbggd int, _cfcdg paraList, _gcbe _ba.PdfRectangle) {
	if len(_cfcdg) == 0 {
		_b.Log.Error("\u0074\u0065xt\u0054\u0061\u0062l\u0065\u0029\u0020\u0070utC\u006fmp\u006f\u0073\u0069\u0074\u0065\u003a\u0020em\u0070\u0074\u0079\u0020\u0070\u0061\u0072a\u0073")
		return
	}
	_dabbg := compositeCell{PdfRectangle: _gcbe, paraList: _cfcdg}
	if _egdf {
		_eb.Printf("\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0070\u0075\u0074\u0043\u006f\u006d\u0070o\u0073i\u0074\u0065\u0028\u0025\u0064\u002c\u0025\u0064\u0029\u003c\u002d\u0025\u0073\u000a", _gadd, _gbggd, _dabbg.String())
	}
	_dabbg.updateBBox()
	_afaba._bbgacd[_aaega(_gadd, _gbggd)] = _dabbg
}

// String returns a description of `v`.
func (_aaef *ruling) String() string {
	if _aaef._adad == _affd {
		return "\u004e\u004f\u0054\u0020\u0052\u0055\u004c\u0049\u004e\u0047"
	}
	_edac, _fccad := "\u0078", "\u0079"
	if _aaef._adad == _deg {
		_edac, _fccad = "\u0079", "\u0078"
	}
	_baf := ""
	if _aaef._fbcfe != 0.0 {
		_baf = _eb.Sprintf(" \u0077\u0069\u0064\u0074\u0068\u003d\u0025\u002e\u0032\u0066", _aaef._fbcfe)
	}
	return _eb.Sprintf("\u0025\u00310\u0073\u0020\u0025\u0073\u003d\u0025\u0036\u002e\u0032\u0066\u0020\u0025\u0073\u003d\u0025\u0036\u002e\u0032\u0066\u0020\u002d\u0020\u0025\u0036\u002e\u0032\u0066\u0020\u0028\u0025\u0036\u002e\u0032\u0066\u0029\u0020\u0025\u0073\u0020\u0025\u0076\u0025\u0073", _aaef._adad, _edac, _aaef._abfa, _fccad, _aaef._bgbbf, _aaef._dffbe, _aaef._dffbe-_aaef._bgbbf, _aaef._eead, _aaef.Color, _baf)
}
func (_begda paraList) llyRange(_dfdf []int, _ccde, _gege float64) []int {
	_aegf := len(_begda)
	if _gege < _begda[_dfdf[0]].Lly || _ccde > _begda[_dfdf[_aegf-1]].Lly {
		return nil
	}
	_dgbd := _c.Search(_aegf, func(_eafa int) bool { return _begda[_dfdf[_eafa]].Lly >= _ccde })
	_fbab := _c.Search(_aegf, func(_aagcb int) bool { return _begda[_dfdf[_aagcb]].Lly > _gege })
	return _dfdf[_dgbd:_fbab]
}
func _egecab(_egfae []pathSection) {
	if _bcef < 0.0 {
		return
	}
	if _ccc {
		_b.Log.Info("\u0067\u0072\u0061\u006e\u0075\u006c\u0061\u0072\u0069\u007a\u0065\u003a\u0020\u0025\u0064 \u0073u\u0062\u0070\u0061\u0074\u0068\u0020\u0073\u0065\u0063\u0074\u0069\u006f\u006e\u0073", len(_egfae))
	}
	for _dbeee, _fbfe := range _egfae {
		for _edgc, _dggeb := range _fbfe._bbbga {
			for _bdcd, _dcde := range _dggeb._dgfd {
				_dggeb._dgfd[_bdcd] = _cbc.Point{X: _egfec(_dcde.X), Y: _egfec(_dcde.Y)}
				if _ccc {
					_adbbd := _dggeb._dgfd[_bdcd]
					if !_cggca(_dcde, _adbbd) {
						_gcccba := _cbc.Point{X: _adbbd.X - _dcde.X, Y: _adbbd.Y - _dcde.Y}
						_eb.Printf("\u0025\u0034d \u002d\u0020\u00254\u0064\u0020\u002d\u0020%4d\u003a %\u002e\u0032\u0066\u0020\u2192\u0020\u0025.2\u0066\u0020\u0028\u0025\u0067\u0029\u000a", _dbeee, _edgc, _bdcd, _dcde, _adbbd, _gcccba)
					}
				}
			}
		}
	}
}
func (_aeeg *wordBag) pullWord(_afcg *textWord, _fda int, _gfa map[int]map[*textWord]struct{}) {
	_aeeg.PdfRectangle = _eece(_aeeg.PdfRectangle, _afcg.PdfRectangle)
	if _afcg._affe > _aeeg._cdc {
		_aeeg._cdc = _afcg._affe
	}
	_aeeg._agfg[_fda] = append(_aeeg._agfg[_fda], _afcg)
	_gfa[_fda][_afcg] = struct{}{}
}
func _fefb(_eege _ba.PdfRectangle) *ruling {
	return &ruling{_adad: _deg, _abfa: _eege.Ury, _bgbbf: _eege.Llx, _dffbe: _eege.Urx}
}
func (_ebc *textObject) getStrokeColor() _ea.Color {
	return _fbcdf(_ebc._bffd.ColorspaceStroking, _ebc._bffd.ColorStroking)
}
func _aacb(_faeg, _fadbb bounded) float64 {
	_bfcb := _fdb(_faeg, _fadbb)
	if !_gabfc(_bfcb) {
		return _bfcb
	}
	return _cdad(_faeg, _fadbb)
}
