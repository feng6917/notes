//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package model provides an interface for working with high-level objects (models) in PDF files, including
// reading and writing documents.
//
// The document structure of a PDF is constructed of a hierarchy of data models, representing a tree
// of information starting from the Document catalog (Figure 5 p. 80).
// It is based on the core package which handles core functionality such as file i/o, parsing and
// handling of primitive PDF objects (core.PdfObject).
//
// As an example of the interface, the following snippet can read the PDF and output the number of pages:
//
//	f, err := os.Open(inputPath)
//		if err != nil {
//		return nil, err
//	}
//	defer f.Close()
//	pdfReader, err := unipdf.NewPdfReader(f)
//	if err != nil {
//		fmt.Printf("Failed to read PDF file: %v\n", err)
//		os.Exit(1)
//	}
//	numPages, err := pdfReader.GetNumPages()
//	if err != nil {
//		fmt.Printf("Failed to get number of pages: %v\n", err)
//		os.Exit(1)
//	}
//	fmt.Printf("The PDF file has %d pages\n", numPages)
//
// For more examples, see the unidoc-examples repository on GitHub: https://golang/unidoc-examples
package model

import (
	_be "bufio"
	_gg "bytes"
	_d "crypto/md5"
	_af "crypto/rand"
	_c "crypto/sha1"
	_ed "crypto/x509"
	_bf "encoding/binary"
	_ad "encoding/hex"
	_gcd "errors"
	_b "fmt"
	_eg "github.com/unidoc/pkcs7"
	_gd "github.com/unidoc/unitype"
	_fda "golang.org/x/xerrors"
	_fd "lgo/unipdf/common"
	_agf "lgo/unipdf/core"
	_bfb "lgo/unipdf/core/security"
	_cg "lgo/unipdf/core/security/crypt"
	_ce "lgo/unipdf/internal/cmap"
	_ged "lgo/unipdf/internal/imageutil"
	_ede "lgo/unipdf/internal/license"
	_db "lgo/unipdf/internal/sampling"
	_fcg "lgo/unipdf/internal/textencoding"
	_dc "lgo/unipdf/internal/timeutils"
	_fba "lgo/unipdf/internal/transform"
	_bb "lgo/unipdf/model/internal/docutil"
	_aa "lgo/unipdf/model/internal/fonts"
	_ca "lgo/unipdf/model/mdp"
	_aaa "lgo/unipdf/model/sigutil"
	_bd "lgo/unipdf/ps"
	_fc "hash"
	_fe "image"
	_ab "image/color"
	_ "image/gif"
	_ "image/png"
	_cf "io"
	_gbd "io/ioutil"
	_afb "math"
	_dd "math/rand"
	_fb "os"
	_aga "regexp"
	_cb "sort"
	_ge "strconv"
	_gc "strings"
	_a "sync"
	_e "time"
	_gb "unicode"
	_ba "unicode/utf8"
)

// ColorFromPdfObjects returns a new PdfColor based on the input slice of color
// component PDF objects.
func (_aaed *PdfColorspaceICCBased) ColorFromPdfObjects(objects []_agf.PdfObject) (PdfColor, error) {
	if _aaed.Alternate == nil {
		if _aaed.N == 1 {
			_ecdd := NewPdfColorspaceDeviceGray()
			return _ecdd.ColorFromPdfObjects(objects)
		} else if _aaed.N == 3 {
			_bfff := NewPdfColorspaceDeviceRGB()
			return _bfff.ColorFromPdfObjects(objects)
		} else if _aaed.N == 4 {
			_aega := NewPdfColorspaceDeviceCMYK()
			return _aega.ColorFromPdfObjects(objects)
		} else {
			return nil, _gcd.New("I\u0043\u0043\u0020\u0042\u0061\u0073\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063e\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0061lt\u0065\u0072\u006ea\u0074i\u0076\u0065")
		}
	}
	return _aaed.Alternate.ColorFromPdfObjects(objects)
}
func (_eda *PdfColorspaceDeviceCMYK) String() string {
	return "\u0044\u0065\u0076\u0069\u0063\u0065\u0043\u004d\u0059\u004b"
}
func (_bcb *PdfReader) newPdfActionImportDataFromDict(_acef *_agf.PdfObjectDictionary) (*PdfActionImportData, error) {
	_eeca, _gbcf := _bdd(_acef.Get("\u0046"))
	if _gbcf != nil {
		return nil, _gbcf
	}
	return &PdfActionImportData{F: _eeca}, nil
}

// GetAllContentStreams gets all the content streams for a page as one string.
func (_aadee *PdfPage) GetAllContentStreams() (string, error) {
	_gaabg, _dffde := _aadee.GetContentStreams()
	if _dffde != nil {
		return "", _dffde
	}
	return _gc.Join(_gaabg, "\u0020"), nil
}

// GetShadingByName gets the shading specified by keyName. Returns nil if not existing.
// The bool flag indicated whether it was found or not.
func (_abdaa *PdfPageResources) GetShadingByName(keyName _agf.PdfObjectName) (*PdfShading, bool) {
	if _abdaa.Shading == nil {
		return nil, false
	}
	_ccegf, _fdgb := _agf.TraceToDirectObject(_abdaa.Shading).(*_agf.PdfObjectDictionary)
	if !_fdgb {
		_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0053\u0068\u0061d\u0069\u006e\u0067\u0020\u0065\u006e\u0074r\u0079\u0020\u002d\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064i\u0063\u0074\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", _abdaa.Shading)
		return nil, false
	}
	if _eafe := _ccegf.Get(keyName); _eafe != nil {
		_gegd, _acgf := _abbd(_eafe)
		if _acgf != nil {
			_fd.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020f\u0061\u0069l\u0065\u0064\u0020\u0074\u006f\u0020\u006c\u006fa\u0064\u0020\u0070\u0064\u0066\u0020\u0073\u0068\u0061\u0064\u0069\u006eg\u003a\u0020\u0025\u0076", _acgf)
			return nil, false
		}
		return _gegd, true
	}
	return nil, false
}
func (_abbc *PdfColorspaceSpecialPattern) String() string {
	return "\u0050a\u0074\u0074\u0065\u0072\u006e"
}

// PdfOutlineItem represents an outline item dictionary (Table 153 - pp. 376 - 377).
type PdfOutlineItem struct {
	PdfOutlineTreeNode
	Title  *_agf.PdfObjectString
	Parent *PdfOutlineTreeNode
	Prev   *PdfOutlineTreeNode
	Next   *PdfOutlineTreeNode
	Count  *int64
	Dest   _agf.PdfObject
	A      _agf.PdfObject
	SE     _agf.PdfObject
	C      _agf.PdfObject
	F      _agf.PdfObject
	_dbac  *_agf.PdfIndirectObject
}

// ColorFromPdfObjects returns a new PdfColor based on the input slice of color
// components. The slice should contain a single PdfObjectFloat element.
func (_befc *PdfColorspaceSpecialSeparation) ColorFromPdfObjects(objects []_agf.PdfObject) (PdfColor, error) {
	if len(objects) != 1 {
		return nil, _gcd.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_ecgf, _eagg := _agf.GetNumbersAsFloat(objects)
	if _eagg != nil {
		return nil, _eagg
	}
	return _befc.ColorFromFloats(_ecgf)
}

// ColorFromFloats returns a new PdfColor based on the input slice of color
// components. The slice should contain three elements representing the
// red, green and blue components of the color. The values of the elements
// should be between 0 and 1.
func (_gdaab *PdfColorspaceDeviceRGB) ColorFromFloats(vals []float64) (PdfColor, error) {
	if len(vals) != 3 {
		return nil, _gcd.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_eegf := vals[0]
	if _eegf < 0.0 || _eegf > 1.0 {
		_fd.Log.Debug("\u0063\u006f\u006cor\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0043\u0053\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020", _eegf)
		return nil, ErrColorOutOfRange
	}
	_beca := vals[1]
	if _beca < 0.0 || _beca > 1.0 {
		_fd.Log.Debug("\u0063\u006f\u006cor\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0043\u0053\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020", _eegf)
		return nil, ErrColorOutOfRange
	}
	_edecg := vals[2]
	if _edecg < 0.0 || _edecg > 1.0 {
		_fd.Log.Debug("\u0063\u006f\u006cor\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0043\u0053\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020", _eegf)
		return nil, ErrColorOutOfRange
	}
	_fbfad := NewPdfColorDeviceRGB(_eegf, _beca, _edecg)
	return _fbfad, nil
}

// AddWatermarkImage adds a watermark to the page.
func (_gecff *PdfPage) AddWatermarkImage(ximg *XObjectImage, opt WatermarkImageOptions) error {
	_fabc, _bdag := _gecff.GetMediaBox()
	if _bdag != nil {
		return _bdag
	}
	_eaege := _fabc.Urx - _fabc.Llx
	_fefgb := _fabc.Ury - _fabc.Lly
	_faffe := float64(*ximg.Width)
	_agde := (_eaege - _faffe) / 2
	if opt.FitToWidth {
		_faffe = _eaege
		_agde = 0
	}
	_cggae := _fefgb
	_bggde := float64(0)
	if opt.PreserveAspectRatio {
		_cggae = _faffe * float64(*ximg.Height) / float64(*ximg.Width)
		_bggde = (_fefgb - _cggae) / 2
	}
	if _gecff.Resources == nil {
		_gecff.Resources = NewPdfPageResources()
	}
	_eddfa := 0
	_gecgb := _agf.PdfObjectName(_b.Sprintf("\u0049\u006d\u0077%\u0064", _eddfa))
	for _gecff.Resources.HasXObjectByName(_gecgb) {
		_eddfa++
		_gecgb = _agf.PdfObjectName(_b.Sprintf("\u0049\u006d\u0077%\u0064", _eddfa))
	}
	_bdag = _gecff.AddImageResource(_gecgb, ximg)
	if _bdag != nil {
		return _bdag
	}
	_eddfa = 0
	_fdgff := _agf.PdfObjectName(_b.Sprintf("\u0047\u0053\u0025\u0064", _eddfa))
	for _gecff.HasExtGState(_fdgff) {
		_eddfa++
		_fdgff = _agf.PdfObjectName(_b.Sprintf("\u0047\u0053\u0025\u0064", _eddfa))
	}
	_dfdd := _agf.MakeDict()
	_dfdd.Set("\u0042\u004d", _agf.MakeName("\u004e\u006f\u0072\u006d\u0061\u006c"))
	_dfdd.Set("\u0043\u0041", _agf.MakeFloat(opt.Alpha))
	_dfdd.Set("\u0063\u0061", _agf.MakeFloat(opt.Alpha))
	_bdag = _gecff.AddExtGState(_fdgff, _dfdd)
	if _bdag != nil {
		return _bdag
	}
	_afbbg := _b.Sprintf("\u0071\u000a"+"\u002f%\u0073\u0020\u0067\u0073\u000a"+"%\u002e\u0030\u0066\u0020\u0030\u00200\u0020\u0025\u002e\u0030\u0066\u0020\u0025\u002e\u0034f\u0020\u0025\u002e4\u0066 \u0063\u006d\u000a"+"\u002f%\u0073\u0020\u0044\u006f\u000a"+"\u0051", _fdgff, _faffe, _cggae, _agde, _bggde, _gecgb)
	_gecff.AddContentStreamByString(_afbbg)
	return nil
}

// Evaluate runs the function on the passed in slice and returns the results.
func (_ddef *PdfFunctionType0) Evaluate(x []float64) ([]float64, error) {
	if len(x) != _ddef.NumInputs {
		_fd.Log.Error("\u004eu\u006d\u0062e\u0072\u0020\u006f\u0066 \u0069\u006e\u0070u\u0074\u0073\u0020\u006e\u006f\u0074\u0020\u006d\u0061tc\u0068\u0069\u006eg\u0020\u0077h\u0061\u0074\u0020\u0069\u0073\u0020n\u0065\u0065d\u0065\u0064")
		return nil, _gcd.New("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072")
	}
	if _ddef._acefg == nil {
		_cbfad := _ddef.processSamples()
		if _cbfad != nil {
			return nil, _cbfad
		}
	}
	_cfadg := _ddef.Encode
	if _cfadg == nil {
		_cfadg = []float64{}
		for _ddecc := 0; _ddecc < len(_ddef.Size); _ddecc++ {
			_cfadg = append(_cfadg, 0)
			_cfadg = append(_cfadg, float64(_ddef.Size[_ddecc]-1))
		}
	}
	_fffbb := _ddef.Decode
	if _fffbb == nil {
		_fffbb = _ddef.Range
	}
	_afdca := make([]int, len(x))
	for _dccfe := 0; _dccfe < len(x); _dccfe++ {
		_gaabe := x[_dccfe]
		_fbfae := _afb.Min(_afb.Max(_gaabe, _ddef.Domain[2*_dccfe]), _ddef.Domain[2*_dccfe+1])
		_aeag := _ged.LinearInterpolate(_fbfae, _ddef.Domain[2*_dccfe], _ddef.Domain[2*_dccfe+1], _cfadg[2*_dccfe], _cfadg[2*_dccfe+1])
		_dbgac := _afb.Min(_afb.Max(_aeag, 0), float64(_ddef.Size[_dccfe]-1))
		_gfedd := int(_afb.Floor(_dbgac + 0.5))
		if _gfedd < 0 {
			_gfedd = 0
		} else if _gfedd > _ddef.Size[_dccfe] {
			_gfedd = _ddef.Size[_dccfe] - 1
		}
		_afdca[_dccfe] = _gfedd
	}
	_geabf := _afdca[0]
	for _gcffg := 1; _gcffg < _ddef.NumInputs; _gcffg++ {
		_bgce := _afdca[_gcffg]
		for _abced := 0; _abced < _gcffg; _abced++ {
			_bgce *= _ddef.Size[_abced]
		}
		_geabf += _bgce
	}
	_geabf *= _ddef.NumOutputs
	var _bfgfg []float64
	for _eaeff := 0; _eaeff < _ddef.NumOutputs; _eaeff++ {
		_bfafbb := _geabf + _eaeff
		if _bfafbb >= len(_ddef._acefg) {
			_fd.Log.Debug("\u0057\u0041\u0052\u004e\u003a \u006e\u006ft\u0020\u0065\u006eo\u0075\u0067\u0068\u0020\u0069\u006ep\u0075\u0074\u0020sa\u006dp\u006c\u0065\u0073\u0020\u0074\u006f\u0020d\u0065\u0074\u0065\u0072\u006d\u0069\u006e\u0065\u0020\u006f\u0075\u0074\u0070\u0075\u0074\u0020\u0076\u0061lu\u0065\u0073\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u002e")
			continue
		}
		_ffdae := _ddef._acefg[_bfafbb]
		_fffbg := _ged.LinearInterpolate(float64(_ffdae), 0, _afb.Pow(2, float64(_ddef.BitsPerSample)), _fffbb[2*_eaeff], _fffbb[2*_eaeff+1])
		_fggeg := _afb.Min(_afb.Max(_fffbg, _ddef.Range[2*_eaeff]), _ddef.Range[2*_eaeff+1])
		_bfgfg = append(_bfgfg, _fggeg)
	}
	return _bfgfg, nil
}

// GetContext returns the action context which contains the specific type-dependent context.
// The context represents the subaction.
func (_df *PdfAction) GetContext() PdfModel {
	if _df == nil {
		return nil
	}
	return _df._ae
}

// NewPdfColorspaceSpecialSeparation returns a new separation color.
func NewPdfColorspaceSpecialSeparation() *PdfColorspaceSpecialSeparation {
	_eebe := &PdfColorspaceSpecialSeparation{}
	return _eebe
}

const (
	BorderStyleSolid     BorderStyle = iota
	BorderStyleDashed    BorderStyle = iota
	BorderStyleBeveled   BorderStyle = iota
	BorderStyleInset     BorderStyle = iota
	BorderStyleUnderline BorderStyle = iota
)

// NewPdfAnnotationRedact returns a new redact annotation.
func NewPdfAnnotationRedact() *PdfAnnotationRedact {
	_feeg := NewPdfAnnotation()
	_cab := &PdfAnnotationRedact{}
	_cab.PdfAnnotation = _feeg
	_cab.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_feeg.SetContext(_cab)
	return _cab
}

// GetContext returns the context of the outline tree node, which is either a
// *PdfOutline or a *PdfOutlineItem. The method returns nil for uninitialized
// tree nodes.
func (_cbge *PdfOutlineTreeNode) GetContext() PdfModel {
	if _bcefa, _deafbf := _cbge._cgaaa.(*PdfOutline); _deafbf {
		return _bcefa
	}
	if _ebbd, _bgga := _cbge._cgaaa.(*PdfOutlineItem); _bgga {
		return _ebbd
	}
	_fd.Log.Debug("\u0045\u0052RO\u0052\u0020\u0049n\u0076\u0061\u006c\u0069d o\u0075tl\u0069\u006e\u0065\u0020\u0074\u0072\u0065e \u006e\u006f\u0064\u0065\u0020\u0069\u0074e\u006d")
	return nil
}

// NewPdfAnnotationSquare returns a new square annotation.
func NewPdfAnnotationSquare() *PdfAnnotationSquare {
	_aeg := NewPdfAnnotation()
	_bcec := &PdfAnnotationSquare{}
	_bcec.PdfAnnotation = _aeg
	_bcec.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_aeg.SetContext(_bcec)
	return _bcec
}

// GetAsTilingPattern returns a tiling pattern. Check with IsTiling() prior to using this.
func (_gceag *PdfPattern) GetAsTilingPattern() *PdfTilingPattern {
	return _gceag._dfed.(*PdfTilingPattern)
}

// PageCallback callback function used in page loading
// that could be used to modify the page content.
//
// Deprecated: will be removed in v4. Use PageProcessCallback instead.
type PageCallback func(_ddfea int, _eeec *PdfPage)
type pdfFontType0 struct {
	fontCommon
	_dcfcf         *_agf.PdfIndirectObject
	_gccd          _fcg.TextEncoder
	Encoding       _agf.PdfObject
	DescendantFont *PdfFont
	_bgccg         *_ce.CMap
}

// ImageToRGB converts ICCBased colorspace image to RGB and returns the result.
func (_bgbda *PdfColorspaceICCBased) ImageToRGB(img Image) (Image, error) {
	if _bgbda.Alternate == nil {
		_fd.Log.Debug("I\u0043\u0043\u0020\u0042\u0061\u0073\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063e\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0061lt\u0065\u0072\u006ea\u0074i\u0076\u0065")
		if _bgbda.N == 1 {
			_fd.Log.Debug("\u0049\u0043\u0043\u0020\u0042a\u0073\u0065\u0064\u0020\u0063o\u006co\u0072\u0073\u0070\u0061\u0063\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0061\u006c\u0074\u0065r\u006e\u0061\u0074\u0069\u0076\u0065\u0020\u002d\u0020\u0075\u0073\u0069\u006e\u0067\u0020\u0044\u0065\u0076\u0069\u0063\u0065\u0047\u0072\u0061y\u0020\u0028\u004e\u003d\u0031\u0029")
			_bbcb := NewPdfColorspaceDeviceGray()
			return _bbcb.ImageToRGB(img)
		} else if _bgbda.N == 3 {
			_fd.Log.Debug("\u0049\u0043\u0043\u0020\u0042\u0061\u0073\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070a\u0063\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067 \u0061\u006c\u0074\u0065\u0072\u006e\u0061\u0074\u0069\u0076\u0065\u0020\u002d\u0020\u0075\u0073\u0069\u006eg\u0020\u0044\u0065\u0076\u0069\u0063e\u0052\u0047B\u0020\u0028N\u003d3\u0029")
			return img, nil
		} else if _bgbda.N == 4 {
			_fd.Log.Debug("\u0049\u0043\u0043\u0020\u0042a\u0073\u0065\u0064\u0020\u0063o\u006co\u0072\u0073\u0070\u0061\u0063\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0061\u006c\u0074\u0065r\u006e\u0061\u0074\u0069\u0076\u0065\u0020\u002d\u0020\u0075\u0073\u0069\u006e\u0067\u0020\u0044\u0065\u0076\u0069\u0063\u0065\u0043\u004d\u0059K\u0020\u0028\u004e\u003d\u0034\u0029")
			_eaba := NewPdfColorspaceDeviceCMYK()
			return _eaba.ImageToRGB(img)
		} else {
			return img, _gcd.New("I\u0043\u0043\u0020\u0042\u0061\u0073\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063e\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0061lt\u0065\u0072\u006ea\u0074i\u0076\u0065")
		}
	}
	_fd.Log.Trace("\u0049\u0043\u0043 \u0042\u0061\u0073\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063\u0065\u0020\u0077\u0069\u0074\u0068\u0020\u0061\u006c\u0074\u0065\u0072\u006e\u0061t\u0069\u0076\u0065\u003a\u0020\u0025\u0023\u0076", _bgbda)
	_fbee, _deee := _bgbda.Alternate.ImageToRGB(img)
	_fd.Log.Trace("I\u0043C\u0020\u0049\u006e\u0070\u0075\u0074\u0020\u0069m\u0061\u0067\u0065\u003a %\u002b\u0076", img)
	_fd.Log.Trace("I\u0043\u0043\u0020\u004fut\u0070u\u0074\u0020\u0069\u006d\u0061g\u0065\u003a\u0020\u0025\u002b\u0076", _fbee)
	return _fbee, _deee
}

var _ pdfFont = (*pdfFontSimple)(nil)

// GetContainingPdfObject returns the container of the pattern object (indirect object).
func (_dgdca *PdfPattern) GetContainingPdfObject() _agf.PdfObject { return _dgdca._efed }

// GetCharMetrics returns the char metrics for character code `code`.
// How it works:
//  1. It calls the GetCharMetrics function for the underlying font, either a simple font or
//     a Type0 font. The underlying font GetCharMetrics() functions do direct charcode ➞  metrics
//     mappings.
//  2. If the underlying font's GetCharMetrics() doesn't have a CharMetrics for `code` then a
//     a CharMetrics with the FontDescriptor's /MissingWidth is returned.
//  3. If there is no /MissingWidth then a failure is returned.
//
// TODO(peterwilliams97) There is nothing callers can do if no CharMetrics are found so we might as
// well give them 0 width. There is no need for the bool return.
//
// TODO(gunnsth): Reconsider whether needed or if can map via GlyphName.
func (_gfab *PdfFont) GetCharMetrics(code _fcg.CharCode) (CharMetrics, bool) {
	var _bcae _aa.CharMetrics
	switch _gbbg := _gfab._effaa.(type) {
	case *pdfFontSimple:
		if _aafbc, _cfeef := _gbbg.GetCharMetrics(code); _cfeef {
			return _aafbc, _cfeef
		}
	case *pdfFontType0:
		if _gdfga, _gaaa := _gbbg.GetCharMetrics(code); _gaaa {
			return _gdfga, _gaaa
		}
	case *pdfCIDFontType0:
		if _bgege, _efge := _gbbg.GetCharMetrics(code); _efge {
			return _bgege, _efge
		}
	case *pdfCIDFontType2:
		if _bgag, _fbfgg := _gbbg.GetCharMetrics(code); _fbfgg {
			return _bgag, _fbfgg
		}
	case *pdfFontType3:
		if _geff, _cedge := _gbbg.GetCharMetrics(code); _cedge {
			return _geff, _cedge
		}
	default:
		_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020G\u0065\u0074\u0043h\u0061\u0072\u004de\u0074\u0072i\u0063\u0073\u0020\u006e\u006f\u0074 \u0069mp\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0066\u006f\u0072\u0020\u0066\u006f\u006e\u0074\u0020\u0074\u0079\u0070\u0065\u003d\u0025\u0054\u002e", _gfab._effaa)
		return _bcae, false
	}
	if _dggd, _abbf := _gfab.GetFontDescriptor(); _abbf == nil && _dggd != nil {
		return _aa.CharMetrics{Wx: _dggd._dgag}, true
	}
	_fd.Log.Debug("\u0047\u0065\u0074\u0043\u0068\u0061\u0072\u004d\u0065\u0074\u0072\u0069\u0063\u0073\u003a\u0020\u004e\u006f\u0020\u006d\u0065\u0074\u0072\u0069c\u0073\u0020\u0066\u006f\u0072 \u0066\u006fn\u0074\u003d\u0025\u0073", _gfab)
	return _bcae, false
}

// NewPdfAnnotationUnderline returns a new text underline annotation.
func NewPdfAnnotationUnderline() *PdfAnnotationUnderline {
	_adf := NewPdfAnnotation()
	_edb := &PdfAnnotationUnderline{}
	_edb.PdfAnnotation = _adf
	_edb.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_adf.SetContext(_edb)
	return _edb
}
func (_ccba *PdfReader) newPdfAnnotationScreenFromDict(_dag *_agf.PdfObjectDictionary) (*PdfAnnotationScreen, error) {
	_fdac := PdfAnnotationScreen{}
	_fdac.T = _dag.Get("\u0054")
	_fdac.MK = _dag.Get("\u004d\u004b")
	_fdac.A = _dag.Get("\u0041")
	_fdac.AA = _dag.Get("\u0041\u0041")
	return &_fdac, nil
}

// UpdatePage updates the `page` in the new revision if it has changed.
func (_edece *PdfAppender) UpdatePage(page *PdfPage) {
	_edece.updateObjectsDeep(page.ToPdfObject(), nil)
}
func (_bcbf *PdfAppender) addNewObject(_bbad _agf.PdfObject) {
	if _, _eccf := _bcbf._gacd[_bbad]; !_eccf {
		_bcbf._bfbg = append(_bcbf._bfbg, _bbad)
		_bcbf._gacd[_bbad] = struct{}{}
	}
}
func _cdcfg(_eebcb _agf.PdfObject) []*_agf.PdfObjectStream {
	if _eebcb == nil {
		return nil
	}
	_ffeaa, _bbbfcf := _agf.GetArray(_eebcb)
	if !_bbbfcf || _ffeaa.Len() == 0 {
		return nil
	}
	_gggc := make([]*_agf.PdfObjectStream, 0, _ffeaa.Len())
	for _, _egaadd := range _ffeaa.Elements() {
		if _cfgab, _cfdca := _agf.GetStream(_egaadd); _cfdca {
			_gggc = append(_gggc, _cfgab)
		}
	}
	return _gggc
}

// GetContainingPdfObject returns the container of the DSS (indirect object).
func (_dgec *DSS) GetContainingPdfObject() _agf.PdfObject { return _dgec._dgfbc }
func (_aeef *DSS) addCRLs(_ecec [][]byte) ([]*_agf.PdfObjectStream, error) {
	return _aeef.add(&_aeef.CRLs, _aeef._gegg, _ecec)
}

// DecodeArray returns the component range values for the Separation colorspace.
func (_bdbac *PdfColorspaceSpecialSeparation) DecodeArray() []float64 { return []float64{0, 1.0} }

// SetAnnotations sets the annotations list.
func (_effbgb *PdfPage) SetAnnotations(annotations []*PdfAnnotation) { _effbgb._abffa = annotations }

// String returns the name of the colorspace (DeviceN).
func (_dedea *PdfColorspaceDeviceN) String() string { return "\u0044e\u0076\u0069\u0063\u0065\u004e" }
func (_cebf *PdfFunctionType0) processSamples() error {
	_faadf := _db.ResampleBytes(_cebf._aded, _cebf.BitsPerSample)
	_cebf._acefg = _faadf
	return nil
}
func (_gdade *pdfFontType3) baseFields() *fontCommon { return &_gdade.fontCommon }

// NewPdfDate returns a new PdfDate object from a PDF date string (see 7.9.4 Dates).
// format: "D: YYYYMMDDHHmmSSOHH'mm"
func NewPdfDate(dateStr string) (PdfDate, error) {
	_gbdee, _cdgbe := _dc.ParsePdfTime(dateStr)
	if _cdgbe != nil {
		return PdfDate{}, _cdgbe
	}
	return NewPdfDateFromTime(_gbdee)
}

// NewPdfAnnotationPrinterMark returns a new printermark annotation.
func NewPdfAnnotationPrinterMark() *PdfAnnotationPrinterMark {
	_ecb := NewPdfAnnotation()
	_bfec := &PdfAnnotationPrinterMark{}
	_bfec.PdfAnnotation = _ecb
	_ecb.SetContext(_bfec)
	return _bfec
}

type pdfFont interface {
	_aa.Font

	// ToPdfObject returns a PDF representation of the font and implements interface Model.
	ToPdfObject() _agf.PdfObject
	getFontDescriptor() *PdfFontDescriptor
	baseFields() *fontCommon
}

// DecodeArray returns an empty slice as there are no components associated with pattern colorspace.
func (_eceea *PdfColorspaceSpecialPattern) DecodeArray() []float64 { return []float64{} }
func _edeg(_fegad *PdfField) []*PdfField {
	_fffgb := []*PdfField{_fegad}
	for _, _aaff := range _fegad.Kids {
		_fffgb = append(_fffgb, _edeg(_aaff)...)
	}
	return _fffgb
}

// ColorFromPdfObjects returns a new PdfColor based on the input slice of color
// components. The slice should contain three PdfObjectFloat elements representing
// the A, B and C components of the color.
func (_fccd *PdfColorspaceCalRGB) ColorFromPdfObjects(objects []_agf.PdfObject) (PdfColor, error) {
	if len(objects) != 3 {
		return nil, _gcd.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_decb, _dcdg := _agf.GetNumbersAsFloat(objects)
	if _dcdg != nil {
		return nil, _dcdg
	}
	return _fccd.ColorFromFloats(_decb)
}

// ToPdfObject returns the PDF representation of the function.
func (_egfcb *PdfFunctionType0) ToPdfObject() _agf.PdfObject {
	if _egfcb._fbbfe == nil {
		_egfcb._fbbfe = &_agf.PdfObjectStream{}
	}
	_gbfa := _agf.MakeDict()
	_gbfa.Set("\u0046\u0075\u006ec\u0074\u0069\u006f\u006e\u0054\u0079\u0070\u0065", _agf.MakeInteger(0))
	_bcgaf := &_agf.PdfObjectArray{}
	for _, _fdfae := range _egfcb.Domain {
		_bcgaf.Append(_agf.MakeFloat(_fdfae))
	}
	_gbfa.Set("\u0044\u006f\u006d\u0061\u0069\u006e", _bcgaf)
	_eaca := &_agf.PdfObjectArray{}
	for _, _abcda := range _egfcb.Range {
		_eaca.Append(_agf.MakeFloat(_abcda))
	}
	_gbfa.Set("\u0052\u0061\u006eg\u0065", _eaca)
	_ffacg := &_agf.PdfObjectArray{}
	for _, _gcde := range _egfcb.Size {
		_ffacg.Append(_agf.MakeInteger(int64(_gcde)))
	}
	_gbfa.Set("\u0053\u0069\u007a\u0065", _ffacg)
	_gbfa.Set("\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0053\u0061\u006d\u0070\u006c\u0065", _agf.MakeInteger(int64(_egfcb.BitsPerSample)))
	if _egfcb.Order != 1 {
		_gbfa.Set("\u004f\u0072\u0064e\u0072", _agf.MakeInteger(int64(_egfcb.Order)))
	}
	_gbfa.Set("\u004c\u0065\u006e\u0067\u0074\u0068", _agf.MakeInteger(int64(len(_egfcb._aded))))
	_egfcb._fbbfe.Stream = _egfcb._aded
	_egfcb._fbbfe.PdfObjectDictionary = _gbfa
	return _egfcb._fbbfe
}

// NewCompliancePdfReader creates a PdfReader or an input io.ReadSeeker that during reading will scan the files for the
// metadata details. It could be used for the PDF standard implementations like PDF/A or PDF/X.
// NOTE: This implementation is in experimental development state.
//
//	Keep in mind that it might change in the subsequent minor versions.
func NewCompliancePdfReader(rs _cf.ReadSeeker) (*CompliancePdfReader, error) {
	const _feca = "\u006d\u006f\u0064\u0065l\u003a\u004e\u0065\u0077\u0043\u006f\u006d\u0070\u006c\u0069a\u006ec\u0065\u0050\u0064\u0066\u0052\u0065\u0061d\u0065\u0072"
	_becac, _edad := _dcab(rs, &ReaderOpts{ComplianceMode: true}, false, _feca)
	if _edad != nil {
		return nil, _edad
	}
	return &CompliancePdfReader{PdfReader: _becac}, nil
}

type pdfFontType3 struct {
	fontCommon
	_afea *_agf.PdfIndirectObject

	// These fields are specific to Type 3 fonts.
	CharProcs  _agf.PdfObject
	Encoding   _agf.PdfObject
	FontBBox   _agf.PdfObject
	FontMatrix _agf.PdfObject
	FirstChar  _agf.PdfObject
	LastChar   _agf.PdfObject
	Widths     _agf.PdfObject
	Resources  _agf.PdfObject
	_aebef     map[_fcg.CharCode]float64
	_gfffe     _fcg.TextEncoder
}

func (_affaf *PdfReader) newPdfFieldFromIndirectObject(_cgaa *_agf.PdfIndirectObject, _dgb *PdfField) (*PdfField, error) {
	if _dafbg, _gfgdg := _affaf._dcdeb.GetModelFromPrimitive(_cgaa).(*PdfField); _gfgdg {
		return _dafbg, nil
	}
	_fbfga, _cbdg := _agf.GetDict(_cgaa)
	if !_cbdg {
		return nil, _b.Errorf("\u0050\u0064f\u0046\u0069\u0065\u006c\u0064 \u0069\u006e\u0064\u0069\u0072e\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079")
	}
	_agfcc := NewPdfField()
	_agfcc._fcgcc = _cgaa
	_agfcc._fcgcc.PdfObject = _fbfga
	if _egfac, _bcdbf := _agf.GetName(_fbfga.Get("\u0046\u0054")); _bcdbf {
		_agfcc.FT = _egfac
	}
	if _dgb != nil {
		_agfcc.Parent = _dgb
	}
	_agfcc.T, _ = _fbfga.Get("\u0054").(*_agf.PdfObjectString)
	_agfcc.TU, _ = _fbfga.Get("\u0054\u0055").(*_agf.PdfObjectString)
	_agfcc.TM, _ = _fbfga.Get("\u0054\u004d").(*_agf.PdfObjectString)
	_agfcc.Ff, _ = _fbfga.Get("\u0046\u0066").(*_agf.PdfObjectInteger)
	_agfcc.V = _fbfga.Get("\u0056")
	_agfcc.DV = _fbfga.Get("\u0044\u0056")
	_agfcc.AA = _fbfga.Get("\u0041\u0041")
	if DA := _fbfga.Get("\u0044\u0041"); DA != nil {
		DA, _ := _agf.GetString(DA)
		_agfcc.VariableText = &VariableText{DA: DA}
		Q, _ := _fbfga.Get("\u0051").(*_agf.PdfObjectInteger)
		DS, _ := _fbfga.Get("\u0044\u0053").(*_agf.PdfObjectString)
		RV := _fbfga.Get("\u0052\u0056")
		_agfcc.VariableText.Q = Q
		_agfcc.VariableText.DS = DS
		_agfcc.VariableText.RV = RV
	}
	_gbff := _agfcc.FT
	if _gbff == nil && _dgb != nil {
		_gbff = _dgb.FT
	}
	if _gbff != nil {
		switch *_gbff {
		case "\u0054\u0078":
			_efac, _cggc := _fece(_fbfga)
			if _cggc != nil {
				return nil, _cggc
			}
			_efac.PdfField = _agfcc
			_agfcc._eaggd = _efac
		case "\u0043\u0068":
			_dead, _fcac := _gbdgfa(_fbfga)
			if _fcac != nil {
				return nil, _fcac
			}
			_dead.PdfField = _agfcc
			_agfcc._eaggd = _dead
		case "\u0042\u0074\u006e":
			_gddf, _bfafb := _bcba(_fbfga)
			if _bfafb != nil {
				return nil, _bfafb
			}
			_gddf.PdfField = _agfcc
			_agfcc._eaggd = _gddf
		case "\u0053\u0069\u0067":
			_gbage, _aefae := _affaf.newPdfFieldSignatureFromDict(_fbfga)
			if _aefae != nil {
				return nil, _aefae
			}
			_gbage.PdfField = _agfcc
			_agfcc._eaggd = _gbage
		default:
			_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072t\u0065d\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073", *_agfcc.FT)
			return nil, _gcd.New("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074\u0079p\u0065")
		}
	}
	if _fceb, _adea := _agf.GetName(_fbfga.Get("\u0053u\u0062\u0074\u0079\u0070\u0065")); _adea {
		if *_fceb == "\u0057\u0069\u0064\u0067\u0065\u0074" {
			_bfaa, _aafbf := _affaf.newPdfAnnotationFromIndirectObject(_cgaa)
			if _aafbf != nil {
				return nil, _aafbf
			}
			_dcca, _eccae := _bfaa.GetContext().(*PdfAnnotationWidget)
			if !_eccae {
				return nil, _gcd.New("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0077\u0069\u0064\u0067e\u0074 \u0061n\u006e\u006f\u0074\u0061\u0074\u0069\u006fn")
			}
			_dcca._efe = _agfcc
			_dcca.Parent = _agfcc._fcgcc
			_agfcc.Annotations = append(_agfcc.Annotations, _dcca)
			return _agfcc, nil
		}
	}
	_ccgg := true
	if _gcad, _faagaf := _agf.GetArray(_fbfga.Get("\u004b\u0069\u0064\u0073")); _faagaf {
		_bbbg := make([]*_agf.PdfIndirectObject, 0, _gcad.Len())
		for _, _ebbea := range _gcad.Elements() {
			_dacgd, _ccgd := _agf.GetIndirect(_ebbea)
			if !_ccgd {
				_fceec, _cbfeg := _agf.GetStream(_ebbea)
				if _cbfeg && _fceec.PdfObjectDictionary != nil {
					_eefbg, _bfaag := _agf.GetNameVal(_fceec.Get("\u0054\u0079\u0070\u0065"))
					if _bfaag && _eefbg == "\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061" {
						_fd.Log.Debug("E\u0052RO\u0052:\u0020f\u006f\u0072\u006d\u0020\u0066i\u0065\u006c\u0064 \u004b\u0069\u0064\u0073\u0020a\u0072\u0072\u0061y\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0073\u0020\u0069n\u0076\u0061\u006cid \u004d\u0065\u0074\u0061\u0064\u0061t\u0061\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u002e\u0020\u0053\u006bi\u0070p\u0069\u006e\u0067\u002e")
						continue
					}
				}
				return nil, _gcd.New("n\u006f\u0074\u0020\u0061\u006e\u0020i\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0028\u0066\u006f\u0072\u006d\u0020\u0066\u0069\u0065\u006cd\u0029")
			}
			_aedc, _fgde := _agf.GetDict(_dacgd)
			if !_fgde {
				return nil, ErrTypeCheck
			}
			if _ccgg {
				_ccgg = !_gagf(_aedc)
			}
			_bbbg = append(_bbbg, _dacgd)
		}
		for _, _daac := range _bbbg {
			if _ccgg {
				_gbcfe, _dfeb := _affaf.newPdfAnnotationFromIndirectObject(_daac)
				if _dfeb != nil {
					_fd.Log.Debug("\u0045r\u0072\u006fr\u0020\u006c\u006fa\u0064\u0069\u006e\u0067\u0020\u0077\u0069d\u0067\u0065\u0074\u0020\u0061\u006en\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u0020\u0066\u006f\u0072 \u0066\u0069\u0065\u006c\u0064\u003a\u0020\u0025\u0076", _dfeb)
					return nil, _dfeb
				}
				_dfbdef, _dcdbc := _gbcfe._eef.(*PdfAnnotationWidget)
				if !_dcdbc {
					return nil, ErrTypeCheck
				}
				_dfbdef._efe = _agfcc
				_agfcc.Annotations = append(_agfcc.Annotations, _dfbdef)
			} else {
				_cace, _adaf := _affaf.newPdfFieldFromIndirectObject(_daac, _agfcc)
				if _adaf != nil {
					_fd.Log.Debug("\u0045\u0072r\u006f\u0072\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0063\u0068\u0069\u006c\u0064\u0020\u0066\u0069\u0065\u006c\u0064: \u0025\u0076", _adaf)
					return nil, _adaf
				}
				_agfcc.Kids = append(_agfcc.Kids, _cace)
			}
		}
	}
	return _agfcc, nil
}

// PdfColorspaceSpecialIndexed is an indexed color space is a lookup table, where the input element
// is an index to the lookup table and the output is a color defined in the lookup table in the Base
// colorspace.
// [/Indexed base hival lookup]
type PdfColorspaceSpecialIndexed struct {
	Base   PdfColorspace
	HiVal  int
	Lookup _agf.PdfObject
	_ababg []byte
	_fcgd  *_agf.PdfIndirectObject
}

// ToPdfObject implements interface PdfModel.
func (_cfae *PdfAnnotationInk) ToPdfObject() _agf.PdfObject {
	_cfae.PdfAnnotation.ToPdfObject()
	_gdbd := _cfae._aeee
	_gdec := _gdbd.PdfObject.(*_agf.PdfObjectDictionary)
	_cfae.PdfAnnotationMarkup.appendToPdfDictionary(_gdec)
	_gdec.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _agf.MakeName("\u0049\u006e\u006b"))
	_gdec.SetIfNotNil("\u0049n\u006b\u004c\u0069\u0073\u0074", _cfae.InkList)
	_gdec.SetIfNotNil("\u0042\u0053", _cfae.BS)
	return _gdbd
}

// ToPdfObject returns the PDF representation of the function.
func (_fbgea *PdfFunctionType3) ToPdfObject() _agf.PdfObject {
	_efcc := _agf.MakeDict()
	_efcc.Set("\u0046\u0075\u006ec\u0074\u0069\u006f\u006e\u0054\u0079\u0070\u0065", _agf.MakeInteger(3))
	_bffde := &_agf.PdfObjectArray{}
	for _, _gbgbae := range _fbgea.Domain {
		_bffde.Append(_agf.MakeFloat(_gbgbae))
	}
	_efcc.Set("\u0044\u006f\u006d\u0061\u0069\u006e", _bffde)
	if _fbgea.Range != nil {
		_fdeff := &_agf.PdfObjectArray{}
		for _, _dccaf := range _fbgea.Range {
			_fdeff.Append(_agf.MakeFloat(_dccaf))
		}
		_efcc.Set("\u0052\u0061\u006eg\u0065", _fdeff)
	}
	if _fbgea.Functions != nil {
		_fdde := &_agf.PdfObjectArray{}
		for _, _gfabb := range _fbgea.Functions {
			_fdde.Append(_gfabb.ToPdfObject())
		}
		_efcc.Set("\u0046u\u006e\u0063\u0074\u0069\u006f\u006es", _fdde)
	}
	if _fbgea.Bounds != nil {
		_cfgee := &_agf.PdfObjectArray{}
		for _, _bdgfe := range _fbgea.Bounds {
			_cfgee.Append(_agf.MakeFloat(_bdgfe))
		}
		_efcc.Set("\u0042\u006f\u0075\u006e\u0064\u0073", _cfgee)
	}
	if _fbgea.Encode != nil {
		_cbcbd := &_agf.PdfObjectArray{}
		for _, _dcdgd := range _fbgea.Encode {
			_cbcbd.Append(_agf.MakeFloat(_dcdgd))
		}
		_efcc.Set("\u0045\u006e\u0063\u006f\u0064\u0065", _cbcbd)
	}
	if _fbgea._gbgd != nil {
		_fbgea._gbgd.PdfObject = _efcc
		return _fbgea._gbgd
	}
	return _efcc
}

// ToPdfObject returns the button field dictionary within an indirect object.
func (_bdad *PdfFieldButton) ToPdfObject() _agf.PdfObject {
	_bdad.PdfField.ToPdfObject()
	_gbebe := _bdad._fcgcc
	_ggagg := _gbebe.PdfObject.(*_agf.PdfObjectDictionary)
	_ggagg.Set("\u0046\u0054", _agf.MakeName("\u0042\u0074\u006e"))
	if _bdad.Opt != nil {
		_ggagg.Set("\u004f\u0070\u0074", _bdad.Opt)
	}
	return _gbebe
}

// R returns the value of the red component of the color.
func (_gagbe *PdfColorDeviceRGB) R() float64 { return _gagbe[0] }

// ToPdfObject returns the PDF representation of the shading dictionary.
func (_gdbff *PdfShadingType4) ToPdfObject() _agf.PdfObject {
	_gdbff.PdfShading.ToPdfObject()
	_cbaad, _cbcd := _gdbff.getShadingDict()
	if _cbcd != nil {
		_fd.Log.Error("\u0055\u006ea\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0061\u0063\u0063\u0065\u0073\u0073\u0020\u0073\u0068\u0061\u0064\u0069\u006e\u0067\u0020di\u0063\u0074")
		return nil
	}
	if _gdbff.BitsPerCoordinate != nil {
		_cbaad.Set("\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006f\u0072\u0064i\u006e\u0061\u0074\u0065", _gdbff.BitsPerCoordinate)
	}
	if _gdbff.BitsPerComponent != nil {
		_cbaad.Set("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074", _gdbff.BitsPerComponent)
	}
	if _gdbff.BitsPerFlag != nil {
		_cbaad.Set("B\u0069\u0074\u0073\u0050\u0065\u0072\u0046\u006c\u0061\u0067", _gdbff.BitsPerFlag)
	}
	if _gdbff.Decode != nil {
		_cbaad.Set("\u0044\u0065\u0063\u006f\u0064\u0065", _gdbff.Decode)
	}
	if _gdbff.Function != nil {
		if len(_gdbff.Function) == 1 {
			_cbaad.Set("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e", _gdbff.Function[0].ToPdfObject())
		} else {
			_gcef := _agf.MakeArray()
			for _, _bbefd := range _gdbff.Function {
				_gcef.Append(_bbefd.ToPdfObject())
			}
			_cbaad.Set("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e", _gcef)
		}
	}
	return _gdbff._ggbge
}
func _bfgfd(_eega *_agf.PdfObjectDictionary, _dfbc *fontCommon, _gabbc _fcg.TextEncoder) (*pdfFontSimple, error) {
	_ageaa := _cebg(_dfbc)
	_ageaa._eebb = _gabbc
	if _gabbc == nil {
		_eefdf := _eega.Get("\u0046i\u0072\u0073\u0074\u0043\u0068\u0061r")
		if _eefdf == nil {
			_eefdf = _agf.MakeInteger(0)
		}
		_ageaa.FirstChar = _eefdf
		_gdccb, _eegff := _agf.GetIntVal(_eefdf)
		if !_eegff {
			_fd.Log.Debug("\u0045\u0052\u0052OR\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064 \u0046i\u0072s\u0074C\u0068\u0061\u0072\u0020\u0074\u0079\u0070\u0065\u0020\u0028\u0025\u0054\u0029", _eefdf)
			return nil, _agf.ErrTypeError
		}
		_dfgb := _fcg.CharCode(_gdccb)
		_eefdf = _eega.Get("\u004c\u0061\u0073\u0074\u0043\u0068\u0061\u0072")
		if _eefdf == nil {
			_eefdf = _agf.MakeInteger(255)
		}
		_ageaa.LastChar = _eefdf
		_gdccb, _eegff = _agf.GetIntVal(_eefdf)
		if !_eegff {
			_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u004c\u0061\u0073\u0074\u0043h\u0061\u0072\u0020\u0074\u0079\u0070\u0065 \u0028\u0025\u0054\u0029", _eefdf)
			return nil, _agf.ErrTypeError
		}
		_cgda := _fcg.CharCode(_gdccb)
		_ageaa._fcad = make(map[_fcg.CharCode]float64)
		_eefdf = _eega.Get("\u0057\u0069\u0064\u0074\u0068\u0073")
		if _eefdf != nil {
			_ageaa.Widths = _eefdf
			_bebgf, _agdbc := _agf.GetArray(_eefdf)
			if !_agdbc {
				_fd.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020W\u0069\u0064t\u0068\u0073\u0020\u0061\u0074\u0074\u0072\u0069b\u0075\u0074\u0065\u0020\u0021\u003d\u0020\u0061\u0072\u0072\u0061\u0079 \u0028\u0025\u0054\u0029", _eefdf)
				return nil, _agf.ErrTypeError
			}
			_ebcgc, _gdag := _bebgf.ToFloat64Array()
			if _gdag != nil {
				_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0069\u006e\u0067\u0020\u0077\u0069d\u0074\u0068\u0073\u0020\u0074\u006f\u0020a\u0072\u0072\u0061\u0079")
				return nil, _gdag
			}
			if len(_ebcgc) != int(_cgda-_dfgb+1) {
				_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0077\u0069\u0064\u0074\u0068s\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0021\u003d\u0020\u0025\u0064 \u0028\u0025\u0064\u0029", _cgda-_dfgb+1, len(_ebcgc))
				return nil, _agf.ErrRangeError
			}
			for _daafb, _decgf := range _ebcgc {
				_ageaa._fcad[_dfgb+_fcg.CharCode(_daafb)] = _decgf
			}
		}
	}
	_ageaa.Encoding = _agf.TraceToDirectObject(_eega.Get("\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067"))
	return _ageaa, nil
}

// PdfAppender appends new PDF content to an existing PDF document via incremental updates.
type PdfAppender struct {
	_dcac  _cf.ReadSeeker
	_dafc  *_agf.PdfParser
	_gdeb  *PdfReader
	Reader *PdfReader
	_dfaf  []*PdfPage
	_edcb  *PdfAcroForm
	_caae  *DSS
	_cfcg  *Permissions
	_dafg  _agf.XrefTable
	_aede  int64
	_bada  int
	_bfbg  []_agf.PdfObject
	_gacd  map[_agf.PdfObject]struct{}
	_agc   map[_agf.PdfObject]int64
	_abca  map[_agf.PdfObject]struct{}
	_eadd  map[_agf.PdfObject]struct{}
	_cdf   int64
	_ffae  bool
	_ccdg  string
	_eeee  *EncryptOptions
	_bgeg  *PdfInfo
}

// PdfAnnotationWidget represents Widget annotations.
// Note: Widget annotations are used to display form fields.
// (Section 12.5.6.19).
type PdfAnnotationWidget struct {
	*PdfAnnotation
	H      _agf.PdfObject
	MK     _agf.PdfObject
	A      _agf.PdfObject
	AA     _agf.PdfObject
	BS     _agf.PdfObject
	Parent _agf.PdfObject
	_efe   *PdfField
	_ggg   bool
}

func (_gfcc *PdfReader) newPdfSignatureReferenceFromDict(_adeb *_agf.PdfObjectDictionary) (*PdfSignatureReference, error) {
	if _gabge, _adgfd := _gfcc._dcdeb.GetModelFromPrimitive(_adeb).(*PdfSignatureReference); _adgfd {
		return _gabge, nil
	}
	_geafg := &PdfSignatureReference{_feaaf: _adeb, Data: _adeb.Get("\u0044\u0061\u0074\u0061")}
	var _adag bool
	_geafg.Type, _ = _agf.GetName(_adeb.Get("\u0054\u0079\u0070\u0065"))
	_geafg.TransformMethod, _adag = _agf.GetName(_adeb.Get("\u0054r\u0061n\u0073\u0066\u006f\u0072\u006d\u004d\u0065\u0074\u0068\u006f\u0064"))
	if !_adag {
		_fd.Log.Error("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0053\u0069g\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0052\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0054\u0072\u0061\u006e\u0073\u0066o\u0072\u006dM\u0065\u0074h\u006f\u0064\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020in\u0076\u0061\u006c\u0069\u0064\u0020\u006f\u0072\u0020m\u0069\u0073\u0073\u0069\u006e\u0067")
		return nil, ErrInvalidAttribute
	}
	_geafg.TransformParams, _ = _agf.GetDict(_adeb.Get("\u0054r\u0061n\u0073\u0066\u006f\u0072\u006d\u0050\u0061\u0072\u0061\u006d\u0073"))
	_geafg.DigestMethod, _ = _agf.GetName(_adeb.Get("\u0044\u0069\u0067e\u0073\u0074\u004d\u0065\u0074\u0068\u006f\u0064"))
	return _geafg, nil
}

// NewStandard14FontWithEncoding returns the standard 14 font named `basefont` as a *PdfFont and
// a TextEncoder that encodes all the runes in `alphabet`, or an error if this is not possible.
// An error can occur if `basefont` is not one the standard 14 font names.
func NewStandard14FontWithEncoding(basefont StdFontName, alphabet map[rune]int) (*PdfFont, _fcg.SimpleEncoder, error) {
	_cdde, _egaefa := _egag(basefont)
	if _egaefa != nil {
		return nil, nil, _egaefa
	}
	_bbcf, _eabb := _cdde.Encoder().(_fcg.SimpleEncoder)
	if !_eabb {
		return nil, nil, _b.Errorf("\u006f\u006e\u006c\u0079\u0020s\u0069\u006d\u0070\u006c\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006eg\u0020\u0069\u0073\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u002c\u0020\u0067\u006f\u0074\u0020\u0025\u0054", _cdde.Encoder())
	}
	_afef := make(map[rune]_fcg.GlyphName)
	for _ffbc := range alphabet {
		if _, _fdeg := _bbcf.RuneToCharcode(_ffbc); !_fdeg {
			_, _fceef := _cdde._fbgbg.Read(_ffbc)
			if !_fceef {
				_fd.Log.Trace("r\u0075\u006e\u0065\u0020\u0025\u0023x\u003d\u0025\u0071\u0020\u006e\u006f\u0074\u0020\u0069n\u0020\u0074\u0068e\u0020f\u006f\u006e\u0074", _ffbc, _ffbc)
				continue
			}
			_edbc, _fceef := _fcg.RuneToGlyph(_ffbc)
			if !_fceef {
				_fd.Log.Debug("\u006eo\u0020\u0067\u006c\u0079\u0070\u0068\u0020\u0066\u006f\u0072\u0020r\u0075\u006e\u0065\u0020\u0025\u0023\u0078\u003d\u0025\u0071", _ffbc, _ffbc)
				continue
			}
			if len(_afef) >= 255 {
				return nil, nil, _gcd.New("\u0074\u006f\u006f\u0020\u006d\u0061\u006e\u0079\u0020\u0063\u0068\u0061\u0072a\u0063\u0074\u0065\u0072\u0073\u0020f\u006f\u0072\u0020\u0073\u0069\u006d\u0070\u006c\u0065\u0020\u0065\u006e\u0063o\u0064\u0069\u006e\u0067")
			}
			_afef[_ffbc] = _edbc
		}
	}
	var (
		_effbe []_fcg.CharCode
		_bfad  []_fcg.CharCode
	)
	for _gagfc := _fcg.CharCode(1); _gagfc <= 0xff; _gagfc++ {
		_bcabf, _ceaf := _bbcf.CharcodeToRune(_gagfc)
		if !_ceaf {
			_effbe = append(_effbe, _gagfc)
			continue
		}
		if _, _ceaf = alphabet[_bcabf]; !_ceaf {
			_bfad = append(_bfad, _gagfc)
		}
	}
	_gcfbb := append(_effbe, _bfad...)
	if len(_gcfbb) < len(_afef) {
		return nil, nil, _b.Errorf("n\u0065\u0065\u0064\u0020\u0074\u006f\u0020\u0065\u006ec\u006f\u0064\u0065\u0020\u0025\u0064\u0020ru\u006e\u0065\u0073\u002c \u0062\u0075\u0074\u0020\u0068\u0061\u0076\u0065\u0020on\u006c\u0079 \u0025\u0064\u0020\u0073\u006c\u006f\u0074\u0073", len(_afef), len(_gcfbb))
	}
	_fbbd := make([]rune, 0, len(_afef))
	for _bgcb := range _afef {
		_fbbd = append(_fbbd, _bgcb)
	}
	_cb.Slice(_fbbd, func(_cedcc, _cfaea int) bool { return _fbbd[_cedcc] < _fbbd[_cfaea] })
	_geda := make(map[_fcg.CharCode]_fcg.GlyphName, len(_fbbd))
	for _, _dbfb := range _fbbd {
		_cbecb := _gcfbb[0]
		_gcfbb = _gcfbb[1:]
		_geda[_cbecb] = _afef[_dbfb]
	}
	_bbcf = _fcg.ApplyDifferences(_bbcf, _geda)
	_cdde.SetEncoder(_bbcf)
	return &PdfFont{_effaa: &_cdde}, _bbcf, nil
}

// SetOCProperties sets the optional content properties.
func (_gfbef *PdfWriter) SetOCProperties(ocProperties _agf.PdfObject) error {
	_ddbdea := _gfbef._bagbb
	if ocProperties != nil {
		_fd.Log.Trace("\u0053e\u0074\u0074\u0069\u006e\u0067\u0020\u004f\u0043\u0020\u0050\u0072o\u0070\u0065\u0072\u0074\u0069\u0065\u0073\u002e\u002e\u002e")
		_ddbdea.Set("\u004f\u0043\u0050r\u006f\u0070\u0065\u0072\u0074\u0069\u0065\u0073", ocProperties)
		return _gfbef.addObjects(ocProperties)
	}
	return nil
}

// PdfAnnotationInk represents Ink annotations.
// (Section 12.5.6.13).
type PdfAnnotationInk struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	InkList _agf.PdfObject
	BS      _agf.PdfObject
}

// ToPdfObject implements interface PdfModel.
// Note: Call the sub-annotation's ToPdfObject to set both the generic and non-generic information.
func (_add *PdfAnnotation) ToPdfObject() _agf.PdfObject {
	_ggff := _add._aeee
	_adcaf := _ggff.PdfObject.(*_agf.PdfObjectDictionary)
	_adcaf.Clear()
	_adcaf.Set("\u0054\u0079\u0070\u0065", _agf.MakeName("\u0041\u006e\u006eo\u0074"))
	_adcaf.SetIfNotNil("\u0052\u0065\u0063\u0074", _add.Rect)
	_adcaf.SetIfNotNil("\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073", _add.Contents)
	_adcaf.SetIfNotNil("\u0050", _add.P)
	_adcaf.SetIfNotNil("\u004e\u004d", _add.NM)
	_adcaf.SetIfNotNil("\u004d", _add.M)
	_adcaf.SetIfNotNil("\u0046", _add.F)
	_adcaf.SetIfNotNil("\u0041\u0050", _add.AP)
	_adcaf.SetIfNotNil("\u0041\u0053", _add.AS)
	_adcaf.SetIfNotNil("\u0042\u006f\u0072\u0064\u0065\u0072", _add.Border)
	_adcaf.SetIfNotNil("\u0043", _add.C)
	_adcaf.SetIfNotNil("\u0053\u0074\u0072u\u0063\u0074\u0050\u0061\u0072\u0065\u006e\u0074", _add.StructParent)
	_adcaf.SetIfNotNil("\u004f\u0043", _add.OC)
	return _ggff
}
func _fece(_badf *_agf.PdfObjectDictionary) (*PdfFieldText, error) {
	_bede := &PdfFieldText{}
	_bede.DA, _ = _agf.GetString(_badf.Get("\u0044\u0041"))
	_bede.Q, _ = _agf.GetInt(_badf.Get("\u0051"))
	_bede.DS, _ = _agf.GetString(_badf.Get("\u0044\u0053"))
	_bede.RV = _badf.Get("\u0052\u0056")
	_bede.MaxLen, _ = _agf.GetInt(_badf.Get("\u004d\u0061\u0078\u004c\u0065\u006e"))
	return _bede, nil
}

// ToPdfObject implements interface PdfModel.
func (_aebg *PdfAnnotationLine) ToPdfObject() _agf.PdfObject {
	_aebg.PdfAnnotation.ToPdfObject()
	_fadb := _aebg._aeee
	_ffcd := _fadb.PdfObject.(*_agf.PdfObjectDictionary)
	_aebg.PdfAnnotationMarkup.appendToPdfDictionary(_ffcd)
	_ffcd.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _agf.MakeName("\u004c\u0069\u006e\u0065"))
	_ffcd.SetIfNotNil("\u004c", _aebg.L)
	_ffcd.SetIfNotNil("\u0042\u0053", _aebg.BS)
	_ffcd.SetIfNotNil("\u004c\u0045", _aebg.LE)
	_ffcd.SetIfNotNil("\u0049\u0043", _aebg.IC)
	_ffcd.SetIfNotNil("\u004c\u004c", _aebg.LL)
	_ffcd.SetIfNotNil("\u004c\u004c\u0045", _aebg.LLE)
	_ffcd.SetIfNotNil("\u0043\u0061\u0070", _aebg.Cap)
	_ffcd.SetIfNotNil("\u0049\u0054", _aebg.IT)
	_ffcd.SetIfNotNil("\u004c\u004c\u004f", _aebg.LLO)
	_ffcd.SetIfNotNil("\u0043\u0050", _aebg.CP)
	_ffcd.SetIfNotNil("\u004de\u0061\u0073\u0075\u0072\u0065", _aebg.Measure)
	_ffcd.SetIfNotNil("\u0043\u004f", _aebg.CO)
	return _fadb
}

// ToPdfObject implements interface PdfModel.
func (_feg *PdfActionURI) ToPdfObject() _agf.PdfObject {
	_feg.PdfAction.ToPdfObject()
	_gcdb := _feg._caf
	_ggf := _gcdb.PdfObject.(*_agf.PdfObjectDictionary)
	_ggf.SetIfNotNil("\u0053", _agf.MakeName(string(ActionTypeURI)))
	_ggf.SetIfNotNil("\u0055\u0052\u0049", _feg.URI)
	_ggf.SetIfNotNil("\u0049\u0073\u004da\u0070", _feg.IsMap)
	return _gcdb
}

// ToPdfObject returns the choice field dictionary within an indirect object (container).
func (_bggb *PdfFieldChoice) ToPdfObject() _agf.PdfObject {
	_bggb.PdfField.ToPdfObject()
	_eceg := _bggb._fcgcc
	_badd := _eceg.PdfObject.(*_agf.PdfObjectDictionary)
	_badd.Set("\u0046\u0054", _agf.MakeName("\u0043\u0068"))
	if _bggb.Opt != nil {
		_badd.Set("\u004f\u0070\u0074", _bggb.Opt)
	}
	if _bggb.TI != nil {
		_badd.Set("\u0054\u0049", _bggb.TI)
	}
	if _bggb.I != nil {
		_badd.Set("\u0049", _bggb.I)
	}
	return _eceg
}
func _bcaed(_fbdg _agf.PdfObject) (*PdfFunctionType3, error) {
	_cgbb := &PdfFunctionType3{}
	var _dgcf *_agf.PdfObjectDictionary
	if _dccag, _febaf := _fbdg.(*_agf.PdfIndirectObject); _febaf {
		_aggae, _adge := _dccag.PdfObject.(*_agf.PdfObjectDictionary)
		if !_adge {
			return nil, _gcd.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
		}
		_cgbb._gbgd = _dccag
		_dgcf = _aggae
	} else if _fbdb, _caaac := _fbdg.(*_agf.PdfObjectDictionary); _caaac {
		_dgcf = _fbdb
	} else {
		return nil, _gcd.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	_bbcd, _ffdb := _agf.TraceToDirectObject(_dgcf.Get("\u0044\u006f\u006d\u0061\u0069\u006e")).(*_agf.PdfObjectArray)
	if !_ffdb {
		_fd.Log.Error("D\u006fm\u0061\u0069\u006e\u0020\u006e\u006f\u0074\u0020s\u0070\u0065\u0063\u0069fi\u0065\u0064")
		return nil, _gcd.New("\u0072\u0065q\u0075\u0069\u0072\u0065d\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020m\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u006f\u0072\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
	}
	if _bbcd.Len() != 2 {
		_fd.Log.Error("\u0044\u006f\u006d\u0061\u0069\u006e\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
		return nil, _gcd.New("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0064\u006f\u006da\u0069\u006e\u0020\u0072an\u0067\u0065")
	}
	_aedf, _acegd := _bbcd.ToFloat64Array()
	if _acegd != nil {
		return nil, _acegd
	}
	_cgbb.Domain = _aedf
	_bbcd, _ffdb = _agf.TraceToDirectObject(_dgcf.Get("\u0052\u0061\u006eg\u0065")).(*_agf.PdfObjectArray)
	if _ffdb {
		if _bbcd.Len() < 0 || _bbcd.Len()%2 != 0 {
			return nil, _gcd.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u0061\u006e\u0067\u0065")
		}
		_aabfg, _cabdf := _bbcd.ToFloat64Array()
		if _cabdf != nil {
			return nil, _cabdf
		}
		_cgbb.Range = _aabfg
	}
	_bbcd, _ffdb = _agf.TraceToDirectObject(_dgcf.Get("\u0046u\u006e\u0063\u0074\u0069\u006f\u006es")).(*_agf.PdfObjectArray)
	if !_ffdb {
		_fd.Log.Error("\u0046\u0075\u006ect\u0069\u006f\u006e\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064")
		return nil, _gcd.New("\u0072\u0065q\u0075\u0069\u0072\u0065d\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020m\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u006f\u0072\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
	}
	_cgbb.Functions = []PdfFunction{}
	for _, _dcbda := range _bbcd.Elements() {
		_fdgdf, _fgfg := _ccedb(_dcbda)
		if _fgfg != nil {
			return nil, _fgfg
		}
		_cgbb.Functions = append(_cgbb.Functions, _fdgdf)
	}
	_bbcd, _ffdb = _agf.TraceToDirectObject(_dgcf.Get("\u0042\u006f\u0075\u006e\u0064\u0073")).(*_agf.PdfObjectArray)
	if !_ffdb {
		_fd.Log.Error("B\u006fu\u006e\u0064\u0073\u0020\u006e\u006f\u0074\u0020s\u0070\u0065\u0063\u0069fi\u0065\u0064")
		return nil, _gcd.New("\u0072\u0065q\u0075\u0069\u0072\u0065d\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020m\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u006f\u0072\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
	}
	_dedf, _acegd := _bbcd.ToFloat64Array()
	if _acegd != nil {
		return nil, _acegd
	}
	_cgbb.Bounds = _dedf
	if len(_cgbb.Bounds) != len(_cgbb.Functions)-1 {
		_fd.Log.Error("B\u006f\u0075\u006e\u0064\u0073\u0020\u0028\u0025\u0064)\u0020\u0061\u006e\u0064\u0020\u006e\u0075m \u0066\u0075\u006e\u0063t\u0069\u006f\u006e\u0073\u0020\u0028\u0025\u0064\u0029 n\u006f\u0074 \u006d\u0061\u0074\u0063\u0068\u0069\u006e\u0067", len(_cgbb.Bounds), len(_cgbb.Functions))
		return nil, _gcd.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_bbcd, _ffdb = _agf.TraceToDirectObject(_dgcf.Get("\u0045\u006e\u0063\u006f\u0064\u0065")).(*_agf.PdfObjectArray)
	if !_ffdb {
		_fd.Log.Error("E\u006ec\u006f\u0064\u0065\u0020\u006e\u006f\u0074\u0020s\u0070\u0065\u0063\u0069fi\u0065\u0064")
		return nil, _gcd.New("\u0072\u0065q\u0075\u0069\u0072\u0065d\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020m\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u006f\u0072\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
	}
	_baag, _acegd := _bbcd.ToFloat64Array()
	if _acegd != nil {
		return nil, _acegd
	}
	_cgbb.Encode = _baag
	if len(_cgbb.Encode) != 2*len(_cgbb.Functions) {
		_fd.Log.Error("\u004c\u0065\u006e\u0020\u0065\u006e\u0063\u006f\u0064\u0065\u0020\u0028\u0025\u0064\u0029 \u0061\u006e\u0064\u0020\u006e\u0075\u006d\u0020\u0066\u0075\u006e\u0063\u0074i\u006f\u006e\u0073\u0020\u0028\u0025\u0064\u0029\u0020\u006e\u006f\u0074 m\u0061\u0074\u0063\u0068\u0069\u006e\u0067\u0020\u0075\u0070", len(_cgbb.Encode), len(_cgbb.Functions))
		return nil, _gcd.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	return _cgbb, nil
}
func _edfg(_edaf _agf.PdfObject) (*PdfColorspaceCalRGB, error) {
	_bddb := NewPdfColorspaceCalRGB()
	if _dcad, _cbga := _edaf.(*_agf.PdfIndirectObject); _cbga {
		_bddb._febbc = _dcad
	}
	_edaf = _agf.TraceToDirectObject(_edaf)
	_ccbfb, _cbfc := _edaf.(*_agf.PdfObjectArray)
	if !_cbfc {
		return nil, _b.Errorf("\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	if _ccbfb.Len() != 2 {
		return nil, _b.Errorf("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0043\u0061\u006c\u0052G\u0042 \u0063o\u006c\u006f\u0072\u0073\u0070\u0061\u0063e")
	}
	_edaf = _agf.TraceToDirectObject(_ccbfb.Get(0))
	_dacf, _cbfc := _edaf.(*_agf.PdfObjectName)
	if !_cbfc {
		return nil, _b.Errorf("\u0043\u0061l\u0052\u0047\u0042\u0020\u006e\u0061\u006d\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006f\u0062je\u0063\u0074")
	}
	if *_dacf != "\u0043\u0061\u006c\u0052\u0047\u0042" {
		return nil, _b.Errorf("\u006e\u006f\u0074 a\u0020\u0043\u0061\u006c\u0052\u0047\u0042\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063\u0065")
	}
	_edaf = _agf.TraceToDirectObject(_ccbfb.Get(1))
	_fcec, _cbfc := _edaf.(*_agf.PdfObjectDictionary)
	if !_cbfc {
		return nil, _b.Errorf("\u0043\u0061l\u0052\u0047\u0042\u0020\u006e\u0061\u006d\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006f\u0062je\u0063\u0074")
	}
	_edaf = _fcec.Get("\u0057\u0068\u0069\u0074\u0065\u0050\u006f\u0069\u006e\u0074")
	_edaf = _agf.TraceToDirectObject(_edaf)
	_ccea, _cbfc := _edaf.(*_agf.PdfObjectArray)
	if !_cbfc {
		return nil, _b.Errorf("\u0043\u0061\u006c\u0052\u0047\u0042\u003a\u0020\u0049\u006e\u0076a\u006c\u0069\u0064\u0020\u0057\u0068\u0069\u0074\u0065\u0050o\u0069\u006e\u0074")
	}
	if _ccea.Len() != 3 {
		return nil, _b.Errorf("\u0043\u0061\u006c\u0052\u0047\u0042\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064 \u0057h\u0069\u0074\u0065\u0050\u006f\u0069\u006e\u0074\u0020\u0061\u0072\u0072\u0061\u0079")
	}
	_aebaa, _cdecg := _ccea.GetAsFloat64Slice()
	if _cdecg != nil {
		return nil, _cdecg
	}
	_bddb.WhitePoint = _aebaa
	_edaf = _fcec.Get("\u0042\u006c\u0061\u0063\u006b\u0050\u006f\u0069\u006e\u0074")
	if _edaf != nil {
		_edaf = _agf.TraceToDirectObject(_edaf)
		_aafa, _cdafc := _edaf.(*_agf.PdfObjectArray)
		if !_cdafc {
			return nil, _b.Errorf("\u0043\u0061\u006c\u0052\u0047\u0042\u003a\u0020\u0049\u006e\u0076a\u006c\u0069\u0064\u0020\u0042\u006c\u0061\u0063\u006b\u0050o\u0069\u006e\u0074")
		}
		if _aafa.Len() != 3 {
			return nil, _b.Errorf("\u0043\u0061\u006c\u0052\u0047\u0042\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064 \u0042l\u0061\u0063\u006b\u0050\u006f\u0069\u006e\u0074\u0020\u0061\u0072\u0072\u0061\u0079")
		}
		_adgc, _abab := _aafa.GetAsFloat64Slice()
		if _abab != nil {
			return nil, _abab
		}
		_bddb.BlackPoint = _adgc
	}
	_edaf = _fcec.Get("\u0047\u0061\u006dm\u0061")
	if _edaf != nil {
		_edaf = _agf.TraceToDirectObject(_edaf)
		_cfaa, _bcdfg := _edaf.(*_agf.PdfObjectArray)
		if !_bcdfg {
			return nil, _b.Errorf("C\u0061\u006c\u0052\u0047B:\u0020I\u006e\u0076\u0061\u006c\u0069d\u0020\u0047\u0061\u006d\u006d\u0061")
		}
		if _cfaa.Len() != 3 {
			return nil, _b.Errorf("C\u0061\u006c\u0052\u0047\u0042\u003a \u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0047a\u006d\u006d\u0061 \u0061r\u0072\u0061\u0079")
		}
		_effbg, _ebfg := _cfaa.GetAsFloat64Slice()
		if _ebfg != nil {
			return nil, _ebfg
		}
		_bddb.Gamma = _effbg
	}
	_edaf = _fcec.Get("\u004d\u0061\u0074\u0072\u0069\u0078")
	if _edaf != nil {
		_edaf = _agf.TraceToDirectObject(_edaf)
		_ggfdg, _acbbb := _edaf.(*_agf.PdfObjectArray)
		if !_acbbb {
			return nil, _b.Errorf("\u0043\u0061\u006c\u0052GB\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u004d\u0061\u0074\u0072i\u0078")
		}
		if _ggfdg.Len() != 9 {
			_fd.Log.Error("\u004d\u0061t\u0072\u0069\u0078 \u0061\u0072\u0072\u0061\u0079\u003a\u0020\u0025\u0073", _ggfdg.String())
			return nil, _b.Errorf("\u0043\u0061\u006c\u0052G\u0042\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064 \u004da\u0074\u0072\u0069\u0078\u0020\u0061\u0072r\u0061\u0079")
		}
		_bcbd, _fbffc := _ggfdg.GetAsFloat64Slice()
		if _fbffc != nil {
			return nil, _fbffc
		}
		_bddb.Matrix = _bcbd
	}
	return _bddb, nil
}

// NewOutlineItem returns a new outline item instance.
func NewOutlineItem(title string, dest OutlineDest) *OutlineItem {
	return &OutlineItem{Title: title, Dest: dest}
}

// NewPdfField returns an initialized PdfField.
func NewPdfField() *PdfField { return &PdfField{_fcgcc: _agf.MakeIndirectObject(_agf.MakeDict())} }

// ColorToRGB converts a ICCBased color to an RGB color.
func (_ecad *PdfColorspaceICCBased) ColorToRGB(color PdfColor) (PdfColor, error) {
	if _ecad.Alternate == nil {
		_fd.Log.Debug("I\u0043\u0043\u0020\u0042\u0061\u0073\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063e\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0061lt\u0065\u0072\u006ea\u0074i\u0076\u0065")
		if _ecad.N == 1 {
			_fd.Log.Debug("\u0049\u0043\u0043\u0020\u0042a\u0073\u0065\u0064\u0020\u0063o\u006co\u0072\u0073\u0070\u0061\u0063\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0061\u006c\u0074\u0065r\u006e\u0061\u0074\u0069\u0076\u0065\u0020\u002d\u0020\u0075\u0073\u0069\u006e\u0067\u0020\u0044\u0065\u0076\u0069\u0063\u0065\u0047\u0072\u0061y\u0020\u0028\u004e\u003d\u0031\u0029")
			_ccbgd := NewPdfColorspaceDeviceGray()
			return _ccbgd.ColorToRGB(color)
		} else if _ecad.N == 3 {
			_fd.Log.Debug("\u0049\u0043\u0043\u0020\u0042\u0061\u0073\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070a\u0063\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067 \u0061\u006c\u0074\u0065\u0072\u006e\u0061\u0074\u0069\u0076\u0065\u0020\u002d\u0020\u0075\u0073\u0069\u006eg\u0020\u0044\u0065\u0076\u0069\u0063e\u0052\u0047B\u0020\u0028N\u003d3\u0029")
			return color, nil
		} else if _ecad.N == 4 {
			_fd.Log.Debug("\u0049\u0043\u0043\u0020\u0042a\u0073\u0065\u0064\u0020\u0063o\u006co\u0072\u0073\u0070\u0061\u0063\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0061\u006c\u0074\u0065r\u006e\u0061\u0074\u0069\u0076\u0065\u0020\u002d\u0020\u0075\u0073\u0069\u006e\u0067\u0020\u0044\u0065\u0076\u0069\u0063\u0065\u0043\u004d\u0059K\u0020\u0028\u004e\u003d\u0034\u0029")
			_cefe := NewPdfColorspaceDeviceCMYK()
			return _cefe.ColorToRGB(color)
		} else {
			return nil, _gcd.New("I\u0043\u0043\u0020\u0042\u0061\u0073\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063e\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0061lt\u0065\u0072\u006ea\u0074i\u0076\u0065")
		}
	}
	_fd.Log.Trace("\u0049\u0043\u0043 \u0042\u0061\u0073\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063\u0065\u0020\u0077\u0069\u0074\u0068\u0020\u0061\u006c\u0074\u0065\u0072\u006e\u0061t\u0069\u0076\u0065\u003a\u0020\u0025\u0023\u0076", _ecad)
	return _ecad.Alternate.ColorToRGB(color)
}

// PdfActionThread represents a thread action.
type PdfActionThread struct {
	*PdfAction
	F *PdfFilespec
	D _agf.PdfObject
	B _agf.PdfObject
}

func (_aagg *PdfReader) newPdfActionResetFormFromDict(_ddf *_agf.PdfObjectDictionary) (*PdfActionResetForm, error) {
	return &PdfActionResetForm{Fields: _ddf.Get("\u0046\u0069\u0065\u006c\u0064\u0073"), Flags: _ddf.Get("\u0046\u006c\u0061g\u0073")}, nil
}

// DefaultImageHandler is the default implementation of the ImageHandler using the standard go library.
type DefaultImageHandler struct{}

func (_deed *PdfAppender) replaceObject(_bfgb, _cdaga _agf.PdfObject) {
	switch _gfff := _bfgb.(type) {
	case *_agf.PdfIndirectObject:
		_deed._agc[_cdaga] = _gfff.ObjectNumber
	case *_agf.PdfObjectStream:
		_deed._agc[_cdaga] = _gfff.ObjectNumber
	}
}

// DSS represents a Document Security Store dictionary.
// The DSS dictionary contains both global and signature specific validation
// information. The certificates and revocation data in the `Certs`, `OCSPs`,
// and `CRLs` fields can be used to validate any signature in the document.
// Additionally, the VRI entry contains validation data per signature.
// The keys in the VRI entry are calculated as upper(hex(sha1(sig.Contents))).
// The values are VRI dictionaries containing certificates and revocation
// information used for validating a single signature.
// See ETSI TS 102 778-4 V1.1.1 for more information.
type DSS struct {
	_dgfbc *_agf.PdfIndirectObject
	Certs  []*_agf.PdfObjectStream
	OCSPs  []*_agf.PdfObjectStream
	CRLs   []*_agf.PdfObjectStream
	VRI    map[string]*VRI
	_agbeg map[string]*_agf.PdfObjectStream
	_ecgfe map[string]*_agf.PdfObjectStream
	_gegg  map[string]*_agf.PdfObjectStream
}

func (_ddbg *PdfReader) newPdfAnnotationFromIndirectObject(_edc *_agf.PdfIndirectObject) (*PdfAnnotation, error) {
	_gccb, _dgg := _edc.PdfObject.(*_agf.PdfObjectDictionary)
	if !_dgg {
		return nil, _b.Errorf("\u0061\u006e\u006e\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u0020\u0069\u006e\u0064\u0069r\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006ft\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020a \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079")
	}
	if model := _ddbg._dcdeb.GetModelFromPrimitive(_gccb); model != nil {
		_daef, _ebbf := model.(*PdfAnnotation)
		if !_ebbf {
			return nil, _b.Errorf("\u0063\u0061\u0063\u0068\u0065\u0064 \u006d\u006f\u0064\u0065\u006c\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0050D\u0046\u0020\u0061\u006e\u006e\u006f\u0074a\u0074\u0069\u006f\u006e")
		}
		return _daef, nil
	}
	_ebed := &PdfAnnotation{}
	_ebed._aeee = _edc
	_ddbg._dcdeb.Register(_gccb, _ebed)
	if _dccg := _gccb.Get("\u0054\u0079\u0070\u0065"); _dccg != nil {
		_ggb, _fced := _dccg.(*_agf.PdfObjectName)
		if !_fced {
			_fd.Log.Trace("\u0049\u006e\u0063\u006f\u006d\u0070\u0061\u0074\u0069\u0062\u0069\u006c\u0069\u0074\u0079\u0021\u0020\u0049\u006e\u0076a\u006c\u0069\u0064\u0020\u0074\u0079\u0070\u0065\u0020\u006f\u0066\u0020\u0054\u0079\u0070\u0065\u0020\u0028\u0025\u0054\u0029\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064 \u0062\u0065\u0020\u004e\u0061m\u0065", _dccg)
		} else {
			if *_ggb != "\u0041\u006e\u006eo\u0074" {
				_fd.Log.Trace("\u0055\u006e\u0073\u0075\u0073\u0070\u0065\u0063\u0074\u0065d\u0020\u0054\u0079\u0070\u0065\u0020\u0021=\u0020\u0041\u006e\u006e\u006f\u0074\u0020\u0028\u0025\u0073\u0029", *_ggb)
			}
		}
	}
	if _fec := _gccb.Get("\u0052\u0065\u0063\u0074"); _fec != nil {
		_ebed.Rect = _fec
	}
	if _gfc := _gccb.Get("\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"); _gfc != nil {
		_ebed.Contents = _gfc
	}
	if _bfg := _gccb.Get("\u0050"); _bfg != nil {
		_ebed.P = _bfg
	}
	if _cfeb := _gccb.Get("\u004e\u004d"); _cfeb != nil {
		_ebed.NM = _cfeb
	}
	if _bga := _gccb.Get("\u004d"); _bga != nil {
		_ebed.M = _bga
	}
	if _bfgd := _gccb.Get("\u0046"); _bfgd != nil {
		_ebed.F = _bfgd
	}
	if _bbb := _gccb.Get("\u0041\u0050"); _bbb != nil {
		_ebed.AP = _bbb
	}
	if _dcf := _gccb.Get("\u0041\u0053"); _dcf != nil {
		_ebed.AS = _dcf
	}
	if _edgcc := _gccb.Get("\u0042\u006f\u0072\u0064\u0065\u0072"); _edgcc != nil {
		_ebed.Border = _edgcc
	}
	if _ece := _gccb.Get("\u0043"); _ece != nil {
		_ebed.C = _ece
	}
	if _afbb := _gccb.Get("\u0053\u0074\u0072u\u0063\u0074\u0050\u0061\u0072\u0065\u006e\u0074"); _afbb != nil {
		_ebed.StructParent = _afbb
	}
	if _cee := _gccb.Get("\u004f\u0043"); _cee != nil {
		_ebed.OC = _cee
	}
	_aea := _gccb.Get("\u0053u\u0062\u0074\u0079\u0070\u0065")
	if _aea == nil {
		_fd.Log.Debug("\u0057\u0041\u0052\u004e\u0049\u004e\u0047:\u0020\u0043\u006f\u006d\u0070\u0061\u0074\u0069\u0062\u0069\u006c\u0069\u0074\u0079 \u0069s\u0073\u0075\u0065\u0020\u002d\u0020a\u006e\u006e\u006f\u0074\u0061\u0074\u0069o\u006e\u0020\u0053\u0075\u0062\u0074\u0079\u0070\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u002d\u0020\u0061\u0073\u0073u\u006d\u0069\u006e\u0067\u0020\u006e\u006f\u0020\u0073\u0075\u0062\u0074\u0079p\u0065")
		_ebed._eef = nil
		return _ebed, nil
	}
	_fdbg, _ggba := _aea.(*_agf.PdfObjectName)
	if !_ggba {
		_fd.Log.Debug("E\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076a\u006c\u0069\u0064\u0020\u0053\u0075\u0062ty\u0070\u0065\u0020\u006fb\u006a\u0065\u0063\u0074\u0020\u0074\u0079\u0070\u0065 !\u003d\u0020n\u0061\u006d\u0065\u0020\u0028\u0025\u0054\u0029", _aea)
		return nil, _b.Errorf("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0053\u0075\u0062\u0074\u0079\u0070\u0065\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u0074\u0079\u0070\u0065\u0020\u0021\u003d n\u0061\u006d\u0065 \u0028%\u0054\u0029", _aea)
	}
	switch *_fdbg {
	case "\u0054\u0065\u0078\u0074":
		_dbbe, _cdd := _ddbg.newPdfAnnotationTextFromDict(_gccb)
		if _cdd != nil {
			return nil, _cdd
		}
		_dbbe.PdfAnnotation = _ebed
		_ebed._eef = _dbbe
		return _ebed, nil
	case "\u004c\u0069\u006e\u006b":
		_cgg, _feed := _ddbg.newPdfAnnotationLinkFromDict(_gccb)
		if _feed != nil {
			return nil, _feed
		}
		_cgg.PdfAnnotation = _ebed
		_ebed._eef = _cgg
		return _ebed, nil
	case "\u0046\u0072\u0065\u0065\u0054\u0065\u0078\u0074":
		_fea, _caga := _ddbg.newPdfAnnotationFreeTextFromDict(_gccb)
		if _caga != nil {
			return nil, _caga
		}
		_fea.PdfAnnotation = _ebed
		_ebed._eef = _fea
		return _ebed, nil
	case "\u004c\u0069\u006e\u0065":
		_fcee, _edbb := _ddbg.newPdfAnnotationLineFromDict(_gccb)
		if _edbb != nil {
			return nil, _edbb
		}
		_fcee.PdfAnnotation = _ebed
		_ebed._eef = _fcee
		_fd.Log.Trace("\u004c\u0049\u004e\u0045\u0020\u0041N\u004e\u004f\u0054\u0041\u0054\u0049\u004f\u004e\u003a\u0020\u0061\u006e\u006eo\u0074\u0020\u0028\u0025\u0054\u0029\u003a \u0025\u002b\u0076\u000a", _ebed, _ebed)
		_fd.Log.Trace("\u004c\u0049\u004eE\u0020\u0041\u004e\u004eO\u0054\u0041\u0054\u0049\u004f\u004e\u003a \u0063\u0074\u0078\u0020\u0028\u0025\u0054\u0029\u003a\u0020\u0025\u002b\u0076\u000a", _fcee, _fcee)
		_fd.Log.Trace("\u004c\u0049\u004e\u0045\u0020\u0041\u004e\u004e\u004f\u0054\u0041\u0054\u0049\u004f\u004e\u0020\u004d\u0061\u0072\u006b\u0075\u0070\u003a\u0020c\u0074\u0078\u0020\u0028\u0025T\u0029\u003a \u0025\u002b\u0076\u000a", _fcee.PdfAnnotationMarkup, _fcee.PdfAnnotationMarkup)
		return _ebed, nil
	case "\u0053\u0071\u0075\u0061\u0072\u0065":
		_cfgb, _gedc := _ddbg.newPdfAnnotationSquareFromDict(_gccb)
		if _gedc != nil {
			return nil, _gedc
		}
		_cfgb.PdfAnnotation = _ebed
		_ebed._eef = _cfgb
		return _ebed, nil
	case "\u0043\u0069\u0072\u0063\u006c\u0065":
		_bdb, _fed := _ddbg.newPdfAnnotationCircleFromDict(_gccb)
		if _fed != nil {
			return nil, _fed
		}
		_bdb.PdfAnnotation = _ebed
		_ebed._eef = _bdb
		return _ebed, nil
	case "\u0050o\u006c\u0079\u0067\u006f\u006e":
		_fcfe, _dac := _ddbg.newPdfAnnotationPolygonFromDict(_gccb)
		if _dac != nil {
			return nil, _dac
		}
		_fcfe.PdfAnnotation = _ebed
		_ebed._eef = _fcfe
		return _ebed, nil
	case "\u0050\u006f\u006c\u0079\u004c\u0069\u006e\u0065":
		_dbdg, _edeb := _ddbg.newPdfAnnotationPolyLineFromDict(_gccb)
		if _edeb != nil {
			return nil, _edeb
		}
		_dbdg.PdfAnnotation = _ebed
		_ebed._eef = _dbdg
		return _ebed, nil
	case "\u0048i\u0067\u0068\u006c\u0069\u0067\u0068t":
		_gcfb, _affe := _ddbg.newPdfAnnotationHighlightFromDict(_gccb)
		if _affe != nil {
			return nil, _affe
		}
		_gcfb.PdfAnnotation = _ebed
		_ebed._eef = _gcfb
		return _ebed, nil
	case "\u0055n\u0064\u0065\u0072\u006c\u0069\u006ee":
		_agba, _ccc := _ddbg.newPdfAnnotationUnderlineFromDict(_gccb)
		if _ccc != nil {
			return nil, _ccc
		}
		_agba.PdfAnnotation = _ebed
		_ebed._eef = _agba
		return _ebed, nil
	case "\u0053\u0071\u0075\u0069\u0067\u0067\u006c\u0079":
		_fgfc, _dadf := _ddbg.newPdfAnnotationSquigglyFromDict(_gccb)
		if _dadf != nil {
			return nil, _dadf
		}
		_fgfc.PdfAnnotation = _ebed
		_ebed._eef = _fgfc
		return _ebed, nil
	case "\u0053t\u0072\u0069\u006b\u0065\u004f\u0075t":
		_fdd, _dgc := _ddbg.newPdfAnnotationStrikeOut(_gccb)
		if _dgc != nil {
			return nil, _dgc
		}
		_fdd.PdfAnnotation = _ebed
		_ebed._eef = _fdd
		return _ebed, nil
	case "\u0043\u0061\u0072e\u0074":
		_ecd, _adca := _ddbg.newPdfAnnotationCaretFromDict(_gccb)
		if _adca != nil {
			return nil, _adca
		}
		_ecd.PdfAnnotation = _ebed
		_ebed._eef = _ecd
		return _ebed, nil
	case "\u0053\u0074\u0061m\u0070":
		_bfdf, _bfge := _ddbg.newPdfAnnotationStampFromDict(_gccb)
		if _bfge != nil {
			return nil, _bfge
		}
		_bfdf.PdfAnnotation = _ebed
		_ebed._eef = _bfdf
		return _ebed, nil
	case "\u0049\u006e\u006b":
		_ccg, _aeea := _ddbg.newPdfAnnotationInkFromDict(_gccb)
		if _aeea != nil {
			return nil, _aeea
		}
		_ccg.PdfAnnotation = _ebed
		_ebed._eef = _ccg
		return _ebed, nil
	case "\u0050\u006f\u0070u\u0070":
		_ddg, _dga := _ddbg.newPdfAnnotationPopupFromDict(_gccb)
		if _dga != nil {
			return nil, _dga
		}
		_ddg.PdfAnnotation = _ebed
		_ebed._eef = _ddg
		return _ebed, nil
	case "\u0046\u0069\u006c\u0065\u0041\u0074\u0074\u0061\u0063h\u006d\u0065\u006e\u0074":
		_daaa, _eegd := _ddbg.newPdfAnnotationFileAttachmentFromDict(_gccb)
		if _eegd != nil {
			return nil, _eegd
		}
		_daaa.PdfAnnotation = _ebed
		_ebed._eef = _daaa
		return _ebed, nil
	case "\u0053\u006f\u0075n\u0064":
		_cbfa, _afbe := _ddbg.newPdfAnnotationSoundFromDict(_gccb)
		if _afbe != nil {
			return nil, _afbe
		}
		_cbfa.PdfAnnotation = _ebed
		_ebed._eef = _cbfa
		return _ebed, nil
	case "\u0052i\u0063\u0068\u004d\u0065\u0064\u0069a":
		_cagb, _dff := _ddbg.newPdfAnnotationRichMediaFromDict(_gccb)
		if _dff != nil {
			return nil, _dff
		}
		_cagb.PdfAnnotation = _ebed
		_ebed._eef = _cagb
		return _ebed, nil
	case "\u004d\u006f\u0076i\u0065":
		_dec, _gfba := _ddbg.newPdfAnnotationMovieFromDict(_gccb)
		if _gfba != nil {
			return nil, _gfba
		}
		_dec.PdfAnnotation = _ebed
		_ebed._eef = _dec
		return _ebed, nil
	case "\u0053\u0063\u0072\u0065\u0065\u006e":
		_bcbb, _adbg := _ddbg.newPdfAnnotationScreenFromDict(_gccb)
		if _adbg != nil {
			return nil, _adbg
		}
		_bcbb.PdfAnnotation = _ebed
		_ebed._eef = _bcbb
		return _ebed, nil
	case "\u0057\u0069\u0064\u0067\u0065\u0074":
		_bdaa, _caaa := _ddbg.newPdfAnnotationWidgetFromDict(_gccb)
		if _caaa != nil {
			return nil, _caaa
		}
		_bdaa.PdfAnnotation = _ebed
		_ebed._eef = _bdaa
		return _ebed, nil
	case "P\u0072\u0069\u006e\u0074\u0065\u0072\u004d\u0061\u0072\u006b":
		_cfgd, _cdbc := _ddbg.newPdfAnnotationPrinterMarkFromDict(_gccb)
		if _cdbc != nil {
			return nil, _cdbc
		}
		_cfgd.PdfAnnotation = _ebed
		_ebed._eef = _cfgd
		return _ebed, nil
	case "\u0054r\u0061\u0070\u004e\u0065\u0074":
		_fcgf, _bdg := _ddbg.newPdfAnnotationTrapNetFromDict(_gccb)
		if _bdg != nil {
			return nil, _bdg
		}
		_fcgf.PdfAnnotation = _ebed
		_ebed._eef = _fcgf
		return _ebed, nil
	case "\u0057a\u0074\u0065\u0072\u006d\u0061\u0072k":
		_ebf, _bgbd := _ddbg.newPdfAnnotationWatermarkFromDict(_gccb)
		if _bgbd != nil {
			return nil, _bgbd
		}
		_ebf.PdfAnnotation = _ebed
		_ebed._eef = _ebf
		return _ebed, nil
	case "\u0033\u0044":
		_abe, _ecde := _ddbg.newPdfAnnotation3DFromDict(_gccb)
		if _ecde != nil {
			return nil, _ecde
		}
		_abe.PdfAnnotation = _ebed
		_ebed._eef = _abe
		return _ebed, nil
	case "\u0050\u0072\u006f\u006a\u0065\u0063\u0074\u0069\u006f\u006e":
		_adcd, _fcfea := _ddbg.newPdfAnnotationProjectionFromDict(_gccb)
		if _fcfea != nil {
			return nil, _fcfea
		}
		_adcd.PdfAnnotation = _ebed
		_ebed._eef = _adcd
		return _ebed, nil
	case "\u0052\u0065\u0064\u0061\u0063\u0074":
		_aad, _bbe := _ddbg.newPdfAnnotationRedactFromDict(_gccb)
		if _bbe != nil {
			return nil, _bbe
		}
		_aad.PdfAnnotation = _ebed
		_ebed._eef = _aad
		return _ebed, nil
	}
	_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u0067\u006e\u006f\u0072\u0069\u006e\u0067\u0020\u0075\u006e\u006b\u006e\u006f\u0077\u006e\u0020a\u006e\u006e\u006f\u0074\u0061t\u0069\u006fn\u003a\u0020\u0025\u0073", *_fdbg)
	return nil, nil
}
func (_fbc *PdfReader) newPdfActionGotoEFromDict(_abcd *_agf.PdfObjectDictionary) (*PdfActionGoToE, error) {
	_afdb, _bed := _bdd(_abcd.Get("\u0046"))
	if _bed != nil {
		return nil, _bed
	}
	return &PdfActionGoToE{D: _abcd.Get("\u0044"), NewWindow: _abcd.Get("\u004ee\u0077\u0057\u0069\u006e\u0064\u006fw"), T: _abcd.Get("\u0054"), F: _afdb}, nil
}

// PdfActionMovie represents a movie action.
type PdfActionMovie struct {
	*PdfAction
	Annotation _agf.PdfObject
	T          _agf.PdfObject
	Operation  _agf.PdfObject
}

// ColorToRGB converts gray -> rgb for a single color component.
func (_egee *PdfColorspaceDeviceGray) ColorToRGB(color PdfColor) (PdfColor, error) {
	_dcfg, _afbed := color.(*PdfColorDeviceGray)
	if !_afbed {
		_fd.Log.Debug("\u0049\u006e\u0070\u0075\u0074\u0020\u0063\u006f\u006c\u006fr\u0020\u006e\u006f\u0074\u0020\u0064\u0065v\u0069\u0063\u0065\u0020\u0067\u0072\u0061\u0079\u0020\u0025\u0054", color)
		return nil, _gcd.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	return NewPdfColorDeviceRGB(float64(*_dcfg), float64(*_dcfg), float64(*_dcfg)), nil
}
func (_baba *fontFile) parseASCIIPart(_gfcf []byte) error {
	if len(_gfcf) < 2 || string(_gfcf[:2]) != "\u0025\u0021" {
		return _gcd.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0073\u0074a\u0072\u0074\u0020\u006f\u0066\u0020\u0041S\u0043\u0049\u0049\u0020\u0073\u0065\u0067\u006d\u0065\u006e\u0074")
	}
	_afaf, _gbedac, _ddegg := _gcedb(_gfcf)
	if _ddegg != nil {
		return _ddegg
	}
	_bcgaa := _ffagc(_afaf)
	_baba._febf = _bcgaa["\u0046\u006f\u006e\u0074\u004e\u0061\u006d\u0065"]
	if _baba._febf == "" {
		_fd.Log.Debug("\u0020\u0046\u006f\u006e\u0074\u0046\u0069\u006c\u0065\u0020\u0068a\u0073\u0020\u006e\u006f\u0020\u002f\u0046\u006f\u006e\u0074N\u0061\u006d\u0065")
	}
	if _gbedac != "" {
		_aabc, _aaagc := _ecbgg(_gbedac)
		if _aaagc != nil {
			return _aaagc
		}
		_cfad, _aaagc := _fcg.NewCustomSimpleTextEncoder(_aabc, nil)
		if _aaagc != nil {
			_fd.Log.Debug("\u0045\u0052\u0052\u004fR\u0020\u003a\u0055\u004e\u004b\u004e\u004f\u0057\u004e\u0020G\u004cY\u0050\u0048\u003a\u0020\u0065\u0072\u0072=\u0025\u0076", _aaagc)
			return nil
		}
		_baba._aggb = _cfad
	}
	return nil
}

// ToPdfObject implements interface PdfModel.
func (_baaa *PdfAnnotationCircle) ToPdfObject() _agf.PdfObject {
	_baaa.PdfAnnotation.ToPdfObject()
	_aaadb := _baaa._aeee
	_ddbc := _aaadb.PdfObject.(*_agf.PdfObjectDictionary)
	_baaa.PdfAnnotationMarkup.appendToPdfDictionary(_ddbc)
	_ddbc.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _agf.MakeName("\u0043\u0069\u0072\u0063\u006c\u0065"))
	_ddbc.SetIfNotNil("\u0042\u0053", _baaa.BS)
	_ddbc.SetIfNotNil("\u0049\u0043", _baaa.IC)
	_ddbc.SetIfNotNil("\u0042\u0045", _baaa.BE)
	_ddbc.SetIfNotNil("\u0052\u0044", _baaa.RD)
	return _aaadb
}

// StdFontName represents name of a standard font.
type StdFontName = _aa.StdFontName

// GetContainingPdfObject returns the containing object for the PdfField, i.e. an indirect object
// containing the field dictionary.
func (_adgdf *PdfField) GetContainingPdfObject() _agf.PdfObject { return _adgdf._fcgcc }

// SetReason sets the `Reason` field of the signature.
func (_fbfea *PdfSignature) SetReason(reason string) { _fbfea.Reason = _agf.MakeString(reason) }

// NewPdfActionNamed returns a new "named" action.
func NewPdfActionNamed() *PdfActionNamed {
	_ffd := NewPdfAction()
	_cacf := &PdfActionNamed{}
	_cacf.PdfAction = _ffd
	_ffd.SetContext(_cacf)
	return _cacf
}

// GetDocMDPPermission returns the DocMDP level of the restrictions
func (_gfde *PdfSignature) GetDocMDPPermission() (_ca.DocMDPPermission, bool) {
	for _, _gccfg := range _gfde.Reference.Elements() {
		if _ggfb, _dgebf := _agf.GetDict(_gccfg); _dgebf {
			if _bfbb, _afec := _agf.GetNameVal(_ggfb.Get("\u0054r\u0061n\u0073\u0066\u006f\u0072\u006d\u004d\u0065\u0074\u0068\u006f\u0064")); _afec && _bfbb == "\u0044\u006f\u0063\u004d\u0044\u0050" {
				if _eagad, _bdaec := _agf.GetDict(_ggfb.Get("\u0054r\u0061n\u0073\u0066\u006f\u0072\u006d\u0050\u0061\u0072\u0061\u006d\u0073")); _bdaec {
					if P, _ebad := _agf.GetIntVal(_eagad.Get("\u0050")); _ebad {
						return _ca.DocMDPPermission(P), true
					}
				}
			}
		}
	}
	return 0, false
}

// ToPdfObject implements interface PdfModel.
func (_agda *PdfAnnotationWidget) ToPdfObject() _agf.PdfObject {
	_agda.PdfAnnotation.ToPdfObject()
	_beff := _agda._aeee
	_ffga := _beff.PdfObject.(*_agf.PdfObjectDictionary)
	if _agda._ggg {
		return _beff
	}
	_agda._ggg = true
	_ffga.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _agf.MakeName("\u0057\u0069\u0064\u0067\u0065\u0074"))
	_ffga.SetIfNotNil("\u0048", _agda.H)
	_ffga.SetIfNotNil("\u004d\u004b", _agda.MK)
	_ffga.SetIfNotNil("\u0041", _agda.A)
	_ffga.SetIfNotNil("\u0041\u0041", _agda.AA)
	_ffga.SetIfNotNil("\u0042\u0053", _agda.BS)
	_gaca := _agda.Parent
	if _agda._efe != nil {
		if _agda._efe._fcgcc == _agda._aeee {
			_agda._efe.ToPdfObject()
		}
		_gaca = _agda._efe.GetContainingPdfObject()
	}
	if _gaca != _beff {
		_ffga.SetIfNotNil("\u0050\u0061\u0072\u0065\u006e\u0074", _gaca)
	}
	_agda._ggg = false
	return _beff
}

// PdfPageResourcesColorspaces contains the colorspace in the PdfPageResources.
// Needs to have matching name and colorspace map entry. The Names define the order.
type PdfPageResourcesColorspaces struct {
	Names       []string
	Colorspaces map[string]PdfColorspace
	_dafcd      *_agf.PdfIndirectObject
}

func (_gbdgf *PdfColorspaceCalGray) String() string { return "\u0043a\u006c\u0047\u0072\u0061\u0079" }

// SetXObjectByName adds the XObject from the passed in stream to the page resources.
// The added XObject is identified by the specified name.
func (_bdfad *PdfPageResources) SetXObjectByName(keyName _agf.PdfObjectName, stream *_agf.PdfObjectStream) error {
	if _bdfad.XObject == nil {
		_bdfad.XObject = _agf.MakeDict()
	}
	_bccb := _agf.TraceToDirectObject(_bdfad.XObject)
	_gbae, _eafg := _bccb.(*_agf.PdfObjectDictionary)
	if !_eafg {
		_fd.Log.Debug("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0058\u004f\u0062j\u0065\u0063\u0074\u002c\u0020\u0067\u006f\u0074\u0020\u0025T\u002f\u0025\u0054", _bdfad.XObject, _bccb)
		return _gcd.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	_gbae.Set(keyName, stream)
	return nil
}

// AddPages adds pages to be appended to the end of the source PDF.
func (_gddbf *PdfAppender) AddPages(pages ...*PdfPage) {
	for _, _dgdd := range pages {
		_dgdd = _dgdd.Duplicate()
		_ddeeg(_dgdd)
		_gddbf._dfaf = append(_gddbf._dfaf, _dgdd)
	}
}

// ToInteger convert to an integer format.
func (_eeef *PdfColorCalRGB) ToInteger(bits int) [3]uint32 {
	_fgge := _afb.Pow(2, float64(bits)) - 1
	return [3]uint32{uint32(_fgge * _eeef.A()), uint32(_fgge * _eeef.B()), uint32(_fgge * _eeef.C())}
}

// PdfAnnotationRedact represents Redact annotations.
// (Section 12.5.6.23).
type PdfAnnotationRedact struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	QuadPoints  _agf.PdfObject
	IC          _agf.PdfObject
	RO          _agf.PdfObject
	OverlayText _agf.PdfObject
	Repeat      _agf.PdfObject
	DA          _agf.PdfObject
	Q           _agf.PdfObject
}

var _ pdfFont = (*pdfCIDFontType2)(nil)

// Evaluate runs the function. Input is [x1 x2 x3].
func (_bbbdc *PdfFunctionType4) Evaluate(xVec []float64) ([]float64, error) {
	if _bbbdc._fbbda == nil {
		_bbbdc._fbbda = _bd.NewPSExecutor(_bbbdc.Program)
	}
	var _deea []_bd.PSObject
	for _, _fecf := range xVec {
		_deea = append(_deea, _bd.MakeReal(_fecf))
	}
	_cbda, _bfddg := _bbbdc._fbbda.Execute(_deea)
	if _bfddg != nil {
		return nil, _bfddg
	}
	_bfege, _bfddg := _bd.PSObjectArrayToFloat64Array(_cbda)
	if _bfddg != nil {
		return nil, _bfddg
	}
	return _bfege, nil
}

// ParsePdfObject parses input pdf object into given output intent.
func (_cead *PdfOutputIntent) ParsePdfObject(object _agf.PdfObject) error {
	_efbca, _cbdec := _agf.GetDict(object)
	if !_cbdec {
		_fd.Log.Error("\u0055\u006e\u006bno\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020%\u0054 \u0066o\u0072 \u006f\u0075\u0074\u0070\u0075\u0074\u0020\u0069\u006e\u0074\u0065\u006e\u0074", object)
		return _gcd.New("\u0075\u006e\u006b\u006e\u006fw\u006e\u0020\u0070\u0064\u0066\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020t\u0079\u0070\u0065\u0020\u0066\u006f\u0072\u0020\u006f\u0075\u0074\u0070\u0075\u0074\u0020\u0069\u006e\u0074\u0065\u006e\u0074")
	}
	_cead._cebc = _efbca
	_cead.Type, _ = _efbca.GetString("\u0054\u0079\u0070\u0065")
	_gbbc, _cbdec := _efbca.GetString("\u0053")
	if _cbdec {
		switch _gbbc {
		case "\u0047T\u0053\u005f\u0050\u0044\u0046\u00411":
			_cead.S = PdfOutputIntentTypeA1
		case "\u0047T\u0053\u005f\u0050\u0044\u0046\u00412":
			_cead.S = PdfOutputIntentTypeA2
		case "\u0047T\u0053\u005f\u0050\u0044\u0046\u00413":
			_cead.S = PdfOutputIntentTypeA3
		case "\u0047T\u0053\u005f\u0050\u0044\u0046\u00414":
			_cead.S = PdfOutputIntentTypeA4
		case "\u0047\u0054\u0053\u005f\u0050\u0044\u0046\u0058":
			_cead.S = PdfOutputIntentTypeX
		}
	}
	_cead.OutputCondition, _ = _efbca.GetString("\u004fu\u0074p\u0075\u0074\u0043\u006f\u006e\u0064\u0069\u0074\u0069\u006f\u006e")
	_cead.OutputConditionIdentifier, _ = _efbca.GetString("\u004fu\u0074\u0070\u0075\u0074C\u006f\u006e\u0064\u0069\u0074i\u006fn\u0049d\u0065\u006e\u0074\u0069\u0066\u0069\u0065r")
	_cead.RegistryName, _ = _efbca.GetString("\u0052\u0065\u0067i\u0073\u0074\u0072\u0079\u004e\u0061\u006d\u0065")
	_cead.Info, _ = _efbca.GetString("\u0049\u006e\u0066\u006f")
	if _dfga, _dcaec := _agf.GetStream(_efbca.Get("\u0044\u0065\u0073\u0074\u004f\u0075\u0074\u0070\u0075\u0074\u0050\u0072o\u0066\u0069\u006c\u0065")); _dcaec {
		_cead.ColorComponents, _ = _agf.GetIntVal(_dfga.Get("\u004e"))
		_cecf, _gaaac := _agf.DecodeStream(_dfga)
		if _gaaac != nil {
			return _gaaac
		}
		_cead.DestOutputProfile = _cecf
	}
	return nil
}

var _dbfed = _aga.MustCompile("\u005b\\\u006e\u005c\u0072\u005d\u002b")

// AcroFormRepairOptions contains options for rebuilding the AcroForm.
type AcroFormRepairOptions struct{}

func _gbcae(_bcgea []*_agf.PdfObjectStream) *_agf.PdfObjectArray {
	if len(_bcgea) == 0 {
		return nil
	}
	_cgcc := make([]_agf.PdfObject, 0, len(_bcgea))
	for _, _dafgf := range _bcgea {
		_cgcc = append(_cgcc, _dafgf)
	}
	return _agf.MakeArray(_cgcc...)
}

// Permissions specify a permissions dictionary (PDF 1.5).
// (Section 12.8.4, Table 258 - Entries in a permissions dictionary p. 477 in PDF32000_2008).
type Permissions struct {
	DocMDP *PdfSignature
	_gebec *_agf.PdfObjectDictionary
}

// ToPdfObject returns the PDF representation of the shading dictionary.
func (_bgfc *PdfShading) ToPdfObject() _agf.PdfObject {
	_bebad := _bgfc._ggbge
	_adaac, _fagce := _bgfc.getShadingDict()
	if _fagce != nil {
		_fd.Log.Error("\u0055\u006ea\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0061\u0063\u0063\u0065\u0073\u0073\u0020\u0073\u0068\u0061\u0064\u0069\u006e\u0067\u0020di\u0063\u0074")
		return nil
	}
	if _bgfc.ShadingType != nil {
		_adaac.Set("S\u0068\u0061\u0064\u0069\u006e\u0067\u0054\u0079\u0070\u0065", _bgfc.ShadingType)
	}
	if _bgfc.ColorSpace != nil {
		_adaac.Set("\u0043\u006f\u006c\u006f\u0072\u0053\u0070\u0061\u0063\u0065", _bgfc.ColorSpace.ToPdfObject())
	}
	if _bgfc.Background != nil {
		_adaac.Set("\u0042\u0061\u0063\u006b\u0067\u0072\u006f\u0075\u006e\u0064", _bgfc.Background)
	}
	if _bgfc.BBox != nil {
		_adaac.Set("\u0042\u0042\u006f\u0078", _bgfc.BBox.ToPdfObject())
	}
	if _bgfc.AntiAlias != nil {
		_adaac.Set("\u0041n\u0074\u0069\u0041\u006c\u0069\u0061s", _bgfc.AntiAlias)
	}
	return _bebad
}

// ToPdfObject implements interface PdfModel.
func (_bgef *PdfAnnotationRedact) ToPdfObject() _agf.PdfObject {
	_bgef.PdfAnnotation.ToPdfObject()
	_afff := _bgef._aeee
	_agadb := _afff.PdfObject.(*_agf.PdfObjectDictionary)
	_bgef.PdfAnnotationMarkup.appendToPdfDictionary(_agadb)
	_agadb.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _agf.MakeName("\u0052\u0065\u0064\u0061\u0063\u0074"))
	_agadb.SetIfNotNil("\u0051\u0075\u0061\u0064\u0050\u006f\u0069\u006e\u0074\u0073", _bgef.QuadPoints)
	_agadb.SetIfNotNil("\u0049\u0043", _bgef.IC)
	_agadb.SetIfNotNil("\u0052\u004f", _bgef.RO)
	_agadb.SetIfNotNil("O\u0076\u0065\u0072\u006c\u0061\u0079\u0054\u0065\u0078\u0074", _bgef.OverlayText)
	_agadb.SetIfNotNil("\u0052\u0065\u0070\u0065\u0061\u0074", _bgef.Repeat)
	_agadb.SetIfNotNil("\u0044\u0041", _bgef.DA)
	_agadb.SetIfNotNil("\u0051", _bgef.Q)
	return _afff
}

// PageFromIndirectObject returns the PdfPage and page number for a given indirect object.
func (_gffef *PdfReader) PageFromIndirectObject(ind *_agf.PdfIndirectObject) (*PdfPage, int, error) {
	if len(_gffef.PageList) != len(_gffef._eddcd) {
		return nil, 0, _gcd.New("\u0070\u0061\u0067\u0065\u0020\u006c\u0069\u0073\u0074\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
	}
	for _bfcb, _degfgc := range _gffef._eddcd {
		if _degfgc == ind {
			return _gffef.PageList[_bfcb], _bfcb + 1, nil
		}
	}
	return nil, 0, _gcd.New("\u0070\u0061\u0067\u0065\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064")
}

// GetNumComponents returns the number of color components (3 for Lab).
func (_cgab *PdfColorLab) GetNumComponents() int { return 3 }

// ColorFromPdfObjects returns a new PdfColor based on the input slice of color
// components. The slice should contain a single PdfObjectFloat element in
// range 0-1.
func (_bdea *PdfColorspaceDeviceGray) ColorFromPdfObjects(objects []_agf.PdfObject) (PdfColor, error) {
	if len(objects) != 1 {
		return nil, _gcd.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_gga, _bbff := _agf.GetNumbersAsFloat(objects)
	if _bbff != nil {
		return nil, _bbff
	}
	return _bdea.ColorFromFloats(_gga)
}
func _ffaa(_egbcd _agf.PdfObject) (*PdfColorspaceSpecialPattern, error) {
	_fd.Log.Trace("\u004e\u0065\u0077\u0020\u0050\u0061\u0074\u0074\u0065\u0072n\u0020\u0043\u0053\u0020\u0066\u0072\u006fm\u0020\u006f\u0062\u006a\u003a\u0020\u0025\u0073\u0020\u0025\u0054", _egbcd.String(), _egbcd)
	_dfgda := NewPdfColorspaceSpecialPattern()
	if _gbaga, _adgg := _egbcd.(*_agf.PdfIndirectObject); _adgg {
		_dfgda._eecg = _gbaga
	}
	_egbcd = _agf.TraceToDirectObject(_egbcd)
	if _dcadb, _ffeg := _egbcd.(*_agf.PdfObjectName); _ffeg {
		if *_dcadb != "\u0050a\u0074\u0074\u0065\u0072\u006e" {
			return nil, _b.Errorf("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u006e\u0061\u006d\u0065")
		}
		return _dfgda, nil
	}
	_eaefa, _fagc := _egbcd.(*_agf.PdfObjectArray)
	if !_fagc {
		_fd.Log.Error("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0061t\u0074\u0065\u0072\u006e\u0020\u0043\u0053 \u004f\u0062\u006a\u0065\u0063\u0074\u003a\u0020\u0025\u0023\u0076", _egbcd)
		return nil, _b.Errorf("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0050\u0061\u0074\u0074e\u0072n\u0020C\u0053\u0020\u006f\u0062\u006a\u0065\u0063t")
	}
	if _eaefa.Len() != 1 && _eaefa.Len() != 2 {
		_fd.Log.Error("\u0049\u006ev\u0061\u006c\u0069\u0064\u0020\u0050\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u0043\u0053\u0020\u0061\u0072\u0072\u0061\u0079\u003a %\u0023\u0076", _eaefa)
		return nil, _b.Errorf("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0061\u0074\u0074\u0065r\u006e\u0020\u0043\u0053\u0020\u0061\u0072\u0072\u0061\u0079")
	}
	_egbcd = _eaefa.Get(0)
	if _agfgb, _gfbb := _egbcd.(*_agf.PdfObjectName); _gfbb {
		if *_agfgb != "\u0050a\u0074\u0074\u0065\u0072\u006e" {
			_fd.Log.Error("\u0049\u006e\u0076al\u0069\u0064\u0020\u0050\u0061\u0074\u0074\u0065\u0072n\u0020C\u0053 \u0061r\u0072\u0061\u0079\u0020\u006e\u0061\u006d\u0065\u003a\u0020\u0025\u0023\u0076", _agfgb)
			return nil, _b.Errorf("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u006e\u0061\u006d\u0065")
		}
	}
	if _eaefa.Len() > 1 {
		_egbcd = _eaefa.Get(1)
		_egbcd = _agf.TraceToDirectObject(_egbcd)
		_ddgf, _afag := NewPdfColorspaceFromPdfObject(_egbcd)
		if _afag != nil {
			return nil, _afag
		}
		_dfgda.UnderlyingCS = _ddgf
	}
	_fd.Log.Trace("R\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0050\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u0077i\u0074\u0068\u0020\u0075\u006e\u0064\u0065\u0072\u006c\u0079in\u0067\u0020\u0063s\u003a \u0025\u0054", _dfgda.UnderlyingCS)
	return _dfgda, nil
}
func _ddba(_acbd *PdfField, _badde _agf.PdfObject) {
	for _, _eecae := range _acbd.Annotations {
		_eecae.AS = _badde
		_eecae.ToPdfObject()
	}
}

// GetNumComponents returns the number of color components of the colorspace device.
// Returns 1 for a grayscale device.
func (_dbdga *PdfColorspaceDeviceGray) GetNumComponents() int { return 1 }

// PdfAnnotationWatermark represents Watermark annotations.
// (Section 12.5.6.22).
type PdfAnnotationWatermark struct {
	*PdfAnnotation
	FixedPrint _agf.PdfObject
}

func (_cbcb *pdfFontType3) getFontDescriptor() *PdfFontDescriptor { return _cbcb._dcfcb }

// ImageToRGB converts an image with samples in Separation CS to an image with samples specified in
// DeviceRGB CS.
func (_fgbc *PdfColorspaceSpecialSeparation) ImageToRGB(img Image) (Image, error) {
	_bgfg := _db.NewReader(img.getBase())
	_aacf := _ged.NewImageBase(int(img.Width), int(img.Height), int(img.BitsPerComponent), _fgbc.AlternateSpace.GetNumComponents(), nil, img._gdga, nil)
	_ecgaa := _db.NewWriter(_aacf)
	_cfgf := _afb.Pow(2, float64(img.BitsPerComponent)) - 1
	_fd.Log.Trace("\u0053\u0065\u0070a\u0072\u0061\u0074\u0069\u006f\u006e\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0073\u0070\u0061\u0063\u0065\u0020\u002d\u003e\u0020\u0054\u006f\u0052\u0047\u0042\u0020\u0063o\u006e\u0076\u0065\u0072\u0073\u0069\u006f\u006e")
	_fd.Log.Trace("\u0054i\u006et\u0054\u0072\u0061\u006e\u0073f\u006f\u0072m\u003a\u0020\u0025\u002b\u0076", _fgbc.TintTransform)
	_aafe := _fgbc.AlternateSpace.DecodeArray()
	var (
		_fbeb uint32
		_bacg error
	)
	for {
		_fbeb, _bacg = _bgfg.ReadSample()
		if _bacg == _cf.EOF {
			break
		}
		if _bacg != nil {
			return img, _bacg
		}
		_cbbd := float64(_fbeb) / _cfgf
		_egaef, _aead := _fgbc.TintTransform.Evaluate([]float64{_cbbd})
		if _aead != nil {
			return img, _aead
		}
		for _cbde, _gdeea := range _egaef {
			_dgad := _ged.LinearInterpolate(_gdeea, _aafe[_cbde*2], _aafe[_cbde*2+1], 0, 1)
			if _aead = _ecgaa.WriteSample(uint32(_dgad * _cfgf)); _aead != nil {
				return img, _aead
			}
		}
	}
	return _fgbc.AlternateSpace.ImageToRGB(_ddgg(&_aacf))
}

// StringToCharcodeBytes maps the provided string runes to charcode bytes and
// it returns the resulting slice of bytes, along with the number of runes
// which could not be converted. If the number of misses is 0, all string runes
// were successfully converted.
func (_aeeac *PdfFont) StringToCharcodeBytes(str string) ([]byte, int) {
	return _aeeac.RunesToCharcodeBytes([]rune(str))
}

// PdfShadingType3 is a Radial shading.
type PdfShadingType3 struct {
	*PdfShading
	Coords   *_agf.PdfObjectArray
	Domain   *_agf.PdfObjectArray
	Function []PdfFunction
	Extend   *_agf.PdfObjectArray
}

// GetXObjectByName returns the XObject with the specified keyName and the object type.
func (_eaegd *PdfPageResources) GetXObjectByName(keyName _agf.PdfObjectName) (*_agf.PdfObjectStream, XObjectType) {
	if _eaegd.XObject == nil {
		return nil, XObjectTypeUndefined
	}
	_ecddb, _gedfc := _agf.TraceToDirectObject(_eaegd.XObject).(*_agf.PdfObjectDictionary)
	if !_gedfc {
		_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052:\u0020\u0058\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020a\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0021\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", _agf.TraceToDirectObject(_eaegd.XObject))
		return nil, XObjectTypeUndefined
	}
	if _abbce := _ecddb.Get(keyName); _abbce != nil {
		_gebed, _acfcbg := _agf.GetStream(_abbce)
		if !_acfcbg {
			_fd.Log.Debug("X\u004f\u0062\u006a\u0065\u0063\u0074 \u006e\u006f\u0074\u0020\u0070\u006fi\u006e\u0074\u0069\u006e\u0067\u0020\u0074o\u0020\u0061\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020%\u0054", _abbce)
			return nil, XObjectTypeUndefined
		}
		_cafb := _gebed.PdfObjectDictionary
		_geca, _acfcbg := _agf.TraceToDirectObject(_cafb.Get("\u0053u\u0062\u0074\u0079\u0070\u0065")).(*_agf.PdfObjectName)
		if !_acfcbg {
			_fd.Log.Debug("\u0058\u004fbj\u0065\u0063\u0074 \u0053\u0075\u0062\u0074ype\u0020no\u0074\u0020\u0061\u0020\u004e\u0061\u006de,\u0020\u0064\u0069\u0063\u0074\u003a\u0020%\u0073", _cafb.String())
			return nil, XObjectTypeUndefined
		}
		if *_geca == "\u0049\u006d\u0061g\u0065" {
			return _gebed, XObjectTypeImage
		} else if *_geca == "\u0046\u006f\u0072\u006d" {
			return _gebed, XObjectTypeForm
		} else if *_geca == "\u0050\u0053" {
			return _gebed, XObjectTypePS
		} else {
			_fd.Log.Debug("\u0058\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0053\u0075b\u0074\u0079\u0070\u0065\u0020\u006e\u006ft\u0020\u006b\u006e\u006f\u0077\u006e\u0020\u0028\u0025\u0073\u0029", *_geca)
			return nil, XObjectTypeUndefined
		}
	} else {
		return nil, XObjectTypeUndefined
	}
}

// ImageToGray returns a new grayscale image based on the passed in RGB image.
func (_cfde *PdfColorspaceDeviceRGB) ImageToGray(img Image) (Image, error) {
	if img.ColorComponents != 3 {
		return img, _gcd.New("\u0070\u0072\u006f\u0076\u0069\u0064e\u0064\u0020\u0069\u006d\u0061\u0067\u0065\u0020\u0069\u0073\u0020\u006e\u006ft\u0020\u0061\u0020\u0044\u0065\u0076\u0069c\u0065\u0052\u0047\u0042")
	}
	_aaag, _dada := _ged.NewImage(int(img.Width), int(img.Height), int(img.BitsPerComponent), img.ColorComponents, img.Data, img._gdga, img._abacg)
	if _dada != nil {
		return img, _dada
	}
	_abaf, _dada := _ged.GrayConverter.Convert(_aaag)
	if _dada != nil {
		return img, _dada
	}
	return _ddgg(_abaf.Base()), nil
}

// ColorFromFloats returns a new PdfColor based on the input slice of color
// components.
func (_bfaf *PdfColorspaceSpecialPattern) ColorFromFloats(vals []float64) (PdfColor, error) {
	if _bfaf.UnderlyingCS == nil {
		return nil, _gcd.New("u\u006e\u0064\u0065\u0072\u006c\u0079i\u006e\u0067\u0020\u0043\u0053\u0020\u006e\u006f\u0074 \u0073\u0070\u0065c\u0069f\u0069\u0065\u0064")
	}
	return _bfaf.UnderlyingCS.ColorFromFloats(vals)
}

// PdfColorspaceDeviceNAttributes contains additional information about the components of colour space that
// conforming readers may use. Conforming readers need not use the alternateSpace and tintTransform parameters,
// and may instead use a custom blending algorithms, along with other information provided in the attributes
// dictionary if present.
type PdfColorspaceDeviceNAttributes struct {
	Subtype     *_agf.PdfObjectName
	Colorants   _agf.PdfObject
	Process     _agf.PdfObject
	MixingHints _agf.PdfObject
	_dea        *_agf.PdfIndirectObject
}

// ToPdfObject implements interface PdfModel.
func (_bccf *PdfAnnotationStamp) ToPdfObject() _agf.PdfObject {
	_bccf.PdfAnnotation.ToPdfObject()
	_cced := _bccf._aeee
	_fbff := _cced.PdfObject.(*_agf.PdfObjectDictionary)
	_bccf.PdfAnnotationMarkup.appendToPdfDictionary(_fbff)
	_fbff.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _agf.MakeName("\u0053\u0074\u0061m\u0070"))
	_fbff.SetIfNotNil("\u004e\u0061\u006d\u0065", _bccf.Name)
	return _cced
}

// ToPdfObject returns colorspace in a PDF object format [name dictionary]
func (_cedgg *PdfColorspaceLab) ToPdfObject() _agf.PdfObject {
	_bbc := _agf.MakeArray()
	_bbc.Append(_agf.MakeName("\u004c\u0061\u0062"))
	_cgbfc := _agf.MakeDict()
	if _cedgg.WhitePoint != nil {
		_ggaab := _agf.MakeArray(_agf.MakeFloat(_cedgg.WhitePoint[0]), _agf.MakeFloat(_cedgg.WhitePoint[1]), _agf.MakeFloat(_cedgg.WhitePoint[2]))
		_cgbfc.Set("\u0057\u0068\u0069\u0074\u0065\u0050\u006f\u0069\u006e\u0074", _ggaab)
	} else {
		_fd.Log.Error("\u004c\u0061\u0062: \u004d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0057h\u0069t\u0065P\u006fi\u006e\u0074\u0020\u0028\u0052\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0029")
	}
	if _cedgg.BlackPoint != nil {
		_gedec := _agf.MakeArray(_agf.MakeFloat(_cedgg.BlackPoint[0]), _agf.MakeFloat(_cedgg.BlackPoint[1]), _agf.MakeFloat(_cedgg.BlackPoint[2]))
		_cgbfc.Set("\u0042\u006c\u0061\u0063\u006b\u0050\u006f\u0069\u006e\u0074", _gedec)
	}
	if _cedgg.Range != nil {
		_feeb := _agf.MakeArray(_agf.MakeFloat(_cedgg.Range[0]), _agf.MakeFloat(_cedgg.Range[1]), _agf.MakeFloat(_cedgg.Range[2]), _agf.MakeFloat(_cedgg.Range[3]))
		_cgbfc.Set("\u0052\u0061\u006eg\u0065", _feeb)
	}
	_bbc.Append(_cgbfc)
	if _cedgg._aegc != nil {
		_cedgg._aegc.PdfObject = _bbc
		return _cedgg._aegc
	}
	return _bbc
}

// PdfShadingType5 is a Lattice-form Gouraud-shaded triangle mesh.
type PdfShadingType5 struct {
	*PdfShading
	BitsPerCoordinate *_agf.PdfObjectInteger
	BitsPerComponent  *_agf.PdfObjectInteger
	VerticesPerRow    *_agf.PdfObjectInteger
	Decode            *_agf.PdfObjectArray
	Function          []PdfFunction
}

// NewPdfActionHide returns a new "hide" action.
func NewPdfActionHide() *PdfActionHide {
	_cacd := NewPdfAction()
	_eae := &PdfActionHide{}
	_eae.PdfAction = _cacd
	_cacd.SetContext(_eae)
	return _eae
}
func _fgcgf(_efeec *fontCommon) *pdfCIDFontType0 { return &pdfCIDFontType0{fontCommon: *_efeec} }

// NewPdfOutline returns an initialized PdfOutline.
func NewPdfOutline() *PdfOutline {
	_daedd := &PdfOutline{_gbeea: _agf.MakeIndirectObject(_agf.MakeDict())}
	_daedd._cgaaa = _daedd
	return _daedd
}

// NewPdfAnnotationPolyLine returns a new polyline annotation.
func NewPdfAnnotationPolyLine() *PdfAnnotationPolyLine {
	_fge := NewPdfAnnotation()
	_ddb := &PdfAnnotationPolyLine{}
	_ddb.PdfAnnotation = _fge
	_ddb.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_fge.SetContext(_ddb)
	return _ddb
}

// NewPdfActionGoTo returns a new "go to" action.
func NewPdfActionGoTo() *PdfActionGoTo {
	_dbb := NewPdfAction()
	_bbd := &PdfActionGoTo{}
	_bbd.PdfAction = _dbb
	_dbb.SetContext(_bbd)
	return _bbd
}

// ToPdfObject converts the font to a PDF representation.
func (_bdga *pdfFontType0) ToPdfObject() _agf.PdfObject {
	if _bdga._dcfcf == nil {
		_bdga._dcfcf = &_agf.PdfIndirectObject{}
	}
	_bgbc := _bdga.baseFields().asPdfObjectDictionary("\u0054\u0079\u0070e\u0030")
	_bdga._dcfcf.PdfObject = _bgbc
	if _bdga.Encoding != nil {
		_bgbc.Set("\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067", _bdga.Encoding)
	} else if _bdga._gccd != nil {
		_bgbc.Set("\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067", _bdga._gccd.ToPdfObject())
	}
	if _bdga.DescendantFont != nil {
		_bgbc.Set("\u0044e\u0073c\u0065\u006e\u0064\u0061\u006e\u0074\u0046\u006f\u006e\u0074\u0073", _agf.MakeArray(_bdga.DescendantFont.ToPdfObject()))
	}
	return _bdga._dcfcf
}

// NewPdfOutlineItem returns an initialized PdfOutlineItem.
func NewPdfOutlineItem() *PdfOutlineItem {
	_eaae := &PdfOutlineItem{_dbac: _agf.MakeIndirectObject(_agf.MakeDict())}
	_eaae._cgaaa = _eaae
	return _eaae
}

// NewPdfActionURI returns a new "Uri" action.
func NewPdfActionURI() *PdfActionURI {
	_gde := NewPdfAction()
	_fdae := &PdfActionURI{}
	_fdae.PdfAction = _gde
	_gde.SetContext(_fdae)
	return _fdae
}

var _dadae = map[string]string{"\u0053\u0079\u006d\u0062\u006f\u006c": "\u0053\u0079\u006d\u0062\u006f\u006c\u0045\u006e\u0063o\u0064\u0069\u006e\u0067", "\u005a\u0061\u0070f\u0044\u0069\u006e\u0067\u0062\u0061\u0074\u0073": "Z\u0061p\u0066\u0044\u0069\u006e\u0067\u0062\u0061\u0074s\u0045\u006e\u0063\u006fdi\u006e\u0067"}

// NewCustomPdfOutputIntent creates a new custom PdfOutputIntent.
func NewCustomPdfOutputIntent(outputCondition, outputConditionIdentifier, info string, destOutputProfile []byte, colorComponents int) *PdfOutputIntent {
	return &PdfOutputIntent{Type: "\u004f\u0075\u0074p\u0075\u0074\u0049\u006e\u0074\u0065\u006e\u0074", OutputCondition: outputCondition, OutputConditionIdentifier: outputConditionIdentifier, Info: info, DestOutputProfile: destOutputProfile, _cebc: _agf.MakeDict(), ColorComponents: colorComponents}
}
func (_egbcae *PdfWriter) setCatalogVersion() {
	_egbcae._bagbb.Set("\u0056e\u0072\u0073\u0069\u006f\u006e", _agf.MakeName(_b.Sprintf("\u0025\u0064\u002e%\u0064", _egbcae._bcdfgg.Major, _egbcae._bcdfgg.Minor)))
}

// SetXObjectImageByName adds the provided XObjectImage to the page resources.
// The added XObjectImage is identified by the specified name.
func (_fdgbg *PdfPageResources) SetXObjectImageByName(keyName _agf.PdfObjectName, ximg *XObjectImage) error {
	_egefc := ximg.ToPdfObject().(*_agf.PdfObjectStream)
	_abgde := _fdgbg.SetXObjectByName(keyName, _egefc)
	return _abgde
}
func (_cdee *PdfReader) newPdfActionGotoRFromDict(_gac *_agf.PdfObjectDictionary) (*PdfActionGoToR, error) {
	_gbg, _affd := _bdd(_gac.Get("\u0046"))
	if _affd != nil {
		return nil, _affd
	}
	return &PdfActionGoToR{D: _gac.Get("\u0044"), NewWindow: _gac.Get("\u004ee\u0077\u0057\u0069\u006e\u0064\u006fw"), F: _gbg}, nil
}
func (_cdede *PdfReader) resolveReference(_ecbdg *_agf.PdfObjectReference) (_agf.PdfObject, bool, error) {
	_afcfa, _badba := _cdede._egdga.ObjCache[int(_ecbdg.ObjectNumber)]
	if !_badba {
		_fd.Log.Trace("R\u0065\u0061\u0064\u0065r \u004co\u006f\u006b\u0075\u0070\u0020r\u0065\u0066\u003a\u0020\u0025\u0073", _ecbdg)
		_faegbb, _acaab := _cdede._egdga.LookupByReference(*_ecbdg)
		if _acaab != nil {
			return nil, false, _acaab
		}
		_cdede._egdga.ObjCache[int(_ecbdg.ObjectNumber)] = _faegbb
		return _faegbb, false, nil
	}
	return _afcfa, true, nil
}

// GetContentStreams returns the content stream as an array of strings.
func (_eegfc *PdfPage) GetContentStreams() ([]string, error) {
	_eccfa := _eegfc.GetContentStreamObjs()
	var _edbe []string
	for _, _aedfd := range _eccfa {
		_cgafb, _dedg := _dcbb(_aedfd)
		if _dedg != nil {
			return nil, _dedg
		}
		_edbe = append(_edbe, _cgafb)
	}
	return _edbe, nil
}

// ToPdfObject returns an indirect object containing the signature field dictionary.
func (_gdbf *PdfFieldSignature) ToPdfObject() _agf.PdfObject {
	if _gdbf.PdfAnnotationWidget != nil {
		_gdbf.PdfAnnotationWidget.ToPdfObject()
	}
	_gdbf.PdfField.ToPdfObject()
	_gdfff := _gdbf._fcgcc
	_ffba := _gdfff.PdfObject.(*_agf.PdfObjectDictionary)
	_ffba.SetIfNotNil("\u0046\u0054", _agf.MakeName("\u0053\u0069\u0067"))
	_ffba.SetIfNotNil("\u004c\u006f\u0063\u006b", _gdbf.Lock)
	_ffba.SetIfNotNil("\u0053\u0056", _gdbf.SV)
	if _gdbf.V != nil {
		_ffba.SetIfNotNil("\u0056", _gdbf.V.ToPdfObject())
	}
	return _gdfff
}

// NewPdfAnnotationPolygon returns a new polygon annotation.
func NewPdfAnnotationPolygon() *PdfAnnotationPolygon {
	_cdb := NewPdfAnnotation()
	_dba := &PdfAnnotationPolygon{}
	_dba.PdfAnnotation = _cdb
	_dba.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_cdb.SetContext(_dba)
	return _dba
}

// NewPdfColorspaceLab returns a new Lab colorspace object.
func NewPdfColorspaceLab() *PdfColorspaceLab {
	_bbfe := &PdfColorspaceLab{}
	_bbfe.BlackPoint = []float64{0.0, 0.0, 0.0}
	_bbfe.Range = []float64{-100, 100, -100, 100}
	return _bbfe
}

// CharcodesToUnicodeWithStats is identical to CharcodesToUnicode except it returns more statistical
// information about hits and misses from the reverse mapping process.
// NOTE: The number of runes returned may be greater than the number of charcodes.
// TODO(peterwilliams97): Deprecate in v4 and use only CharcodesToStrings()
func (_gbed *PdfFont) CharcodesToUnicodeWithStats(charcodes []_fcg.CharCode) (_cccd []rune, _dgae, _bdfg int) {
	_efbe, _dgae, _bdfg := _gbed.CharcodesToStrings(charcodes)
	return []rune(_gc.Join(_efbe, "")), _dgae, _bdfg
}

// CharMetrics represents width and height metrics of a glyph.
type CharMetrics = _aa.CharMetrics

// WriteString outputs the object as it is to be written to file.
func (_gbfcg *pdfSignDictionary) WriteString() string {
	_gbfcg._cbfbge = 0
	_gbfcg._dbdbd = 0
	_gbfcg._bgdee = 0
	_gbfcg._dbeeb = 0
	_bfdfb := _gg.NewBuffer(nil)
	_bfdfb.WriteString("\u003c\u003c")
	for _, _gdfea := range _gbfcg.Keys() {
		_fddec := _gbfcg.Get(_gdfea)
		switch _gdfea {
		case "\u0042y\u0074\u0065\u0052\u0061\u006e\u0067e":
			_bfdfb.WriteString(_gdfea.WriteString())
			_bfdfb.WriteString("\u0020")
			_gbfcg._bgdee = _bfdfb.Len()
			_bfdfb.WriteString(_fddec.WriteString())
			_bfdfb.WriteString("\u0020")
			_gbfcg._dbeeb = _bfdfb.Len() - 1
		case "\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073":
			_bfdfb.WriteString(_gdfea.WriteString())
			_bfdfb.WriteString("\u0020")
			_gbfcg._cbfbge = _bfdfb.Len()
			_bfdfb.WriteString(_fddec.WriteString())
			_bfdfb.WriteString("\u0020")
			_gbfcg._dbdbd = _bfdfb.Len() - 1
		default:
			_bfdfb.WriteString(_gdfea.WriteString())
			_bfdfb.WriteString("\u0020")
			_bfdfb.WriteString(_fddec.WriteString())
		}
	}
	_bfdfb.WriteString("\u003e\u003e")
	return _bfdfb.String()
}

// GetSubFilter returns SubFilter value or empty string.
func (_cddg *pdfSignDictionary) GetSubFilter() string {
	_daecc := _cddg.Get("\u0053u\u0062\u0046\u0069\u006c\u0074\u0065r")
	if _daecc == nil {
		return ""
	}
	if _gfeab, _ggfgf := _agf.GetNameVal(_daecc); _ggfgf {
		return _gfeab
	}
	return ""
}

// ToPdfObject returns a *PdfIndirectObject containing a *PdfObjectArray representation of the DeviceN colorspace.
/*
	Format: [/DeviceN names alternateSpace tintTransform]
	    or: [/DeviceN names alternateSpace tintTransform attributes]
*/
func (_efbc *PdfColorspaceDeviceN) ToPdfObject() _agf.PdfObject {
	_cgdg := _agf.MakeArray(_agf.MakeName("\u0044e\u0076\u0069\u0063\u0065\u004e"))
	_cgdg.Append(_efbc.ColorantNames)
	_cgdg.Append(_efbc.AlternateSpace.ToPdfObject())
	_cgdg.Append(_efbc.TintTransform.ToPdfObject())
	if _efbc.Attributes != nil {
		_cgdg.Append(_efbc.Attributes.ToPdfObject())
	}
	if _efbc._bddcd != nil {
		_efbc._bddcd.PdfObject = _cgdg
		return _efbc._bddcd
	}
	return _cgdg
}
func _ffagc(_ceeda string) map[string]string {
	_begf := _dbfed.Split(_ceeda, -1)
	_gcgg := map[string]string{}
	for _, _feaa := range _begf {
		_bcgbc := _feaf.FindStringSubmatch(_feaa)
		if _bcgbc == nil {
			continue
		}
		_aebgf, _cdgag := _bcgbc[1], _bcgbc[2]
		_gcgg[_aebgf] = _cdgag
	}
	return _gcgg
}
func (_ccegd *pdfFontSimple) getFontDescriptor() *PdfFontDescriptor {
	if _caeg := _ccegd._dcfcb; _caeg != nil {
		return _caeg
	}
	return _ccegd._cfggc
}

// NewPdfDateFromTime will create a PdfDate based on the given time
func NewPdfDateFromTime(timeObj _e.Time) (PdfDate, error) {
	_bgdag := timeObj.Format("\u002d\u0030\u0037\u003a\u0030\u0030")
	_fbcba, _ := _ge.ParseInt(_bgdag[1:3], 10, 32)
	_aeaae, _ := _ge.ParseInt(_bgdag[4:6], 10, 32)
	return PdfDate{_dcggc: int64(timeObj.Year()), _fccbd: int64(timeObj.Month()), _ggca: int64(timeObj.Day()), _cfgfg: int64(timeObj.Hour()), _dgaab: int64(timeObj.Minute()), _gdebc: int64(timeObj.Second()), _dfead: _bgdag[0], _gddba: _fbcba, _ebcf: _aeaae}, nil
}

// GetNumComponents returns the number of color components.
func (_bbfc *PdfColorspaceICCBased) GetNumComponents() int { return _bbfc.N }

// ColorFromFloats returns a new PdfColor based on the input slice of color
// components. The slice should contain a single element between 0 and 1.
func (_eaef *PdfColorspaceDeviceGray) ColorFromFloats(vals []float64) (PdfColor, error) {
	if len(vals) != 1 {
		return nil, _gcd.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_agef := vals[0]
	if _agef < 0.0 || _agef > 1.0 {
		_fd.Log.Debug("\u0049\u006eco\u006d\u0070\u0061t\u0069\u0062\u0069\u006city\u003a R\u0061\u006e\u0067\u0065\u0020\u006f\u0075ts\u0069\u0064\u0065\u0020\u005b\u0030\u002c1\u005d")
	}
	if _agef < 0.0 {
		_agef = 0.0
	} else if _agef > 1.0 {
		_agef = 1.0
	}
	return NewPdfColorDeviceGray(_agef), nil
}

// SetPdfCreator sets the Creator attribute of the output PDF.
func SetPdfCreator(creator string) { _ecba.Lock(); defer _ecba.Unlock(); _agbb = creator }

// PdfColorDeviceRGB represents a color in DeviceRGB colorspace with R, G, B components, where component is
// defined in the range 0.0 - 1.0 where 1.0 is the primary intensity.
type PdfColorDeviceRGB [3]float64

func (_dacg *PdfReader) newPdfAnnotationPrinterMarkFromDict(_gdcdd *_agf.PdfObjectDictionary) (*PdfAnnotationPrinterMark, error) {
	_cefb := PdfAnnotationPrinterMark{}
	_cefb.MN = _gdcdd.Get("\u004d\u004e")
	return &_cefb, nil
}

// ToPdfObject implements interface PdfModel.
func (_bff *PdfAnnotationScreen) ToPdfObject() _agf.PdfObject {
	_bff.PdfAnnotation.ToPdfObject()
	_bfeg := _bff._aeee
	_cadg := _bfeg.PdfObject.(*_agf.PdfObjectDictionary)
	_cadg.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _agf.MakeName("\u0053\u0063\u0072\u0065\u0065\u006e"))
	_cadg.SetIfNotNil("\u0054", _bff.T)
	_cadg.SetIfNotNil("\u004d\u004b", _bff.MK)
	_cadg.SetIfNotNil("\u0041", _bff.A)
	_cadg.SetIfNotNil("\u0041\u0041", _bff.AA)
	return _bfeg
}

// CharcodesToUnicode converts the character codes `charcodes` to a slice of runes.
// How it works:
//  1. Use the ToUnicode CMap if there is one.
//  2. Use the underlying font's encoding.
func (_bced *PdfFont) CharcodesToUnicode(charcodes []_fcg.CharCode) []rune {
	_dfcef, _, _ := _bced.CharcodesToUnicodeWithStats(charcodes)
	return _dfcef
}

// Subtype returns the font's "Subtype" field.
func (_gcaf *PdfFont) Subtype() string {
	_aacfg := _gcaf.baseFields()._bcbfd
	if _aegda, _cggca := _gcaf._effaa.(*pdfFontType0); _cggca {
		_aacfg = _aacfg + "\u003a" + _aegda.DescendantFont.Subtype()
	}
	return _aacfg
}

// ToInteger convert to an integer format.
func (_cddc *PdfColorDeviceRGB) ToInteger(bits int) [3]uint32 {
	_agdb := _afb.Pow(2, float64(bits)) - 1
	return [3]uint32{uint32(_agdb * _cddc.R()), uint32(_agdb * _cddc.G()), uint32(_agdb * _cddc.B())}
}

// GetNumComponents returns the number of color components of the colorspace device.
// Returns 3 for an RGB device.
func (_faadb *PdfColorspaceDeviceRGB) GetNumComponents() int { return 3 }

// Mask returns the uin32 bitmask for the specific flag.
func (_cfcb FieldFlag) Mask() uint32 { return uint32(_cfcb) }

// ColorFromPdfObjects returns a new PdfColor based on the input slice of color
// components. The slice should contain a single PdfObjectFloat element.
func (_fcdb *PdfColorspaceSpecialIndexed) ColorFromPdfObjects(objects []_agf.PdfObject) (PdfColor, error) {
	if len(objects) != 1 {
		return nil, _gcd.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_dgccc, _aggg := _agf.GetNumbersAsFloat(objects)
	if _aggg != nil {
		return nil, _aggg
	}
	return _fcdb.ColorFromFloats(_dgccc)
}

// PdfShadingType1 is a Function-based shading.
type PdfShadingType1 struct {
	*PdfShading
	Domain   *_agf.PdfObjectArray
	Matrix   *_agf.PdfObjectArray
	Function []PdfFunction
}

// SetContext sets the sub annotation (context).
func (_efce *PdfAnnotation) SetContext(ctx PdfModel) { _efce._eef = ctx }

// SetOpenAction sets the OpenAction in the PDF catalog.
// The value shall be either an array defining a destination (12.3.2 "Destinations" PDF32000_2008),
// or an action dictionary representing an action (12.6 "Actions" PDF32000_2008).
func (_dbafeb *PdfWriter) SetOpenAction(dest _agf.PdfObject) error {
	if dest == nil || _agf.IsNullObject(dest) {
		return nil
	}
	_dbafeb._bagbb.Set("\u004f\u0070\u0065\u006e\u0041\u0063\u0074\u0069\u006f\u006e", dest)
	return _dbafeb.addObjects(dest)
}

// ToPdfObject recursively builds the Outline tree PDF object.
func (_bbdce *PdfOutline) ToPdfObject() _agf.PdfObject {
	_cgbbg := _bbdce._gbeea
	_gaeg := _cgbbg.PdfObject.(*_agf.PdfObjectDictionary)
	_gaeg.Set("\u0054\u0079\u0070\u0065", _agf.MakeName("\u004f\u0075\u0074\u006c\u0069\u006e\u0065\u0073"))
	if _bbdce.First != nil {
		_gaeg.Set("\u0046\u0069\u0072s\u0074", _bbdce.First.ToPdfObject())
	}
	if _bbdce.Last != nil {
		_gaeg.Set("\u004c\u0061\u0073\u0074", _bbdce.Last.GetContext().GetContainingPdfObject())
	}
	if _bbdce.Parent != nil {
		_gaeg.Set("\u0050\u0061\u0072\u0065\u006e\u0074", _bbdce.Parent.GetContext().GetContainingPdfObject())
	}
	if _bbdce.Count != nil {
		_gaeg.Set("\u0043\u006f\u0075n\u0074", _agf.MakeInteger(*_bbdce.Count))
	}
	return _cgbbg
}

// GetStructRoot gets the StructTreeRoot object
func (_egef *PdfPage) GetStructTreeRoot() (*_agf.PdfObject, bool) {
	_egdda, _geegb := _egef._ecae.GetCatalogStructTreeRoot()
	return &_egdda, _geegb
}

// Items returns all children outline items.
func (_edfdb *Outline) Items() []*OutlineItem { return _edfdb.Entries }

// IsShading specifies if the pattern is a shading pattern.
func (_bgfdd *PdfPattern) IsShading() bool { return _bgfdd.PatternType == 2 }
func (_ecagd *PdfWriter) optimizeDocument() error {
	if _ecagd._fdfce == nil {
		return nil
	}
	_febcae, _egead := _agf.GetDict(_ecagd._eaaaab)
	if !_egead {
		return _gcd.New("\u0061\u006e\u0020in\u0066\u006f\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0069s\u0020n\u006ft\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079")
	}
	_gacbb := _bb.Document{ID: [2]string{_ecagd._bedbef, _ecagd._daddd}, Version: _ecagd._bcdfgg, Objects: _ecagd._dgbd, Info: _febcae, Crypt: _ecagd._cecgd, UseHashBasedID: _ecagd._gcbdb}
	if _aegcg := _ecagd._fdfce.ApplyStandard(&_gacbb); _aegcg != nil {
		return _aegcg
	}
	_ecagd._bedbef, _ecagd._daddd = _gacbb.ID[0], _gacbb.ID[1]
	_ecagd._bcdfgg = _gacbb.Version
	_ecagd._dgbd = _gacbb.Objects
	_ecagd._eaaaab.PdfObject = _gacbb.Info
	_ecagd._gcbdb = _gacbb.UseHashBasedID
	_ecagd._cecgd = _gacbb.Crypt
	_eagdc := make(map[_agf.PdfObject]struct{}, len(_ecagd._dgbd))
	for _, _gfeec := range _ecagd._dgbd {
		_eagdc[_gfeec] = struct{}{}
	}
	_ecagd._ccbbf = _eagdc
	return nil
}

// PdfActionImportData represents a importData action.
type PdfActionImportData struct {
	*PdfAction
	F *PdfFilespec
}

// NewPdfShadingType2 creates an empty shading type 2 dictionary.
func NewPdfShadingType2() *PdfShadingType2 {
	_bbaaa := &PdfShadingType2{}
	_bbaaa.PdfShading = &PdfShading{}
	_bbaaa.PdfShading._ggbge = _agf.MakeIndirectObject(_agf.MakeDict())
	_bbaaa.PdfShading._gefcd = _bbaaa
	return _bbaaa
}

// IsCID returns true if the underlying font is CID.
func (_dfcc *PdfFont) IsCID() bool { return _dfcc.baseFields().isCIDFont() }
func (_egaf *PdfWriter) setDocInfo(_cfgdce _agf.PdfObject) {
	if _egaf.hasObject(_egaf._eaaaab) {
		delete(_egaf._ccbbf, _egaf._eaaaab)
		delete(_egaf._gbgbad, _egaf._eaaaab)
		for _ebfgc, _gcdg := range _egaf._dgbd {
			if _gcdg == _egaf._eaaaab {
				copy(_egaf._dgbd[_ebfgc:], _egaf._dgbd[_ebfgc+1:])
				_egaf._dgbd[len(_egaf._dgbd)-1] = nil
				_egaf._dgbd = _egaf._dgbd[:len(_egaf._dgbd)-1]
				break
			}
		}
	}
	_egdcb := _agf.PdfIndirectObject{}
	_egdcb.PdfObject = _cfgdce
	_egaf._eaaaab = &_egdcb
	_egaf.addObject(&_egdcb)
}

// NewPdfAnnotationRichMedia returns a new rich media annotation.
func NewPdfAnnotationRichMedia() *PdfAnnotationRichMedia {
	_gdbc := NewPdfAnnotation()
	_debb := &PdfAnnotationRichMedia{}
	_debb.PdfAnnotation = _gdbc
	_gdbc.SetContext(_debb)
	return _debb
}
func _beaba(_dfcce _agf.PdfObject) (*PdfFunctionType2, error) {
	_febab := &PdfFunctionType2{}
	var _bfef *_agf.PdfObjectDictionary
	if _dfeaa, _eeabc := _dfcce.(*_agf.PdfIndirectObject); _eeabc {
		_babdc, _eacb := _dfeaa.PdfObject.(*_agf.PdfObjectDictionary)
		if !_eacb {
			return nil, _gcd.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
		}
		_febab._ecgd = _dfeaa
		_bfef = _babdc
	} else if _dbdgd, _dbccd := _dfcce.(*_agf.PdfObjectDictionary); _dbccd {
		_bfef = _dbdgd
	} else {
		return nil, _gcd.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	_fd.Log.Trace("\u0046U\u004e\u0043\u0032\u003a\u0020\u0025s", _bfef.String())
	_gcfed, _cdeca := _agf.TraceToDirectObject(_bfef.Get("\u0044\u006f\u006d\u0061\u0069\u006e")).(*_agf.PdfObjectArray)
	if !_cdeca {
		_fd.Log.Error("D\u006fm\u0061\u0069\u006e\u0020\u006e\u006f\u0074\u0020s\u0070\u0065\u0063\u0069fi\u0065\u0064")
		return nil, _gcd.New("\u0072\u0065q\u0075\u0069\u0072\u0065d\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020m\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u006f\u0072\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
	}
	if _gcfed.Len() < 0 || _gcfed.Len()%2 != 0 {
		_fd.Log.Error("D\u006fm\u0061\u0069\u006e\u0020\u0072\u0061\u006e\u0067e\u0020\u0069\u006e\u0076al\u0069\u0064")
		return nil, _gcd.New("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0064\u006f\u006da\u0069\u006e\u0020\u0072an\u0067\u0065")
	}
	_agaca, _bacfa := _gcfed.ToFloat64Array()
	if _bacfa != nil {
		return nil, _bacfa
	}
	_febab.Domain = _agaca
	_gcfed, _cdeca = _agf.TraceToDirectObject(_bfef.Get("\u0052\u0061\u006eg\u0065")).(*_agf.PdfObjectArray)
	if _cdeca {
		if _gcfed.Len() < 0 || _gcfed.Len()%2 != 0 {
			return nil, _gcd.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u0061\u006e\u0067\u0065")
		}
		_ffdaeg, _febg := _gcfed.ToFloat64Array()
		if _febg != nil {
			return nil, _febg
		}
		_febab.Range = _ffdaeg
	}
	_gcfed, _cdeca = _agf.TraceToDirectObject(_bfef.Get("\u0043\u0030")).(*_agf.PdfObjectArray)
	if _cdeca {
		_cbbga, _ebfab := _gcfed.ToFloat64Array()
		if _ebfab != nil {
			return nil, _ebfab
		}
		_febab.C0 = _cbbga
	}
	_gcfed, _cdeca = _agf.TraceToDirectObject(_bfef.Get("\u0043\u0031")).(*_agf.PdfObjectArray)
	if _cdeca {
		_eggbb, _gbcdg := _gcfed.ToFloat64Array()
		if _gbcdg != nil {
			return nil, _gbcdg
		}
		_febab.C1 = _eggbb
	}
	if len(_febab.C0) != len(_febab.C1) {
		_fd.Log.Error("\u0043\u0030\u0020\u0061nd\u0020\u0043\u0031\u0020\u006e\u006f\u0074\u0020\u006d\u0061\u0074\u0063\u0068\u0069n\u0067")
		return nil, _agf.ErrRangeError
	}
	N, _bacfa := _agf.GetNumberAsFloat(_agf.TraceToDirectObject(_bfef.Get("\u004e")))
	if _bacfa != nil {
		_fd.Log.Error("\u004e\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020o\u0072\u0020\u0069\u006e\u0076\u0061\u006ci\u0064\u002c\u0020\u0064\u0069\u0063\u0074\u003a\u0020\u0025\u0073", _bfef.String())
		return nil, _bacfa
	}
	_febab.N = N
	return _febab, nil
}

// DecodeArray returns the range of color component values in DeviceCMYK colorspace.
func (_dfbde *PdfColorspaceDeviceCMYK) DecodeArray() []float64 {
	return []float64{0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0}
}
func _fabcg() string { _ecba.Lock(); defer _ecba.Unlock(); return _abdfe }

// EnableByName LTV enables the signature dictionary of the PDF AcroForm
// field identified the specified name. The signing certificate chain is
// extracted from the signature dictionary. Optionally, additional certificates
// can be specified through the `extraCerts` parameter. The LTV client attempts
// to build the certificate chain up to a trusted root by downloading any
// missing certificates.
func (_aeced *LTV) EnableByName(name string, extraCerts []*_ed.Certificate) error {
	_ececf := _aeced._daebc._gdeb.AcroForm
	for _, _afbg := range _ececf.AllFields() {
		_bgda, _ := _afbg.GetContext().(*PdfFieldSignature)
		if _bgda == nil {
			continue
		}
		if _cgcd := _bgda.PartialName(); _cgcd != name {
			continue
		}
		return _aeced.Enable(_bgda.V, extraCerts)
	}
	return nil
}

// ToPdfObject returns the PDF representation of the shading dictionary.
func (_fdgfe *PdfShadingType6) ToPdfObject() _agf.PdfObject {
	_fdgfe.PdfShading.ToPdfObject()
	_eeed, _dedcag := _fdgfe.getShadingDict()
	if _dedcag != nil {
		_fd.Log.Error("\u0055\u006ea\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0061\u0063\u0063\u0065\u0073\u0073\u0020\u0073\u0068\u0061\u0064\u0069\u006e\u0067\u0020di\u0063\u0074")
		return nil
	}
	if _fdgfe.BitsPerCoordinate != nil {
		_eeed.Set("\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006f\u0072\u0064i\u006e\u0061\u0074\u0065", _fdgfe.BitsPerCoordinate)
	}
	if _fdgfe.BitsPerComponent != nil {
		_eeed.Set("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074", _fdgfe.BitsPerComponent)
	}
	if _fdgfe.BitsPerFlag != nil {
		_eeed.Set("B\u0069\u0074\u0073\u0050\u0065\u0072\u0046\u006c\u0061\u0067", _fdgfe.BitsPerFlag)
	}
	if _fdgfe.Decode != nil {
		_eeed.Set("\u0044\u0065\u0063\u006f\u0064\u0065", _fdgfe.Decode)
	}
	if _fdgfe.Function != nil {
		if len(_fdgfe.Function) == 1 {
			_eeed.Set("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e", _fdgfe.Function[0].ToPdfObject())
		} else {
			_fgbgdc := _agf.MakeArray()
			for _, _eecce := range _fdgfe.Function {
				_fgbgdc.Append(_eecce.ToPdfObject())
			}
			_eeed.Set("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e", _fgbgdc)
		}
	}
	return _fdgfe._ggbge
}

// ToPdfObject implements interface PdfModel.
func (_ddad *PdfAnnotationPrinterMark) ToPdfObject() _agf.PdfObject {
	_ddad.PdfAnnotation.ToPdfObject()
	_bgbg := _ddad._aeee
	_cece := _bgbg.PdfObject.(*_agf.PdfObjectDictionary)
	_cece.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _agf.MakeName("P\u0072\u0069\u006e\u0074\u0065\u0072\u004d\u0061\u0072\u006b"))
	_cece.SetIfNotNil("\u004d\u004e", _ddad.MN)
	return _bgbg
}

// ToPdfObject convert PdfInfo to pdf object.
func (_bcga *PdfInfo) ToPdfObject() _agf.PdfObject {
	_egec := _agf.MakeDict()
	_egec.SetIfNotNil("\u0054\u0069\u0074l\u0065", _bcga.Title)
	_egec.SetIfNotNil("\u0041\u0075\u0074\u0068\u006f\u0072", _bcga.Author)
	_egec.SetIfNotNil("\u0053u\u0062\u006a\u0065\u0063\u0074", _bcga.Subject)
	_egec.SetIfNotNil("\u004b\u0065\u0079\u0077\u006f\u0072\u0064\u0073", _bcga.Keywords)
	_egec.SetIfNotNil("\u0043r\u0065\u0061\u0074\u006f\u0072", _bcga.Creator)
	_egec.SetIfNotNil("\u0050\u0072\u006f\u0064\u0075\u0063\u0065\u0072", _bcga.Producer)
	_egec.SetIfNotNil("\u0054r\u0061\u0070\u0070\u0065\u0064", _bcga.Trapped)
	if _bcga.CreationDate != nil {
		_egec.SetIfNotNil("\u0043\u0072\u0065a\u0074\u0069\u006f\u006e\u0044\u0061\u0074\u0065", _bcga.CreationDate.ToPdfObject())
	}
	if _bcga.ModifiedDate != nil {
		_egec.SetIfNotNil("\u004do\u0064\u0044\u0061\u0074\u0065", _bcga.ModifiedDate.ToPdfObject())
	}
	for _, _ecbg := range _bcga._adfbb.Keys() {
		_egec.SetIfNotNil(_ecbg, _bcga._adfbb.Get(_ecbg))
	}
	return _egec
}

// Add appends an outline item as a child of the current outline item.
func (_ddegc *OutlineItem) Add(item *OutlineItem) { _ddegc.Entries = append(_ddegc.Entries, item) }

// SetType sets the field button's type.  Can be one of:
// - PdfFieldButtonPush for push button fields
// - PdfFieldButtonCheckbox for checkbox fields
// - PdfFieldButtonRadio for radio button fields
// This sets the field's flag appropriately.
func (_ddc *PdfFieldButton) SetType(btype ButtonType) {
	_cfcgg := uint32(0)
	if _ddc.Ff != nil {
		_cfcgg = uint32(*_ddc.Ff)
	}
	switch btype {
	case ButtonTypePush:
		_cfcgg |= FieldFlagPushbutton.Mask()
	case ButtonTypeRadio:
		_cfcgg |= FieldFlagRadio.Mask()
	}
	_ddc.Ff = _agf.MakeInteger(int64(_cfcgg))
}
func (_aabdc *pdfFontType0) subsetRegistered() error {
	_dbdb, _dcffd := _aabdc.DescendantFont._effaa.(*pdfCIDFontType2)
	if !_dcffd {
		_fd.Log.Debug("\u0046\u006fnt\u0020\u006e\u006ft\u0020\u0073\u0075\u0070por\u0074ed\u0020\u0066\u006f\u0072\u0020\u0073\u0075bs\u0065\u0074\u0074\u0069\u006e\u0067\u0020%\u0054", _aabdc.DescendantFont)
		return nil
	}
	if _dbdb == nil {
		return nil
	}
	if _dbdb._dcfcb == nil {
		_fd.Log.Debug("\u004d\u0069\u0073si\u006e\u0067\u0020\u0066\u006f\u006e\u0074\u0020\u0064\u0065\u0073\u0063\u0072\u0069\u0070\u0074\u006f\u0072")
		return nil
	}
	if _aabdc._gccd == nil {
		_fd.Log.Debug("\u004e\u006f\u0020e\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0073\u0075\u0062s\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0069\u0067\u006e\u006f\u0072\u0065\u0064")
		return nil
	}
	_ecef, _dcffd := _agf.GetStream(_dbdb._dcfcb.FontFile2)
	if !_dcffd {
		_fd.Log.Debug("\u0045\u006d\u0062\u0065\u0064\u0064\u0065\u0064\u0020\u0066\u006f\u006e\u0074\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u006e\u006f\u0074\u0020\u0066o\u0075\u006e\u0064\u0020\u002d\u002d\u0020\u0041\u0042\u004f\u0052T\u0020\u0073\u0075\u0062\u0073\u0065\u0074\u0074\u0069\u006e\u0067")
		return _gcd.New("\u0066\u006f\u006e\u0074fi\u006c\u0065\u0032\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064")
	}
	_caefb, _gafgaa := _agf.DecodeStream(_ecef)
	if _gafgaa != nil {
		_fd.Log.Debug("\u0044\u0065c\u006f\u0064\u0065 \u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076", _gafgaa)
		return _gafgaa
	}
	_feegb, _gafgaa := _gd.Parse(_gg.NewReader(_caefb))
	if _gafgaa != nil {
		_fd.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0025\u0064\u0020\u0062\u0079\u0074\u0065\u0020f\u006f\u006e\u0074", len(_ecef.Stream))
		return _gafgaa
	}
	var _ddcde []rune
	var _fcdcb *_gd.Font
	switch _dcgbe := _aabdc._gccd.(type) {
	case *_fcg.TrueTypeFontEncoder:
		_ddcde = _dcgbe.RegisteredRunes()
		_fcdcb, _gafgaa = _feegb.SubsetKeepRunes(_ddcde)
		if _gafgaa != nil {
			_fd.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _gafgaa)
			return _gafgaa
		}
		_dcgbe.SubsetRegistered()
	case *_fcg.IdentityEncoder:
		_ddcde = _dcgbe.RegisteredRunes()
		_geaa := make([]_gd.GlyphIndex, len(_ddcde))
		for _dbfc, _adeag := range _ddcde {
			_geaa[_dbfc] = _gd.GlyphIndex(_adeag)
		}
		_fcdcb, _gafgaa = _feegb.SubsetKeepIndices(_geaa)
		if _gafgaa != nil {
			_fd.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _gafgaa)
			return _gafgaa
		}
	case _fcg.SimpleEncoder:
		_fabd := _dcgbe.Charcodes()
		for _, _fcef := range _fabd {
			_fcace, _gdef := _dcgbe.CharcodeToRune(_fcef)
			if !_gdef {
				_fd.Log.Debug("\u0045\u0052\u0052O\u0052\u003a\u0020\u0075\u006e\u0061\u0062\u006c\u0065\u0020\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0020\u0063\u0068\u0061\u0072\u0063\u006f\u0064\u0065\u0020\u0074\u006f \u0072\u0075\u006e\u0065\u003a\u0020\u0025\u0064", _fcef)
				continue
			}
			_ddcde = append(_ddcde, _fcace)
		}
	default:
		return _b.Errorf("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065\u006e\u0063\u006f\u0064\u0065\u0072\u0020\u0066\u006f\u0072\u0020s\u0075\u0062\u0073\u0065\u0074t\u0069\u006eg\u003a\u0020\u0025\u0054", _aabdc._gccd)
	}
	var _dcbf _gg.Buffer
	_gafgaa = _fcdcb.Write(&_dcbf)
	if _gafgaa != nil {
		_fd.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _gafgaa)
		return _gafgaa
	}
	if _aabdc._egfbf != nil {
		_dgcec := make(map[_ce.CharCode]rune, len(_ddcde))
		for _, _ggfdge := range _ddcde {
			_dagc, _dbdd := _aabdc._gccd.RuneToCharcode(_ggfdge)
			if !_dbdd {
				continue
			}
			_dgcec[_ce.CharCode(_dagc)] = _ggfdge
		}
		_aabdc._egfbf = _ce.NewToUnicodeCMap(_dgcec)
	}
	_ecef, _gafgaa = _agf.MakeStream(_dcbf.Bytes(), _agf.NewFlateEncoder())
	if _gafgaa != nil {
		_fd.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _gafgaa)
		return _gafgaa
	}
	_ecef.Set("\u004ce\u006e\u0067\u0074\u0068\u0031", _agf.MakeInteger(int64(_dcbf.Len())))
	if _dgfg, _fgdaed := _agf.GetStream(_dbdb._dcfcb.FontFile2); _fgdaed {
		*_dgfg = *_ecef
	} else {
		_dbdb._dcfcb.FontFile2 = _ecef
	}
	_bceccf := _ebgg()
	if len(_aabdc._fccf) > 0 {
		_aabdc._fccf = _cbace(_aabdc._fccf, _bceccf)
	}
	if len(_dbdb._fccf) > 0 {
		_dbdb._fccf = _cbace(_dbdb._fccf, _bceccf)
	}
	if len(_aabdc._afbeb) > 0 {
		_aabdc._afbeb = _cbace(_aabdc._afbeb, _bceccf)
	}
	if _dbdb._dcfcb != nil {
		_aada, _gfbgg := _agf.GetName(_dbdb._dcfcb.FontName)
		if _gfbgg && len(_aada.String()) > 0 {
			_eaad := _cbace(_aada.String(), _bceccf)
			_dbdb._dcfcb.FontName = _agf.MakeName(_eaad)
		}
	}
	return nil
}

// UpdateXObjectImageFromImage creates a new XObject Image from an
// Image object `img` and default masks from xobjIn.
// The default masks are overridden if img.hasAlpha
// If `encoder` is nil, uses raw encoding (none).
func UpdateXObjectImageFromImage(xobjIn *XObjectImage, img *Image, cs PdfColorspace, encoder _agf.StreamEncoder) (*XObjectImage, error) {
	if encoder == nil {
		encoder = _agf.NewRawEncoder()
	}
	encoder.UpdateParams(img.GetParamsDict())
	_cbffb, _dbdfa := encoder.EncodeBytes(img.Data)
	if _dbdfa != nil {
		_fd.Log.Debug("\u0045\u0072\u0072or\u0020\u0077\u0069\u0074\u0068\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0076", _dbdfa)
		return nil, _dbdfa
	}
	_agacf := NewXObjectImage()
	_cfece := img.Width
	_egbbe := img.Height
	_agacf.Width = &_cfece
	_agacf.Height = &_egbbe
	_deeea := img.BitsPerComponent
	_agacf.BitsPerComponent = &_deeea
	_agacf.Filter = encoder
	_agacf.Stream = _cbffb
	if cs == nil {
		if img.ColorComponents == 1 {
			_agacf.ColorSpace = NewPdfColorspaceDeviceGray()
		} else if img.ColorComponents == 3 {
			_agacf.ColorSpace = NewPdfColorspaceDeviceRGB()
		} else if img.ColorComponents == 4 {
			_agacf.ColorSpace = NewPdfColorspaceDeviceCMYK()
		} else {
			return nil, _gcd.New("c\u006fl\u006f\u0072\u0073\u0070\u0061\u0063\u0065\u0020u\u006e\u0064\u0065\u0066in\u0065\u0064")
		}
	} else {
		_agacf.ColorSpace = cs
	}
	if len(img._gdga) != 0 {
		_afcfb := NewXObjectImage()
		_afcfb.Filter = encoder
		_eabfa, _accee := encoder.EncodeBytes(img._gdga)
		if _accee != nil {
			_fd.Log.Debug("\u0045\u0072\u0072or\u0020\u0077\u0069\u0074\u0068\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0076", _accee)
			return nil, _accee
		}
		_afcfb.Stream = _eabfa
		_afcfb.BitsPerComponent = _agacf.BitsPerComponent
		_afcfb.Width = &img.Width
		_afcfb.Height = &img.Height
		_afcfb.ColorSpace = NewPdfColorspaceDeviceGray()
		_agacf.SMask = _afcfb.ToPdfObject()
	} else {
		_agacf.SMask = xobjIn.SMask
		_agacf.ImageMask = xobjIn.ImageMask
		if _agacf.ColorSpace.GetNumComponents() == 1 {
			_ffeff(_agacf)
		}
	}
	return _agacf, nil
}

// PdfActionNamed represents a named action.
type PdfActionNamed struct {
	*PdfAction
	N _agf.PdfObject
}

// HasExtGState checks if ExtGState name is available.
func (_cccba *PdfPage) HasExtGState(name _agf.PdfObjectName) bool {
	if _cccba.Resources == nil {
		return false
	}
	if _cccba.Resources.ExtGState == nil {
		return false
	}
	_effe, _efacf := _agf.TraceToDirectObject(_cccba.Resources.ExtGState).(*_agf.PdfObjectDictionary)
	if !_efacf {
		_fd.Log.Debug("\u0045\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0045\u0078t\u0047\u0053\u0074\u0061\u0074\u0065\u0020\u0064i\u0063t\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069c\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u003a\u0020\u0025\u0076", _agf.TraceToDirectObject(_cccba.Resources.ExtGState))
		return false
	}
	_gged := _effe.Get(name)
	_adabfg := _gged != nil
	return _adabfg
}

// PdfAnnotationLink represents Link annotations.
// (Section 12.5.6.5 p. 403).
type PdfAnnotationLink struct {
	*PdfAnnotation
	A          _agf.PdfObject
	Dest       _agf.PdfObject
	H          _agf.PdfObject
	PA         _agf.PdfObject
	QuadPoints _agf.PdfObject
	BS         _agf.PdfObject
	_bbdg      *PdfAction
	_accb      *PdfReader
}

// NewXObjectImageFromImage creates a new XObject Image from an image object
// with default options. If encoder is nil, uses raw encoding (none).
func NewXObjectImageFromImage(img *Image, cs PdfColorspace, encoder _agf.StreamEncoder) (*XObjectImage, error) {
	_aeega := NewXObjectImage()
	return UpdateXObjectImageFromImage(_aeega, img, cs, encoder)
}

// ToPdfObject returns the PDF representation of the shading dictionary.
func (_gccbb *PdfShadingType2) ToPdfObject() _agf.PdfObject {
	_gccbb.PdfShading.ToPdfObject()
	_dbbdg, _gebbc := _gccbb.getShadingDict()
	if _gebbc != nil {
		_fd.Log.Error("\u0055\u006ea\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0061\u0063\u0063\u0065\u0073\u0073\u0020\u0073\u0068\u0061\u0064\u0069\u006e\u0067\u0020di\u0063\u0074")
		return nil
	}
	if _dbbdg == nil {
		_fd.Log.Error("\u0053\u0068\u0061\u0064in\u0067\u0020\u0064\u0069\u0063\u0074\u0020\u0069\u0073\u0020\u006e\u0069\u006c")
		return nil
	}
	if _gccbb.Coords != nil {
		_dbbdg.Set("\u0043\u006f\u006f\u0072\u0064\u0073", _gccbb.Coords)
	}
	if _gccbb.Domain != nil {
		_dbbdg.Set("\u0044\u006f\u006d\u0061\u0069\u006e", _gccbb.Domain)
	}
	if _gccbb.Function != nil {
		if len(_gccbb.Function) == 1 {
			_dbbdg.Set("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e", _gccbb.Function[0].ToPdfObject())
		} else {
			_badgb := _agf.MakeArray()
			for _, _gdaad := range _gccbb.Function {
				_badgb.Append(_gdaad.ToPdfObject())
			}
			_dbbdg.Set("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e", _badgb)
		}
	}
	if _gccbb.Extend != nil {
		_dbbdg.Set("\u0045\u0078\u0074\u0065\u006e\u0064", _gccbb.Extend)
	}
	return _gccbb._ggbge
}

// XObjectForm (Table 95 in 8.10.2).
type XObjectForm struct {
	Filter        _agf.StreamEncoder
	FormType      _agf.PdfObject
	BBox          _agf.PdfObject
	Matrix        _agf.PdfObject
	Resources     *PdfPageResources
	Group         _agf.PdfObject
	Ref           _agf.PdfObject
	MetaData      _agf.PdfObject
	PieceInfo     _agf.PdfObject
	LastModified  _agf.PdfObject
	StructParent  _agf.PdfObject
	StructParents _agf.PdfObject
	OPI           _agf.PdfObject
	OC            _agf.PdfObject
	Name          _agf.PdfObject

	// Stream data.
	Stream []byte
	_dfeac *_agf.PdfObjectStream
}

// ToPdfObject implements interface PdfModel.
func (_afgf *PdfAnnotationFreeText) ToPdfObject() _agf.PdfObject {
	_afgf.PdfAnnotation.ToPdfObject()
	_ggbac := _afgf._aeee
	_gcdfe := _ggbac.PdfObject.(*_agf.PdfObjectDictionary)
	_afgf.PdfAnnotationMarkup.appendToPdfDictionary(_gcdfe)
	_gcdfe.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _agf.MakeName("\u0046\u0072\u0065\u0065\u0054\u0065\u0078\u0074"))
	_gcdfe.SetIfNotNil("\u0044\u0041", _afgf.DA)
	_gcdfe.SetIfNotNil("\u0051", _afgf.Q)
	_gcdfe.SetIfNotNil("\u0052\u0043", _afgf.RC)
	_gcdfe.SetIfNotNil("\u0044\u0053", _afgf.DS)
	_gcdfe.SetIfNotNil("\u0043\u004c", _afgf.CL)
	_gcdfe.SetIfNotNil("\u0049\u0054", _afgf.IT)
	_gcdfe.SetIfNotNil("\u0042\u0045", _afgf.BE)
	_gcdfe.SetIfNotNil("\u0052\u0044", _afgf.RD)
	_gcdfe.SetIfNotNil("\u0042\u0053", _afgf.BS)
	_gcdfe.SetIfNotNil("\u004c\u0045", _afgf.LE)
	return _ggbac
}
func _dgcfd(_fddfe _agf.PdfObject, _fgff *PdfReader) (*OutlineDest, error) {
	_dcdef, _fdfad := _agf.GetArray(_fddfe)
	if !_fdfad {
		return nil, _gcd.New("\u006f\u0075\u0074\u006c\u0069\u006e\u0065 \u0064\u0065\u0073t\u0069\u006e\u0061\u0074i\u006f\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079")
	}
	_cfdfa := _dcdef.Len()
	if _cfdfa < 2 {
		return nil, _b.Errorf("\u0069n\u0076\u0061l\u0069\u0064\u0020\u006fu\u0074\u006c\u0069n\u0065\u0020\u0064\u0065\u0073\u0074\u0069\u006e\u0061ti\u006f\u006e\u0020a\u0072\u0072a\u0079\u0020\u006c\u0065\u006e\u0067t\u0068\u003a \u0025\u0064", _cfdfa)
	}
	_ddbgg := &OutlineDest{Mode: "\u0046\u0069\u0074"}
	_dbaec := _dcdef.Get(0)
	if _beag, _gbbgg := _agf.GetIndirect(_dbaec); _gbbgg {
		if _, _cged, _agbfc := _fgff.PageFromIndirectObject(_beag); _agbfc == nil {
			_ddbgg.Page = int64(_cged - 1)
		} else {
			_fd.Log.Debug("\u0057\u0041\u0052\u004e\u003a\u0020\u0063o\u0075\u006c\u0064 \u006e\u006f\u0074\u0020g\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0069\u006e\u0064\u0065\u0078\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u002b\u0076", _beag)
		}
		_ddbgg.PageObj = _beag
	} else if _ecce, _dfebe := _agf.GetIntVal(_dbaec); _dfebe {
		if _ecce >= 0 && _ecce < len(_fgff.PageList) {
			_ddbgg.PageObj = _fgff.PageList[_ecce].GetPageAsIndirectObject()
		} else {
			_fd.Log.Debug("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064", _ecce)
		}
		_ddbgg.Page = int64(_ecce)
	} else {
		return nil, _b.Errorf("\u0069\u006eva\u006c\u0069\u0064 \u006f\u0075\u0074\u006cine\u0020de\u0073\u0074\u0069\u006e\u0061\u0074\u0069on\u0020\u0070\u0061\u0067\u0065\u003a\u0020%\u0054", _dbaec)
	}
	_dbage, _fdfad := _agf.GetNameVal(_dcdef.Get(1))
	if !_fdfad {
		_fd.Log.Debug("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006f\u0075\u0074\u006c\u0069\u006e\u0065\u0020\u0064\u0065s\u0074\u0069\u006e\u0061\u0074\u0069\u006fn\u0020\u006d\u0061\u0067\u006e\u0069\u0066\u0069\u0063\u0061\u0074i\u006f\u006e\u0020\u006d\u006f\u0064\u0065\u003a\u0020\u0025\u0076", _dcdef.Get(1))
		return _ddbgg, nil
	}
	switch _dbage {
	case "\u0046\u0069\u0074", "\u0046\u0069\u0074\u0042":
	case "\u0046\u0069\u0074\u0048", "\u0046\u0069\u0074B\u0048":
		if _cfdfa > 2 {
			_ddbgg.Y, _ = _agf.GetNumberAsFloat(_agf.TraceToDirectObject(_dcdef.Get(2)))
		}
	case "\u0046\u0069\u0074\u0056", "\u0046\u0069\u0074B\u0056":
		if _cfdfa > 2 {
			_ddbgg.X, _ = _agf.GetNumberAsFloat(_agf.TraceToDirectObject(_dcdef.Get(2)))
		}
	case "\u0058\u0059\u005a":
		if _cfdfa > 4 {
			_ddbgg.X, _ = _agf.GetNumberAsFloat(_agf.TraceToDirectObject(_dcdef.Get(2)))
			_ddbgg.Y, _ = _agf.GetNumberAsFloat(_agf.TraceToDirectObject(_dcdef.Get(3)))
			_ddbgg.Zoom, _ = _agf.GetNumberAsFloat(_agf.TraceToDirectObject(_dcdef.Get(4)))
		}
	default:
		_dbage = "\u0046\u0069\u0074"
	}
	_ddbgg.Mode = _dbage
	return _ddbgg, nil
}

// ToUnicode returns the name of the font's "ToUnicode" field if there is one, or "" if there isn't.
func (_gceb *PdfFont) ToUnicode() string {
	if _gceb.baseFields()._egfbf == nil {
		return ""
	}
	return _gceb.baseFields()._egfbf.Name()
}

// SignatureHandlerDocMDP extends SignatureHandler with the ValidateWithOpts method for checking the DocMDP policy.
type SignatureHandlerDocMDP interface {
	SignatureHandler

	// ValidateWithOpts validates a PDF signature by checking PdfReader or PdfParser
	// ValidateWithOpts shall contain Validate call
	ValidateWithOpts(_gbdd *PdfSignature, _dcegb Hasher, _aefe SignatureHandlerDocMDPParams) (SignatureValidationResult, error)
}

// SetPdfCreationDate sets the CreationDate attribute of the output PDF.
func SetPdfCreationDate(creationDate _e.Time) {
	_ecba.Lock()
	defer _ecba.Unlock()
	_acbaf = creationDate
}
func (_ffc *PdfReader) newPdfAnnotationMarkupFromDict(_bbf *_agf.PdfObjectDictionary) (*PdfAnnotationMarkup, error) {
	_dfgc := &PdfAnnotationMarkup{}
	if _gcae := _bbf.Get("\u0054"); _gcae != nil {
		_dfgc.T = _gcae
	}
	if _caca := _bbf.Get("\u0050\u006f\u0070u\u0070"); _caca != nil {
		_dgf, _ege := _caca.(*_agf.PdfIndirectObject)
		if !_ege {
			if _, _bae := _caca.(*_agf.PdfObjectNull); !_bae {
				return nil, _gcd.New("p\u006f\u0070\u0075\u0070\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0070\u006f\u0069\u006e\u0074\u0020t\u006f\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072ec\u0074\u0020\u006fb\u006ae\u0063\u0074")
			}
		} else {
			_cfef, _bfea := _ffc.newPdfAnnotationFromIndirectObject(_dgf)
			if _bfea != nil {
				return nil, _bfea
			}
			if _cfef != nil {
				_cage, _bgeb := _cfef._eef.(*PdfAnnotationPopup)
				if !_bgeb {
					return nil, _gcd.New("\u006f\u0062\u006ae\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0072\u0065\u0066\u0065\u0072\u0072\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0061\u0020\u0070\u006f\u0070\u0075\u0070\u0020\u0061n\u006e\u006f\u0074\u0061\u0074\u0069\u006f\u006e")
				}
				_dfgc.Popup = _cage
			}
		}
	}
	if _fbfa := _bbf.Get("\u0043\u0041"); _fbfa != nil {
		_dfgc.CA = _fbfa
	}
	if _bgc := _bbf.Get("\u0052\u0043"); _bgc != nil {
		_dfgc.RC = _bgc
	}
	if _dbc := _bbf.Get("\u0043\u0072\u0065a\u0074\u0069\u006f\u006e\u0044\u0061\u0074\u0065"); _dbc != nil {
		_dfgc.CreationDate = _dbc
	}
	if _ddfc := _bbf.Get("\u0049\u0052\u0054"); _ddfc != nil {
		_dfgc.IRT = _ddfc
	}
	if _bgcc := _bbf.Get("\u0053\u0075\u0062\u006a"); _bgcc != nil {
		_dfgc.Subj = _bgcc
	}
	if _egbf := _bbf.Get("\u0052\u0054"); _egbf != nil {
		_dfgc.RT = _egbf
	}
	if _cbfe := _bbf.Get("\u0049\u0054"); _cbfe != nil {
		_dfgc.IT = _cbfe
	}
	if _gcfd := _bbf.Get("\u0045\u0078\u0044\u0061\u0074\u0061"); _gcfd != nil {
		_dfgc.ExData = _gcfd
	}
	return _dfgc, nil
}

// A PdfPattern can represent a Pattern, either a tiling pattern or a shading pattern.
// Note that all patterns shall be treated as colours; a Pattern colour space shall be established with the CS or cs
// operator just like other colour spaces, and a particular pattern shall be installed as the current colour with the
// SCN or scn operator.
type PdfPattern struct {

	// Type: Pattern
	PatternType int64
	_dfed       PdfModel
	_efed       _agf.PdfObject
}

// ImageToRGB converts CalRGB colorspace image to RGB and returns the result.
func (_gcgd *PdfColorspaceCalRGB) ImageToRGB(img Image) (Image, error) {
	_bdbag := _db.NewReader(img.getBase())
	_afcf := _ged.NewImageBase(int(img.Width), int(img.Height), int(img.BitsPerComponent), 3, nil, nil, nil)
	_bgccd := _db.NewWriter(_afcf)
	_efcg := _afb.Pow(2, float64(img.BitsPerComponent)) - 1
	_fdgf := make([]uint32, 3)
	var (
		_cedb                                    error
		_eeeg, _gabg, _eagag, _fca, _bfcf, _gbda float64
	)
	for {
		_cedb = _bdbag.ReadSamples(_fdgf)
		if _cedb == _cf.EOF {
			break
		} else if _cedb != nil {
			return img, _cedb
		}
		_eeeg = float64(_fdgf[0]) / _efcg
		_gabg = float64(_fdgf[1]) / _efcg
		_eagag = float64(_fdgf[2]) / _efcg
		_fca = _gcgd.Matrix[0]*_afb.Pow(_eeeg, _gcgd.Gamma[0]) + _gcgd.Matrix[3]*_afb.Pow(_gabg, _gcgd.Gamma[1]) + _gcgd.Matrix[6]*_afb.Pow(_eagag, _gcgd.Gamma[2])
		_bfcf = _gcgd.Matrix[1]*_afb.Pow(_eeeg, _gcgd.Gamma[0]) + _gcgd.Matrix[4]*_afb.Pow(_gabg, _gcgd.Gamma[1]) + _gcgd.Matrix[7]*_afb.Pow(_eagag, _gcgd.Gamma[2])
		_gbda = _gcgd.Matrix[2]*_afb.Pow(_eeeg, _gcgd.Gamma[0]) + _gcgd.Matrix[5]*_afb.Pow(_gabg, _gcgd.Gamma[1]) + _gcgd.Matrix[8]*_afb.Pow(_eagag, _gcgd.Gamma[2])
		_eeeg = 3.240479*_fca + -1.537150*_bfcf + -0.498535*_gbda
		_gabg = -0.969256*_fca + 1.875992*_bfcf + 0.041556*_gbda
		_eagag = 0.055648*_fca + -0.204043*_bfcf + 1.057311*_gbda
		_eeeg = _afb.Min(_afb.Max(_eeeg, 0), 1.0)
		_gabg = _afb.Min(_afb.Max(_gabg, 0), 1.0)
		_eagag = _afb.Min(_afb.Max(_eagag, 0), 1.0)
		_fdgf[0] = uint32(_eeeg * _efcg)
		_fdgf[1] = uint32(_gabg * _efcg)
		_fdgf[2] = uint32(_eagag * _efcg)
		if _cedb = _bgccd.WriteSamples(_fdgf); _cedb != nil {
			return img, _cedb
		}
	}
	return _ddgg(&_afcf), nil
}
func _gcedbd(_egfdf *_agf.PdfObjectDictionary) (*PdfShadingType7, error) {
	_begfc := PdfShadingType7{}
	_cbag := _egfdf.Get("\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006f\u0072\u0064i\u006e\u0061\u0074\u0065")
	if _cbag == nil {
		_fd.Log.Debug("\u0052e\u0071\u0075i\u0072\u0065\u0064 \u0061\u0074\u0074\u0072\u0069\u0062\u0075t\u0065\u0020\u006d\u0069\u0073\u0073i\u006e\u0067\u003a\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072C\u006f\u006f\u0072\u0064\u0069\u006e\u0061\u0074\u0065")
		return nil, ErrRequiredAttributeMissing
	}
	_eaaaa, _dcdefa := _cbag.(*_agf.PdfObjectInteger)
	if !_dcdefa {
		_fd.Log.Debug("\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006f\u0072\u0064\u0069\u006e\u0061\u0074\u0065\u0020\u006eo\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", _cbag)
		return nil, _agf.ErrTypeError
	}
	_begfc.BitsPerCoordinate = _eaaaa
	_cbag = _egfdf.Get("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074")
	if _cbag == nil {
		_fd.Log.Debug("\u0052e\u0071\u0075i\u0072\u0065\u0064\u0020a\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u0020\u006d\u0069\u0073\u0073in\u0067\u003a\u0020B\u0069\u0074s\u0050\u0065\u0072\u0043\u006f\u006dp\u006f\u006ee\u006e\u0074")
		return nil, ErrRequiredAttributeMissing
	}
	_eaaaa, _dcdefa = _cbag.(*_agf.PdfObjectInteger)
	if !_dcdefa {
		_fd.Log.Debug("B\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065r \u0028\u0067\u006ft\u0020%\u0054\u0029", _cbag)
		return nil, _agf.ErrTypeError
	}
	_begfc.BitsPerComponent = _eaaaa
	_cbag = _egfdf.Get("B\u0069\u0074\u0073\u0050\u0065\u0072\u0046\u006c\u0061\u0067")
	if _cbag == nil {
		_fd.Log.Debug("\u0052\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u0020\u006di\u0073\u0073\u0069\u006e\u0067\u003a\u0020\u0042\u0069\u0074\u0073\u0050\u0065r\u0046\u006c\u0061\u0067")
		return nil, ErrRequiredAttributeMissing
	}
	_eaaaa, _dcdefa = _cbag.(*_agf.PdfObjectInteger)
	if !_dcdefa {
		_fd.Log.Debug("B\u0069\u0074\u0073\u0050\u0065\u0072F\u006c\u0061\u0067\u0020\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0074e\u0067\u0065\u0072\u0020\u0028\u0067\u006f\u0074\u0020\u0025T\u0029", _cbag)
		return nil, _agf.ErrTypeError
	}
	_begfc.BitsPerComponent = _eaaaa
	_cbag = _egfdf.Get("\u0044\u0065\u0063\u006f\u0064\u0065")
	if _cbag == nil {
		_fd.Log.Debug("\u0052\u0065\u0071ui\u0072\u0065\u0064\u0020\u0061\u0074\u0074\u0072\u0069b\u0075t\u0065 \u006di\u0073\u0073\u0069\u006e\u0067\u003a\u0020\u0044\u0065\u0063\u006f\u0064\u0065")
		return nil, ErrRequiredAttributeMissing
	}
	_eeecb, _dcdefa := _cbag.(*_agf.PdfObjectArray)
	if !_dcdefa {
		_fd.Log.Debug("\u0044\u0065\u0063\u006fd\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072a\u0079\u0020\u0028\u0067\u006f\u0074\u0020%\u0054\u0029", _cbag)
		return nil, _agf.ErrTypeError
	}
	_begfc.Decode = _eeecb
	if _bfafg := _egfdf.Get("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e"); _bfafg != nil {
		_begfc.Function = []PdfFunction{}
		if _eccb, _afbcg := _bfafg.(*_agf.PdfObjectArray); _afbcg {
			for _, _feebd := range _eccb.Elements() {
				_gaadc, _affgg := _ccedb(_feebd)
				if _affgg != nil {
					_fd.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e:\u0020\u0025\u0076", _affgg)
					return nil, _affgg
				}
				_begfc.Function = append(_begfc.Function, _gaadc)
			}
		} else {
			_cdfd, _fdgec := _ccedb(_bfafg)
			if _fdgec != nil {
				_fd.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e:\u0020\u0025\u0076", _fdgec)
				return nil, _fdgec
			}
			_begfc.Function = append(_begfc.Function, _cdfd)
		}
	}
	return &_begfc, nil
}

// PdfActionResetForm represents a resetForm action.
type PdfActionResetForm struct {
	*PdfAction
	Fields _agf.PdfObject
	Flags  _agf.PdfObject
}

func _abef(_cafgg *_agf.PdfObjectDictionary, _dcbc *fontCommon) (*pdfCIDFontType2, error) {
	if _dcbc._bcbfd != "\u0043\u0049\u0044F\u006f\u006e\u0074\u0054\u0079\u0070\u0065\u0032" {
		_fd.Log.Debug("\u0045R\u0052\u004fR\u003a\u0020\u0046\u006fn\u0074\u0020\u0053u\u0062\u0054\u0079\u0070\u0065\u0020\u0021\u003d\u0020CI\u0044\u0046\u006fn\u0074\u0054y\u0070\u0065\u0032\u002e\u0020\u0066o\u006e\u0074=\u0025\u0073", _dcbc)
		return nil, _agf.ErrRangeError
	}
	_fbfac := _badbg(_dcbc)
	_cagef, _dcef := _agf.GetDict(_cafgg.Get("\u0043\u0049\u0044\u0053\u0079\u0073\u0074\u0065\u006d\u0049\u006e\u0066\u006f"))
	if !_dcef {
		_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043I\u0044\u0053\u0079st\u0065\u006d\u0049\u006e\u0066\u006f \u0028\u0052\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0029\u0020\u006d\u0069\u0073\u0073i\u006e\u0067\u002e\u0020\u0066\u006f\u006e\u0074=\u0025\u0073", _dcbc)
		return nil, ErrRequiredAttributeMissing
	}
	_fbfac.CIDSystemInfo = _cagef
	_fbfac.DW = _cafgg.Get("\u0044\u0057")
	_fbfac.W = _cafgg.Get("\u0057")
	_fbfac.DW2 = _cafgg.Get("\u0044\u0057\u0032")
	_fbfac.W2 = _cafgg.Get("\u0057\u0032")
	_fbfac.CIDToGIDMap = _cafgg.Get("C\u0049\u0044\u0054\u006f\u0047\u0049\u0044\u004d\u0061\u0070")
	_fbfac._fgecb = 1000.0
	if _fgbg, _bfdd := _agf.GetNumberAsFloat(_fbfac.DW); _bfdd == nil {
		_fbfac._fgecb = _fgbg
	}
	_aebcf, _fgbe := _ffbba(_fbfac.W)
	if _fgbe != nil {
		return nil, _fgbe
	}
	if _aebcf == nil {
		_aebcf = map[_fcg.CharCode]float64{}
	}
	_fbfac._egaaf = _aebcf
	return _fbfac, nil
}

// GetNumComponents returns the number of input color components, i.e. that are input to the tint transform.
func (_beee *PdfColorspaceDeviceN) GetNumComponents() int { return _beee.ColorantNames.Len() }
func _gfgcd(_gega _aa.StdFont) pdfFontSimple {
	_aafeae := _gega.Descriptor()
	return pdfFontSimple{fontCommon: fontCommon{_bcbfd: "\u0054\u0079\u0070e\u0031", _fccf: _gega.Name()}, _fbgbg: _gega.GetMetricsTable(), _cfggc: &PdfFontDescriptor{FontName: _agf.MakeName(string(_aafeae.Name)), FontFamily: _agf.MakeName(_aafeae.Family), FontWeight: _agf.MakeFloat(float64(_aafeae.Weight)), Flags: _agf.MakeInteger(int64(_aafeae.Flags)), FontBBox: _agf.MakeArrayFromFloats(_aafeae.BBox[:]), ItalicAngle: _agf.MakeFloat(_aafeae.ItalicAngle), Ascent: _agf.MakeFloat(_aafeae.Ascent), Descent: _agf.MakeFloat(_aafeae.Descent), CapHeight: _agf.MakeFloat(_aafeae.CapHeight), XHeight: _agf.MakeFloat(_aafeae.XHeight), StemV: _agf.MakeFloat(_aafeae.StemV), StemH: _agf.MakeFloat(_aafeae.StemH)}, _eebb: _gega.Encoder()}
}
func (_dgddf *PdfWriter) writeBytes(_bfggb []byte) {
	if _dgddf._ccdaa != nil {
		return
	}
	_acde, _ebbfc := _dgddf._eafee.Write(_bfggb)
	_dgddf._fdce += int64(_acde)
	_dgddf._ccdaa = _ebbfc
}

// ImageToRGB convert an indexed image to RGB.
func (_fegd *PdfColorspaceSpecialIndexed) ImageToRGB(img Image) (Image, error) {
	N := _fegd.Base.GetNumComponents()
	if N < 1 {
		return Image{}, _b.Errorf("\u0062\u0061d \u0062\u0061\u0073e\u0020\u0063\u006f\u006cors\u0070ac\u0065\u0020\u004e\u0075\u006d\u0043\u006fmp\u006f\u006e\u0065\u006e\u0074\u0073\u003d%\u0064", N)
	}
	_daec := _ged.NewImageBase(int(img.Width), int(img.Height), 8, N, nil, img._gdga, img._abacg)
	_cbdc := _db.NewReader(img.getBase())
	_cdga := _db.NewWriter(_daec)
	var (
		_bedc  uint32
		_efeb  int
		_bdeaf error
	)
	for {
		_bedc, _bdeaf = _cbdc.ReadSample()
		if _bdeaf == _cf.EOF {
			break
		} else if _bdeaf != nil {
			return img, _bdeaf
		}
		_efeb = int(_bedc)
		_fd.Log.Trace("\u0049\u006ed\u0065\u0078\u0065\u0064\u003a\u0020\u0069\u006e\u0064\u0065\u0078\u003d\u0025\u0064\u0020\u004e\u003d\u0025\u0064\u0020\u006c\u0075t=\u0025\u0064", _efeb, N, len(_fegd._ababg))
		if (_efeb+1)*N > len(_fegd._ababg) {
			_efeb = len(_fegd._ababg)/N - 1
			_fd.Log.Trace("C\u006c\u0069\u0070\u0070in\u0067 \u0074\u006f\u0020\u0069\u006ed\u0065\u0078\u003a\u0020\u0025\u0064", _efeb)
			if _efeb < 0 {
				_fd.Log.Debug("\u0045R\u0052\u004fR\u003a\u0020\u0043a\u006e\u0027\u0074\u0020\u0063\u006c\u0069p\u0020\u0069\u006e\u0064\u0065\u0078.\u0020\u0049\u0073\u0020\u0050\u0044\u0046\u0020\u0066\u0069\u006ce\u0020\u0064\u0061\u006d\u0061\u0067\u0065\u0064\u003f")
				break
			}
		}
		for _eafa := _efeb * N; _eafa < (_efeb+1)*N; _eafa++ {
			if _bdeaf = _cdga.WriteSample(uint32(_fegd._ababg[_eafa])); _bdeaf != nil {
				return img, _bdeaf
			}
		}
	}
	return _fegd.Base.ImageToRGB(_ddgg(&_daec))
}
func (_aaee *DSS) add(_abgdc *[]*_agf.PdfObjectStream, _fef map[string]*_agf.PdfObjectStream, _cbcg [][]byte) ([]*_agf.PdfObjectStream, error) {
	_acd := make([]*_agf.PdfObjectStream, 0, len(_cbcg))
	for _, _abfbe := range _cbcg {
		_ecca, _eceb := _aadgc(_abfbe)
		if _eceb != nil {
			return nil, _eceb
		}
		_gfafe, _egbeg := _fef[string(_ecca)]
		if !_egbeg {
			_gfafe, _eceb = _agf.MakeStream(_abfbe, _agf.NewRawEncoder())
			if _eceb != nil {
				return nil, _eceb
			}
			_fef[string(_ecca)] = _gfafe
			*_abgdc = append(*_abgdc, _gfafe)
		}
		_acd = append(_acd, _gfafe)
	}
	return _acd, nil
}
func (_adabf *LTV) buildCertChain(_bgde, _bdae []*_ed.Certificate) ([]*_ed.Certificate, map[string]*_ed.Certificate, error) {
	_bcacb := map[string]*_ed.Certificate{}
	for _, _eeega := range _bgde {
		_bcacb[_eeega.Subject.CommonName] = _eeega
	}
	_cgbde := _bgde
	for _, _eggeg := range _bdae {
		_dbcae := _eggeg.Subject.CommonName
		if _, _ggfgg := _bcacb[_dbcae]; _ggfgg {
			continue
		}
		_bcacb[_dbcae] = _eggeg
		_cgbde = append(_cgbde, _eggeg)
	}
	if len(_cgbde) == 0 {
		return nil, nil, ErrSignNoCertificates
	}
	var _ecfe error
	for _befb := _cgbde[0]; _befb != nil && !_adabf.CertClient.IsCA(_befb); {
		_adcdb, _acefd := _bcacb[_befb.Issuer.CommonName]
		if !_acefd {
			if _adcdb, _ecfe = _adabf.CertClient.GetIssuer(_befb); _ecfe != nil {
				_fd.Log.Debug("W\u0041\u0052\u004e\u003a\u0020\u0043\u006f\u0075\u006cd\u0020\u006e\u006f\u0074\u0020\u0072\u0065tr\u0069\u0065\u0076\u0065 \u0063\u0065\u0072\u0074\u0069\u0066\u0069\u0063\u0061te\u0020\u0069s\u0073\u0075\u0065\u0072\u003a\u0020\u0025\u0076", _ecfe)
				break
			}
			_bcacb[_befb.Issuer.CommonName] = _adcdb
			_cgbde = append(_cgbde, _adcdb)
		}
		_befb = _adcdb
	}
	return _cgbde, _bcacb, nil
}

// ToPdfObject returns colorspace in a PDF object format [name stream]
func (_dgfc *PdfColorspaceICCBased) ToPdfObject() _agf.PdfObject {
	_acfa := &_agf.PdfObjectArray{}
	_acfa.Append(_agf.MakeName("\u0049\u0043\u0043\u0042\u0061\u0073\u0065\u0064"))
	var _cdge *_agf.PdfObjectStream
	if _dgfc._gbcdd != nil {
		_cdge = _dgfc._gbcdd
	} else {
		_cdge = &_agf.PdfObjectStream{}
	}
	_bbgff := _agf.MakeDict()
	_bbgff.Set("\u004e", _agf.MakeInteger(int64(_dgfc.N)))
	if _dgfc.Alternate != nil {
		_bbgff.Set("\u0041l\u0074\u0065\u0072\u006e\u0061\u0074e", _dgfc.Alternate.ToPdfObject())
	}
	if _dgfc.Metadata != nil {
		_bbgff.Set("\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061", _dgfc.Metadata)
	}
	if _dgfc.Range != nil {
		var _cgec []_agf.PdfObject
		for _, _dbag := range _dgfc.Range {
			_cgec = append(_cgec, _agf.MakeFloat(_dbag))
		}
		_bbgff.Set("\u0052\u0061\u006eg\u0065", _agf.MakeArray(_cgec...))
	}
	_bbgff.Set("\u004c\u0065\u006e\u0067\u0074\u0068", _agf.MakeInteger(int64(len(_dgfc.Data))))
	_cdge.Stream = _dgfc.Data
	_cdge.PdfObjectDictionary = _bbgff
	_acfa.Append(_cdge)
	if _dgfc._cecae != nil {
		_dgfc._cecae.PdfObject = _acfa
		return _dgfc._cecae
	}
	return _acfa
}

// WriteToFile writes the Appender output to file specified by path.
func (_bceb *PdfAppender) WriteToFile(outputPath string) error {
	_gfdf, _cgeg := _fb.Create(outputPath)
	if _cgeg != nil {
		return _cgeg
	}
	defer _gfdf.Close()
	return _bceb.Write(_gfdf)
}

// Encoder returns the font's text encoder.
func (_gcff pdfFontType0) Encoder() _fcg.TextEncoder { return _gcff._gccd }

var _ pdfFont = (*pdfFontType3)(nil)

// PdfActionURI represents an URI action.
type PdfActionURI struct {
	*PdfAction
	URI   _agf.PdfObject
	IsMap _agf.PdfObject
}

func (_gdgb *PdfReader) newPdfAnnotationTextFromDict(_eefa *_agf.PdfObjectDictionary) (*PdfAnnotationText, error) {
	_dge := PdfAnnotationText{}
	_agd, _edcg := _gdgb.newPdfAnnotationMarkupFromDict(_eefa)
	if _edcg != nil {
		return nil, _edcg
	}
	_dge.PdfAnnotationMarkup = _agd
	_dge.Open = _eefa.Get("\u004f\u0070\u0065\u006e")
	_dge.Name = _eefa.Get("\u004e\u0061\u006d\u0065")
	_dge.State = _eefa.Get("\u0053\u0074\u0061t\u0065")
	_dge.StateModel = _eefa.Get("\u0053\u0074\u0061\u0074\u0065\u004d\u006f\u0064\u0065\u006c")
	return &_dge, nil
}

// ToPdfObject converts the pdfFontSimple to its PDF representation for outputting.
func (_fbbce *pdfFontSimple) ToPdfObject() _agf.PdfObject {
	if _fbbce._gfbgf == nil {
		_fbbce._gfbgf = &_agf.PdfIndirectObject{}
	}
	_fcgfd := _fbbce.baseFields().asPdfObjectDictionary("")
	_fbbce._gfbgf.PdfObject = _fcgfd
	if _fbbce.FirstChar != nil {
		_fcgfd.Set("\u0046i\u0072\u0073\u0074\u0043\u0068\u0061r", _fbbce.FirstChar)
	}
	if _fbbce.LastChar != nil {
		_fcgfd.Set("\u004c\u0061\u0073\u0074\u0043\u0068\u0061\u0072", _fbbce.LastChar)
	}
	if _fbbce.Widths != nil {
		_fcgfd.Set("\u0057\u0069\u0064\u0074\u0068\u0073", _fbbce.Widths)
	}
	if _fbbce.Encoding != nil {
		_fcgfd.Set("\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067", _fbbce.Encoding)
	} else if _fbbce._dbgde != nil {
		_cdefc := _fbbce._dbgde.ToPdfObject()
		if _cdefc != nil {
			_fcgfd.Set("\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067", _cdefc)
		}
	}
	return _fbbce._gfbgf
}
func (_daagc fontCommon) isCIDFont() bool {
	if _daagc._bcbfd == "" {
		_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052:\u0020\u0069\u0073\u0043\u0049\u0044\u0046\u006f\u006e\u0074\u002e\u0020\u0063o\u006e\u0074\u0065\u0078\u0074\u0020\u0069\u0073\u0020\u006e\u0069\u006c\u002e\u0020\u0066\u006f\u006e\u0074\u003d\u0025\u0073", _daagc)
	}
	_fagfd := false
	switch _daagc._bcbfd {
	case "\u0054\u0079\u0070e\u0030", "\u0043\u0049\u0044F\u006f\u006e\u0074\u0054\u0079\u0070\u0065\u0030", "\u0043\u0049\u0044F\u006f\u006e\u0074\u0054\u0079\u0070\u0065\u0032":
		_fagfd = true
	}
	_fd.Log.Trace("i\u0073\u0043\u0049\u0044\u0046\u006fn\u0074\u003a\u0020\u0069\u0073\u0043\u0049\u0044\u003d%\u0074\u0020\u0066o\u006et\u003d\u0025\u0073", _fagfd, _daagc)
	return _fagfd
}

// NewPdfColorspaceDeviceGray returns a new grayscale colorspace.
func NewPdfColorspaceDeviceGray() *PdfColorspaceDeviceGray { return &PdfColorspaceDeviceGray{} }
func (_bbdgg *PdfColorspaceICCBased) String() string {
	return "\u0049\u0043\u0043\u0042\u0061\u0073\u0065\u0064"
}

// Initialize initializes the PdfSignature.
func (_agfeec *PdfSignature) Initialize() error {
	if _agfeec.Handler == nil {
		return _gcd.New("\u0073\u0069\u0067n\u0061\u0074\u0075\u0072e\u0020\u0068\u0061\u006e\u0064\u006c\u0065r\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c")
	}
	return _agfeec.Handler.InitSignature(_agfeec)
}

// ToPdfObject sets the common field elements.
// Note: Call the more field context's ToPdfObject to set both the generic and
// non-generic information.
func (_badc *PdfField) ToPdfObject() _agf.PdfObject {
	_cea := _badc._fcgcc
	_bgae := _cea.PdfObject.(*_agf.PdfObjectDictionary)
	_bffb := _agf.MakeArray()
	for _, _afdf := range _badc.Kids {
		_bffb.Append(_afdf.ToPdfObject())
	}
	for _, _dfdf := range _badc.Annotations {
		if _dfdf._aeee != _badc._fcgcc {
			_bffb.Append(_dfdf.GetContext().ToPdfObject())
		}
	}
	if _badc.Parent != nil {
		_bgae.SetIfNotNil("\u0050\u0061\u0072\u0065\u006e\u0074", _badc.Parent.GetContainingPdfObject())
	}
	if _bffb.Len() > 0 {
		_bgae.Set("\u004b\u0069\u0064\u0073", _bffb)
	}
	_bgae.SetIfNotNil("\u0046\u0054", _badc.FT)
	_bgae.SetIfNotNil("\u0054", _badc.T)
	_bgae.SetIfNotNil("\u0054\u0055", _badc.TU)
	_bgae.SetIfNotNil("\u0054\u004d", _badc.TM)
	_bgae.SetIfNotNil("\u0046\u0066", _badc.Ff)
	_bgae.SetIfNotNil("\u0056", _badc.V)
	_bgae.SetIfNotNil("\u0044\u0056", _badc.DV)
	_bgae.SetIfNotNil("\u0041\u0041", _badc.AA)
	if _badc.VariableText != nil {
		_bgae.SetIfNotNil("\u0044\u0041", _badc.VariableText.DA)
		_bgae.SetIfNotNil("\u0051", _badc.VariableText.Q)
		_bgae.SetIfNotNil("\u0044\u0053", _badc.VariableText.DS)
		_bgae.SetIfNotNil("\u0052\u0056", _badc.VariableText.RV)
	}
	return _cea
}

// PdfModel is a higher level PDF construct which can be collapsed into a PdfObject.
// Each PdfModel has an underlying PdfObject and vice versa (one-to-one).
// Under normal circumstances there should only be one copy of each.
// Copies can be made, but care must be taken to do it properly.
type PdfModel interface {
	ToPdfObject() _agf.PdfObject
	GetContainingPdfObject() _agf.PdfObject
}

// StandardImplementer is an interface that defines specified PDF standards like PDF/A-1A (pdfa.Profile1A)
// NOTE: This implementation is in experimental development state.
//
//	Keep in mind that it might change in the subsequent minor versions.
type StandardImplementer interface {
	StandardValidator
	StandardApplier

	// StandardName gets the human-readable name of the standard.
	StandardName() string
}

// PdfColorspaceCalGray represents CalGray color space.
type PdfColorspaceCalGray struct {
	WhitePoint []float64
	BlackPoint []float64
	Gamma      float64
	_gec       *_agf.PdfIndirectObject
}

// NewPdfActionGoTo3DView returns a new "goTo3DView" action.
func NewPdfActionGoTo3DView() *PdfActionGoTo3DView {
	_dfg := NewPdfAction()
	_afe := &PdfActionGoTo3DView{}
	_afe.PdfAction = _dfg
	_dfg.SetContext(_afe)
	return _afe
}
func (_dgbgc *PdfWriter) flushWriter() error {
	if _dgbgc._ccdaa == nil {
		_dgbgc._ccdaa = _dgbgc._eafee.Flush()
	}
	return _dgbgc._ccdaa
}

// GetContainingPdfObject implements interface PdfModel.
func (_eacg *Permissions) GetContainingPdfObject() _agf.PdfObject { return _eacg._gebec }

// GetMediaBox gets the inheritable media box value, either from the page
// or a higher up page/pages struct.
func (_fdgc *PdfPage) GetMediaBox() (*PdfRectangle, error) {
	if _fdgc.MediaBox != nil {
		return _fdgc.MediaBox, nil
	}
	_dgaf := _fdgc.Parent
	for _dgaf != nil {
		_gfdcdd, _ddgbg := _agf.GetDict(_dgaf)
		if !_ddgbg {
			return nil, _gcd.New("\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u006f\u0062\u006a\u0065\u0063t\u0073\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079")
		}
		if _dcbfg := _gfdcdd.Get("\u004d\u0065\u0064\u0069\u0061\u0042\u006f\u0078"); _dcbfg != nil {
			_efaeb, _fdgea := _agf.GetArray(_dcbfg)
			if !_fdgea {
				return nil, _gcd.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006d\u0065\u0064\u0069a\u0020\u0062\u006f\u0078")
			}
			_bfdag, _bgcae := NewPdfRectangle(*_efaeb)
			if _bgcae != nil {
				return nil, _bgcae
			}
			return _bfdag, nil
		}
		_dgaf = _gfdcdd.Get("\u0050\u0061\u0072\u0065\u006e\u0074")
	}
	return nil, _gcd.New("m\u0065\u0064\u0069\u0061 b\u006fx\u0020\u006e\u006f\u0074\u0020d\u0065\u0066\u0069\u006e\u0065\u0064")
}

// NewPdfAnnotationTrapNet returns a new trapnet annotation.
func NewPdfAnnotationTrapNet() *PdfAnnotationTrapNet {
	_cfd := NewPdfAnnotation()
	_bagf := &PdfAnnotationTrapNet{}
	_bagf.PdfAnnotation = _cfd
	_cfd.SetContext(_bagf)
	return _bagf
}

// DecodeArray returns the range of color component values in the ICCBased colorspace.
func (_agbef *PdfColorspaceICCBased) DecodeArray() []float64 { return _agbef.Range }
func _fcdge() string {
	_ecba.Lock()
	defer _ecba.Unlock()
	_aecaf := _ede.GetLicenseKey()
	if len(_badad) > 0 && (_aecaf.IsLicensed() || _aecab) {
		return _badad
	}
	return _b.Sprintf("\u0055\u006e\u0069Do\u0063\u0020\u0076\u0025\u0073\u0020\u0028\u0025\u0073)\u0020-\u0020h\u0074t\u0070\u003a\u002f\u002f\u0075\u006e\u0069\u0064\u006f\u0063\u002e\u0069\u006f", _ccfac(), _aecaf.TypeToString())
}

// ToPdfObject converts the PdfPage to a dictionary within an indirect object container.
func (_abbedg *PdfPage) ToPdfObject() _agf.PdfObject {
	_eebage := _abbedg._edegf
	_abbedg.GetPageDict()
	return _eebage
}

// GetAsShadingPattern returns a shading pattern. Check with IsShading() prior to using this.
func (_cdabd *PdfPattern) GetAsShadingPattern() *PdfShadingPattern {
	return _cdabd._dfed.(*PdfShadingPattern)
}

// Encoder returns the font's text encoder.
func (_gcdff pdfCIDFontType2) Encoder() _fcg.TextEncoder { return _gcdff._cfbd }

// PdfFunctionType3 defines stitching of the subdomains of several 1-input functions to produce
// a single new 1-input function.
type PdfFunctionType3 struct {
	Domain    []float64
	Range     []float64
	Functions []PdfFunction
	Bounds    []float64
	Encode    []float64
	_gbgd     *_agf.PdfIndirectObject
}

// Encoder returns the font's text encoder.
func (_dfbdec pdfCIDFontType0) Encoder() _fcg.TextEncoder { return _dfbdec._aaef }

// ToGray returns a PdfColorDeviceGray color based on the current RGB color.
func (_edfd *PdfColorDeviceRGB) ToGray() *PdfColorDeviceGray {
	_ebeg := 0.3*_edfd.R() + 0.59*_edfd.G() + 0.11*_edfd.B()
	_ebeg = _afb.Min(_afb.Max(_ebeg, 0.0), 1.0)
	return NewPdfColorDeviceGray(_ebeg)
}

// NewPdfAction returns an initialized generic PDF action model.
func NewPdfAction() *PdfAction {
	_bc := &PdfAction{}
	_bc._caf = _agf.MakeIndirectObject(_agf.MakeDict())
	return _bc
}

// GetXHeight returns the XHeight of the font `descriptor`.
func (_adac *PdfFontDescriptor) GetXHeight() (float64, error) {
	return _agf.GetNumberAsFloat(_adac.XHeight)
}

// PdfOutlineTreeNode contains common fields used by the outline and outline
// item objects.
type PdfOutlineTreeNode struct {
	_cgaaa interface{}
	First  *PdfOutlineTreeNode
	Last   *PdfOutlineTreeNode
}

func (_fgdaa *PdfReader) buildPageList(_dbfcc *_agf.PdfIndirectObject, _ffea *_agf.PdfIndirectObject, _acdbd map[_agf.PdfObject]struct{}) error {
	if _dbfcc == nil {
		return nil
	}
	if _, _ddabc := _acdbd[_dbfcc]; _ddabc {
		_fd.Log.Debug("\u0043\u0079\u0063l\u0069\u0063\u0020\u0072e\u0063\u0075\u0072\u0073\u0069\u006f\u006e,\u0020\u0073\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u0020\u0028\u0025\u0076\u0029", _dbfcc.ObjectNumber)
		return nil
	}
	_acdbd[_dbfcc] = struct{}{}
	_afbbd, _dceac := _dbfcc.PdfObject.(*_agf.PdfObjectDictionary)
	if !_dceac {
		return _gcd.New("n\u006f\u0064\u0065\u0020no\u0074 \u0061\u0020\u0064\u0069\u0063t\u0069\u006f\u006e\u0061\u0072\u0079")
	}
	_bcbdc, _dceac := (*_afbbd).Get("\u0054\u0079\u0070\u0065").(*_agf.PdfObjectName)
	if !_dceac {
		if _afbbd.Get("\u004b\u0069\u0064\u0073") == nil {
			return _gcd.New("\u006e\u006f\u0064\u0065 \u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0054\u0079p\u0065 \u0028\u0052\u0065\u0071\u0075\u0069\u0072e\u0064\u0029")
		}
		_fd.Log.Debug("ER\u0052\u004fR\u003a\u0020\u006e\u006f\u0064\u0065\u0020\u006d\u0069s\u0073\u0069\u006e\u0067\u0020\u0054\u0079\u0070\u0065\u002c\u0020\u0062\u0075\u0074\u0020\u0068\u0061\u0073\u0020\u004b\u0069\u0064\u0073\u002e\u0020\u0041\u0073\u0073u\u006di\u006e\u0067\u0020\u0050\u0061\u0067\u0065\u0073 \u006eo\u0064\u0065.")
		_bcbdc = _agf.MakeName("\u0050\u0061\u0067e\u0073")
		_afbbd.Set("\u0054\u0079\u0070\u0065", _bcbdc)
	}
	_fd.Log.Trace("\u0062\u0075\u0069\u006c\u0064\u0050a\u0067\u0065\u004c\u0069\u0073\u0074\u0020\u006e\u006f\u0064\u0065\u0020\u0074y\u0070\u0065\u003a\u0020\u0025\u0073\u0020(\u0025\u002b\u0076\u0029", *_bcbdc, _dbfcc)
	if *_bcbdc == "\u0050\u0061\u0067\u0065" {
		_geedcc, _dgfaf := _fgdaa.newPdfPageFromDict(_afbbd)
		if _dgfaf != nil {
			return _dgfaf
		}
		_geedcc.setContainer(_dbfcc)
		if _ffea != nil {
			_afbbd.Set("\u0050\u0061\u0072\u0065\u006e\u0074", _ffea)
		}
		_fgdaa._eddcd = append(_fgdaa._eddcd, _dbfcc)
		_fgdaa.PageList = append(_fgdaa.PageList, _geedcc)
		return nil
	}
	if *_bcbdc != "\u0050\u0061\u0067e\u0073" {
		_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0063\u006fnt\u0065n\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067 \u006e\u006f\u006e\u0020\u0050\u0061\u0067\u0065\u002f\u0050\u0061\u0067\u0065\u0073\u0020\u006f\u0062j\u0065\u0063\u0074\u0021\u0020\u0028\u0025\u0073\u0029", _bcbdc)
		return _gcd.New("\u0074\u0061\u0062\u006c\u0065\u0020o\u0066\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067 \u006e\u006f\u006e\u0020\u0050\u0061\u0067\u0065\u002f\u0050\u0061\u0067\u0065\u0073 \u006fb\u006a\u0065\u0063\u0074")
	}
	if _ffea != nil {
		_afbbd.Set("\u0050\u0061\u0072\u0065\u006e\u0074", _ffea)
	}
	if !_fgdaa._ccage {
		_dfbf := _fgdaa.traverseObjectData(_dbfcc)
		if _dfbf != nil {
			return _dfbf
		}
	}
	_gaega, _cegdb := _fgdaa._egdga.Resolve(_afbbd.Get("\u004b\u0069\u0064\u0073"))
	if _cegdb != nil {
		_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u0061\u0064\u0069\u006eg\u0020\u004b\u0069\u0064\u0073\u0020\u006fb\u006a\u0065\u0063\u0074")
		return _cegdb
	}
	var _gcffc *_agf.PdfObjectArray
	_gcffc, _dceac = _gaega.(*_agf.PdfObjectArray)
	if !_dceac {
		_cefeb, _gbaaa := _gaega.(*_agf.PdfIndirectObject)
		if !_gbaaa {
			return _gcd.New("\u0069\u006e\u0076\u0061li\u0064\u0020\u004b\u0069\u0064\u0073\u0020\u006f\u0062\u006a\u0065\u0063\u0074")
		}
		_gcffc, _dceac = _cefeb.PdfObject.(*_agf.PdfObjectArray)
		if !_dceac {
			return _gcd.New("\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u004b\u0069\u0064\u0073\u0020\u0069\u006ed\u0069r\u0065\u0063\u0074\u0020\u006f\u0062\u006ae\u0063\u0074")
		}
	}
	_fd.Log.Trace("\u004b\u0069\u0064\u0073\u003a\u0020\u0025\u0073", _gcffc)
	for _afgfg, _gedgf := range _gcffc.Elements() {
		_dbadfa, _bddcga := _agf.GetIndirect(_gedgf)
		if !_bddcga {
			_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0050\u0061\u0067\u0065\u0020\u006e\u006f\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074 \u006f\u0062\u006a\u0065\u0063t\u0020\u002d \u0028\u0025\u0073\u0029", _dbadfa)
			return _gcd.New("\u0070a\u0067\u0065\u0020\u006e\u006f\u0074\u0020\u0069\u006e\u0064\u0069r\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074")
		}
		_gcffc.Set(_afgfg, _dbadfa)
		_cegdb = _fgdaa.buildPageList(_dbadfa, _dbfcc, _acdbd)
		if _cegdb != nil {
			return _cegdb
		}
	}
	return nil
}

// NewPdfRectangle creates a PDF rectangle object based on an input array of 4 integers.
// Defining the lower left (LL) and upper right (UR) corners with
// floating point numbers.
func NewPdfRectangle(arr _agf.PdfObjectArray) (*PdfRectangle, error) {
	_gaegb := PdfRectangle{}
	if arr.Len() != 4 {
		return nil, _gcd.New("\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0072\u0065\u0063\u0074\u0061\u006e\u0067\u006c\u0065\u0020\u0061\u0072r\u0061\u0079\u002c\u0020\u006c\u0065\u006e \u0021\u003d\u0020\u0034")
	}
	var _gada error
	_gaegb.Llx, _gada = _agf.GetNumberAsFloat(arr.Get(0))
	if _gada != nil {
		return nil, _gada
	}
	_gaegb.Lly, _gada = _agf.GetNumberAsFloat(arr.Get(1))
	if _gada != nil {
		return nil, _gada
	}
	_gaegb.Urx, _gada = _agf.GetNumberAsFloat(arr.Get(2))
	if _gada != nil {
		return nil, _gada
	}
	_gaegb.Ury, _gada = _agf.GetNumberAsFloat(arr.Get(3))
	if _gada != nil {
		return nil, _gada
	}
	return &_gaegb, nil
}
func (_gaff *PdfFont) baseFields() *fontCommon {
	if _gaff._effaa == nil {
		_fd.Log.Debug("\u0045\u0052\u0052OR\u003a\u0020\u0062\u0061\u0073\u0065\u0046\u0069\u0065l\u0064s\u002e \u0063o\u006e\u0074\u0065\u0078\u0074\u0020\u0069\u0073\u0020\u006e\u0069\u006c\u002e")
		return nil
	}
	return _gaff._effaa.baseFields()
}

// SetSubtype sets the Subtype S for given PdfOutputIntent.
func (_egcd *PdfOutputIntent) SetSubtype(subtype PdfOutputIntentType) error {
	if !subtype.IsValid() {
		return _gcd.New("\u0070\u0072o\u0076\u0069\u0064\u0065d\u0020\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u004f\u0075t\u0070\u0075\u0074\u0049\u006e\u0074\u0065\u006e\u0074\u0020\u0053\u0075b\u0054\u0079\u0070\u0065")
	}
	_egcd.S = subtype
	return nil
}

// GetPdfInfo returns the PDF info dictionary.
func (_gbbbb *PdfReader) GetPdfInfo() (*PdfInfo, error) {
	_fbdbf, _fabgb := _gbbbb.GetTrailer()
	if _fabgb != nil {
		return nil, _fabgb
	}
	var _ebbbe *_agf.PdfObjectDictionary
	_aeeea := _fbdbf.Get("\u0049\u006e\u0066\u006f")
	switch _gbgda := _aeeea.(type) {
	case *_agf.PdfObjectReference:
		_eddca := _gbgda
		_aeeea, _fabgb = _gbbbb.GetIndirectObjectByNumber(int(_eddca.ObjectNumber))
		_aeeea = _agf.TraceToDirectObject(_aeeea)
		if _fabgb != nil {
			return nil, _fabgb
		}
		_ebbbe, _ = _aeeea.(*_agf.PdfObjectDictionary)
	case *_agf.PdfObjectDictionary:
		_ebbbe = _gbgda
	}
	if _ebbbe == nil {
		return nil, _gcd.New("I\u006e\u0066\u006f\u0020\u0064\u0069c\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006eo\u0074\u0020\u0070r\u0065s\u0065\u006e\u0074")
	}
	_aege, _fabgb := NewPdfInfoFromObject(_ebbbe)
	if _fabgb != nil {
		return nil, _fabgb
	}
	return _aege, nil
}
func (_abdac *PdfWriter) getPdfVersion() string {
	return _b.Sprintf("\u0025\u0064\u002e%\u0064", _abdac._bcdfgg.Major, _abdac._bcdfgg.Minor)
}

// NewStandard14Font returns the standard 14 font named `basefont` as a *PdfFont, or an error if it
// `basefont` is not one of the standard 14 font names.
func NewStandard14Font(basefont StdFontName) (*PdfFont, error) {
	_gfggg, _adfae := _egag(basefont)
	if _adfae != nil {
		return nil, _adfae
	}
	if basefont != SymbolName && basefont != ZapfDingbatsName {
		_gfggg._dbgde = _fcg.NewWinAnsiEncoder()
	}
	return &PdfFont{_effaa: &_gfggg}, nil
}

// PdfColorDeviceCMYK is a CMYK32 color, where each component is defined in the range 0.0 - 1.0 where 1.0 is the primary intensity.
type PdfColorDeviceCMYK [4]float64

// DecodeArray returns the range of color component values in CalGray colorspace.
func (_gbagg *PdfColorspaceCalGray) DecodeArray() []float64 { return []float64{0.0, 1.0} }

// Sign signs a specific page with a digital signature.
// The signature field parameter must have a valid signature dictionary
// specified by its V field.
func (_efgd *PdfAppender) Sign(pageNum int, field *PdfFieldSignature) error {
	if field == nil {
		return _gcd.New("\u0073\u0069g\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065 n\u0069\u006c")
	}
	_fbgf := field.V
	if _fbgf == nil {
		return _gcd.New("\u0073\u0069\u0067na\u0074\u0075\u0072\u0065\u0020\u0064\u0069\u0063\u0074i\u006fn\u0061r\u0079 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c")
	}
	_gafcg := pageNum - 1
	if _gafcg < 0 || _gafcg > len(_efgd._dfaf)-1 {
		return _b.Errorf("\u0070\u0061\u0067\u0065\u0020\u0025\u0064\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064", pageNum)
	}
	_dage := _efgd.Reader.PageList[_gafcg]
	field.P = _dage.ToPdfObject()
	if field.T == nil || field.T.String() == "" {
		field.T = _agf.MakeString(_b.Sprintf("\u0053\u0069\u0067n\u0061\u0074\u0075\u0072\u0065\u0020\u0025\u0064", pageNum))
	}
	_dage.AddAnnotation(field.PdfAnnotationWidget.PdfAnnotation)
	if _efgd._edcb == _efgd._gdeb.AcroForm {
		_efgd._edcb = _efgd.Reader.AcroForm
	}
	_fdfg := _efgd._edcb
	if _fdfg == nil {
		_fdfg = NewPdfAcroForm()
	}
	_fdfg.SigFlags = _agf.MakeInteger(3)
	_aeac := append(_fdfg.AllFields(), field.PdfField)
	_fdfg.Fields = &_aeac
	_efgd.ReplaceAcroForm(_fdfg)
	_efgd.UpdatePage(_dage)
	_efgd._dfaf[_gafcg] = _dage
	if _, _gddbb := field.V.GetDocMDPPermission(); _gddbb {
		_efgd._cfcg = NewPermissions(field.V)
	}
	return nil
}

// ReaderOpts defines options for creating PdfReader instances.
type ReaderOpts struct {

	// Password password of the PDF file encryption.
	// Default: empty ("").
	Password string

	// LazyLoad set if the PDF file would be loaded using lazy-loading mode.
	// Default: true.
	LazyLoad bool

	// ComplianceMode set if parsed PDF file should contain meta information for the verifiers of the compliance standards like PDF/A.
	ComplianceMode bool
}

// PdfColorspaceDeviceRGB represents an RGB colorspace.
type PdfColorspaceDeviceRGB struct{}

// Val returns the color value.
func (_fedb *PdfColorDeviceGray) Val() float64 { return float64(*_fedb) }

// ColorFromPdfObjects gets the color from a series of pdf objects (4 for cmyk).
func (_eaddf *PdfColorspaceDeviceCMYK) ColorFromPdfObjects(objects []_agf.PdfObject) (PdfColor, error) {
	if len(objects) != 4 {
		return nil, _gcd.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_addb, _dgcc := _agf.GetNumbersAsFloat(objects)
	if _dgcc != nil {
		return nil, _dgcc
	}
	return _eaddf.ColorFromFloats(_addb)
}

// AddImageResource adds an image to the XObject resources.
func (_afdcf *PdfPage) AddImageResource(name _agf.PdfObjectName, ximg *XObjectImage) error {
	var _dcddg *_agf.PdfObjectDictionary
	if _afdcf.Resources.XObject == nil {
		_dcddg = _agf.MakeDict()
		_afdcf.Resources.XObject = _dcddg
	} else {
		var _ccbff bool
		_dcddg, _ccbff = (_afdcf.Resources.XObject).(*_agf.PdfObjectDictionary)
		if !_ccbff {
			return _gcd.New("\u0069\u006e\u0076\u0061li\u0064\u0020\u0078\u0072\u0065\u0073\u0020\u0064\u0069\u0063\u0074\u0020\u0074\u0079p\u0065")
		}
	}
	_dcddg.Set(name, ximg.ToPdfObject())
	return nil
}
func (_dgcde *PdfReader) loadForms() (*PdfAcroForm, error) {
	if _dgcde._egdga.GetCrypter() != nil && !_dgcde._egdga.IsAuthenticated() {
		return nil, _b.Errorf("\u0066\u0069\u006ce\u0020\u006e\u0065\u0065d\u0020\u0074\u006f\u0020\u0062\u0065\u0020d\u0065\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0020\u0066\u0069\u0072\u0073\u0074")
	}
	_dgacd := _dgcde._ceaadd
	_acca := _dgacd.Get("\u0041\u0063\u0072\u006f\u0046\u006f\u0072\u006d")
	if _acca == nil {
		return nil, nil
	}
	_egagf, _bbabc := _agf.GetIndirect(_acca)
	_acca = _agf.TraceToDirectObject(_acca)
	if _agf.IsNullObject(_acca) {
		_fd.Log.Trace("\u0041\u0063\u0072of\u006f\u0072\u006d\u0020\u0069\u0073\u0020\u0061\u0020n\u0075l\u006c \u006fb\u006a\u0065\u0063\u0074\u0020\u0028\u0065\u006d\u0070\u0074\u0079\u0029\u000a")
		return nil, nil
	}
	_dedb, _gdcag := _agf.GetDict(_acca)
	if !_gdcag {
		_fd.Log.Debug("\u0049n\u0076\u0061\u006c\u0069d\u0020\u0041\u0063\u0072\u006fF\u006fr\u006d \u0065\u006e\u0074\u0072\u0079\u0020\u0025T", _acca)
		_fd.Log.Debug("\u0044\u006f\u0065\u0073 n\u006f\u0074\u0020\u0068\u0061\u0076\u0065\u0020\u0066\u006f\u0072\u006d\u0073")
		return nil, _b.Errorf("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0061\u0063\u0072\u006ff\u006fr\u006d \u0065\u006e\u0074\u0072\u0079\u0020\u0025T", _acca)
	}
	_fd.Log.Trace("\u0048\u0061\u0073\u0020\u0041\u0063\u0072\u006f\u0020f\u006f\u0072\u006d\u0073")
	_fd.Log.Trace("\u0054\u0072\u0061\u0076\u0065\u0072\u0073\u0065\u0020\u0074\u0068\u0065\u0020\u0041\u0063r\u006ff\u006f\u0072\u006d\u0073\u0020\u0073\u0074\u0072\u0075\u0063\u0074\u0075\u0072\u0065")
	if !_dgcde._ccage {
		_ggafg := _dgcde.traverseObjectData(_dedb)
		if _ggafg != nil {
			_fd.Log.Debug("E\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0074\u0072a\u0076\u0065\u0072\u0073\u0065\u0020\u0041\u0063\u0072\u006fFo\u0072\u006d\u0073 \u0028%\u0073\u0029", _ggafg)
			return nil, _ggafg
		}
	}
	_ecaea, _abgbe := _dgcde.newPdfAcroFormFromDict(_egagf, _dedb)
	if _abgbe != nil {
		return nil, _abgbe
	}
	_ecaea._agfed = !_bbabc
	return _ecaea, nil
}

// PdfAnnotationCaret represents Caret annotations.
// (Section 12.5.6.11).
type PdfAnnotationCaret struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	RD _agf.PdfObject
	Sy _agf.PdfObject
}

// GetContainingPdfObject returns the container of the outline item (indirect object).
func (_becf *PdfOutlineItem) GetContainingPdfObject() _agf.PdfObject { return _becf._dbac }

// GetNumComponents returns the number of color components (1 for CalGray).
func (_dcgb *PdfColorCalGray) GetNumComponents() int { return 1 }

// PdfColorspaceSpecialPattern is a Pattern colorspace.
// Can be defined either as /Pattern or with an underlying colorspace [/Pattern cs].
type PdfColorspaceSpecialPattern struct {
	UnderlyingCS PdfColorspace
	_eecg        *_agf.PdfIndirectObject
}

func (_fccab *fontFile) loadFromSegments(_cbede, _ffec []byte) error {
	_fd.Log.Trace("\u006c\u006f\u0061dF\u0072\u006f\u006d\u0053\u0065\u0067\u006d\u0065\u006e\u0074\u0073\u003a\u0020\u0025\u0064\u0020\u0025\u0064", len(_cbede), len(_ffec))
	_cdfgb := _fccab.parseASCIIPart(_cbede)
	if _cdfgb != nil {
		return _cdfgb
	}
	_fd.Log.Trace("f\u006f\u006e\u0074\u0066\u0069\u006c\u0065\u003d\u0025\u0073", _fccab)
	if len(_ffec) == 0 {
		return nil
	}
	_fd.Log.Trace("f\u006f\u006e\u0074\u0066\u0069\u006c\u0065\u003d\u0025\u0073", _fccab)
	return nil
}

// ColorFromFloats returns a new PdfColor based on the input slice of color
// components. The slice should contain three elements representing the
// A, B and C components of the color. The values of the elements should be
// between 0 and 1.
func (_eefag *PdfColorspaceCalRGB) ColorFromFloats(vals []float64) (PdfColor, error) {
	if len(vals) != 3 {
		return nil, _gcd.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_eebac := vals[0]
	if _eebac < 0.0 || _eebac > 1.0 {
		_fd.Log.Debug("\u0063\u006f\u006cor\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0043\u0053\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020", _eebac)
		return nil, ErrColorOutOfRange
	}
	_fbfg := vals[1]
	if _fbfg < 0.0 || _fbfg > 1.0 {
		_fd.Log.Debug("\u0063\u006f\u006cor\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0043\u0053\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020", _fbfg)
		return nil, ErrColorOutOfRange
	}
	_bgebe := vals[2]
	if _bgebe < 0.0 || _bgebe > 1.0 {
		_fd.Log.Debug("\u0063\u006f\u006cor\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0043\u0053\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020", _bgebe)
		return nil, ErrColorOutOfRange
	}
	_gfgge := NewPdfColorCalRGB(_eebac, _fbfg, _bgebe)
	return _gfgge, nil
}

// Enable LTV enables the specified signature. The signing certificate
// chain is extracted from the signature dictionary. Optionally, additional
// certificates can be specified through the `extraCerts` parameter.
// The LTV client attempts to build the certificate chain up to a trusted root
// by downloading any missing certificates.
func (_fdddb *LTV) Enable(sig *PdfSignature, extraCerts []*_ed.Certificate) error {
	if _abgaf := _fdddb.validateSig(sig); _abgaf != nil {
		return _abgaf
	}
	_eggg, _dbcee := _fdddb.generateVRIKey(sig)
	if _dbcee != nil {
		return _dbcee
	}
	if _, _cbgcc := _fdddb._cbbe.VRI[_eggg]; _cbgcc && _fdddb.SkipExisting {
		return nil
	}
	_bcdbc, _dbcee := sig.GetCerts()
	if _dbcee != nil {
		return _dbcee
	}
	return _fdddb.enable(_bcdbc, extraCerts, _eggg)
}
func _dcgae(_cbac *PdfAnnotation) (*XObjectForm, *PdfRectangle, error) {
	_cbfg, _fbac := _agf.GetDict(_cbac.AP)
	if !_fbac {
		return nil, nil, _gcd.New("f\u0069\u0065\u006c\u0064\u0020\u006di\u0073\u0073\u0069\u006e\u0067\u0020\u0041\u0050\u0020d\u0069\u0063\u0074i\u006fn\u0061\u0072\u0079")
	}
	if _cbfg == nil {
		return nil, nil, nil
	}
	_bfdgg, _fbac := _agf.GetArray(_cbac.Rect)
	if !_fbac || _bfdgg.Len() != 4 {
		return nil, nil, _gcd.New("\u0072\u0065\u0063t\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064")
	}
	_faba, _bdebe := NewPdfRectangle(*_bfdgg)
	if _bdebe != nil {
		return nil, nil, _bdebe
	}
	_dbgb := _agf.TraceToDirectObject(_cbfg.Get("\u004e"))
	switch _gabb := _dbgb.(type) {
	case *_agf.PdfObjectStream:
		_ebeda := _gabb
		_abdb, _edafd := NewXObjectFormFromStream(_ebeda)
		return _abdb, _faba, _edafd
	case *_agf.PdfObjectDictionary:
		_fgdae := _gabb
		_acda, _egaa := _agf.GetName(_cbac.AS)
		if !_egaa {
			return nil, nil, nil
		}
		if _fgdae.Get(*_acda) == nil {
			_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052:\u0020\u0041\u0053\u0020\u0073\u0074\u0061\u0074\u0065\u0020\u006e\u006f\u0074 \u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064\u0020\u0069\u006e\u0020\u0041\u0050\u0020\u0064\u0069\u0063\u0074\u0020\u002d\u0020\u0069\u0067\u006e\u006f\u0072\u0069\u006eg")
			return nil, nil, nil
		}
		_cega, _egaa := _agf.GetStream(_fgdae.Get(*_acda))
		if !_egaa {
			_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0055n\u0061\u0062\u006ce \u0074\u006f\u0020\u0061\u0063\u0063e\u0073\u0073\u0020\u0061\u0070\u0070\u0065\u0061\u0072\u0061\u006e\u0063\u0065\u0020\u0073t\u0072\u0065\u0061\u006d\u0020\u0066\u006f\u0072 \u0025\u0076", _acda)
			return nil, nil, _gcd.New("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006d\u0069s\u0073\u0069\u006e\u0067")
		}
		_edag, _dafge := NewXObjectFormFromStream(_cega)
		return _edag, _faba, _dafge
	}
	_fd.Log.Debug("\u0049\u006e\u0076\u0061li\u0064\u0020\u0074\u0079\u0070\u0065\u0020\u0066\u006f\u0072\u0020\u004e\u003a\u0020%\u0054", _dbgb)
	return nil, nil, _gcd.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
}
func (_fdgfg *PdfReader) flattenFieldsWithOpts(_gdgbd bool, _cbgdd FieldAppearanceGenerator, _faeb *FieldFlattenOpts) error {
	if _faeb == nil {
		_faeb = &FieldFlattenOpts{}
	}
	var _faga bool
	_cadde := map[*PdfAnnotation]bool{}
	{
		var _dgfac []*PdfField
		_bcfe := _fdgfg.AcroForm
		if _bcfe != nil {
			if _faeb.FilterFunc != nil {
				_dgfac = _bcfe.filteredFields(_faeb.FilterFunc, true)
				_faga = _bcfe.Fields != nil && len(*_bcfe.Fields) > 0
			} else {
				_dgfac = _bcfe.AllFields()
			}
		}
		for _, _bdfe := range _dgfac {
			for _, _dbea := range _bdfe.Annotations {
				_cadde[_dbea.PdfAnnotation] = _bdfe.V != nil
				if _cbgdd != nil {
					_ggcg, _bcfb := _cbgdd.GenerateAppearanceDict(_bcfe, _bdfe, _dbea)
					if _bcfb != nil {
						return _bcfb
					}
					_dbea.AP = _ggcg
				}
			}
		}
	}
	if _gdgbd {
		for _, _gbeg := range _fdgfg.PageList {
			_dfadbe, _bcebe := _gbeg.GetAnnotations()
			if _bcebe != nil {
				return _bcebe
			}
			for _, _gbgbf := range _dfadbe {
				_cadde[_gbgbf] = true
			}
		}
	}
	for _, _acedc := range _fdgfg.PageList {
		var _gadgd []*PdfAnnotation
		if _cbgdd != nil {
			if _bacc := _cbgdd.WrapContentStream(_acedc); _bacc != nil {
				return _bacc
			}
		}
		_feea, _gfca := _acedc.GetAnnotations()
		if _gfca != nil {
			return _gfca
		}
		for _, _deaf := range _feea {
			_adffc, _fbffe := _cadde[_deaf]
			if !_fbffe && _faeb.AnnotFilterFunc != nil {
				if _, _cbgc := _deaf.GetContext().(*PdfAnnotationWidget); !_cbgc {
					_fbffe = _faeb.AnnotFilterFunc(_deaf)
				}
			}
			if !_fbffe {
				_gadgd = append(_gadgd, _deaf)
				continue
			}
			switch _deaf.GetContext().(type) {
			case *PdfAnnotationPopup:
				continue
			case *PdfAnnotationLink:
				continue
			case *PdfAnnotationProjection:
				continue
			}
			_bgfeg, _bebfb, _acdf := _dcgae(_deaf)
			if _acdf != nil {
				if !_adffc {
					_fd.Log.Trace("\u0046\u0069\u0065\u006c\u0064\u0020\u0077\u0069\u0074h\u006f\u0075\u0074\u0020\u0056\u0020\u002d\u003e\u0020\u0061\u006e\u006e\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u0020\u0077\u0069\u0074h\u006f\u0075t\u0020\u0061p\u0070\u0065\u0061\u0072\u0061\u006e\u0063\u0065\u0020\u0073\u0074\u0072\u0065am\u0020\u002d\u0020\u0073\u006b\u0069\u0070\u0070\u0069n\u0067\u0020\u006f\u0076\u0065\u0072")
					continue
				}
				_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u0020\u0041\u006e\u006e\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u0020\u0077\u0069\u0074h\u006f\u0075\u0074\u0020\u0061\u0070\u0070\u0065\u0061\u0072\u0061\u006e\u0063\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d,\u0020\u0065\u0072\u0072\u0020\u003a\u0020\u0025\u0076\u0020\u002d\u0020\u0073\u006bi\u0070\u0070\u0069n\u0067\u0020\u006f\u0076\u0065\u0072", _acdf)
				continue
			}
			if _bgfeg == nil {
				continue
			}
			_bcge := _acedc.Resources.GenerateXObjectName()
			_acedc.Resources.SetXObjectFormByName(_bcge, _bgfeg)
			_ddeg, _acdf := _fcdg(_bgfeg)
			if _acdf != nil {
				_fd.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0069\u006e\u0067\u0020\u0061\u0070p\u0065\u0061\u0072\u0061\u006e\u0063\u0065\u0020\u004d\u0061\u0074\u0072\u0069\u0078\u002c\u0020s\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u0020\u0078\u0066\u006f\u0072\u006d\u0020\u0062\u0062\u006f\u0078\u0020\u0061\u0064\u006a\u0075\u0073t\u006d\u0065\u006e\u0074\u003a \u0025\u0076", _acdf)
			} else {
				_eccg := _fba.IdentityMatrix()
				_eccg = _eccg.Translate(-_ddeg.Llx, -_ddeg.Lly)
				_eccg = _eccg.Scale(_bebfb.Width()/_ddeg.Width(), _bebfb.Height()/_ddeg.Height())
				_bebfb.Transform(_eccg)
			}
			_dbbde := _afb.Min(_bebfb.Llx, _bebfb.Urx)
			_bgba := _afb.Min(_bebfb.Lly, _bebfb.Ury)
			var _ddcd []string
			_ddcd = append(_ddcd, "\u0071")
			_ddcd = append(_ddcd, _b.Sprintf("\u0025\u002e\u0036\u0066\u0020\u0025\u002e\u0036\u0066\u0020\u0025\u002e\u0036\u0066\u0020%\u002e6\u0066\u0020\u0025\u002e\u0036\u0066\u0020\u0025\u002e\u0036\u0066\u0020\u0063\u006d", 1.0, 0.0, 0.0, 1.0, _dbbde, _bgba))
			_ddcd = append(_ddcd, _b.Sprintf("\u002f\u0025\u0073\u0020\u0044\u006f", _bcge.String()))
			_ddcd = append(_ddcd, "\u0051")
			_bfeb := _gc.Join(_ddcd, "\u000a")
			_acdf = _acedc.AppendContentStream(_bfeb)
			if _acdf != nil {
				return _acdf
			}
			if _bgfeg.Resources != nil {
				_ecgag, _ggcd := _agf.GetDict(_bgfeg.Resources.Font)
				if _ggcd {
					for _, _dcec := range _ecgag.Keys() {
						if !_acedc.Resources.HasFontByName(_dcec) {
							_acedc.Resources.SetFontByName(_dcec, _ecgag.Get(_dcec))
						}
					}
				}
			}
		}
		if len(_gadgd) > 0 {
			_acedc._abffa = _gadgd
		} else {
			_acedc._abffa = []*PdfAnnotation{}
		}
	}
	if !_faga {
		_fdgfg.AcroForm = nil
	}
	return nil
}

// CharcodeBytesToUnicode converts PDF character codes `data` to a Go unicode string.
//
// 9.10 Extraction of Text Content (page 292)
// The process of finding glyph descriptions in OpenType fonts by a conforming reader shall be the following:
//   - For Type 1 fonts using “CFF” tables, the process shall be as described in 9.6.6.2, "Encodings
//     for Type 1 Fonts".
//   - For TrueType fonts using “glyf” tables, the process shall be as described in 9.6.6.4,
//     "Encodings for TrueType Fonts". Since this process sometimes produces ambiguous results,
//     conforming writers, instead of using a simple font, shall use a Type 0 font with an Identity-H
//     encoding and use the glyph indices as character codes, as described following Table 118.
func (_dbada *PdfFont) CharcodeBytesToUnicode(data []byte) (string, int, int) {
	_bcgag, _, _ebecb := _dbada.CharcodesToUnicodeWithStats(_dbada.BytesToCharcodes(data))
	_cggg := _fcg.ExpandLigatures(_bcgag)
	return _cggg, _ba.RuneCountInString(_cggg), _ebecb
}

// NewPdfColorCalRGB returns a new CalRBG color.
func NewPdfColorCalRGB(a, b, c float64) *PdfColorCalRGB {
	_bbeg := PdfColorCalRGB{a, b, c}
	return &_bbeg
}

// NewPdfFontFromPdfObject loads a PdfFont from the dictionary `fontObj`.  If there is a problem an
// error is returned.
func NewPdfFontFromPdfObject(fontObj _agf.PdfObject) (*PdfFont, error) { return _fbffcc(fontObj, true) }
func _beffgc() _e.Time                                                 { _ecba.Lock(); defer _ecba.Unlock(); return _bbaee }

// HasPatternByName checks whether a pattern object is defined by the specified keyName.
func (_ebgbe *PdfPageResources) HasPatternByName(keyName _agf.PdfObjectName) bool {
	_, _dfcf := _ebgbe.GetPatternByName(keyName)
	return _dfcf
}
func (_dbgg *PdfReader) newPdfAnnotationFreeTextFromDict(_ebg *_agf.PdfObjectDictionary) (*PdfAnnotationFreeText, error) {
	_ebgc := PdfAnnotationFreeText{}
	_cdbcg, _gdcd := _dbgg.newPdfAnnotationMarkupFromDict(_ebg)
	if _gdcd != nil {
		return nil, _gdcd
	}
	_ebgc.PdfAnnotationMarkup = _cdbcg
	_ebgc.DA = _ebg.Get("\u0044\u0041")
	_ebgc.Q = _ebg.Get("\u0051")
	_ebgc.RC = _ebg.Get("\u0052\u0043")
	_ebgc.DS = _ebg.Get("\u0044\u0053")
	_ebgc.CL = _ebg.Get("\u0043\u004c")
	_ebgc.IT = _ebg.Get("\u0049\u0054")
	_ebgc.BE = _ebg.Get("\u0042\u0045")
	_ebgc.RD = _ebg.Get("\u0052\u0044")
	_ebgc.BS = _ebg.Get("\u0042\u0053")
	_ebgc.LE = _ebg.Get("\u004c\u0045")
	return &_ebgc, nil
}

// GetNumComponents returns the number of color components of the underlying
// colorspace device.
func (_eede *PdfColorspaceSpecialPattern) GetNumComponents() int {
	return _eede.UnderlyingCS.GetNumComponents()
}

// ToPdfObject returns the PDF representation of the DSS dictionary.
func (_ddbcf *DSS) ToPdfObject() _agf.PdfObject {
	_dcga := _ddbcf._dgfbc.PdfObject.(*_agf.PdfObjectDictionary)
	_dcga.Clear()
	_fdge := _agf.MakeDict()
	for _adgdd, _eedga := range _ddbcf.VRI {
		_fdge.Set(*_agf.MakeName(_adgdd), _eedga.ToPdfObject())
	}
	_dcga.SetIfNotNil("\u0043\u0065\u0072t\u0073", _gbcae(_ddbcf.Certs))
	_dcga.SetIfNotNil("\u004f\u0043\u0053P\u0073", _gbcae(_ddbcf.OCSPs))
	_dcga.SetIfNotNil("\u0043\u0052\u004c\u0073", _gbcae(_ddbcf.CRLs))
	_dcga.Set("\u0056\u0052\u0049", _fdge)
	return _ddbcf._dgfbc
}

// AddCustomInfo adds a custom info into document info dictionary.
func (_abea *PdfInfo) AddCustomInfo(name string, value string) error {
	if _abea._adfbb == nil {
		_abea._adfbb = _agf.MakeDict()
	}
	if _, _ebgbb := _cbfbe[name]; _ebgbb {
		return _b.Errorf("\u0063\u0061\u006e\u006e\u006ft\u0020\u0075\u0073\u0065\u0020\u0073\u0074\u0061\u006e\u0064\u0061\u0072\u0064 \u0069\u006e\u0066\u006f\u0020\u006b\u0065\u0079\u0020\u0025\u0073\u0020\u0061\u0073\u0020\u0063\u0075\u0073\u0074\u006f\u006d\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u006b\u0065y", name)
	}
	_abea._adfbb.SetIfNotNil(*_agf.MakeName(name), _agf.MakeString(value))
	return nil
}

// PdfFieldButton represents a button field which includes push buttons, checkboxes, and radio buttons.
type PdfFieldButton struct {
	*PdfField
	Opt  *_agf.PdfObjectArray
	_ffb *Image
}

// PdfColorPatternType2 represents a color shading pattern type 2 (Axial).
type PdfColorPatternType2 struct {
	Color       PdfColor
	PatternName _agf.PdfObjectName
}

// NewPdfReader returns a new PdfReader for an input io.ReadSeeker interface. Can be used to read PDF from
// memory or file. Immediately loads and traverses the PDF structure including pages and page contents (if
// not encrypted). Loads entire document structure into memory.
// Alternatively a lazy-loading reader can be created with NewPdfReaderLazy which loads only references,
// and references are loaded from disk into memory on an as-needed basis.
func NewPdfReader(rs _cf.ReadSeeker) (*PdfReader, error) {
	const _ddgag = "\u006do\u0064e\u006c\u003a\u004e\u0065\u0077P\u0064\u0066R\u0065\u0061\u0064\u0065\u0072"
	return _dcab(rs, &ReaderOpts{}, false, _ddgag)
}

// GetContainingPdfObject implements interface PdfModel.
func (_cfa *PdfAction) GetContainingPdfObject() _agf.PdfObject { return _cfa._caf }

// NewPdfAnnotation returns an initialized generic PDF annotation model.
func NewPdfAnnotation() *PdfAnnotation {
	_aab := &PdfAnnotation{}
	_aab._aeee = _agf.MakeIndirectObject(_agf.MakeDict())
	return _aab
}

// GetCapHeight returns the CapHeight of the font `descriptor`.
func (_abdc *PdfFontDescriptor) GetCapHeight() (float64, error) {
	return _agf.GetNumberAsFloat(_abdc.CapHeight)
}

// NewPdfOutputIntentFromPdfObject creates a new PdfOutputIntent from the input core.PdfObject.
func NewPdfOutputIntentFromPdfObject(object _agf.PdfObject) (*PdfOutputIntent, error) {
	_dgfe := &PdfOutputIntent{}
	if _febfe := _dgfe.ParsePdfObject(object); _febfe != nil {
		return nil, _febfe
	}
	return _dgfe, nil
}

// ToPdfOutlineItem returns a low level PdfOutlineItem object,
// based on the current instance.
func (_fddb *OutlineItem) ToPdfOutlineItem() (*PdfOutlineItem, int64) {
	_cgbfd := NewPdfOutlineItem()
	_cgbfd.Title = _agf.MakeEncodedString(_fddb.Title, true)
	_cgbfd.Dest = _fddb.Dest.ToPdfObject()
	var _adgba []*PdfOutlineItem
	var _accgd int64
	var _befcf *PdfOutlineItem
	for _, _eecabg := range _fddb.Entries {
		_ecea, _gfec := _eecabg.ToPdfOutlineItem()
		_ecea.Parent = &_cgbfd.PdfOutlineTreeNode
		if _befcf != nil {
			_befcf.Next = &_ecea.PdfOutlineTreeNode
			_ecea.Prev = &_befcf.PdfOutlineTreeNode
		}
		_adgba = append(_adgba, _ecea)
		_accgd += _gfec
		_befcf = _ecea
	}
	_bade := len(_adgba)
	_accgd += int64(_bade)
	if _bade > 0 {
		_cgbfd.First = &_adgba[0].PdfOutlineTreeNode
		_cgbfd.Last = &_adgba[_bade-1].PdfOutlineTreeNode
		_cgbfd.Count = &_accgd
	}
	return _cgbfd, _accgd
}

// SetVersion sets the PDF version of the output file.
func (_ggbgg *PdfWriter) SetVersion(majorVersion, minorVersion int) {
	_ggbgg._bcdfgg.Major = majorVersion
	_ggbgg._bcdfgg.Minor = minorVersion
}

// GetNamedDestinations returns the Dests entry in the PDF catalog.
// See section 12.3.2.3 "Named Destinations" (p. 367 PDF32000_2008).
func (_eaaba *PdfReader) GetNamedDestinations() (_agf.PdfObject, error) {
	_dcgead := _agf.ResolveReference(_eaaba._ceaadd.Get("\u0044\u0065\u0073t\u0073"))
	if _dcgead == nil {
		return nil, nil
	}
	if !_eaaba._ccage {
		_cdgc := _eaaba.traverseObjectData(_dcgead)
		if _cdgc != nil {
			return nil, _cdgc
		}
	}
	return _dcgead, nil
}

// OutlineDest represents the destination of an outline item.
// It holds the page and the position on the page an outline item points to.
type OutlineDest struct {
	PageObj *_agf.PdfIndirectObject `json:"-"`
	Page    int64                   `json:"page"`
	Mode    string                  `json:"mode"`
	X       float64                 `json:"x"`
	Y       float64                 `json:"y"`
	Zoom    float64                 `json:"zoom"`
}

func _afed(_bcfgf *_agf.PdfObjectDictionary) (*PdfShadingType1, error) {
	_cegc := PdfShadingType1{}
	if _ggfe := _bcfgf.Get("\u0044\u006f\u006d\u0061\u0069\u006e"); _ggfe != nil {
		_ggfe = _agf.TraceToDirectObject(_ggfe)
		_fffff, _gbggdf := _ggfe.(*_agf.PdfObjectArray)
		if !_gbggdf {
			_fd.Log.Debug("\u0044\u006f\u006d\u0061i\u006e\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072a\u0079\u0020\u0028\u0067\u006f\u0074\u0020%\u0054\u0029", _ggfe)
			return nil, _gcd.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
		}
		_cegc.Domain = _fffff
	}
	if _bggdb := _bcfgf.Get("\u004d\u0061\u0074\u0072\u0069\u0078"); _bggdb != nil {
		_bggdb = _agf.TraceToDirectObject(_bggdb)
		_cdgd, _dfbdd := _bggdb.(*_agf.PdfObjectArray)
		if !_dfbdd {
			_fd.Log.Debug("\u004d\u0061\u0074\u0072i\u0078\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072a\u0079\u0020\u0028\u0067\u006f\u0074\u0020%\u0054\u0029", _bggdb)
			return nil, _gcd.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
		}
		_cegc.Matrix = _cdgd
	}
	_bgge := _bcfgf.Get("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e")
	if _bgge == nil {
		_fd.Log.Debug("\u0052\u0065q\u0075\u0069\u0072\u0065d\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020m\u0069\u0073\u0073\u0069\u006e\u0067\u003a\u0020\u0020\u0046\u0075\u006ec\u0074\u0069\u006f\u006e")
		return nil, ErrRequiredAttributeMissing
	}
	_cegc.Function = []PdfFunction{}
	if _agcga, _fagee := _bgge.(*_agf.PdfObjectArray); _fagee {
		for _, _fagde := range _agcga.Elements() {
			_ffgda, _edagd := _ccedb(_fagde)
			if _edagd != nil {
				_fd.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e:\u0020\u0025\u0076", _edagd)
				return nil, _edagd
			}
			_cegc.Function = append(_cegc.Function, _ffgda)
		}
	} else {
		_abgbc, _afgdg := _ccedb(_bgge)
		if _afgdg != nil {
			_fd.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e:\u0020\u0025\u0076", _afgdg)
			return nil, _afgdg
		}
		_cegc.Function = append(_cegc.Function, _abgbc)
	}
	return &_cegc, nil
}

// GetTrailer returns the PDF's trailer dictionary.
func (_gcggf *PdfReader) GetTrailer() (*_agf.PdfObjectDictionary, error) {
	_ffedf := _gcggf._egdga.GetTrailer()
	if _ffedf == nil {
		return nil, _gcd.New("\u0074r\u0061i\u006c\u0065\u0072\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067")
	}
	return _ffedf, nil
}

// BytesToCharcodes converts the bytes in a PDF string to character codes.
func (_bcgfa *PdfFont) BytesToCharcodes(data []byte) []_fcg.CharCode {
	_fd.Log.Trace("\u0042\u0079\u0074es\u0054\u006f\u0043\u0068\u0061\u0072\u0063\u006f\u0064e\u0073:\u0020d\u0061t\u0061\u003d\u005b\u0025\u0020\u0030\u0032\u0078\u005d\u003d\u0025\u0023\u0071", data, data)
	if _gafga, _acfg := _bcgfa._effaa.(*pdfFontType0); _acfg && _gafga._bgccg != nil {
		if _bfae, _gefca := _gafga.bytesToCharcodes(data); _gefca {
			return _bfae
		}
	}
	var (
		_adafg = make([]_fcg.CharCode, 0, len(data)+len(data)%2)
		_ffab  = _bcgfa.baseFields()
	)
	if _ffab._egfbf != nil {
		if _aagbg, _fccdb := _ffab._egfbf.BytesToCharcodes(data); _fccdb {
			for _, _bfcd := range _aagbg {
				_adafg = append(_adafg, _fcg.CharCode(_bfcd))
			}
			return _adafg
		}
	}
	if _ffab.isCIDFont() {
		if len(data) == 1 {
			data = []byte{0, data[0]}
		}
		if len(data)%2 != 0 {
			_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0050\u0061\u0064\u0064\u0069\u006e\u0067\u0020\u0064\u0061\u0074\u0061\u003d\u0025\u002b\u0076\u0020t\u006f\u0020\u0065\u0076\u0065n\u0020\u006ce\u006e\u0067\u0074\u0068", data)
			data = append(data, 0)
		}
		for _aegbd := 0; _aegbd < len(data); _aegbd += 2 {
			_eecba := uint16(data[_aegbd])<<8 | uint16(data[_aegbd+1])
			_adafg = append(_adafg, _fcg.CharCode(_eecba))
		}
	} else {
		for _, _fffe := range data {
			_adafg = append(_adafg, _fcg.CharCode(_fffe))
		}
	}
	return _adafg
}

// ToPdfObject implements interface PdfModel.
func (_cadb *PdfAnnotationLink) ToPdfObject() _agf.PdfObject {
	_cadb.PdfAnnotation.ToPdfObject()
	_bgg := _cadb._aeee
	_gda := _bgg.PdfObject.(*_agf.PdfObjectDictionary)
	_gda.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _agf.MakeName("\u004c\u0069\u006e\u006b"))
	if _cadb._bbdg != nil && _cadb._bbdg._ae != nil {
		_gda.Set("\u0041", _cadb._bbdg._ae.ToPdfObject())
	} else if _cadb.A != nil {
		_gda.Set("\u0041", _cadb.A)
	}
	_gda.SetIfNotNil("\u0044\u0065\u0073\u0074", _cadb.Dest)
	_gda.SetIfNotNil("\u0048", _cadb.H)
	_gda.SetIfNotNil("\u0050\u0041", _cadb.PA)
	_gda.SetIfNotNil("\u0051\u0075\u0061\u0064\u0050\u006f\u0069\u006e\u0074\u0073", _cadb.QuadPoints)
	_gda.SetIfNotNil("\u0042\u0053", _cadb.BS)
	return _bgg
}

// NewCompositePdfFontFromTTFFile loads a composite font from a TTF font file. Composite fonts can
// be used to represent unicode fonts which can have multi-byte character codes, representing a wide
// range of values. They are often used for symbolic languages, including Chinese, Japanese and Korean.
// It is represented by a Type0 Font with an underlying CIDFontType2 and an Identity-H encoding map.
// TODO: May be extended in the future to support a larger variety of CMaps and vertical fonts.
// NOTE: For simple fonts, use NewPdfFontFromTTFFile.
func NewCompositePdfFontFromTTFFile(filePath string) (*PdfFont, error) {
	_fagfc, _dfdb := _fb.Open(filePath)
	if _dfdb != nil {
		_fd.Log.Debug("\u0045\u0052\u0052OR\u003a\u0020\u006f\u0070\u0065\u006e\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0065\u003a\u0020\u0025\u0076", _dfdb)
		return nil, _dfdb
	}
	defer _fagfc.Close()
	return NewCompositePdfFontFromTTF(_fagfc)
}

// FontDescriptor returns font's PdfFontDescriptor. This may be a builtin descriptor for standard 14
// fonts but must be an explicit descriptor for other fonts.
func (_bcdfe *PdfFont) FontDescriptor() *PdfFontDescriptor {
	if _bcdfe.baseFields()._dcfcb != nil {
		return _bcdfe.baseFields()._dcfcb
	}
	if _cddf := _bcdfe._effaa.getFontDescriptor(); _cddf != nil {
		return _cddf
	}
	_fd.Log.Error("\u0041\u006cl \u0066\u006f\u006et\u0073\u0020\u0068\u0061ve \u0061 D\u0065\u0073\u0063\u0072\u0069\u0070\u0074or\u002e\u0020\u0066\u006f\u006e\u0074\u003d%\u0073", _bcdfe)
	return nil
}

// PdfActionGoToR represents a GoToR action.
type PdfActionGoToR struct {
	*PdfAction
	F         *PdfFilespec
	D         _agf.PdfObject
	NewWindow _agf.PdfObject
}

// HasXObjectByName checks if an XObject with a specified keyName is defined.
func (_cdgfb *PdfPageResources) HasXObjectByName(keyName _agf.PdfObjectName) bool {
	_geece, _ := _cdgfb.GetXObjectByName(keyName)
	return _geece != nil
}

// NewPdfAnnotationText returns a new text annotation.
func NewPdfAnnotationText() *PdfAnnotationText {
	_cgag := NewPdfAnnotation()
	_ebb := &PdfAnnotationText{}
	_ebb.PdfAnnotation = _cgag
	_ebb.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_cgag.SetContext(_ebb)
	return _ebb
}

// PdfColorspace interface defines the common methods of a PDF colorspace.
// The colorspace defines the data storage format for each color and color representation.
//
// Device based colorspace, specified by name
// - /DeviceGray
// - /DeviceRGB
// - /DeviceCMYK
//
// CIE based colorspace specified by [name, dictionary]
// - [/CalGray dict]
// - [/CalRGB dict]
// - [/Lab dict]
// - [/ICCBased dict]
//
// Special colorspaces
// - /Pattern
// - /Indexed
// - /Separation
// - /DeviceN
//
// Work is in progress to support all colorspaces. At the moment ICCBased color spaces fall back to the alternate
// colorspace which works OK in most cases. For full color support, will need fully featured ICC support.
type PdfColorspace interface {

	// String returns the PdfColorspace's name.
	String() string

	// ImageToRGB converts an Image in a given PdfColorspace to an RGB image.
	ImageToRGB(Image) (Image, error)

	// ColorToRGB converts a single color in a given PdfColorspace to an RGB color.
	ColorToRGB(_gbgf PdfColor) (PdfColor, error)

	// GetNumComponents returns the number of components in the PdfColorspace.
	GetNumComponents() int

	// ToPdfObject returns a PdfObject representation of the PdfColorspace.
	ToPdfObject() _agf.PdfObject

	// ColorFromPdfObjects returns a PdfColor in the given PdfColorspace from an array of PdfObject where each
	// PdfObject represents a numeric value.
	ColorFromPdfObjects(_ccgc []_agf.PdfObject) (PdfColor, error)

	// ColorFromFloats returns a new PdfColor based on input color components for a given PdfColorspace.
	ColorFromFloats(_beec []float64) (PdfColor, error)

	// DecodeArray returns the Decode array for the PdfColorSpace, i.e. the range of each component.
	DecodeArray() []float64
}

// PdfColorLab represents a color in the L*, a*, b* 3 component colorspace.
// Each component is defined in the range 0.0 - 1.0 where 1.0 is the primary intensity.
type PdfColorLab [3]float64

// PdfPageResources is a Page resources model.
// Implements PdfModel.
type PdfPageResources struct {
	ExtGState  _agf.PdfObject
	ColorSpace _agf.PdfObject
	Pattern    _agf.PdfObject
	Shading    _agf.PdfObject
	XObject    _agf.PdfObject
	Font       _agf.PdfObject
	ProcSet    _agf.PdfObject
	Properties _agf.PdfObject
	_ebga      *_agf.PdfObjectDictionary
	_dgceaa    *PdfPageResourcesColorspaces
}

func (_deca *PdfReader) newPdfAnnotationProjectionFromDict(_bdaaf *_agf.PdfObjectDictionary) (*PdfAnnotationProjection, error) {
	_faaa := &PdfAnnotationProjection{}
	_fbcd, _fagf := _deca.newPdfAnnotationMarkupFromDict(_bdaaf)
	if _fagf != nil {
		return nil, _fagf
	}
	_faaa.PdfAnnotationMarkup = _fbcd
	return _faaa, nil
}

// AppendContentStream adds content stream by string.  Appends to the last
// contentstream instance if many.
func (_eagde *PdfPage) AppendContentStream(contentStr string) error {
	_bcbdd, _geee := _eagde.GetContentStreams()
	if _geee != nil {
		return _geee
	}
	if len(_bcbdd) == 0 {
		_bcbdd = []string{contentStr}
		return _eagde.SetContentStreams(_bcbdd, _agf.NewFlateEncoder())
	}
	var _ccfa _gg.Buffer
	_ccfa.WriteString(_bcbdd[len(_bcbdd)-1])
	_ccfa.WriteString("\u000a")
	_ccfa.WriteString(contentStr)
	_bcbdd[len(_bcbdd)-1] = _ccfa.String()
	return _eagde.SetContentStreams(_bcbdd, _agf.NewFlateEncoder())
}
func _badbg(_fddce *fontCommon) *pdfCIDFontType2 { return &pdfCIDFontType2{fontCommon: *_fddce} }
func (_gcfedc *PdfWriter) seekByName(_ecgbd _agf.PdfObject, _begg []string, _befaa string) ([]_agf.PdfObject, error) {
	_fd.Log.Trace("\u0053\u0065\u0065\u006b\u0020\u0062\u0079\u0020\u006e\u0061\u006d\u0065.\u002e\u0020\u0025\u0054", _ecgbd)
	var _aacdd []_agf.PdfObject
	if _gacda, _bccg := _ecgbd.(*_agf.PdfIndirectObject); _bccg {
		return _gcfedc.seekByName(_gacda.PdfObject, _begg, _befaa)
	}
	if _bfceb, _gcfba := _ecgbd.(*_agf.PdfObjectStream); _gcfba {
		return _gcfedc.seekByName(_bfceb.PdfObjectDictionary, _begg, _befaa)
	}
	if _gaffc, _cbfdc := _ecgbd.(*_agf.PdfObjectDictionary); _cbfdc {
		_fd.Log.Trace("\u0044\u0069\u0063\u0074")
		for _, _dgebfd := range _gaffc.Keys() {
			_geedg := _gaffc.Get(_dgebfd)
			if string(_dgebfd) == _befaa {
				_aacdd = append(_aacdd, _geedg)
			}
			for _, _bfdfe := range _begg {
				if string(_dgebfd) == _bfdfe {
					_fd.Log.Trace("\u0046\u006f\u006c\u006c\u006f\u0077\u0020\u006b\u0065\u0079\u0020\u0025\u0073", _bfdfe)
					_fabgc, _beffd := _gcfedc.seekByName(_geedg, _begg, _befaa)
					if _beffd != nil {
						return _aacdd, _beffd
					}
					_aacdd = append(_aacdd, _fabgc...)
					break
				}
			}
		}
		return _aacdd, nil
	}
	return _aacdd, nil
}

// NewPdfSignature creates a new PdfSignature object.
func NewPdfSignature(handler SignatureHandler) *PdfSignature {
	_gfecf := &PdfSignature{Type: _agf.MakeName("\u0053\u0069\u0067"), Handler: handler}
	_daad := &pdfSignDictionary{PdfObjectDictionary: _agf.MakeDict(), _adfab: &handler, _ecaged: _gfecf}
	_gfecf._ceeec = _agf.MakeIndirectObject(_daad)
	return _gfecf
}

// ToPdfObject implements interface PdfModel.
func (_ccb *PdfActionGoToE) ToPdfObject() _agf.PdfObject {
	_ccb.PdfAction.ToPdfObject()
	_ada := _ccb._caf
	_fa := _ada.PdfObject.(*_agf.PdfObjectDictionary)
	_fa.SetIfNotNil("\u0053", _agf.MakeName(string(ActionTypeGoToE)))
	if _ccb.F != nil {
		_fa.Set("\u0046", _ccb.F.ToPdfObject())
	}
	_fa.SetIfNotNil("\u0044", _ccb.D)
	_fa.SetIfNotNil("\u004ee\u0077\u0057\u0069\u006e\u0064\u006fw", _ccb.NewWindow)
	_fa.SetIfNotNil("\u0054", _ccb.T)
	return _ada
}

// SetPdfModifiedDate sets the ModDate attribute of the output PDF.
func SetPdfModifiedDate(modifiedDate _e.Time) {
	_ecba.Lock()
	defer _ecba.Unlock()
	_bbaee = modifiedDate
}

// Inspect inspects the object types, subtypes and content in the PDF file returning a map of
// object type to number of instances of each.
func (_cbeea *PdfReader) Inspect() (map[string]int, error) { return _cbeea._egdga.Inspect() }

// AddExtGState adds a graphics state to the XObject resources.
func (_eeeea *PdfPage) AddExtGState(name _agf.PdfObjectName, egs *_agf.PdfObjectDictionary) error {
	if _eeeea.Resources == nil {
		_eeeea.Resources = NewPdfPageResources()
	}
	if _eeeea.Resources.ExtGState == nil {
		_eeeea.Resources.ExtGState = _agf.MakeDict()
	}
	_bbde, _acedfc := _agf.TraceToDirectObject(_eeeea.Resources.ExtGState).(*_agf.PdfObjectDictionary)
	if !_acedfc {
		_fd.Log.Debug("\u0045\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0045\u0078t\u0047\u0053\u0074\u0061\u0074\u0065\u0020\u0064i\u0063t\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069c\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u003a\u0020\u0025\u0076", _agf.TraceToDirectObject(_eeeea.Resources.ExtGState))
		return _gcd.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	_bbde.Set(name, egs)
	return nil
}

// GetCharMetrics returns the character metrics for the specified character code.  A bool flag is
// returned to indicate whether or not the entry was found in the glyph to charcode mapping.
// How it works:
//  1. Return a value the /Widths array (charWidths) if there is one.
//  2. If the font has the same name as a standard 14 font then return width=250.
//  3. Otherwise return no match and let the caller substitute a default.
func (_fgba pdfFontSimple) GetCharMetrics(code _fcg.CharCode) (_aa.CharMetrics, bool) {
	if _agcaf, _agcc := _fgba._fcad[code]; _agcc {
		return _aa.CharMetrics{Wx: _agcaf}, true
	}
	if _aa.IsStdFont(_aa.StdFontName(_fgba._fccf)) {
		return _aa.CharMetrics{Wx: 250}, true
	}
	return _aa.CharMetrics{}, false
}

// NewPdfAnnotationWidget returns an initialized annotation widget.
func NewPdfAnnotationWidget() *PdfAnnotationWidget {
	_bac := NewPdfAnnotation()
	_cbf := &PdfAnnotationWidget{}
	_cbf.PdfAnnotation = _bac
	_bac.SetContext(_cbf)
	return _cbf
}

// GetContainingPdfObject gets the primitive used to parse the color space.
func (_edcbf *PdfColorspaceICCBased) GetContainingPdfObject() _agf.PdfObject { return _edcbf._gbcdd }

const (
	ActionTypeGoTo        PdfActionType = "\u0047\u006f\u0054\u006f"
	ActionTypeGoTo3DView  PdfActionType = "\u0047\u006f\u0054\u006f\u0033\u0044\u0056\u0069\u0065\u0077"
	ActionTypeGoToE       PdfActionType = "\u0047\u006f\u0054o\u0045"
	ActionTypeGoToR       PdfActionType = "\u0047\u006f\u0054o\u0052"
	ActionTypeHide        PdfActionType = "\u0048\u0069\u0064\u0065"
	ActionTypeImportData  PdfActionType = "\u0049\u006d\u0070\u006f\u0072\u0074\u0044\u0061\u0074\u0061"
	ActionTypeJavaScript  PdfActionType = "\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"
	ActionTypeLaunch      PdfActionType = "\u004c\u0061\u0075\u006e\u0063\u0068"
	ActionTypeMovie       PdfActionType = "\u004d\u006f\u0076i\u0065"
	ActionTypeNamed       PdfActionType = "\u004e\u0061\u006de\u0064"
	ActionTypeRendition   PdfActionType = "\u0052e\u006e\u0064\u0069\u0074\u0069\u006fn"
	ActionTypeResetForm   PdfActionType = "\u0052e\u0073\u0065\u0074\u0046\u006f\u0072m"
	ActionTypeSetOCGState PdfActionType = "S\u0065\u0074\u004f\u0043\u0047\u0053\u0074\u0061\u0074\u0065"
	ActionTypeSound       PdfActionType = "\u0053\u006f\u0075n\u0064"
	ActionTypeSubmitForm  PdfActionType = "\u0053\u0075\u0062\u006d\u0069\u0074\u0046\u006f\u0072\u006d"
	ActionTypeThread      PdfActionType = "\u0054\u0068\u0072\u0065\u0061\u0064"
	ActionTypeTrans       PdfActionType = "\u0054\u0072\u0061n\u0073"
	ActionTypeURI         PdfActionType = "\u0055\u0052\u0049"
)

// NewDSS returns a new DSS dictionary.
func NewDSS() *DSS {
	return &DSS{_dgfbc: _agf.MakeIndirectObject(_agf.MakeDict()), VRI: map[string]*VRI{}}
}

// CheckAccessRights checks access rights and permissions for a specified password.  If either user/owner
// password is specified,  full rights are granted, otherwise the access rights are specified by the
// Permissions flag.
//
// The bool flag indicates that the user can access and view the file.
// The AccessPermissions shows what access the user has for editing etc.
// An error is returned if there was a problem performing the authentication.
func (_dbceg *PdfReader) CheckAccessRights(password []byte) (bool, _bfb.Permissions, error) {
	return _dbceg._egdga.CheckAccessRights(password)
}

// NewPdfPage returns a new PDF page.
func NewPdfPage() *PdfPage {
	_fbedb := PdfPage{}
	_fbedb._ececfb = _agf.MakeDict()
	_fbedb.Resources = NewPdfPageResources()
	_abcaf := _agf.PdfIndirectObject{}
	_abcaf.PdfObject = _fbedb._ececfb
	_fbedb._edegf = &_abcaf
	_fbedb._gabcc = *_fbedb._ececfb
	return &_fbedb
}

// ContentStreamWrapper wraps the Page's contentstream into q ... Q blocks.
type ContentStreamWrapper interface{ WrapContentStream(_dbfef *PdfPage) error }

// GetNumComponents returns the number of color components (1 for Separation).
func (_gecf *PdfColorspaceSpecialSeparation) GetNumComponents() int { return 1 }
func (_cgfa *Image) resampleLowBits(_efgce []uint32) {
	_fcdcbd := _ged.BytesPerLine(int(_cgfa.Width), int(_cgfa.BitsPerComponent), _cgfa.ColorComponents)
	_aggef := make([]byte, _cgfa.ColorComponents*_fcdcbd*int(_cgfa.Height))
	_bffe := int(_cgfa.BitsPerComponent) * _cgfa.ColorComponents * int(_cgfa.Width)
	_egeb := uint8(8)
	var (
		_gbfc, _fcfaf int
		_cdbg         uint32
	)
	for _abde := 0; _abde < int(_cgfa.Height); _abde++ {
		_fcfaf = _abde * _fcdcbd
		for _fabfd := 0; _fabfd < _bffe; _fabfd++ {
			_cdbg = _efgce[_gbfc]
			_egeb -= uint8(_cgfa.BitsPerComponent)
			_aggef[_fcfaf] |= byte(_cdbg) << _egeb
			if _egeb == 0 {
				_egeb = 8
				_fcfaf++
			}
			_gbfc++
		}
	}
	_cgfa.Data = _aggef
}
func (_geab *PdfReader) newPdfAnnotationStrikeOut(_cgbg *_agf.PdfObjectDictionary) (*PdfAnnotationStrikeOut, error) {
	_faag := PdfAnnotationStrikeOut{}
	_bagc, _baab := _geab.newPdfAnnotationMarkupFromDict(_cgbg)
	if _baab != nil {
		return nil, _baab
	}
	_faag.PdfAnnotationMarkup = _bagc
	_faag.QuadPoints = _cgbg.Get("\u0051\u0075\u0061\u0064\u0050\u006f\u0069\u006e\u0074\u0073")
	return &_faag, nil
}

// ToPdfObject implements interface PdfModel.
func (_aafb *PdfAnnotationWatermark) ToPdfObject() _agf.PdfObject {
	_aafb.PdfAnnotation.ToPdfObject()
	_dgab := _aafb._aeee
	_fage := _dgab.PdfObject.(*_agf.PdfObjectDictionary)
	_fage.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _agf.MakeName("\u0057a\u0074\u0065\u0072\u006d\u0061\u0072k"))
	_fage.SetIfNotNil("\u0046\u0069\u0078\u0065\u0064\u0050\u0072\u0069\u006e\u0074", _aafb.FixedPrint)
	return _dgab
}
func (_gfa *PdfReader) newPdfActionSubmitFormFromDict(_egfb *_agf.PdfObjectDictionary) (*PdfActionSubmitForm, error) {
	_dae, _bec := _bdd(_egfb.Get("\u0046"))
	if _bec != nil {
		return nil, _bec
	}
	return &PdfActionSubmitForm{F: _dae, Fields: _egfb.Get("\u0046\u0069\u0065\u006c\u0064\u0073"), Flags: _egfb.Get("\u0046\u006c\u0061g\u0073")}, nil
}

// GetNumComponents returns the number of color components of the colorspace device.
// Returns 1 for a CalGray device.
func (_cfecd *PdfColorspaceCalGray) GetNumComponents() int { return 1 }

// ToPdfObject converts the pdfCIDFontType0 to a PDF representation.
func (_baddc *pdfCIDFontType0) ToPdfObject() _agf.PdfObject { return _agf.MakeNull() }

// PdfColorspaceICCBased format [/ICCBased stream]
//
// The stream shall contain the ICC profile.
// A conforming reader shall support ICC.1:2004:10 as required by PDF 1.7, which will enable it
// to properly render all embedded ICC profiles regardless of the PDF version
//
// In the current implementation, we rely on the alternative colormap provided.
type PdfColorspaceICCBased struct {
	N         int
	Alternate PdfColorspace

	// If omitted ICC not supported: then use DeviceGray,
	// DeviceRGB or DeviceCMYK for N=1,3,4 respectively.
	Range    []float64
	Metadata *_agf.PdfObjectStream
	Data     []byte
	_cecae   *_agf.PdfIndirectObject
	_gbcdd   *_agf.PdfObjectStream
}

// GetContentStream returns the XObject Form's content stream.
func (_fabdb *XObjectForm) GetContentStream() ([]byte, error) {
	_fdbeg, _dbaab := _agf.DecodeStream(_fabdb._dfeac)
	if _dbaab != nil {
		return nil, _dbaab
	}
	return _fdbeg, nil
}

// SetEncoder sets the encoding for the underlying font.
// TODO(peterwilliams97): Change function signature to SetEncoder(encoder *textencoding.simpleEncoder).
// TODO(gunnsth): Makes sense if SetEncoder is removed from the interface fonts.Font as proposed in PR #260.
func (_abeg *pdfFontSimple) SetEncoder(encoder _fcg.TextEncoder) { _abeg._dbgde = encoder }

// GetRotate gets the inheritable rotate value, either from the page
// or a higher up page/pages struct.
func (_gbdbc *PdfPage) GetRotate() (int64, error) {
	if _gbdbc.Rotate != nil {
		return *_gbdbc.Rotate, nil
	}
	_daddb := _gbdbc.Parent
	for _daddb != nil {
		_gcea, _agcg := _agf.GetDict(_daddb)
		if !_agcg {
			return 0, _gcd.New("\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u006f\u0062\u006a\u0065\u0063t\u0073\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079")
		}
		if _gffb := _gcea.Get("\u0052\u006f\u0074\u0061\u0074\u0065"); _gffb != nil {
			_caega, _bfecb := _agf.GetInt(_gffb)
			if !_bfecb {
				return 0, _gcd.New("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0074a\u0074\u0065\u0020\u0076al\u0075\u0065")
			}
			if _caega != nil {
				return int64(*_caega), nil
			}
			return 0, _gcd.New("\u0072\u006f\u0074\u0061te\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0069\u0073\u0020\u006e\u0069\u006c")
		}
		_daddb = _gcea.Get("\u0050\u0061\u0072\u0065\u006e\u0074")
	}
	return 0, _gcd.New("\u0072o\u0074a\u0074\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064")
}

// PdfFunctionType4 is a Postscript calculator functions.
type PdfFunctionType4 struct {
	Domain  []float64
	Range   []float64
	Program *_bd.PSProgram
	_fbbda  *_bd.PSExecutor
	_bfdde  []byte
	_bcfbb  *_agf.PdfObjectStream
}

// PdfAnnotationTrapNet represents TrapNet annotations.
// (Section 12.5.6.21).
type PdfAnnotationTrapNet struct{ *PdfAnnotation }

// FieldAppearanceGenerator generates appearance stream for a given field.
type FieldAppearanceGenerator interface {
	ContentStreamWrapper
	GenerateAppearanceDict(_dbca *PdfAcroForm, _gfga *PdfField, _egbd *PdfAnnotationWidget) (*_agf.PdfObjectDictionary, error)
}

func _cbfgb(_fefbe *_agf.PdfObjectArray) (float64, error) {
	_bgbbc, _efec := _fefbe.ToFloat64Array()
	if _efec != nil {
		_fd.Log.Debug("\u0042\u0061\u0064\u0020\u004d\u0061\u0074\u0074\u0065\u0020\u0061\u0072\u0072\u0061\u0079:\u0020m\u0061\u0074\u0074\u0065\u003d\u0025\u0073\u0020\u0065\u0072\u0072\u003d\u0025\u0076", _fefbe, _efec)
	}
	switch len(_bgbbc) {
	case 1:
		return _bgbbc[0], nil
	case 3:
		_fbbab := PdfColorspaceDeviceRGB{}
		_bafg, _aaafgc := _fbbab.ColorFromFloats(_bgbbc)
		if _aaafgc != nil {
			return 0.0, _aaafgc
		}
		return _bafg.(*PdfColorDeviceRGB).ToGray().Val(), nil
	case 4:
		_dcgdf := PdfColorspaceDeviceCMYK{}
		_dcfde, _cecgg := _dcgdf.ColorFromFloats(_bgbbc)
		if _cecgg != nil {
			return 0.0, _cecgg
		}
		_cedfc, _cecgg := _dcgdf.ColorToRGB(_dcfde.(*PdfColorDeviceCMYK))
		if _cecgg != nil {
			return 0.0, _cecgg
		}
		return _cedfc.(*PdfColorDeviceRGB).ToGray().Val(), nil
	}
	_efec = _gcd.New("\u0062a\u0064 \u004d\u0061\u0074\u0074\u0065\u0020\u0063\u006f\u006c\u006f\u0072")
	_fd.Log.Error("\u0074\u006f\u0047ra\u0079\u003a\u0020\u006d\u0061\u0074\u0074\u0065\u003d\u0025\u0073\u0020\u0065\u0072\u0072\u003d\u0025\u0076", _fefbe, _efec)
	return 0.0, _efec
}
func (_cfeeg *PdfReader) newPdfSignatureFromIndirect(_dbaa *_agf.PdfIndirectObject) (*PdfSignature, error) {
	_daeab, _gdeee := _dbaa.PdfObject.(*_agf.PdfObjectDictionary)
	if !_gdeee {
		_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0053\u0069\u0067\u006e\u0061\u0074\u0075\u0072e\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u006e\u006ft\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020a \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079")
		return nil, ErrTypeCheck
	}
	if _fcgdge, _egbcc := _cfeeg._dcdeb.GetModelFromPrimitive(_dbaa).(*PdfSignature); _egbcc {
		return _fcgdge, nil
	}
	_gagfb := &PdfSignature{}
	_gagfb._ceeec = _dbaa
	_gagfb.Type, _ = _agf.GetName(_daeab.Get("\u0054\u0079\u0070\u0065"))
	_gagfb.Filter, _gdeee = _agf.GetName(_daeab.Get("\u0046\u0069\u006c\u0074\u0065\u0072"))
	if !_gdeee {
		_fd.Log.Error("\u0045\u0052R\u004f\u0052\u003a\u0020\u0053i\u0067\u006e\u0061\u0074\u0075r\u0065\u0020\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006f\u0072\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067")
		return nil, ErrInvalidAttribute
	}
	_gagfb.SubFilter, _ = _agf.GetName(_daeab.Get("\u0053u\u0062\u0046\u0069\u006c\u0074\u0065r"))
	_gagfb.Contents, _gdeee = _agf.GetString(_daeab.Get("\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"))
	if !_gdeee {
		_fd.Log.Error("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0063\u006f\u006et\u0065\u006e\u0074\u0073\u0020\u006d\u0069s\u0073\u0069\u006e\u0067")
		return nil, ErrInvalidAttribute
	}
	if _dccdb, _gbfbb := _agf.GetArray(_daeab.Get("\u0052e\u0066\u0065\u0072\u0065\u006e\u0063e")); _gbfbb {
		_gagfb.Reference = _agf.MakeArray()
		for _, _bbgg := range _dccdb.Elements() {
			_cfcgf, _begff := _agf.GetDict(_bbgg)
			if !_begff {
				_fd.Log.Error("\u0045\u0052R\u004f\u0052\u003a\u0020R\u0065\u0066e\u0072\u0065\u006e\u0063\u0065\u0020\u0063\u006fn\u0074\u0065\u006e\u0074\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0061\u0074\u0065\u0064")
				return nil, ErrInvalidAttribute
			}
			_dcbce, _ccbgde := _cfeeg.newPdfSignatureReferenceFromDict(_cfcgf)
			if _ccbgde != nil {
				return nil, _ccbgde
			}
			_gagfb.Reference.Append(_dcbce.ToPdfObject())
		}
	}
	_gagfb.Cert = _daeab.Get("\u0043\u0065\u0072\u0074")
	_gagfb.ByteRange, _ = _agf.GetArray(_daeab.Get("\u0042y\u0074\u0065\u0052\u0061\u006e\u0067e"))
	_gagfb.Changes, _ = _agf.GetArray(_daeab.Get("\u0043h\u0061\u006e\u0067\u0065\u0073"))
	_gagfb.Name, _ = _agf.GetString(_daeab.Get("\u004e\u0061\u006d\u0065"))
	_gagfb.M, _ = _agf.GetString(_daeab.Get("\u004d"))
	_gagfb.Location, _ = _agf.GetString(_daeab.Get("\u004c\u006f\u0063\u0061\u0074\u0069\u006f\u006e"))
	_gagfb.Reason, _ = _agf.GetString(_daeab.Get("\u0052\u0065\u0061\u0073\u006f\u006e"))
	_gagfb.ContactInfo, _ = _agf.GetString(_daeab.Get("C\u006f\u006e\u0074\u0061\u0063\u0074\u0049\u006e\u0066\u006f"))
	_gagfb.R, _ = _agf.GetInt(_daeab.Get("\u0052"))
	_gagfb.V, _ = _agf.GetInt(_daeab.Get("\u0056"))
	_gagfb.PropBuild, _ = _agf.GetDict(_daeab.Get("\u0050\u0072\u006f\u0070\u005f\u0042\u0075\u0069\u006c\u0064"))
	_gagfb.PropAuthTime, _ = _agf.GetInt(_daeab.Get("\u0050\u0072\u006f\u0070\u005f\u0041\u0075\u0074\u0068\u0054\u0069\u006d\u0065"))
	_gagfb.PropAuthType, _ = _agf.GetName(_daeab.Get("\u0050\u0072\u006f\u0070\u005f\u0041\u0075\u0074\u0068\u0054\u0079\u0070\u0065"))
	_cfeeg._dcdeb.Register(_dbaa, _gagfb)
	return _gagfb, nil
}
func (_abdbeb *PdfWriter) makeOffSetReference(_dcbfd int64) {
	_bbabcc := _b.Sprintf("\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u000a\u0025\u0064\u000a", _dcbfd)
	_abdbeb.writeString(_bbabcc)
	_abdbeb.writeString("\u0025\u0025\u0045\u004f\u0046\u000a")
}

// ColorFromFloats returns a new PdfColor based on the input slice of color
// components. The slice should contain a single element.
func (_cdae *PdfColorspaceSpecialSeparation) ColorFromFloats(vals []float64) (PdfColor, error) {
	if len(vals) != 1 {
		return nil, _gcd.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_adbc := vals[0]
	_gbgab := []float64{_adbc}
	_fbaf, _eeeb := _cdae.TintTransform.Evaluate(_gbgab)
	if _eeeb != nil {
		_fd.Log.Debug("\u0045\u0072r\u006f\u0072\u002c\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0065\u0076\u0061\u006c\u0075\u0061\u0074\u0065: \u0025\u0076", _eeeb)
		_fd.Log.Trace("\u0054\u0069\u006e\u0074 t\u0072\u0061\u006e\u0073\u0066\u006f\u0072\u006d\u003a\u0020\u0025\u002b\u0076", _cdae.TintTransform)
		return nil, _eeeb
	}
	_fd.Log.Trace("\u0050\u0072\u006f\u0063\u0065\u0073\u0073\u0069\u006e\u0067\u0020\u0043\u006f\u006c\u006fr\u0046\u0072\u006f\u006d\u0046\u006c\u006f\u0061\u0074\u0073\u0028\u0025\u002bv\u0029\u0020\u006f\u006e\u0020\u0041\u006c\u0074\u0065\u0072\u006e\u0061te\u0053\u0070\u0061\u0063\u0065\u003a\u0020\u0025\u0023\u0076", _fbaf, _cdae.AlternateSpace)
	_ffgcb, _eeeb := _cdae.AlternateSpace.ColorFromFloats(_fbaf)
	if _eeeb != nil {
		_fd.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u002c\u0020\u0066a\u0069\u006c\u0065d \u0074\u006f\u0020\u0065\u0076\u0061l\u0075\u0061\u0074\u0065\u0020\u0069\u006e\u0020\u0061\u006c\u0074\u0065\u0072\u006e\u0061t\u0065\u0020\u0073\u0070\u0061\u0063\u0065\u003a \u0025\u0076", _eeeb)
		return nil, _eeeb
	}
	return _ffgcb, nil
}
func (_bfafa *PdfReader) buildOutlineTree(_fdcdb _agf.PdfObject, _cdbb *PdfOutlineTreeNode, _ddbcg *PdfOutlineTreeNode, _fccea map[_agf.PdfObject]struct{}) (*PdfOutlineTreeNode, *PdfOutlineTreeNode, error) {
	if _fccea == nil {
		_fccea = map[_agf.PdfObject]struct{}{}
	}
	_fccea[_fdcdb] = struct{}{}
	_cdcc, _befad := _fdcdb.(*_agf.PdfIndirectObject)
	if !_befad {
		return nil, nil, _b.Errorf("\u006f\u0075\u0074\u006c\u0069\u006e\u0065 \u0063\u006f\u006et\u0061\u0069\u006e\u0065r\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0025\u0054", _fdcdb)
	}
	_bgdaf, _geedc := _cdcc.PdfObject.(*_agf.PdfObjectDictionary)
	if !_geedc {
		return nil, nil, _gcd.New("\u006e\u006f\u0074 a\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006f\u0062\u006a\u0065\u0063\u0074")
	}
	_fd.Log.Trace("\u0062\u0075\u0069\u006c\u0064\u0020\u006f\u0075\u0074\u006c\u0069\u006e\u0065 \u0074\u0072\u0065\u0065\u003a\u0020d\u0069\u0063\u0074\u003a\u0020\u0025\u0076\u0020\u0028\u0025\u0076\u0029\u0020p\u003a\u0020\u0025\u0070", _bgdaf, _cdcc, _cdcc)
	if _debgee := _bgdaf.Get("\u0054\u0069\u0074l\u0065"); _debgee != nil {
		_dcece, _fadg := _bfafa.newPdfOutlineItemFromIndirectObject(_cdcc)
		if _fadg != nil {
			return nil, nil, _fadg
		}
		_dcece.Parent = _cdbb
		_dcece.Prev = _ddbcg
		_egcaf := _agf.ResolveReference(_bgdaf.Get("\u0046\u0069\u0072s\u0074"))
		if _, _dgbc := _fccea[_egcaf]; _egcaf != nil && _egcaf != _cdcc && !_dgbc {
			if !_agf.IsNullObject(_egcaf) {
				_addg, _cfegd, _ebfcg := _bfafa.buildOutlineTree(_egcaf, &_dcece.PdfOutlineTreeNode, nil, _fccea)
				if _ebfcg != nil {
					_fd.Log.Debug("D\u0045\u0042U\u0047\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0062\u0075\u0069\u006c\u0064\u0020\u006fu\u0074\u006c\u0069\u006e\u0065\u0020\u0069\u0074\u0065\u006d\u0020\u0074\u0072\u0065\u0065\u003a \u0025\u0076\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u0020n\u006f\u0064\u0065\u0020\u0063\u0068\u0069\u006c\u0064\u0072\u0065n\u002e", _ebfcg)
				} else {
					_dcece.First = _addg
					_dcece.Last = _cfegd
				}
			}
		}
		_fabae := _agf.ResolveReference(_bgdaf.Get("\u004e\u0065\u0078\u0074"))
		if _, _bfag := _fccea[_fabae]; _fabae != nil && _fabae != _cdcc && !_bfag {
			if !_agf.IsNullObject(_fabae) {
				_gaeb, _cdadda, _ecac := _bfafa.buildOutlineTree(_fabae, _cdbb, &_dcece.PdfOutlineTreeNode, _fccea)
				if _ecac != nil {
					_fd.Log.Debug("D\u0045\u0042U\u0047\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0062\u0075\u0069\u006c\u0064\u0020\u006fu\u0074\u006c\u0069\u006e\u0065\u0020\u0074\u0072\u0065\u0065\u0020\u0066\u006f\u0072\u0020\u004ee\u0078\u0074\u0020\u006e\u006f\u0064\u0065\u003a\u0020\u0025\u0076\u002e\u0020S\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u0020\u006e\u006f\u0064e\u002e", _ecac)
				} else {
					_dcece.Next = _gaeb
					return &_dcece.PdfOutlineTreeNode, _cdadda, nil
				}
			}
		}
		return &_dcece.PdfOutlineTreeNode, &_dcece.PdfOutlineTreeNode, nil
	}
	_fddddf, _dfcaa := _bcef(_cdcc)
	if _dfcaa != nil {
		return nil, nil, _dfcaa
	}
	_fddddf.Parent = _cdbb
	if _fafc := _bgdaf.Get("\u0046\u0069\u0072s\u0074"); _fafc != nil {
		_fafc = _agf.ResolveReference(_fafc)
		if _, _bcdfb := _fccea[_fafc]; _fafc != nil && _fafc != _cdcc && !_bcdfb {
			_deefa := _agf.TraceToDirectObject(_fafc)
			if _, _gdfcb := _deefa.(*_agf.PdfObjectNull); !_gdfcb && _deefa != nil {
				_fgfff, _aebb, _gebe := _bfafa.buildOutlineTree(_fafc, &_fddddf.PdfOutlineTreeNode, nil, _fccea)
				if _gebe != nil {
					_fd.Log.Debug("\u0044\u0045\u0042\u0055\u0047\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020b\u0075\u0069\u006c\u0064\u0020\u006f\u0075\u0074\u006c\u0069n\u0065\u0020\u0074\u0072\u0065\u0065\u003a\u0020\u0025\u0076\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069n\u0067\u0020\u006e\u006f\u0064\u0065 \u0063\u0068i\u006c\u0064r\u0065n\u002e", _gebe)
				} else {
					_fddddf.First = _fgfff
					_fddddf.Last = _aebb
				}
			}
		}
	}
	return &_fddddf.PdfOutlineTreeNode, &_fddddf.PdfOutlineTreeNode, nil
}
func _ccedb(_efgcc _agf.PdfObject) (PdfFunction, error) {
	_efgcc = _agf.ResolveReference(_efgcc)
	if _edab, _gbaa := _efgcc.(*_agf.PdfObjectStream); _gbaa {
		_aeeb := _edab.PdfObjectDictionary
		_ggaeb, _dbafd := _aeeb.Get("\u0046\u0075\u006ec\u0074\u0069\u006f\u006e\u0054\u0079\u0070\u0065").(*_agf.PdfObjectInteger)
		if !_dbafd {
			_fd.Log.Error("F\u0075\u006e\u0063\u0074\u0069\u006fn\u0054\u0079\u0070\u0065\u0020\u006e\u0075\u006d\u0062e\u0072\u0020\u006di\u0073s\u0069\u006e\u0067")
			return nil, _gcd.New("\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074e\u0072 \u006f\u0072\u0020\u006d\u0069\u0073\u0073i\u006e\u0067")
		}
		if *_ggaeb == 0 {
			return _cgcf(_edab)
		} else if *_ggaeb == 4 {
			return _cagbd(_edab)
		} else {
			return nil, _gcd.New("i\u006e\u0076\u0061\u006cid\u0020f\u0075\u006e\u0063\u0074\u0069o\u006e\u0020\u0074\u0079\u0070\u0065")
		}
	} else if _dacdd, _cgcb := _efgcc.(*_agf.PdfIndirectObject); _cgcb {
		_fbde, _fbdf := _dacdd.PdfObject.(*_agf.PdfObjectDictionary)
		if !_fbdf {
			_fd.Log.Error("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e\u0020\u0049\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u006eo\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006eg\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079")
			return nil, _gcd.New("\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074e\u0072 \u006f\u0072\u0020\u006d\u0069\u0073\u0073i\u006e\u0067")
		}
		_eagfc, _fbdf := _fbde.Get("\u0046\u0075\u006ec\u0074\u0069\u006f\u006e\u0054\u0079\u0070\u0065").(*_agf.PdfObjectInteger)
		if !_fbdf {
			_fd.Log.Error("F\u0075\u006e\u0063\u0074\u0069\u006fn\u0054\u0079\u0070\u0065\u0020\u006e\u0075\u006d\u0062e\u0072\u0020\u006di\u0073s\u0069\u006e\u0067")
			return nil, _gcd.New("\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074e\u0072 \u006f\u0072\u0020\u006d\u0069\u0073\u0073i\u006e\u0067")
		}
		if *_eagfc == 2 {
			return _beaba(_dacdd)
		} else if *_eagfc == 3 {
			return _bcaed(_dacdd)
		} else {
			return nil, _gcd.New("i\u006e\u0076\u0061\u006cid\u0020f\u0075\u006e\u0063\u0074\u0069o\u006e\u0020\u0074\u0079\u0070\u0065")
		}
	} else if _gafce, _abbed := _efgcc.(*_agf.PdfObjectDictionary); _abbed {
		_bdacg, _ddcf := _gafce.Get("\u0046\u0075\u006ec\u0074\u0069\u006f\u006e\u0054\u0079\u0070\u0065").(*_agf.PdfObjectInteger)
		if !_ddcf {
			_fd.Log.Error("F\u0075\u006e\u0063\u0074\u0069\u006fn\u0054\u0079\u0070\u0065\u0020\u006e\u0075\u006d\u0062e\u0072\u0020\u006di\u0073s\u0069\u006e\u0067")
			return nil, _gcd.New("\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074e\u0072 \u006f\u0072\u0020\u006d\u0069\u0073\u0073i\u006e\u0067")
		}
		if *_bdacg == 2 {
			return _beaba(_gafce)
		} else if *_bdacg == 3 {
			return _bcaed(_gafce)
		} else {
			return nil, _gcd.New("i\u006e\u0076\u0061\u006cid\u0020f\u0075\u006e\u0063\u0074\u0069o\u006e\u0020\u0074\u0079\u0070\u0065")
		}
	} else {
		_fd.Log.Debug("\u0046u\u006e\u0063\u0074\u0069\u006f\u006e\u0020\u0054\u0079\u0070\u0065 \u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0023\u0076", _efgcc)
		return nil, _gcd.New("\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
	}
}

// IsTerminal returns true for terminal fields, false otherwise.
// Terminal fields are fields whose descendants are only widget annotations.
func (_aabd *PdfField) IsTerminal() bool              { return len(_aabd.Kids) == 0 }
func (_aadec *pdfFontSimple) baseFields() *fontCommon { return &_aadec.fontCommon }
func (_fgbge *PdfWriter) setWriter(_cbcgg _cf.Writer) {
	_fgbge._fdce = _fgbge._gdfa
	_fgbge._eafee = _be.NewWriter(_cbcgg)
}

// ToPdfObject implements interface PdfModel.
func (_afd *PdfActionTrans) ToPdfObject() _agf.PdfObject {
	_afd.PdfAction.ToPdfObject()
	_cag := _afd._caf
	_ace := _cag.PdfObject.(*_agf.PdfObjectDictionary)
	_ace.SetIfNotNil("\u0053", _agf.MakeName(string(ActionTypeTrans)))
	_ace.SetIfNotNil("\u0054\u0072\u0061n\u0073", _afd.Trans)
	return _cag
}

// GetCharMetrics returns the char metrics for character code `code`.
func (_ffbcd pdfFontType3) GetCharMetrics(code _fcg.CharCode) (_aa.CharMetrics, bool) {
	if _cbaaf, _bafae := _ffbcd._aebef[code]; _bafae {
		return _aa.CharMetrics{Wx: _cbaaf}, true
	}
	if _aa.IsStdFont(_aa.StdFontName(_ffbcd._fccf)) {
		return _aa.CharMetrics{Wx: 250}, true
	}
	return _aa.CharMetrics{}, false
}

// NewPdfOutlineTree returns an initialized PdfOutline tree.
func NewPdfOutlineTree() *PdfOutline { _abad := NewPdfOutline(); _abad._cgaaa = &_abad; return _abad }
func (_gead *pdfFontType0) getFontDescriptor() *PdfFontDescriptor {
	if _gead._dcfcb == nil && _gead.DescendantFont != nil {
		return _gead.DescendantFont.FontDescriptor()
	}
	return _gead._dcfcb
}
func (_fcedfe SignatureValidationResult) String() string {
	var _febca _gg.Buffer
	_febca.WriteString(_b.Sprintf("\u004ea\u006d\u0065\u003a\u0020\u0025\u0073\n", _fcedfe.Name))
	if _fcedfe.Date._dcggc > 0 {
		_febca.WriteString(_b.Sprintf("\u0044a\u0074\u0065\u003a\u0020\u0025\u0073\n", _fcedfe.Date.ToGoTime().String()))
	} else {
		_febca.WriteString("\u0044\u0061\u0074\u0065 n\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064\u000a")
	}
	if len(_fcedfe.Reason) > 0 {
		_febca.WriteString(_b.Sprintf("R\u0065\u0061\u0073\u006f\u006e\u003a\u0020\u0025\u0073\u000a", _fcedfe.Reason))
	} else {
		_febca.WriteString("N\u006f \u0072\u0065\u0061\u0073\u006f\u006e\u0020\u0073p\u0065\u0063\u0069\u0066ie\u0064\u000a")
	}
	if len(_fcedfe.Location) > 0 {
		_febca.WriteString(_b.Sprintf("\u004c\u006f\u0063\u0061\u0074\u0069\u006f\u006e\u003a\u0020\u0025\u0073\u000a", _fcedfe.Location))
	} else {
		_febca.WriteString("\u004c\u006f\u0063at\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064\u000a")
	}
	if len(_fcedfe.ContactInfo) > 0 {
		_febca.WriteString(_b.Sprintf("\u0043\u006f\u006e\u0074\u0061\u0063\u0074\u0020\u0049\u006e\u0066\u006f:\u0020\u0025\u0073\u000a", _fcedfe.ContactInfo))
	} else {
		_febca.WriteString("C\u006f\u006e\u0074\u0061\u0063\u0074 \u0069\u006e\u0066\u006f\u0020\u006e\u006f\u0074\u0020s\u0070\u0065\u0063i\u0066i\u0065\u0064\u000a")
	}
	_febca.WriteString(_b.Sprintf("F\u0069\u0065\u006c\u0064\u0073\u003a\u0020\u0025\u0064\u000a", len(_fcedfe.Fields)))
	if _fcedfe.IsSigned {
		_febca.WriteString("S\u0069\u0067\u006e\u0065\u0064\u003a \u0044\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020i\u0073\u0020\u0073i\u0067n\u0065\u0064\u000a")
	} else {
		_febca.WriteString("\u0053\u0069\u0067\u006eed\u003a\u0020\u004e\u006f\u0074\u0020\u0073\u0069\u0067\u006e\u0065\u0064\u000a")
	}
	if _fcedfe.IsVerified {
		_febca.WriteString("\u0053\u0069\u0067n\u0061\u0074\u0075\u0072e\u0020\u0076\u0061\u006c\u0069\u0064\u0061t\u0069\u006f\u006e\u003a\u0020\u0049\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u000a")
	} else {
		_febca.WriteString("\u0053\u0069\u0067\u006e\u0061\u0074u\u0072\u0065\u0020\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e:\u0020\u0049\u0073\u0020\u0069\u006e\u0076a\u006c\u0069\u0064\u000a")
	}
	if _fcedfe.IsTrusted {
		_febca.WriteString("\u0054\u0072\u0075\u0073\u0074\u0065\u0064\u003a\u0020\u0043\u0065\u0072\u0074\u0069\u0066i\u0063a\u0074\u0065\u0020\u0069\u0073\u0020\u0074\u0072\u0075\u0073\u0074\u0065\u0064\u000a")
	} else {
		_febca.WriteString("\u0054\u0072\u0075s\u0074\u0065\u0064\u003a \u0055\u006e\u0074\u0072\u0075\u0073\u0074e\u0064\u0020\u0063\u0065\u0072\u0074\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u000a")
	}
	if !_fcedfe.GeneralizedTime.IsZero() {
		_febca.WriteString(_b.Sprintf("G\u0065n\u0065\u0072\u0061\u006c\u0069\u007a\u0065\u0064T\u0069\u006d\u0065\u003a %\u0073\u000a", _fcedfe.GeneralizedTime.String()))
	}
	if _fcedfe.DiffResults != nil {
		_febca.WriteString(_b.Sprintf("\u0064\u0069\u0066\u0066 i\u0073\u0020\u0070\u0065\u0072\u006d\u0069\u0074\u0074\u0065\u0064\u003a\u0020\u0025v\u000a", _fcedfe.DiffResults.IsPermitted()))
		if len(_fcedfe.DiffResults.Warnings) > 0 {
			_febca.WriteString("\u004d\u0044\u0050\u0020\u0077\u0061\u0072\u006e\u0069n\u0067\u0073\u003a\u000a")
			for _, _gaea := range _fcedfe.DiffResults.Warnings {
				_febca.WriteString(_b.Sprintf("\u0009\u0025\u0073\u000a", _gaea))
			}
		}
		if len(_fcedfe.DiffResults.Errors) > 0 {
			_febca.WriteString("\u004d\u0044\u0050 \u0065\u0072\u0072\u006f\u0072\u0073\u003a\u000a")
			for _, _bagbg := range _fcedfe.DiffResults.Errors {
				_febca.WriteString(_b.Sprintf("\u0009\u0025\u0073\u000a", _bagbg))
			}
		}
	}
	return _febca.String()
}
func _cgcf(_cfeda *_agf.PdfObjectStream) (*PdfFunctionType0, error) {
	_dccbc := &PdfFunctionType0{}
	_dccbc._fbbfe = _cfeda
	_adbcf := _cfeda.PdfObjectDictionary
	_dfcbd, _gdgbab := _agf.TraceToDirectObject(_adbcf.Get("\u0044\u006f\u006d\u0061\u0069\u006e")).(*_agf.PdfObjectArray)
	if !_gdgbab {
		_fd.Log.Error("D\u006fm\u0061\u0069\u006e\u0020\u006e\u006f\u0074\u0020s\u0070\u0065\u0063\u0069fi\u0065\u0064")
		return nil, _gcd.New("\u0072\u0065q\u0075\u0069\u0072\u0065d\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020m\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u006f\u0072\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
	}
	if _dfcbd.Len() < 0 || _dfcbd.Len()%2 != 0 {
		_fd.Log.Error("\u0044\u006f\u006d\u0061\u0069\u006e\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
		return nil, _gcd.New("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0064\u006f\u006da\u0069\u006e\u0020\u0072an\u0067\u0065")
	}
	_dccbc.NumInputs = _dfcbd.Len() / 2
	_deba, _abbeb := _dfcbd.ToFloat64Array()
	if _abbeb != nil {
		return nil, _abbeb
	}
	_dccbc.Domain = _deba
	_dfcbd, _gdgbab = _agf.TraceToDirectObject(_adbcf.Get("\u0052\u0061\u006eg\u0065")).(*_agf.PdfObjectArray)
	if !_gdgbab {
		_fd.Log.Error("\u0052\u0061\u006e\u0067e \u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064")
		return nil, _gcd.New("\u0072\u0065q\u0075\u0069\u0072\u0065d\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020m\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u006f\u0072\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
	}
	if _dfcbd.Len() < 0 || _dfcbd.Len()%2 != 0 {
		return nil, _gcd.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u0061\u006e\u0067\u0065")
	}
	_dccbc.NumOutputs = _dfcbd.Len() / 2
	_eebag, _abbeb := _dfcbd.ToFloat64Array()
	if _abbeb != nil {
		return nil, _abbeb
	}
	_dccbc.Range = _eebag
	_dfcbd, _gdgbab = _agf.TraceToDirectObject(_adbcf.Get("\u0053\u0069\u007a\u0065")).(*_agf.PdfObjectArray)
	if !_gdgbab {
		_fd.Log.Error("\u0053i\u007ae\u0020\u006e\u006f\u0074\u0020s\u0070\u0065c\u0069\u0066\u0069\u0065\u0064")
		return nil, _gcd.New("\u0072\u0065q\u0075\u0069\u0072\u0065d\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020m\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u006f\u0072\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
	}
	_gcda, _abbeb := _dfcbd.ToIntegerArray()
	if _abbeb != nil {
		return nil, _abbeb
	}
	if len(_gcda) != _dccbc.NumInputs {
		_fd.Log.Error("T\u0061\u0062\u006c\u0065\u0020\u0073\u0069\u007a\u0065\u0020\u006e\u006f\u0074\u0020\u006d\u0061\u0074\u0063h\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072 o\u0066\u0020\u0069n\u0070u\u0074\u0073")
		return nil, _gcd.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_dccbc.Size = _gcda
	_dbbec, _gdgbab := _agf.TraceToDirectObject(_adbcf.Get("\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0053\u0061\u006d\u0070\u006c\u0065")).(*_agf.PdfObjectInteger)
	if !_gdgbab {
		_fd.Log.Error("B\u0069\u0074\u0073\u0050\u0065\u0072S\u0061\u006d\u0070\u006c\u0065\u0020\u006e\u006f\u0074 \u0073\u0070\u0065c\u0069f\u0069\u0065\u0064")
		return nil, _gcd.New("\u0072\u0065q\u0075\u0069\u0072\u0065d\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020m\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u006f\u0072\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
	}
	if *_dbbec != 1 && *_dbbec != 2 && *_dbbec != 4 && *_dbbec != 8 && *_dbbec != 12 && *_dbbec != 16 && *_dbbec != 24 && *_dbbec != 32 {
		_fd.Log.Error("\u0042\u0069\u0074s \u0070\u0065\u0072\u0020\u0073\u0061\u006d\u0070\u006ce\u0020o\u0075t\u0073i\u0064\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064\u0029", *_dbbec)
		return nil, _gcd.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_dccbc.BitsPerSample = int(*_dbbec)
	_dccbc.Order = 1
	_gcdfd, _gdgbab := _agf.TraceToDirectObject(_adbcf.Get("\u004f\u0072\u0064e\u0072")).(*_agf.PdfObjectInteger)
	if _gdgbab {
		if *_gcdfd != 1 && *_gcdfd != 3 {
			_fd.Log.Error("\u0049n\u0076a\u006c\u0069\u0064\u0020\u006fr\u0064\u0065r\u0020\u0028\u0025\u0064\u0029", *_gcdfd)
			return nil, _gcd.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
		}
		_dccbc.Order = int(*_gcdfd)
	}
	_dfcbd, _gdgbab = _agf.TraceToDirectObject(_adbcf.Get("\u0045\u006e\u0063\u006f\u0064\u0065")).(*_agf.PdfObjectArray)
	if _gdgbab {
		_gbeefe, _fdfc := _dfcbd.ToFloat64Array()
		if _fdfc != nil {
			return nil, _fdfc
		}
		_dccbc.Encode = _gbeefe
	}
	_dfcbd, _gdgbab = _agf.TraceToDirectObject(_adbcf.Get("\u0044\u0065\u0063\u006f\u0064\u0065")).(*_agf.PdfObjectArray)
	if _gdgbab {
		_cafegd, _eeac := _dfcbd.ToFloat64Array()
		if _eeac != nil {
			return nil, _eeac
		}
		_dccbc.Decode = _cafegd
	}
	_beaf, _abbeb := _agf.DecodeStream(_cfeda)
	if _abbeb != nil {
		return nil, _abbeb
	}
	_dccbc._aded = _beaf
	return _dccbc, nil
}

// GetColorspaces loads PdfPageResourcesColorspaces from `r.ColorSpace` and returns an error if there
// is a problem loading. Once loaded, the same object is returned on multiple calls.
func (_ecgec *PdfPageResources) GetColorspaces() (*PdfPageResourcesColorspaces, error) {
	if _ecgec._dgceaa != nil {
		return _ecgec._dgceaa, nil
	}
	if _ecgec.ColorSpace == nil {
		return nil, nil
	}
	_gefaf, _ffcbb := _efeee(_ecgec.ColorSpace)
	if _ffcbb != nil {
		return nil, _ffcbb
	}
	_ecgec._dgceaa = _gefaf
	return _ecgec._dgceaa, nil
}

// NewPdfActionSetOCGState returns a new "named" action.
func NewPdfActionSetOCGState() *PdfActionSetOCGState {
	_cfcc := NewPdfAction()
	_cfac := &PdfActionSetOCGState{}
	_cfac.PdfAction = _cfcc
	_cfcc.SetContext(_cfac)
	return _cfac
}
func _gfdcd(_ccafg []byte) bool {
	if len(_ccafg) < 4 {
		return true
	}
	for _cgdb := range _ccafg[:4] {
		_ffff := rune(_cgdb)
		if !_gb.Is(_gb.ASCII_Hex_Digit, _ffff) && !_gb.IsSpace(_ffff) {
			return true
		}
	}
	return false
}

// PdfColorCalGray represents a CalGray colorspace.
type PdfColorCalGray float64

// M returns the value of the magenta component of the color.
func (_eggc *PdfColorDeviceCMYK) M() float64 { return _eggc[1] }

// GetCustomInfo returns a custom info value for the specified name.
func (_ccffb *PdfInfo) GetCustomInfo(name string) *_agf.PdfObjectString {
	var _gbgb *_agf.PdfObjectString
	if _ccffb._adfbb == nil {
		return _gbgb
	}
	if _efgb, _ebacg := _ccffb._adfbb.Get(*_agf.MakeName(name)).(*_agf.PdfObjectString); _ebacg {
		_gbgb = _efgb
	}
	return _gbgb
}
func (_bagff *PdfWriter) setHashIDs(_afcce _fc.Hash) error {
	_gaeef := _afcce.Sum(nil)
	if _bagff._bedbef == "" {
		_bagff._bedbef = _ad.EncodeToString(_gaeef[:8])
	}
	_bagff.setDocumentIDs(_bagff._bedbef, _ad.EncodeToString(_gaeef[8:]))
	return nil
}

// ToPdfObject returns the PDF representation of the pattern.
func (_aabg *PdfPattern) ToPdfObject() _agf.PdfObject {
	_agccc := _aabg.getDict()
	_agccc.Set("\u0054\u0079\u0070\u0065", _agf.MakeName("\u0050a\u0074\u0074\u0065\u0072\u006e"))
	_agccc.Set("P\u0061\u0074\u0074\u0065\u0072\u006e\u0054\u0079\u0070\u0065", _agf.MakeInteger(_aabg.PatternType))
	return _aabg._efed
}

// GetRevision returns the specific version of the PdfReader for the current Pdf document
func (_bggcc *PdfReader) GetRevision(revisionNumber int) (*PdfReader, error) {
	_bcecg := _bggcc._egdga.GetRevisionNumber()
	if revisionNumber < 0 || revisionNumber > _bcecg {
		return nil, _gcd.New("w\u0072\u006f\u006e\u0067 r\u0065v\u0069\u0073\u0069\u006f\u006e \u006e\u0075\u006d\u0062\u0065\u0072")
	}
	if revisionNumber == _bcecg {
		return _bggcc, nil
	}
	if _bggcc._fged[revisionNumber] != nil {
		return _bggcc._fged[revisionNumber], nil
	}
	_dfffc := _bggcc
	for _bddeb := _bcecg - 1; _bddeb >= revisionNumber; _bddeb-- {
		_ffgcd, _fbdcc := _dfffc.GetPreviousRevision()
		if _fbdcc != nil {
			return nil, _fbdcc
		}
		_bggcc._fged[_bddeb] = _ffgcd
		_dfffc = _ffgcd
	}
	return _dfffc, nil
}

// SubsetRegistered subsets the font to only the glyphs that have been registered by the encoder.
//
// NOTE: This only works on fonts that support subsetting. For unsupported fonts this is a no-op, although a debug
// message is emitted.  Currently supported fonts are embedded Truetype CID fonts (type 0).
//
// NOTE: Make sure to call this soon before writing (once all needed runes have been registered).
// If using package creator, use its EnableFontSubsetting method instead.
func (_facb *PdfFont) SubsetRegistered() error {
	switch _ebbg := _facb._effaa.(type) {
	case *pdfFontType0:
		_eaff := _ebbg.subsetRegistered()
		if _eaff != nil {
			_fd.Log.Debug("\u0053\u0075b\u0073\u0065\u0074 \u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076", _eaff)
			return _eaff
		}
		if _ebbg._dcfcf != nil {
			if _ebbg._gccd != nil {
				_ebbg._gccd.ToPdfObject()
			}
			_ebbg.ToPdfObject()
		}
	default:
		_fd.Log.Debug("F\u006f\u006e\u0074\u0020\u0025\u0054 \u0064\u006f\u0065\u0073\u0020\u006eo\u0074\u0020\u0073\u0075\u0070\u0070\u006fr\u0074\u0020\u0073\u0075\u0062\u0073\u0065\u0074\u0074\u0069n\u0067", _ebbg)
	}
	return nil
}

// PdfSignatureReference represents a PDF signature reference dictionary and is used for signing via form signature fields.
// (Section 12.8.1, Table 253 - Entries in a signature reference dictionary p. 469 in PDF32000_2008).
type PdfSignatureReference struct {
	_feaaf          *_agf.PdfObjectDictionary
	Type            *_agf.PdfObjectName
	TransformMethod *_agf.PdfObjectName
	TransformParams _agf.PdfObject
	Data            _agf.PdfObject
	DigestMethod    *_agf.PdfObjectName
}

// ButtonType represents the subtype of a button field, can be one of:
// - Checkbox (ButtonTypeCheckbox)
// - PushButton (ButtonTypePushButton)
// - RadioButton (ButtonTypeRadioButton)
type ButtonType int

func (_abbb *PdfReader) newPdfAnnotationCaretFromDict(_edd *_agf.PdfObjectDictionary) (*PdfAnnotationCaret, error) {
	_caaaa := PdfAnnotationCaret{}
	_cfec, _febe := _abbb.newPdfAnnotationMarkupFromDict(_edd)
	if _febe != nil {
		return nil, _febe
	}
	_caaaa.PdfAnnotationMarkup = _cfec
	_caaaa.RD = _edd.Get("\u0052\u0044")
	_caaaa.Sy = _edd.Get("\u0053\u0079")
	return &_caaaa, nil
}
func _dcab(_dcdbe _cf.ReadSeeker, _fcdgc *ReaderOpts, _cdgg bool, _bddef string) (*PdfReader, error) {
	if _fcdgc == nil {
		_fcdgc = NewReaderOpts()
	}
	_aagec := *_fcdgc
	_gggb := &PdfReader{_bggga: _dcdbe, _eggbg: map[_agf.PdfObject]struct{}{}, _dcdeb: _aaeeg(), _ccage: _fcdgc.LazyLoad, _gcbbc: _fcdgc.ComplianceMode, _gdab: _cdgg, _ddgee: &_aagec}
	_eddd, _bbdfe := _gcgff("\u0072")
	if _bbdfe != nil {
		return nil, _bbdfe
	}
	_bbdfe = _ede.Track(_eddd, _bddef)
	if _bbdfe != nil {
		return nil, _bbdfe
	}
	_gggb._gdfb = _eddd
	var _dacgf *_agf.PdfParser
	if !_gggb._gcbbc {
		_dacgf, _bbdfe = _agf.NewParser(_dcdbe)
	} else {
		_dacgf, _bbdfe = _agf.NewCompliancePdfParser(_dcdbe)
	}
	if _bbdfe != nil {
		return nil, _bbdfe
	}
	_gggb._egdga = _dacgf
	_dagfc, _bbdfe := _gggb.IsEncrypted()
	if _bbdfe != nil {
		return nil, _bbdfe
	}
	if !_dagfc {
		_bbdfe = _gggb.loadStructure()
		if _bbdfe != nil {
			return nil, _bbdfe
		}
	} else if _cdgg {
		_adgeg, _cgfbe := _gggb.Decrypt([]byte(_fcdgc.Password))
		if _cgfbe != nil {
			return nil, _cgfbe
		}
		if !_adgeg {
			return nil, _gcd.New("\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f \u0064\u0065c\u0072\u0079\u0070\u0074\u0020\u0070\u0061\u0073\u0073w\u006f\u0072\u0064\u0020p\u0072\u006f\u0074\u0065\u0063\u0074\u0065\u0064\u0020\u0066\u0069\u006c\u0065\u0020\u002d\u0020\u006e\u0065\u0065\u0064\u0020\u0074\u006f\u0020\u0073\u0070\u0065\u0063\u0069\u0066y\u0020\u0070\u0061s\u0073\u0020\u0074\u006f\u0020\u0044\u0065\u0063\u0072\u0079\u0070\u0074")
		}
	}
	_gggb._gaaabg = make(map[*PdfReader]*PdfReader)
	_gggb._fged = make([]*PdfReader, _dacgf.GetRevisionNumber())
	return _gggb, nil
}

// SetContext sets the sub action (context).
func (_aaf *PdfAction) SetContext(ctx PdfModel) { _aaf._ae = ctx }

// SetContentStream sets the pattern cell's content stream.
func (_egage *PdfTilingPattern) SetContentStream(content []byte, encoder _agf.StreamEncoder) error {
	_dacgb, _efaf := _egage._efed.(*_agf.PdfObjectStream)
	if !_efaf {
		_fd.Log.Debug("\u0054\u0069l\u0069\u006e\u0067\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", _egage._efed)
		return _agf.ErrTypeError
	}
	if encoder == nil {
		encoder = _agf.NewRawEncoder()
	}
	_bcbec := _dacgb.PdfObjectDictionary
	_ggdc := encoder.MakeStreamDict()
	_bcbec.Merge(_ggdc)
	_facbd, _dgagg := encoder.EncodeBytes(content)
	if _dgagg != nil {
		return _dgagg
	}
	_bcbec.Set("\u004c\u0065\u006e\u0067\u0074\u0068", _agf.MakeInteger(int64(len(_facbd))))
	_dacgb.Stream = _facbd
	return nil
}
func (_edeeg *PdfReader) newPdfAnnotationPolyLineFromDict(_afg *_agf.PdfObjectDictionary) (*PdfAnnotationPolyLine, error) {
	_cedg := PdfAnnotationPolyLine{}
	_adgb, _fcfc := _edeeg.newPdfAnnotationMarkupFromDict(_afg)
	if _fcfc != nil {
		return nil, _fcfc
	}
	_cedg.PdfAnnotationMarkup = _adgb
	_cedg.Vertices = _afg.Get("\u0056\u0065\u0072\u0074\u0069\u0063\u0065\u0073")
	_cedg.LE = _afg.Get("\u004c\u0045")
	_cedg.BS = _afg.Get("\u0042\u0053")
	_cedg.IC = _afg.Get("\u0049\u0043")
	_cedg.BE = _afg.Get("\u0042\u0045")
	_cedg.IT = _afg.Get("\u0049\u0054")
	_cedg.Measure = _afg.Get("\u004de\u0061\u0073\u0075\u0072\u0065")
	return &_cedg, nil
}

// VariableText contains the common attributes of a variable text.
// The VariableText is typically not used directly, but is can encapsulate by PdfField
// See section 12.7.3.3 "Variable Text" and Table 222 (pp. 434-436 PDF32000_2008).
type VariableText struct {
	DA *_agf.PdfObjectString
	Q  *_agf.PdfObjectInteger
	DS *_agf.PdfObjectString
	RV _agf.PdfObject
}

// GetNumComponents returns the number of color components (1 for Indexed).
func (_dbadc *PdfColorspaceSpecialIndexed) GetNumComponents() int { return 1 }

// NewPdfAnnotationScreen returns a new screen annotation.
func NewPdfAnnotationScreen() *PdfAnnotationScreen {
	_eaa := NewPdfAnnotation()
	_cgbf := &PdfAnnotationScreen{}
	_cgbf.PdfAnnotation = _eaa
	_eaa.SetContext(_cgbf)
	return _cgbf
}

type pdfCIDFontType0 struct {
	fontCommon
	_cbaceb *_agf.PdfIndirectObject
	_aaef   _fcg.TextEncoder

	// Table 117 – Entries in a CIDFont dictionary (page 269)
	// (Required) Dictionary that defines the character collection of the CIDFont.
	// See Table 116.
	CIDSystemInfo *_agf.PdfObjectDictionary

	// Glyph metrics fields (optional).
	DW     _agf.PdfObject
	W      _agf.PdfObject
	DW2    _agf.PdfObject
	W2     _agf.PdfObject
	_gdgga map[_fcg.CharCode]float64
	_efcec float64
}

func _bbddf(_abegd *[]*PdfField, _dgabg FieldFilterFunc, _fgeg bool) []*PdfField {
	if _abegd == nil {
		return nil
	}
	_gcgdb := *_abegd
	if len(*_abegd) == 0 {
		return nil
	}
	_dcdab := _gcgdb[:0]
	if _dgabg == nil {
		_dgabg = func(*PdfField) bool { return true }
	}
	var _befdg []*PdfField
	for _, _aabad := range _gcgdb {
		_gddca := _dgabg(_aabad)
		if _gddca {
			_befdg = append(_befdg, _aabad)
			if len(_aabad.Kids) > 0 {
				_befdg = append(_befdg, _bbddf(&_aabad.Kids, _dgabg, _fgeg)...)
			}
		}
		if !_fgeg || !_gddca || len(_aabad.Kids) > 0 {
			_dcdab = append(_dcdab, _aabad)
		}
	}
	*_abegd = _dcdab
	return _befdg
}
func (_gfda *PdfReader) newPdfAnnotationInkFromDict(_dfa *_agf.PdfObjectDictionary) (*PdfAnnotationInk, error) {
	_fcc := PdfAnnotationInk{}
	_eeb, _gdcc := _gfda.newPdfAnnotationMarkupFromDict(_dfa)
	if _gdcc != nil {
		return nil, _gdcc
	}
	_fcc.PdfAnnotationMarkup = _eeb
	_fcc.InkList = _dfa.Get("\u0049n\u006b\u004c\u0069\u0073\u0074")
	_fcc.BS = _dfa.Get("\u0042\u0053")
	return &_fcc, nil
}

// ColorFromFloats returns a new PdfColor based on the input slice of color
// components. The slice should contain a single element between 0 and 1.
func (_cbc *PdfColorspaceCalGray) ColorFromFloats(vals []float64) (PdfColor, error) {
	if len(vals) != 1 {
		return nil, _gcd.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_ceg := vals[0]
	if _ceg < 0.0 || _ceg > 1.0 {
		_fd.Log.Debug("\u0063\u006f\u006cor\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0043\u0053\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020", _ceg)
		return nil, ErrColorOutOfRange
	}
	_fgab := NewPdfColorCalGray(_ceg)
	return _fgab, nil
}

// PdfActionHide represents a hide action.
type PdfActionHide struct {
	*PdfAction
	T _agf.PdfObject
	H _agf.PdfObject
}

// PdfVersion returns version of the PDF file.
func (_gcba *PdfReader) PdfVersion() _agf.Version { return _gcba._egdga.PdfVersion() }

// Width returns the width of `rect`.
func (_aeed *PdfRectangle) Width() float64 { return _afb.Abs(_aeed.Urx - _aeed.Llx) }

// PdfAnnotationPrinterMark represents PrinterMark annotations.
// (Section 12.5.6.20).
type PdfAnnotationPrinterMark struct {
	*PdfAnnotation
	MN _agf.PdfObject
}

// GetColorspaceByName returns the colorspace with the specified name from the page resources.
func (_egeef *PdfPageResources) GetColorspaceByName(keyName _agf.PdfObjectName) (PdfColorspace, bool) {
	_agfcge, _dgbad := _egeef.GetColorspaces()
	if _dgbad != nil {
		_fd.Log.Debug("\u0045\u0052R\u004f\u0052\u0020\u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0072\u0061\u0063\u0065: \u0025\u0076", _dgbad)
		return nil, false
	}
	if _agfcge == nil {
		return nil, false
	}
	_ffbbg, _ebbfb := _agfcge.Colorspaces[string(keyName)]
	if !_ebbfb {
		return nil, false
	}
	return _ffbbg, true
}
func (_ebfa *PdfReader) newPdfAnnotationHighlightFromDict(_fdaf *_agf.PdfObjectDictionary) (*PdfAnnotationHighlight, error) {
	_fag := PdfAnnotationHighlight{}
	_bef, _fcff := _ebfa.newPdfAnnotationMarkupFromDict(_fdaf)
	if _fcff != nil {
		return nil, _fcff
	}
	_fag.PdfAnnotationMarkup = _bef
	_fag.QuadPoints = _fdaf.Get("\u0051\u0075\u0061\u0064\u0050\u006f\u0069\u006e\u0074\u0073")
	return &_fag, nil
}

// PdfAnnotationPopup represents Popup annotations.
// (Section 12.5.6.14).
type PdfAnnotationPopup struct {
	*PdfAnnotation
	Parent _agf.PdfObject
	Open   _agf.PdfObject
}

// NewPdfPageResourcesFromDict creates and returns a new PdfPageResources object
// from the input dictionary.
func NewPdfPageResourcesFromDict(dict *_agf.PdfObjectDictionary) (*PdfPageResources, error) {
	_cagdb := NewPdfPageResources()
	if _dddc := dict.Get("\u0045x\u0074\u0047\u0053\u0074\u0061\u0074e"); _dddc != nil {
		_cagdb.ExtGState = _dddc
	}
	if _gfdg := dict.Get("\u0043\u006f\u006c\u006f\u0072\u0053\u0070\u0061\u0063\u0065"); _gfdg != nil && !_agf.IsNullObject(_gfdg) {
		_cagdb.ColorSpace = _gfdg
	}
	if _beecd := dict.Get("\u0050a\u0074\u0074\u0065\u0072\u006e"); _beecd != nil {
		_cagdb.Pattern = _beecd
	}
	if _acgg := dict.Get("\u0053h\u0061\u0064\u0069\u006e\u0067"); _acgg != nil {
		_cagdb.Shading = _acgg
	}
	if _edagg := dict.Get("\u0058O\u0062\u006a\u0065\u0063\u0074"); _edagg != nil {
		_cagdb.XObject = _edagg
	}
	if _fabac := _agf.ResolveReference(dict.Get("\u0046\u006f\u006e\u0074")); _fabac != nil {
		_cagdb.Font = _fabac
	}
	if _dcecec := dict.Get("\u0050r\u006f\u0063\u0053\u0065\u0074"); _dcecec != nil {
		_cagdb.ProcSet = _dcecec
	}
	if _dggac := dict.Get("\u0050\u0072\u006f\u0070\u0065\u0072\u0074\u0069\u0065\u0073"); _dggac != nil {
		_cagdb.Properties = _dggac
	}
	return _cagdb, nil
}

// ToPdfObject returns the PDF representation of the shading dictionary.
func (_afgeg *PdfShadingType5) ToPdfObject() _agf.PdfObject {
	_afgeg.PdfShading.ToPdfObject()
	_cdcbc, _dcdbb := _afgeg.getShadingDict()
	if _dcdbb != nil {
		_fd.Log.Error("\u0055\u006ea\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0061\u0063\u0063\u0065\u0073\u0073\u0020\u0073\u0068\u0061\u0064\u0069\u006e\u0067\u0020di\u0063\u0074")
		return nil
	}
	if _afgeg.BitsPerCoordinate != nil {
		_cdcbc.Set("\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006f\u0072\u0064i\u006e\u0061\u0074\u0065", _afgeg.BitsPerCoordinate)
	}
	if _afgeg.BitsPerComponent != nil {
		_cdcbc.Set("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074", _afgeg.BitsPerComponent)
	}
	if _afgeg.VerticesPerRow != nil {
		_cdcbc.Set("\u0056\u0065\u0072\u0074\u0069\u0063\u0065\u0073\u0050e\u0072\u0052\u006f\u0077", _afgeg.VerticesPerRow)
	}
	if _afgeg.Decode != nil {
		_cdcbc.Set("\u0044\u0065\u0063\u006f\u0064\u0065", _afgeg.Decode)
	}
	if _afgeg.Function != nil {
		if len(_afgeg.Function) == 1 {
			_cdcbc.Set("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e", _afgeg.Function[0].ToPdfObject())
		} else {
			_fcbdg := _agf.MakeArray()
			for _, _dgdfgg := range _afgeg.Function {
				_fcbdg.Append(_dgdfgg.ToPdfObject())
			}
			_cdcbc.Set("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e", _fcbdg)
		}
	}
	return _afgeg._ggbge
}

// NewPdfActionMovie returns a new "movie" action.
func NewPdfActionMovie() *PdfActionMovie {
	_bcg := NewPdfAction()
	_ff := &PdfActionMovie{}
	_ff.PdfAction = _bcg
	_bcg.SetContext(_ff)
	return _ff
}

// ColorFromPdfObjects gets the color from a series of pdf objects (3 for rgb).
func (_dgeac *PdfColorspaceDeviceRGB) ColorFromPdfObjects(objects []_agf.PdfObject) (PdfColor, error) {
	if len(objects) != 3 {
		return nil, _gcd.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_agg, _bbgc := _agf.GetNumbersAsFloat(objects)
	if _bbgc != nil {
		return nil, _bbgc
	}
	return _dgeac.ColorFromFloats(_agg)
}
func (_dfgeb *PdfWriter) adjustXRefAffectedVersion(_cgbcc bool) {
	if _cgbcc && _dfgeb._bcdfgg.Major == 1 && _dfgeb._bcdfgg.Minor < 5 {
		_dfgeb._bcdfgg.Minor = 5
	}
}

// SetSamples convert samples to byte-data and sets for the image.
// NOTE: The method resamples the data and this could lead to high memory usage,
// especially on large images. It should be used only when it is not possible
// to work with the image byte data directly.
func (_acdc *Image) SetSamples(samples []uint32) {
	if _acdc.BitsPerComponent < 8 {
		samples = _acdc.samplesAddPadding(samples)
	}
	_dgeed := _db.ResampleUint32(samples, int(_acdc.BitsPerComponent), 8)
	_ddcdc := make([]byte, len(_dgeed))
	for _beeb, _cagc := range _dgeed {
		_ddcdc[_beeb] = byte(_cagc)
	}
	_acdc.Data = _ddcdc
}

// PdfShading represents a shading dictionary. There are 7 types of shading,
// indicatedby the shading type variable:
// 1: Function-based shading.
// 2: Axial shading.
// 3: Radial shading.
// 4: Free-form Gouraud-shaded triangle mesh.
// 5: Lattice-form Gouraud-shaded triangle mesh.
// 6: Coons patch mesh.
// 7: Tensor-product patch mesh.
// types 4-7 are contained in a stream object, where the dictionary is given by the stream dictionary.
type PdfShading struct {
	ShadingType *_agf.PdfObjectInteger
	ColorSpace  PdfColorspace
	Background  *_agf.PdfObjectArray
	BBox        *PdfRectangle
	AntiAlias   *_agf.PdfObjectBool
	_gefcd      PdfModel
	_ggbge      _agf.PdfObject
}

// NewPdfColorPatternType2 returns an empty color shading pattern type 2 (Axial).
func NewPdfColorPatternType2() *PdfColorPatternType2 { _bcbe := &PdfColorPatternType2{}; return _bcbe }
func _fgbce(_bcbdf *_agf.PdfObjectDictionary) (*PdfTilingPattern, error) {
	_ecage := &PdfTilingPattern{}
	_bagb := _bcbdf.Get("\u0050a\u0069\u006e\u0074\u0054\u0079\u0070e")
	if _bagb == nil {
		_fd.Log.Debug("\u0050\u0061\u0069\u006e\u0074\u0054\u0079\u0070\u0065\u0020\u006d\u0069s\u0073\u0069\u006e\u0067")
		return nil, ErrRequiredAttributeMissing
	}
	_daefdf, _eebc := _bagb.(*_agf.PdfObjectInteger)
	if !_eebc {
		_fd.Log.Debug("\u0050\u0061\u0069\u006e\u0074\u0054y\u0070\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074e\u0067\u0065\u0072\u0020\u0028\u0067\u006ft\u0020\u0025\u0054\u0029", _bagb)
		return nil, _agf.ErrTypeError
	}
	_ecage.PaintType = _daefdf
	_bagb = _bcbdf.Get("\u0054\u0069\u006c\u0069\u006e\u0067\u0054\u0079\u0070\u0065")
	if _bagb == nil {
		_fd.Log.Debug("\u0054i\u006ci\u006e\u0067\u0054\u0079\u0070e\u0020\u006di\u0073\u0073\u0069\u006e\u0067")
		return nil, ErrRequiredAttributeMissing
	}
	_cdad, _eebc := _bagb.(*_agf.PdfObjectInteger)
	if !_eebc {
		_fd.Log.Debug("\u0054\u0069\u006cin\u0067\u0054\u0079\u0070\u0065\u0020\u006e\u006f\u0074 \u0061n\u0020i\u006et\u0065\u0067\u0065\u0072\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", _bagb)
		return nil, _agf.ErrTypeError
	}
	_ecage.TilingType = _cdad
	_bagb = _bcbdf.Get("\u0042\u0042\u006f\u0078")
	if _bagb == nil {
		_fd.Log.Debug("\u0042\u0042\u006fx\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067")
		return nil, ErrRequiredAttributeMissing
	}
	_bagb = _agf.TraceToDirectObject(_bagb)
	_aecbe, _eebc := _bagb.(*_agf.PdfObjectArray)
	if !_eebc {
		_fd.Log.Debug("\u0042B\u006f\u0078 \u0073\u0068\u006fu\u006c\u0064\u0020\u0062\u0065\u0020\u0073p\u0065\u0063\u0069\u0066\u0069\u0065d\u0020\u0062\u0079\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061y\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", _bagb)
		return nil, _agf.ErrTypeError
	}
	_bbdef, _cdabc := NewPdfRectangle(*_aecbe)
	if _cdabc != nil {
		_fd.Log.Debug("\u0042\u0042\u006f\u0078\u0020\u0065\u0072\u0072\u006fr\u003a\u0020\u0025\u0076", _cdabc)
		return nil, _cdabc
	}
	_ecage.BBox = _bbdef
	_bagb = _bcbdf.Get("\u0058\u0053\u0074e\u0070")
	if _bagb == nil {
		_fd.Log.Debug("\u0058\u0053\u0074\u0065\u0070\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067")
		return nil, ErrRequiredAttributeMissing
	}
	_gcbbg, _cdabc := _agf.GetNumberAsFloat(_bagb)
	if _cdabc != nil {
		_fd.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0058S\u0074e\u0070\u0020\u0061\u0073\u0020\u0066\u006c\u006f\u0061\u0074\u003a\u0020\u0025\u0076", _gcbbg)
		return nil, _cdabc
	}
	_ecage.XStep = _agf.MakeFloat(_gcbbg)
	_bagb = _bcbdf.Get("\u0059\u0053\u0074e\u0070")
	if _bagb == nil {
		_fd.Log.Debug("\u0059\u0053\u0074\u0065\u0070\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067")
		return nil, ErrRequiredAttributeMissing
	}
	_bfcec, _cdabc := _agf.GetNumberAsFloat(_bagb)
	if _cdabc != nil {
		_fd.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0059S\u0074e\u0070\u0020\u0061\u0073\u0020\u0066\u006c\u006f\u0061\u0074\u003a\u0020\u0025\u0076", _bfcec)
		return nil, _cdabc
	}
	_ecage.YStep = _agf.MakeFloat(_bfcec)
	_bagb = _bcbdf.Get("\u0052e\u0073\u006f\u0075\u0072\u0063\u0065s")
	if _bagb == nil {
		_fd.Log.Debug("\u0052\u0065\u0073\u006f\u0075\u0072\u0063\u0065\u0073\u0020\u006d\u0069s\u0073\u0069\u006e\u0067")
		return nil, ErrRequiredAttributeMissing
	}
	_bcbdf, _eebc = _agf.TraceToDirectObject(_bagb).(*_agf.PdfObjectDictionary)
	if !_eebc {
		return nil, _b.Errorf("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u0065\u0073\u006f\u0075\u0072\u0063e\u0020d\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0054\u0029", _bagb)
	}
	_adbbf, _cdabc := NewPdfPageResourcesFromDict(_bcbdf)
	if _cdabc != nil {
		return nil, _cdabc
	}
	_ecage.Resources = _adbbf
	if _efdd := _bcbdf.Get("\u004d\u0061\u0074\u0072\u0069\u0078"); _efdd != nil {
		_afab, _fbbbg := _efdd.(*_agf.PdfObjectArray)
		if !_fbbbg {
			_fd.Log.Debug("\u004d\u0061\u0074\u0072i\u0078\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072a\u0079\u0020\u0028\u0067\u006f\u0074\u0020%\u0054\u0029", _efdd)
			return nil, _agf.ErrTypeError
		}
		_ecage.Matrix = _afab
	}
	return _ecage, nil
}

// PdfFunction interface represents the common methods of a function in PDF.
type PdfFunction interface {
	Evaluate([]float64) ([]float64, error)
	ToPdfObject() _agf.PdfObject
}

// NewOutline returns a new outline instance.
func NewOutline() *Outline { return &Outline{} }

// CompliancePdfReader is a wrapper over PdfReader that is used for verifying if the input Pdf document matches the
// compliance rules of standards like PDF/A.
// NOTE: This implementation is in experimental development state.
//
//	Keep in mind that it might change in the subsequent minor versions.
type CompliancePdfReader struct {
	*PdfReader
	_eecd _agf.ParserMetadata
}

// GenerateXObjectName generates an unused XObject name that can be used for
// adding new XObjects. Uses format XObj1, XObj2, ...
func (_baagc *PdfPageResources) GenerateXObjectName() _agf.PdfObjectName {
	_aeeab := 1
	for {
		_gfgb := _agf.MakeName(_b.Sprintf("\u0058\u004f\u0062\u006a\u0025\u0064", _aeeab))
		if !_baagc.HasXObjectByName(*_gfgb) {
			return *_gfgb
		}
		_aeeab++
	}
}
func (_dcc *PdfReader) newPdfActionNamedFromDict(_bcc *_agf.PdfObjectDictionary) (*PdfActionNamed, error) {
	return &PdfActionNamed{N: _bcc.Get("\u004e")}, nil
}
func (_bgecg *PdfWriter) writeOutputIntents() error {
	if len(_bgecg._ageec) == 0 {
		return nil
	}
	_dbgc := make([]_agf.PdfObject, len(_bgecg._ageec))
	for _aebdd, _gcdbce := range _bgecg._ageec {
		_efdg := _gcdbce.ToPdfObject()
		_dbgc[_aebdd] = _agf.MakeIndirectObject(_efdg)
	}
	_deacf := _agf.MakeIndirectObject(_agf.MakeArray(_dbgc...))
	_bgecg._bagbb.Set("\u004f\u0075\u0074\u0070\u0075\u0074\u0049\u006e\u0074\u0065\u006e\u0074\u0073", _deacf)
	if _cadc := _bgecg.addObjects(_deacf); _cadc != nil {
		return _cadc
	}
	return nil
}

// Write writes out the PDF.
func (_aabfb *PdfWriter) Write(writer _cf.Writer) error {
	_fd.Log.Trace("\u0057r\u0069\u0074\u0065\u0028\u0029")
	_fbfee := _aabfb.checkLicense()
	if _fbfee != nil {
		return _fbfee
	}
	if _fbfee = _aabfb.writeOutlines(); _fbfee != nil {
		return _fbfee
	}
	if _fbfee = _aabfb.writeAcroFormFields(); _fbfee != nil {
		return _fbfee
	}
	_aabfb.checkPendingObjects()
	if _fbfee = _aabfb.writeOutputIntents(); _fbfee != nil {
		return _fbfee
	}
	_aabfb.setCatalogVersion()
	_aabfb.copyObjects()
	if _fbfee = _aabfb.optimize(); _fbfee != nil {
		return _fbfee
	}
	if _fbfee = _aabfb.optimizeDocument(); _fbfee != nil {
		return _fbfee
	}
	var _acgfg _fc.Hash
	if _aabfb._gcbdb {
		_acgfg = _d.New()
		writer = _cf.MultiWriter(_acgfg, writer)
	}
	_aabfb.setWriter(writer)
	_fcacg := _aabfb.checkCrossReferenceStream()
	_aadaa, _fcacg := _aabfb.mapObjectStreams(_fcacg)
	_aabfb.adjustXRefAffectedVersion(_fcacg)
	_aabfb.writeDocumentVersion()
	_aabfb.updateObjectNumbers()
	_aabfb.writeObjects()
	if _fbfee = _aabfb.writeObjectsInStreams(_aadaa); _fbfee != nil {
		return _fbfee
	}
	_acdfeb := _aabfb._fdce
	var _addeg int
	for _dbfee := range _aabfb._ddcg {
		if _dbfee > _addeg {
			_addeg = _dbfee
		}
	}
	if _aabfb._gcbdb {
		if _fbfee = _aabfb.setHashIDs(_acgfg); _fbfee != nil {
			return _fbfee
		}
	}
	if _fcacg {
		if _fbfee = _aabfb.writeXRefStreams(_addeg, _acdfeb); _fbfee != nil {
			return _fbfee
		}
	} else {
		_aabfb.writeTrailer(_addeg)
	}
	_aabfb.makeOffSetReference(_acdfeb)
	if _fbfee = _aabfb.flushWriter(); _fbfee != nil {
		return _fbfee
	}
	return nil
}

// SetPdfProducer sets the Producer attribute of the output PDF.
func SetPdfProducer(producer string) { _ecba.Lock(); defer _ecba.Unlock(); _badad = producer }

// NewStandard14FontMustCompile returns the standard 14 font named `basefont` as a *PdfFont.
// If `basefont` is one of the 14 Standard14Font values defined above then NewStandard14FontMustCompile
// is guaranteed to succeed.
func NewStandard14FontMustCompile(basefont StdFontName) *PdfFont {
	_dfge, _ebba := NewStandard14Font(basefont)
	if _ebba != nil {
		panic(_b.Errorf("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0053\u0074\u0061n\u0064\u0061\u0072\u0064\u0031\u0034\u0046\u006f\u006e\u0074 \u0025\u0023\u0071", basefont))
	}
	return _dfge
}
func _bcdc(_ggdgc *_agf.PdfObjectDictionary, _adaad *fontCommon) (*pdfCIDFontType0, error) {
	if _adaad._bcbfd != "\u0043\u0049\u0044F\u006f\u006e\u0074\u0054\u0079\u0070\u0065\u0030" {
		_fd.Log.Debug("\u0045R\u0052\u004fR\u003a\u0020\u0046\u006fn\u0074\u0020\u0053u\u0062\u0054\u0079\u0070\u0065\u0020\u0021\u003d\u0020CI\u0044\u0046\u006fn\u0074\u0054y\u0070\u0065\u0030\u002e\u0020\u0066o\u006e\u0074=\u0025\u0073", _adaad)
		return nil, _agf.ErrRangeError
	}
	_dcdf := _fgcgf(_adaad)
	_bdcce, _cedbf := _agf.GetDict(_ggdgc.Get("\u0043\u0049\u0044\u0053\u0079\u0073\u0074\u0065\u006d\u0049\u006e\u0066\u006f"))
	if !_cedbf {
		_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043I\u0044\u0053\u0079st\u0065\u006d\u0049\u006e\u0066\u006f \u0028\u0052\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0029\u0020\u006d\u0069\u0073\u0073i\u006e\u0067\u002e\u0020\u0066\u006f\u006e\u0074=\u0025\u0073", _adaad)
		return nil, ErrRequiredAttributeMissing
	}
	_dcdf.CIDSystemInfo = _bdcce
	_dcdf.DW = _ggdgc.Get("\u0044\u0057")
	_dcdf.W = _ggdgc.Get("\u0057")
	_dcdf.DW2 = _ggdgc.Get("\u0044\u0057\u0032")
	_dcdf.W2 = _ggdgc.Get("\u0057\u0032")
	_dcdf._efcec = 1000.0
	if _dbdgaa, _gbgba := _agf.GetNumberAsFloat(_dcdf.DW); _gbgba == nil {
		_dcdf._efcec = _dbdgaa
	}
	_edbd, _afgbg := _ffbba(_dcdf.W)
	if _afgbg != nil {
		return nil, _afgbg
	}
	if _edbd == nil {
		_edbd = map[_fcg.CharCode]float64{}
	}
	_dcdf._gdgga = _edbd
	return _dcdf, nil
}

// SetBorderWidth sets the style's border width.
func (_abac *PdfBorderStyle) SetBorderWidth(width float64) { _abac.W = &width }

// CharcodesToStrings returns the unicode strings corresponding to `charcodes`.
// The int returns are the number of strings and the number of unconvereted codes.
// NOTE: The number of strings returned is equal to the number of charcodes
func (_bddf *PdfFont) CharcodesToStrings(charcodes []_fcg.CharCode) ([]string, int, int) {
	_eeag := _bddf.baseFields()
	_eace := make([]string, 0, len(charcodes))
	_beea := 0
	_bffa := _bddf.Encoder()
	_bbgfff := _eeag._egfbf != nil && _bddf.IsSimple() && _bddf.Subtype() == "\u0054\u0072\u0075\u0065\u0054\u0079\u0070\u0065" && !_gc.Contains(_eeag._egfbf.Name(), "\u0049d\u0065\u006e\u0074\u0069\u0074\u0079-")
	if !_bbgfff && _bffa != nil {
		switch _ffdd := _bffa.(type) {
		case _fcg.SimpleEncoder:
			_fbcc := _ffdd.BaseName()
			if _, _gdffb := _eddb[_fbcc]; _gdffb {
				for _, _abeeg := range charcodes {
					if _eece, _cbgdg := _bffa.CharcodeToRune(_abeeg); _cbgdg {
						_eace = append(_eace, string(_eece))
					} else {
						_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u004e\u006f\u0020\u0072u\u006e\u0065\u002e\u0020\u0063\u006f\u0064\u0065=\u0030x\u0025\u0030\u0034\u0078\u0020\u0063\u0068\u0061\u0072\u0063\u006f\u0064\u0065\u0073\u003d\u005b\u0025\u00200\u0034\u0078\u005d\u0020\u0043\u0049\u0044\u003d\u0025\u0074\u000a"+"\t\u0066\u006f\u006e\u0074=%\u0073\n\u0009\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003d\u0025\u0073", _abeeg, charcodes, _eeag.isCIDFont(), _bddf, _bffa)
						_beea++
						_eace = append(_eace, _ce.MissingCodeString)
					}
				}
				return _eace, len(_eace), _beea
			}
		}
	}
	for _, _bgff := range charcodes {
		if _eeag._egfbf != nil {
			if _cadded, _ffbf := _eeag._egfbf.CharcodeToUnicode(_ce.CharCode(_bgff)); _ffbf {
				_eace = append(_eace, _cadded)
				continue
			}
		}
		if _bffa != nil {
			if _gaac, _egffc := _bffa.CharcodeToRune(_bgff); _egffc {
				_eace = append(_eace, string(_gaac))
				continue
			}
		}
		_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u004e\u006f\u0020\u0072u\u006e\u0065\u002e\u0020\u0063\u006f\u0064\u0065=\u0030x\u0025\u0030\u0034\u0078\u0020\u0063\u0068\u0061\u0072\u0063\u006f\u0064\u0065\u0073\u003d\u005b\u0025\u00200\u0034\u0078\u005d\u0020\u0043\u0049\u0044\u003d\u0025\u0074\u000a"+"\t\u0066\u006f\u006e\u0074=%\u0073\n\u0009\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003d\u0025\u0073", _bgff, charcodes, _eeag.isCIDFont(), _bddf, _bffa)
		_beea++
		_eace = append(_eace, _ce.MissingCodeString)
	}
	if _beea != 0 {
		_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0043\u006f\u0075\u006c\u0064\u006e\u0027\u0074\u0020\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0020\u0074\u006f\u0020u\u006e\u0069\u0063\u006f\u0064\u0065\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020i\u006ep\u0075\u0074\u002e\u000a"+"\u0009\u006e\u0075\u006d\u0043\u0068\u0061\u0072\u0073\u003d\u0025d\u0020\u006e\u0075\u006d\u004d\u0069\u0073\u0073\u0065\u0073=\u0025\u0064\u000a"+"\u0009\u0066\u006f\u006e\u0074\u003d\u0025\u0073", len(charcodes), _beea, _bddf)
	}
	return _eace, len(_eace), _beea
}

// GetContainingPdfObject implements model.PdfModel interface.
func (_gggdd *PdfOutputIntent) GetContainingPdfObject() _agf.PdfObject { return _gggdd._cebc }

// PdfFunctionType0 uses a sequence of sample values (contained in a stream) to provide an approximation
// for functions whose domains and ranges are bounded. The samples are organized as an m-dimensional
// table in which each entry has n components
type PdfFunctionType0 struct {
	Domain        []float64
	Range         []float64
	NumInputs     int
	NumOutputs    int
	Size          []int
	BitsPerSample int
	Order         int
	Encode        []float64
	Decode        []float64
	_aded         []byte
	_acefg        []uint32
	_fbbfe        *_agf.PdfObjectStream
}

func (_gdacc *pdfFontSimple) addEncoding() error {
	var (
		_aefb  string
		_egcg  map[_fcg.CharCode]_fcg.GlyphName
		_gbeda _fcg.SimpleEncoder
	)
	if _gdacc.Encoder() != nil {
		_gagbg, _dedc := _gdacc.Encoder().(_fcg.SimpleEncoder)
		if _dedc && _gagbg != nil {
			_aefb = _gagbg.BaseName()
		}
	}
	if _gdacc.Encoding != nil {
		_gabe, _cbgg, _bcdfd := _gdacc.getFontEncoding()
		if _bcdfd != nil {
			_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0042\u0061\u0073\u0065F\u006f\u006e\u0074\u003d\u0025\u0071\u0020\u0053u\u0062t\u0079\u0070\u0065\u003d\u0025\u0071\u0020\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003d\u0025\u0073 \u0028\u0025\u0054\u0029\u0020\u0065\u0072\u0072\u003d\u0025\u0076", _gdacc._fccf, _gdacc._bcbfd, _gdacc.Encoding, _gdacc.Encoding, _bcdfd)
			return _bcdfd
		}
		if _gabe != "" {
			_aefb = _gabe
		}
		_egcg = _cbgg
		_gbeda, _bcdfd = _fcg.NewSimpleTextEncoder(_aefb, _egcg)
		if _bcdfd != nil {
			return _bcdfd
		}
	}
	if _gbeda == nil {
		_eaffc := _gdacc._dcfcb
		if _eaffc != nil {
			switch _gdacc._bcbfd {
			case "\u0054\u0079\u0070e\u0031":
				if _eaffc.fontFile != nil && _eaffc.fontFile._aggb != nil {
					_fd.Log.Debug("\u0055\u0073\u0069\u006e\u0067\u0020\u0066\u006f\u006et\u0046\u0069\u006c\u0065")
					_gbeda = _eaffc.fontFile._aggb
				}
			case "\u0054\u0072\u0075\u0065\u0054\u0079\u0070\u0065":
				if _eaffc._fdddd != nil {
					_fd.Log.Debug("\u0055s\u0069n\u0067\u0020\u0046\u006f\u006e\u0074\u0046\u0069\u006c\u0065\u0032")
					_bfed, _acdb := _eaffc._fdddd.MakeEncoder()
					if _acdb == nil {
						_gbeda = _bfed
					}
				}
			}
		}
	}
	if _gbeda != nil {
		if _egcg != nil {
			_fd.Log.Trace("\u0064\u0069\u0066fe\u0072\u0065\u006e\u0063\u0065\u0073\u003d\u0025\u002b\u0076\u0020\u0066\u006f\u006e\u0074\u003d\u0025\u0073", _egcg, _gdacc.baseFields())
			_gbeda = _fcg.ApplyDifferences(_gbeda, _egcg)
		}
		_gdacc.SetEncoder(_gbeda)
	}
	return nil
}

// ToPdfObject returns the text field dictionary within an indirect object (container).
func (_cfefa *PdfFieldText) ToPdfObject() _agf.PdfObject {
	_cfefa.PdfField.ToPdfObject()
	_ecfb := _cfefa._fcgcc
	_aacbe := _ecfb.PdfObject.(*_agf.PdfObjectDictionary)
	_aacbe.Set("\u0046\u0054", _agf.MakeName("\u0054\u0078"))
	if _cfefa.DA != nil {
		_aacbe.Set("\u0044\u0041", _cfefa.DA)
	}
	if _cfefa.Q != nil {
		_aacbe.Set("\u0051", _cfefa.Q)
	}
	if _cfefa.DS != nil {
		_aacbe.Set("\u0044\u0053", _cfefa.DS)
	}
	if _cfefa.RV != nil {
		_aacbe.Set("\u0052\u0056", _cfefa.RV)
	}
	if _cfefa.MaxLen != nil {
		_aacbe.Set("\u004d\u0061\u0078\u004c\u0065\u006e", _cfefa.MaxLen)
	}
	return _ecfb
}

// ColorToRGB converts a Lab color to an RGB color.
func (_gdee *PdfColorspaceLab) ColorToRGB(color PdfColor) (PdfColor, error) {
	_edca := func(_eebd float64) float64 {
		if _eebd >= 6.0/29 {
			return _eebd * _eebd * _eebd
		}
		return 108.0 / 841 * (_eebd - 4.0/29.0)
	}
	_gagbb, _ggfa := color.(*PdfColorLab)
	if !_ggfa {
		_fd.Log.Debug("\u0069\u006e\u0070\u0075t \u0063\u006f\u006c\u006f\u0072\u0020\u006e\u006f\u0074\u0020\u006c\u0061\u0062")
		return nil, _gcd.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	LStar := _gagbb.L()
	AStar := _gagbb.A()
	BStar := _gagbb.B()
	L := (LStar+16)/116 + AStar/500
	M := (LStar + 16) / 116
	N := (LStar+16)/116 - BStar/200
	X := _gdee.WhitePoint[0] * _edca(L)
	Y := _gdee.WhitePoint[1] * _edca(M)
	Z := _gdee.WhitePoint[2] * _edca(N)
	_bbbff := 3.240479*X + -1.537150*Y + -0.498535*Z
	_bgfb := -0.969256*X + 1.875992*Y + 0.041556*Z
	_dede := 0.055648*X + -0.204043*Y + 1.057311*Z
	_bbbff = _afb.Min(_afb.Max(_bbbff, 0), 1.0)
	_bgfb = _afb.Min(_afb.Max(_bgfb, 0), 1.0)
	_dede = _afb.Min(_afb.Max(_dede, 0), 1.0)
	return NewPdfColorDeviceRGB(_bbbff, _bgfb, _dede), nil
}

// PdfAnnotationPolyLine represents PolyLine annotations.
// (Section 12.5.6.9).
type PdfAnnotationPolyLine struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	Vertices _agf.PdfObject
	LE       _agf.PdfObject
	BS       _agf.PdfObject
	IC       _agf.PdfObject
	BE       _agf.PdfObject
	IT       _agf.PdfObject
	Measure  _agf.PdfObject
}

// GetContainingPdfObject returns the XObject Form's containing object (indirect object).
func (_degfa *XObjectForm) GetContainingPdfObject() _agf.PdfObject { return _degfa._dfeac }

// SetName sets the `Name` field of the signature.
func (_acgc *PdfSignature) SetName(name string) { _acgc.Name = _agf.MakeString(name) }
func (_dbdgc *PdfReader) newPdfAnnotationPopupFromDict(_fcfa *_agf.PdfObjectDictionary) (*PdfAnnotationPopup, error) {
	_efced := PdfAnnotationPopup{}
	_efced.Parent = _fcfa.Get("\u0050\u0061\u0072\u0065\u006e\u0074")
	_efced.Open = _fcfa.Get("\u004f\u0070\u0065\u006e")
	return &_efced, nil
}

// NewPdfAnnotation3D returns a new 3d annotation.
func NewPdfAnnotation3D() *PdfAnnotation3D {
	_efad := NewPdfAnnotation()
	_fae := &PdfAnnotation3D{}
	_fae.PdfAnnotation = _efad
	_efad.SetContext(_fae)
	return _fae
}

// ColorFromFloats returns a new PdfColor based on the input slice of color
// components.
func (_gffc *PdfColorspaceICCBased) ColorFromFloats(vals []float64) (PdfColor, error) {
	if _gffc.Alternate == nil {
		if _gffc.N == 1 {
			_bcdb := NewPdfColorspaceDeviceGray()
			return _bcdb.ColorFromFloats(vals)
		} else if _gffc.N == 3 {
			_badb := NewPdfColorspaceDeviceRGB()
			return _badb.ColorFromFloats(vals)
		} else if _gffc.N == 4 {
			_gagdb := NewPdfColorspaceDeviceCMYK()
			return _gagdb.ColorFromFloats(vals)
		} else {
			return nil, _gcd.New("I\u0043\u0043\u0020\u0042\u0061\u0073\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063e\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0061lt\u0065\u0072\u006ea\u0074i\u0076\u0065")
		}
	}
	return _gffc.Alternate.ColorFromFloats(vals)
}

// ToPdfObject implements interface PdfModel.
func (_ef *PdfActionThread) ToPdfObject() _agf.PdfObject {
	_ef.PdfAction.ToPdfObject()
	_dca := _ef._caf
	_gdf := _dca.PdfObject.(*_agf.PdfObjectDictionary)
	_gdf.SetIfNotNil("\u0053", _agf.MakeName(string(ActionTypeThread)))
	if _ef.F != nil {
		_gdf.Set("\u0046", _ef.F.ToPdfObject())
	}
	_gdf.SetIfNotNil("\u0044", _ef.D)
	_gdf.SetIfNotNil("\u0042", _ef.B)
	return _dca
}

// ToPdfObject implements interface PdfModel.
func (_adae *PdfActionHide) ToPdfObject() _agf.PdfObject {
	_adae.PdfAction.ToPdfObject()
	_egd := _adae._caf
	_efc := _egd.PdfObject.(*_agf.PdfObjectDictionary)
	_efc.SetIfNotNil("\u0053", _agf.MakeName(string(ActionTypeHide)))
	_efc.SetIfNotNil("\u0054", _adae.T)
	_efc.SetIfNotNil("\u0048", _adae.H)
	return _egd
}

// Set applies flag fl to the flag's bitmask and returns the combined flag.
func (_dgcef FieldFlag) Set(fl FieldFlag) FieldFlag { return FieldFlag(_dgcef.Mask() | fl.Mask()) }
func (_dadda *PdfField) inherit(_gbged func(*PdfField) bool) (bool, error) {
	_baae := map[*PdfField]bool{}
	_gbec := false
	_afdc := _dadda
	for _afdc != nil {
		if _, _efbff := _baae[_afdc]; _efbff {
			return false, _gcd.New("\u0072\u0065\u0063\u0075rs\u0069\u0076\u0065\u0020\u0074\u0072\u0061\u0076\u0065\u0072\u0073\u0061\u006c")
		}
		_cgecf := _gbged(_afdc)
		if _cgecf {
			_gbec = true
			break
		}
		_baae[_afdc] = true
		_afdc = _afdc.Parent
	}
	return _gbec, nil
}

// GetPdfVersion gets the version of the PDF used within this document.
func (_gageb *PdfWriter) GetPdfVersion() string { return _gageb.getPdfVersion() }

// PdfReader represents a PDF file reader. It is a frontend to the lower level parsing mechanism and provides
// a higher level access to work with PDF structure and information, such as the page structure etc.
type PdfReader struct {
	_egdga   *_agf.PdfParser
	_eafdd   _agf.PdfObject
	_afgbb   *_agf.PdfIndirectObject
	_cfffb   *_agf.PdfObjectDictionary
	_eddcd   []*_agf.PdfIndirectObject
	PageList []*PdfPage
	_fbaed   int
	_ceaadd  *_agf.PdfObjectDictionary
	_gfdaa   *PdfOutlineTreeNode
	AcroForm *PdfAcroForm
	DSS      *DSS
	Rotate   *int64
	_gbdc    *Permissions
	_gaaabg  map[*PdfReader]*PdfReader
	_fged    []*PdfReader
	_dcdeb   *modelManager
	_ccage   bool
	_eggbg   map[_agf.PdfObject]struct{}
	_bggga   _cf.ReadSeeker
	_gdfb    string
	_gcbbc   bool
	_ddgee   *ReaderOpts
	_gdab    bool
}

func (_ebcfb *PdfWriter) checkPendingObjects() {
	for _aecaa, _effdb := range _ebcfb._afcfaf {
		if !_ebcfb.hasObject(_aecaa) {
			_fd.Log.Debug("\u0057\u0041\u0052\u004e\u0020\u0050\u0065n\u0064\u0069\u006eg\u0020\u006f\u0062j\u0065\u0063t\u0020\u0025\u002b\u0076\u0020\u0025T\u0020(%\u0070\u0029\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0061\u0064\u0064\u0065\u0064\u0020\u0066\u006f\u0072\u0020\u0077\u0072\u0069\u0074\u0069\u006e\u0067", _aecaa, _aecaa, _aecaa)
			for _, _babf := range _effdb {
				for _, _dgcfdb := range _babf.Keys() {
					_edbbc := _babf.Get(_dgcfdb)
					if _edbbc == _aecaa {
						_fd.Log.Debug("\u0050e\u006e\u0064i\u006e\u0067\u0020\u006fb\u006a\u0065\u0063t\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0061nd\u0020\u0072\u0065p\u006c\u0061c\u0065\u0064\u0020\u0077\u0069\u0074h\u0020\u006eu\u006c\u006c")
						_babf.Set(_dgcfdb, _agf.MakeNull())
						break
					}
				}
			}
		}
	}
}

// NewStandardPdfOutputIntent creates a new standard PdfOutputIntent.
func NewStandardPdfOutputIntent(outputCondition, outputConditionIdentifier, registryName string, destOutputProfile []byte, colorComponents int) *PdfOutputIntent {
	return &PdfOutputIntent{Type: "\u004f\u0075\u0074p\u0075\u0074\u0049\u006e\u0074\u0065\u006e\u0074", OutputCondition: outputCondition, OutputConditionIdentifier: outputConditionIdentifier, RegistryName: registryName, DestOutputProfile: destOutputProfile, ColorComponents: colorComponents, _cebc: _agf.MakeDict()}
}

// GetContext returns a reference to the subpattern entry: either PdfTilingPattern or PdfShadingPattern.
func (_cacff *PdfPattern) GetContext() PdfModel { return _cacff._dfed }

// PdfFunctionType2 defines an exponential interpolation of one input value and n
// output values:
//
//	f(x) = y_0, ..., y_(n-1)
//
// y_j = C0_j + x^N * (C1_j - C0_j); for 0 <= j < n
// When N=1 ; linear interpolation between C0 and C1.
type PdfFunctionType2 struct {
	Domain []float64
	Range  []float64
	C0     []float64
	C1     []float64
	N      float64
	_ecgd  *_agf.PdfIndirectObject
}

func (_agcd *PdfReader) loadStructure() error {
	if _agcd._egdga.GetCrypter() != nil && !_agcd._egdga.IsAuthenticated() {
		return _b.Errorf("\u0066\u0069\u006ce\u0020\u006e\u0065\u0065d\u0020\u0074\u006f\u0020\u0062\u0065\u0020d\u0065\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0020\u0066\u0069\u0072\u0073\u0074")
	}
	_beeba := _agcd._egdga.GetTrailer()
	if _beeba == nil {
		return _b.Errorf("\u006di\u0073s\u0069\u006e\u0067\u0020\u0074\u0072\u0061\u0069\u006c\u0065\u0072")
	}
	_cdecgf, _defe := _beeba.Get("\u0052\u006f\u006f\u0074").(*_agf.PdfObjectReference)
	if !_defe {
		return _b.Errorf("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0052\u006f\u006ft\u0020\u0028\u0074\u0072\u0061\u0069\u006c\u0065\u0072\u003a \u0025\u0073\u0029", _beeba)
	}
	_cdaea, _dcfdb := _agcd._egdga.LookupByReference(*_cdecgf)
	if _dcfdb != nil {
		_fd.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072\u0065\u0061\u0064\u0020\u0072\u006f\u006f\u0074\u0020\u0065\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u0063\u0061\u0074\u0061\u006c\u006f\u0067\u003a\u0020\u0025\u0073", _dcfdb)
		return _dcfdb
	}
	_febcc, _defe := _cdaea.(*_agf.PdfIndirectObject)
	if !_defe {
		_fd.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u004d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0063\u0061\u0074\u0061\u006c\u006f\u0067\u003a\u0020\u0028\u0072\u006f\u006f\u0074\u0020\u0025\u0071\u0029\u0020\u0028\u0074\u0072\u0061\u0069\u006c\u0065\u0072\u0020\u0025\u0073\u0029", _cdaea, *_beeba)
		return _gcd.New("\u006di\u0073s\u0069\u006e\u0067\u0020\u0063\u0061\u0074\u0061\u006c\u006f\u0067")
	}
	_abdeg, _defe := (*_febcc).PdfObject.(*_agf.PdfObjectDictionary)
	if !_defe {
		_fd.Log.Debug("E\u0052\u0052\u004f\u0052\u003a\u0020I\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0063\u0061t\u0061\u006c\u006fg\u0020(\u0025\u0073\u0029", _febcc.PdfObject)
		return _gcd.New("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0063\u0061\u0074\u0061\u006c\u006f\u0067")
	}
	_fd.Log.Trace("C\u0061\u0074\u0061\u006c\u006f\u0067\u003a\u0020\u0025\u0073", _abdeg)
	_gacea, _defe := _abdeg.Get("\u0050\u0061\u0067e\u0073").(*_agf.PdfObjectReference)
	if !_defe {
		return _gcd.New("\u0070\u0061\u0067\u0065\u0073\u0020\u0069\u006e\u0020\u0063\u0061\u0074\u0061\u006c\u006f\u0067\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020b\u0065\u0020\u0061\u0020\u0072e\u0066\u0065r\u0065\u006e\u0063\u0065")
	}
	_egegd, _dcfdb := _agcd._egdga.LookupByReference(*_gacea)
	if _dcfdb != nil {
		_fd.Log.Debug("E\u0052\u0052\u004f\u0052\u003a\u0020F\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020r\u0065\u0061\u0064 \u0070a\u0067\u0065\u0073")
		return _dcfdb
	}
	_ebedb, _defe := _egegd.(*_agf.PdfIndirectObject)
	if !_defe {
		_fd.Log.Debug("E\u0052\u0052\u004f\u0052\u003a\u0020P\u0061\u0067\u0065\u0073\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0069n\u0076a\u006c\u0069\u0064")
		_fd.Log.Debug("\u006f\u0070\u003a\u0020\u0025\u0070", _ebedb)
		return _gcd.New("p\u0061g\u0065\u0073\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0069\u006e\u0076al\u0069\u0064")
	}
	_cdadd, _defe := _ebedb.PdfObject.(*_agf.PdfObjectDictionary)
	if !_defe {
		_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0050\u0061\u0067\u0065\u0073\u0020\u006f\u0062j\u0065c\u0074\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0025\u0073\u0029", _ebedb)
		return _gcd.New("p\u0061g\u0065\u0073\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0069\u006e\u0076al\u0069\u0064")
	}
	_dgcecc, _defe := _agf.GetInt(_cdadd.Get("\u0043\u006f\u0075n\u0074"))
	if !_defe {
		_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0050\u0061\u0067\u0065\u0073\u0020\u0063\u006f\u0075\u006e\u0074\u0020\u006fb\u006a\u0065\u0063\u0074\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
		return _gcd.New("\u0070\u0061\u0067\u0065s \u0063\u006f\u0075\u006e\u0074\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064")
	}
	if _, _defe = _agf.GetName(_cdadd.Get("\u0054\u0079\u0070\u0065")); !_defe {
		_fd.Log.Debug("\u0050\u0061\u0067\u0065\u0073\u0020\u0064\u0069\u0063\u0074\u0020T\u0079\u0070\u0065\u0020\u0066\u0069\u0065\u006cd\u0020n\u006f\u0074\u0020\u0073\u0065\u0074\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0054\u0079p\u0065\u0020\u0074\u006f\u0020\u0050\u0061\u0067\u0065\u0073\u002e")
		_cdadd.Set("\u0054\u0079\u0070\u0065", _agf.MakeName("\u0050\u0061\u0067e\u0073"))
	}
	if _caaacd, _eedfc := _agf.GetInt(_cdadd.Get("\u0052\u006f\u0074\u0061\u0074\u0065")); _eedfc {
		_daae := int64(*_caaacd)
		_agcd.Rotate = &_daae
	}
	_agcd._eafdd = _cdecgf
	_agcd._ceaadd = _abdeg
	_agcd._cfffb = _cdadd
	_agcd._afgbb = _ebedb
	_agcd._fbaed = int(*_dgcecc)
	_agcd._eddcd = []*_agf.PdfIndirectObject{}
	_bcaec := map[_agf.PdfObject]struct{}{}
	_dcfdb = _agcd.buildPageList(_ebedb, nil, _bcaec)
	if _dcfdb != nil {
		return _dcfdb
	}
	_fd.Log.Trace("\u002d\u002d\u002d")
	_fd.Log.Trace("\u0054\u004f\u0043")
	_fd.Log.Trace("\u0050\u0061\u0067e\u0073")
	_fd.Log.Trace("\u0025\u0064\u003a\u0020\u0025\u0073", len(_agcd._eddcd), _agcd._eddcd)
	_agcd._gfdaa, _dcfdb = _agcd.loadOutlines()
	if _dcfdb != nil {
		_fd.Log.Debug("E\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0062\u0075i\u006c\u0064\u0020\u006f\u0075\u0074\u006c\u0069\u006e\u0065 t\u0072\u0065\u0065 \u0028%\u0073\u0029", _dcfdb)
		return _dcfdb
	}
	_agcd.AcroForm, _dcfdb = _agcd.loadForms()
	if _dcfdb != nil {
		return _dcfdb
	}
	_agcd.DSS, _dcfdb = _agcd.loadDSS()
	if _dcfdb != nil {
		return _dcfdb
	}
	_agcd._gbdc, _dcfdb = _agcd.loadPerms()
	if _dcfdb != nil {
		return _dcfdb
	}
	return nil
}

// FlattenFields flattens the form fields and annotations for the PDF loaded in `pdf` and makes
// non-editable.
// Looks up all widget annotations corresponding to form fields and flattens them by drawing the content
// through the content stream rather than annotations.
// References to flattened annotations will be removed from Page Annots array. For fields the AcroForm entry
// will be emptied.
// When `allannots` is true, all annotations will be flattened. Keep false if want to keep non-form related
// annotations intact.
// When `appgen` is not nil, it will be used to generate appearance streams for the field annotations.
func (_gadb *PdfReader) FlattenFields(allannots bool, appgen FieldAppearanceGenerator) error {
	return _gadb.flattenFieldsWithOpts(allannots, appgen, nil)
}

// ToPdfObject returns the PDF representation of the colorspace.
func (_ffag *PdfColorspaceSpecialSeparation) ToPdfObject() _agf.PdfObject {
	_bdbe := _agf.MakeArray(_agf.MakeName("\u0053\u0065\u0070\u0061\u0072\u0061\u0074\u0069\u006f\u006e"))
	_bdbe.Append(_ffag.ColorantName)
	_bdbe.Append(_ffag.AlternateSpace.ToPdfObject())
	_bdbe.Append(_ffag.TintTransform.ToPdfObject())
	if _ffag._abeb != nil {
		_ffag._abeb.PdfObject = _bdbe
		return _ffag._abeb
	}
	return _bdbe
}
func _gagf(_cddcg *_agf.PdfObjectDictionary) bool {
	for _, _cege := range _cddcg.Keys() {
		if _, _bffg := _fbgb[_cege.String()]; _bffg {
			return true
		}
	}
	return false
}

// GetNumComponents returns the number of color components (3 for RGB).
func (_agca *PdfColorDeviceRGB) GetNumComponents() int { return 3 }

// RepairAcroForm attempts to rebuild the AcroForm fields using the widget
// annotations present in the document pages. Pass nil for the opts parameter
// in order to use the default options.
// NOTE: Currently, the opts parameter is declared in order to enable adding
// future options, but passing nil will always result in the default options
// being used.
func (_fabb *PdfReader) RepairAcroForm(opts *AcroFormRepairOptions) error {
	var _cccbc []*PdfField
	_ecacf := map[*_agf.PdfIndirectObject]struct{}{}
	for _, _afad := range _fabb.PageList {
		_gfac, _adcfe := _afad.GetAnnotations()
		if _adcfe != nil {
			return _adcfe
		}
		for _, _fbdcb := range _gfac {
			var _aaefad *PdfField
			switch _cfbdb := _fbdcb.GetContext().(type) {
			case *PdfAnnotationWidget:
				if _cfbdb._efe != nil {
					_aaefad = _cfbdb._efe
					break
				}
				if _gafgg, _dfaea := _agf.GetIndirect(_cfbdb.Parent); _dfaea {
					_aaefad, _adcfe = _fabb.newPdfFieldFromIndirectObject(_gafgg, nil)
					if _adcfe == nil {
						break
					}
					_fd.Log.Debug("W\u0041\u0052\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0070\u0061\u0072s\u0065\u0020\u0066\u006f\u0072\u006d\u0020\u0066\u0069\u0065ld\u0020\u0025\u002bv\u003a \u0025\u0076", _gafgg, _adcfe)
				}
				if _cfbdb._aeee != nil {
					_aaefad, _adcfe = _fabb.newPdfFieldFromIndirectObject(_cfbdb._aeee, nil)
					if _adcfe == nil {
						break
					}
					_fd.Log.Debug("W\u0041\u0052\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0070\u0061\u0072s\u0065\u0020\u0066\u006f\u0072\u006d\u0020\u0066\u0069\u0065ld\u0020\u0025\u002bv\u003a \u0025\u0076", _cfbdb._aeee, _adcfe)
				}
			}
			if _aaefad == nil {
				continue
			}
			if _, _abbcg := _ecacf[_aaefad._fcgcc]; _abbcg {
				continue
			}
			_ecacf[_aaefad._fcgcc] = struct{}{}
			_cccbc = append(_cccbc, _aaefad)
		}
	}
	if len(_cccbc) == 0 {
		return nil
	}
	if _fabb.AcroForm == nil {
		_fabb.AcroForm = NewPdfAcroForm()
	}
	_fabb.AcroForm.Fields = &_cccbc
	return nil
}

// HasExtGState checks whether a font is defined by the specified keyName.
func (_agee *PdfPageResources) HasExtGState(keyName _agf.PdfObjectName) bool {
	_, _ffgg := _agee.GetFontByName(keyName)
	return _ffgg
}

// CustomKeys returns all custom info keys as list.
func (_fcfd *PdfInfo) CustomKeys() []string {
	if _fcfd._adfbb == nil {
		return nil
	}
	_acgb := make([]string, len(_fcfd._adfbb.Keys()))
	for _, _edbf := range _fcfd._adfbb.Keys() {
		_acgb = append(_acgb, _edbf.String())
	}
	return _acgb
}

// OutlineItem represents a PDF outline item dictionary (Table 153 - pp. 376 - 377).
type OutlineItem struct {
	Title   string         `json:"title"`
	Dest    OutlineDest    `json:"dest"`
	Entries []*OutlineItem `json:"entries,omitempty"`
}

// PdfColor interface represents a generic color in PDF.
type PdfColor interface{}

func (_afgdc *PdfColorspaceLab) String() string { return "\u004c\u0061\u0062" }

// IsCheckbox returns true if the button field represents a checkbox, false otherwise.
func (_fecag *PdfFieldButton) IsCheckbox() bool { return _fecag.GetType() == ButtonTypeCheckbox }
func (_cbfd *DSS) generateHashMap(_aeaaf []*_agf.PdfObjectStream) (map[string]*_agf.PdfObjectStream, error) {
	_fbbb := map[string]*_agf.PdfObjectStream{}
	for _, _fgaa := range _aeaaf {
		_agfgf, _babg := _agf.DecodeStream(_fgaa)
		if _babg != nil {
			return nil, _babg
		}
		_cbfee, _babg := _aadgc(_agfgf)
		if _babg != nil {
			return nil, _babg
		}
		_fbbb[string(_cbfee)] = _fgaa
	}
	return _fbbb, nil
}

// Clear clears flag fl from the flag and returns the resulting flag.
func (_aage FieldFlag) Clear(fl FieldFlag) FieldFlag { return FieldFlag(_aage.Mask() &^ fl.Mask()) }
func (_adg *PdfReader) newPdfAnnotationSquareFromDict(_cafg *_agf.PdfObjectDictionary) (*PdfAnnotationSquare, error) {
	_dffc := PdfAnnotationSquare{}
	_acf, _baa := _adg.newPdfAnnotationMarkupFromDict(_cafg)
	if _baa != nil {
		return nil, _baa
	}
	_dffc.PdfAnnotationMarkup = _acf
	_dffc.BS = _cafg.Get("\u0042\u0053")
	_dffc.IC = _cafg.Get("\u0049\u0043")
	_dffc.BE = _cafg.Get("\u0042\u0045")
	_dffc.RD = _cafg.Get("\u0052\u0044")
	return &_dffc, nil
}

// GetRuneMetrics returns the character metrics for the specified rune.
// A bool flag is returned to indicate whether or not the entry was found.
func (_fedbd pdfCIDFontType2) GetRuneMetrics(r rune) (_aa.CharMetrics, bool) {
	_dcgea, _dgee := _fedbd._dbae[r]
	if !_dgee {
		_deef, _dbaeg := _agf.GetInt(_fedbd.DW)
		if !_dbaeg {
			return _aa.CharMetrics{}, false
		}
		_dcgea = int(*_deef)
	}
	return _aa.CharMetrics{Wx: float64(_dcgea)}, true
}

// String returns string value of output intent for given type
// ISO_19005-2 6.2.3: GTS_PDFA1 value should be used for PDF/A-1, A-2 and A-3 at least
func (_bceef PdfOutputIntentType) String() string {
	switch _bceef {
	case PdfOutputIntentTypeA1:
		return "\u0047T\u0053\u005f\u0050\u0044\u0046\u00411"
	case PdfOutputIntentTypeA2:
		return "\u0047T\u0053\u005f\u0050\u0044\u0046\u00411"
	case PdfOutputIntentTypeA3:
		return "\u0047T\u0053\u005f\u0050\u0044\u0046\u00411"
	case PdfOutputIntentTypeA4:
		return "\u0047T\u0053\u005f\u0050\u0044\u0046\u00411"
	case PdfOutputIntentTypeX:
		return "\u0047\u0054\u0053\u005f\u0050\u0044\u0046\u0058"
	default:
		return "\u0055N\u0044\u0045\u0046\u0049\u004e\u0045D"
	}
}
func (_bcgba fontCommon) coreString() string {
	_dccf := ""
	if _bcgba._dcfcb != nil {
		_dccf = _bcgba._dcfcb.String()
	}
	return _b.Sprintf("\u0025#\u0071\u0020%\u0023\u0071\u0020%\u0071\u0020\u006f\u0062\u006a\u003d\u0025d\u0020\u0054\u006f\u0055\u006e\u0069c\u006f\u0064\u0065\u003d\u0025\u0074\u0020\u0066\u006c\u0061\u0067s\u003d\u0030\u0078\u0025\u0030\u0078\u0020\u0025\u0073", _bcgba._bcbfd, _bcgba._fccf, _bcgba._afbeb, _bcgba._gcdfc, _bcgba._ebabcd != nil, _bcgba.fontFlags(), _dccf)
}

// GetOCProperties returns the optional content properties PdfObject.
func (_fegag *PdfReader) GetOCProperties() (_agf.PdfObject, error) {
	_edcega := _fegag._ceaadd
	_ecdfd := _edcega.Get("\u004f\u0043\u0050r\u006f\u0070\u0065\u0072\u0074\u0069\u0065\u0073")
	_ecdfd = _agf.ResolveReference(_ecdfd)
	if !_fegag._ccage {
		_eddfgc := _fegag.traverseObjectData(_ecdfd)
		if _eddfgc != nil {
			return nil, _eddfgc
		}
	}
	return _ecdfd, nil
}

// ToPdfObject return the CalGray colorspace as a PDF object (name dictionary).
func (_cadd *PdfColorspaceCalGray) ToPdfObject() _agf.PdfObject {
	_fdfff := &_agf.PdfObjectArray{}
	_fdfff.Append(_agf.MakeName("\u0043a\u006c\u0047\u0072\u0061\u0079"))
	_bgdd := _agf.MakeDict()
	if _cadd.WhitePoint != nil {
		_bgdd.Set("\u0057\u0068\u0069\u0074\u0065\u0050\u006f\u0069\u006e\u0074", _agf.MakeArray(_agf.MakeFloat(_cadd.WhitePoint[0]), _agf.MakeFloat(_cadd.WhitePoint[1]), _agf.MakeFloat(_cadd.WhitePoint[2])))
	} else {
		_fd.Log.Error("\u0043\u0061\u006c\u0047\u0072\u0061\u0079\u003a\u0020\u004d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0057\u0068\u0069\u0074\u0065\u0050\u006fi\u006e\u0074\u0020\u0028\u0052e\u0071\u0075i\u0072\u0065\u0064\u0029")
	}
	if _cadd.BlackPoint != nil {
		_bgdd.Set("\u0042\u006c\u0061\u0063\u006b\u0050\u006f\u0069\u006e\u0074", _agf.MakeArray(_agf.MakeFloat(_cadd.BlackPoint[0]), _agf.MakeFloat(_cadd.BlackPoint[1]), _agf.MakeFloat(_cadd.BlackPoint[2])))
	}
	_bgdd.Set("\u0047\u0061\u006dm\u0061", _agf.MakeFloat(_cadd.Gamma))
	_fdfff.Append(_bgdd)
	if _cadd._gec != nil {
		_cadd._gec.PdfObject = _fdfff
		return _cadd._gec
	}
	return _fdfff
}

// NewPdfFilespecFromObj creates and returns a new PdfFilespec object.
func NewPdfFilespecFromObj(obj _agf.PdfObject) (*PdfFilespec, error) {
	_bedec := &PdfFilespec{}
	var _feba *_agf.PdfObjectDictionary
	if _cbfbb, _geaf := _agf.GetIndirect(obj); _geaf {
		_bedec._bfdc = _cbfbb
		_gefd, _abfaa := _agf.GetDict(_cbfbb.PdfObject)
		if !_abfaa {
			_fd.Log.Debug("\u004f\u0062\u006a\u0065c\u0074\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069c\u0074i\u006f\u006e\u0061\u0072\u0079\u0020\u0074y\u0070\u0065")
			return nil, _agf.ErrTypeError
		}
		_feba = _gefd
	} else if _ddge, _efcge := _agf.GetDict(obj); _efcge {
		_bedec._bfdc = _ddge
		_feba = _ddge
	} else {
		_fd.Log.Debug("O\u0062\u006a\u0065\u0063\u0074\u0020t\u0079\u0070\u0065\u0020\u0075\u006e\u0065\u0078\u0070e\u0063\u0074\u0065d\u0020(\u0025\u0054\u0029", obj)
		return nil, _agf.ErrTypeError
	}
	if _feba == nil {
		_fd.Log.Debug("\u0044i\u0063t\u0069\u006f\u006e\u0061\u0072y\u0020\u006di\u0073\u0073\u0069\u006e\u0067")
		return nil, _gcd.New("\u0064\u0069\u0063t\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067")
	}
	if _gdeag := _feba.Get("\u0054\u0079\u0070\u0065"); _gdeag != nil {
		_ddgb, _fgac := _gdeag.(*_agf.PdfObjectName)
		if !_fgac {
			_fd.Log.Trace("\u0049\u006e\u0063\u006f\u006d\u0070\u0061\u0074\u0069\u0062\u0069\u006c\u0069\u0074\u0079\u0021\u0020\u0049\u006e\u0076a\u006c\u0069\u0064\u0020\u0074\u0079\u0070\u0065\u0020\u006f\u0066\u0020\u0054\u0079\u0070\u0065\u0020\u0028\u0025\u0054\u0029\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064 \u0062\u0065\u0020\u004e\u0061m\u0065", _gdeag)
		} else {
			if *_ddgb != "\u0046\u0069\u006c\u0065\u0073\u0070\u0065\u0063" {
				_fd.Log.Trace("\u0055\u006e\u0073\u0075\u0073\u0070e\u0063\u0074\u0065\u0064\u0020\u0054\u0079\u0070\u0065\u0020\u0021\u003d\u0020F\u0069\u006c\u0065\u0073\u0070\u0065\u0063 \u0028\u0025\u0073\u0029", *_ddgb)
			}
		}
	}
	if _fgga := _feba.Get("\u0046\u0053"); _fgga != nil {
		_bedec.FS = _fgga
	}
	if _adbfe := _feba.Get("\u0046"); _adbfe != nil {
		_bedec.F = _adbfe
	}
	if _bfcab := _feba.Get("\u0055\u0046"); _bfcab != nil {
		_bedec.UF = _bfcab
	}
	if _gacec := _feba.Get("\u0044\u004f\u0053"); _gacec != nil {
		_bedec.DOS = _gacec
	}
	if _bebfd := _feba.Get("\u004d\u0061\u0063"); _bebfd != nil {
		_bedec.Mac = _bebfd
	}
	if _beba := _feba.Get("\u0055\u006e\u0069\u0078"); _beba != nil {
		_bedec.Unix = _beba
	}
	if _aggf := _feba.Get("\u0049\u0044"); _aggf != nil {
		_bedec.ID = _aggf
	}
	if _dfbg := _feba.Get("\u0056"); _dfbg != nil {
		_bedec.V = _dfbg
	}
	if _fgbb := _feba.Get("\u0045\u0046"); _fgbb != nil {
		_bedec.EF = _fgbb
	}
	if _gfcbd := _feba.Get("\u0052\u0046"); _gfcbd != nil {
		_bedec.RF = _gfcbd
	}
	if _babb := _feba.Get("\u0044\u0065\u0073\u0063"); _babb != nil {
		_bedec.Desc = _babb
	}
	if _eefd := _feba.Get("\u0043\u0049"); _eefd != nil {
		_bedec.CI = _eefd
	}
	return _bedec, nil
}
func (_dfae fontCommon) fontFlags() int {
	if _dfae._dcfcb == nil {
		return 0
	}
	return _dfae._dcfcb._babge
}

var (
	ErrRequiredAttributeMissing = _gcd.New("\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0020\u0061\u0074t\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u006d\u0069\u0073s\u0069\u006e\u0067")
	ErrInvalidAttribute         = _gcd.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065")
	ErrTypeCheck                = _gcd.New("\u0074\u0079\u0070\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	_cffa                       = _gcd.New("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072")
	ErrEncrypted                = _gcd.New("\u0066\u0069\u006c\u0065\u0020\u006e\u0065\u0065\u0064\u0073\u0020\u0074\u006f\u0020\u0062e\u0020d\u0065\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0020\u0066\u0069\u0072\u0073\u0074")
	ErrNoFont                   = _gcd.New("\u0066\u006fn\u0074\u0020\u006eo\u0074\u0020\u0064\u0065\u0066\u0069\u006e\u0065\u0064")
	ErrFontNotSupported         = _fda.Errorf("u\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0066\u006fn\u0074\u0020\u0028\u0025\u0077\u0029", _agf.ErrNotSupported)
	ErrType1CFontNotSupported   = _fda.Errorf("\u0054y\u0070\u00651\u0043\u0020\u0066o\u006e\u0074\u0073\u0020\u0061\u0072\u0065 \u006e\u006f\u0074\u0020\u0063\u0075r\u0072\u0065\u006e\u0074\u006c\u0079\u0020\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0028\u0025\u0077\u0029", _agf.ErrNotSupported)
	ErrType3FontNotSupported    = _fda.Errorf("\u0054y\u0070\u00653\u0020\u0066\u006f\u006et\u0073\u0020\u0061r\u0065\u0020\u006e\u006f\u0074\u0020\u0063\u0075\u0072re\u006e\u0074\u006cy\u0020\u0073u\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0028%\u0077\u0029", _agf.ErrNotSupported)
	ErrTTCmapNotSupported       = _fda.Errorf("\u0075\u006es\u0075\u0070\u0070\u006fr\u0074\u0065d\u0020\u0054\u0072\u0075\u0065\u0054\u0079\u0070e\u0020\u0063\u006d\u0061\u0070\u0020\u0066\u006f\u0072\u006d\u0061\u0074 \u0028\u0025\u0077\u0029", _agf.ErrNotSupported)
	ErrSignNotEnoughSpace       = _fda.Errorf("\u0069\u006e\u0073\u0075\u0066\u0066\u0069c\u0069\u0065\u006et\u0020\u0073\u0070a\u0063\u0065 \u0061\u006c\u006c\u006f\u0063\u0061t\u0065d \u0066\u006f\u0072\u0020\u0074\u0068\u0065\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0073")
	ErrSignNoCertificates       = _fda.Errorf("\u0063\u006ful\u0064\u0020\u006eo\u0074\u0020\u0072\u0065tri\u0065ve\u0020\u0063\u0065\u0072\u0074\u0069\u0066ic\u0061\u0074\u0065\u0020\u0063\u0068\u0061i\u006e")
)

// HasFontByName checks whether a font is defined by the specified keyName.
func (_badfb *PdfPageResources) HasFontByName(keyName _agf.PdfObjectName) bool {
	_, _egggb := _badfb.GetFontByName(keyName)
	return _egggb
}

// Duplicate creates a duplicate page based on the current one and returns it.
func (_bfabd *PdfPage) Duplicate() *PdfPage {
	_acec := *_bfabd
	_acec._ececfb = _agf.MakeDict()
	_acec._edegf = _agf.MakeIndirectObject(_acec._ececfb)
	_acec._gabcc = *_acec._ececfb
	return &_acec
}

// NewPdfAppenderWithOpts creates a new Pdf appender from a Pdf reader with options.
func NewPdfAppenderWithOpts(reader *PdfReader, opts *ReaderOpts, encryptOptions *EncryptOptions) (*PdfAppender, error) {
	_fggf := &PdfAppender{_dcac: reader._bggga, Reader: reader, _dafc: reader._egdga, _eadd: reader._eggbg}
	_fbg, _cdab := _fggf._dcac.Seek(0, _cf.SeekEnd)
	if _cdab != nil {
		return nil, _cdab
	}
	_fggf._cdf = _fbg
	if _, _cdab = _fggf._dcac.Seek(0, _cf.SeekStart); _cdab != nil {
		return nil, _cdab
	}
	_fggf._gdeb, _cdab = NewPdfReaderWithOpts(_fggf._dcac, opts)
	if _cdab != nil {
		return nil, _cdab
	}
	for _, _fdf := range _fggf.Reader.GetObjectNums() {
		if _fggf._bada < _fdf {
			_fggf._bada = _fdf
		}
	}
	_fggf._dafg = _fggf._dafc.GetXrefTable()
	_fggf._aede = _fggf._dafc.GetXrefOffset()
	_fggf._dfaf = append(_fggf._dfaf, _fggf._gdeb.PageList...)
	_fggf._gacd = make(map[_agf.PdfObject]struct{})
	_fggf._agc = make(map[_agf.PdfObject]int64)
	_fggf._abca = make(map[_agf.PdfObject]struct{})
	_fggf._edcb = _fggf._gdeb.AcroForm
	_fggf._caae = _fggf._gdeb.DSS
	if opts != nil {
		_fggf._ccdg = opts.Password
	}
	if encryptOptions != nil {
		_fggf._eeee = encryptOptions
	}
	return _fggf, nil
}

// HasFontByName checks if has font resource by name.
func (_ccadd *PdfPage) HasFontByName(name _agf.PdfObjectName) bool {
	_abbfd, _cbgaa := _ccadd.Resources.Font.(*_agf.PdfObjectDictionary)
	if !_cbgaa {
		return false
	}
	if _ffgdg := _abbfd.Get(name); _ffgdg != nil {
		return true
	}
	return false
}

// Transform rectangle with the supplied matrix.
func (_fdfcf *PdfRectangle) Transform(transformMatrix _fba.Matrix) {
	_fdfcf.Llx, _fdfcf.Lly = transformMatrix.Transform(_fdfcf.Llx, _fdfcf.Lly)
	_fdfcf.Urx, _fdfcf.Ury = transformMatrix.Transform(_fdfcf.Urx, _fdfcf.Ury)
	_fdfcf.Normalize()
}

// DecodeArray returns the range of color component values in DeviceRGB colorspace.
func (_befg *PdfColorspaceDeviceRGB) DecodeArray() []float64 {
	return []float64{0.0, 1.0, 0.0, 1.0, 0.0, 1.0}
}

// PartialName returns the partial name of the field.
func (_dgcg *PdfField) PartialName() string {
	_ggdfb := ""
	if _dgcg.T != nil {
		_ggdfb = _dgcg.T.Decoded()
	} else {
		_fd.Log.Debug("\u0046\u0069el\u0064\u0020\u006di\u0073\u0073\u0069\u006eg T\u0020fi\u0065\u006c\u0064\u0020\u0028\u0069\u006eco\u006d\u0070\u0061\u0074\u0069\u0062\u006ce\u0029")
	}
	return _ggdfb
}

// ToPdfObject implements interface PdfModel.
func (_gbee *PdfBorderStyle) ToPdfObject() _agf.PdfObject {
	_abgd := _agf.MakeDict()
	if _gbee._eegdd != nil {
		if _aed, _ffgd := _gbee._eegdd.(*_agf.PdfIndirectObject); _ffgd {
			_aed.PdfObject = _abgd
		}
	}
	_abgd.Set("\u0053u\u0062\u0074\u0079\u0070\u0065", _agf.MakeName("\u0042\u006f\u0072\u0064\u0065\u0072"))
	if _gbee.W != nil {
		_abgd.Set("\u0057", _agf.MakeFloat(*_gbee.W))
	}
	if _gbee.S != nil {
		_abgd.Set("\u0053", _agf.MakeName(_gbee.S.GetPdfName()))
	}
	if _gbee.D != nil {
		_abgd.Set("\u0044", _agf.MakeArrayFromIntegers(*_gbee.D))
	}
	if _gbee._eegdd != nil {
		return _gbee._eegdd
	}
	return _abgd
}

// GetNumComponents returns the number of color components of the colorspace device.
// Returns 4 for a CMYK32 device.
func (_dadbf *PdfColorspaceDeviceCMYK) GetNumComponents() int { return 4 }
func _bafd(_bfcff _agf.PdfObject) (*PdfColorspaceLab, error) {
	_abgca := NewPdfColorspaceLab()
	if _adcg, _bbbf := _bfcff.(*_agf.PdfIndirectObject); _bbbf {
		_abgca._aegc = _adcg
	}
	_bfcff = _agf.TraceToDirectObject(_bfcff)
	_gfbd, _cagab := _bfcff.(*_agf.PdfObjectArray)
	if !_cagab {
		return nil, _b.Errorf("\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	if _gfbd.Len() != 2 {
		return nil, _b.Errorf("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0043\u0061\u006c\u0052G\u0042 \u0063o\u006c\u006f\u0072\u0073\u0070\u0061\u0063e")
	}
	_bfcff = _agf.TraceToDirectObject(_gfbd.Get(0))
	_fgfef, _cagab := _bfcff.(*_agf.PdfObjectName)
	if !_cagab {
		return nil, _b.Errorf("\u006c\u0061\u0062\u0020\u006e\u0061\u006d\u0065\u0020\u006e\u006ft\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006f\u0062j\u0065\u0063\u0074")
	}
	if *_fgfef != "\u004c\u0061\u0062" {
		return nil, _b.Errorf("n\u006ft\u0020\u0061\u0020\u004c\u0061\u0062\u0020\u0063o\u006c\u006f\u0072\u0073pa\u0063\u0065")
	}
	_bfcff = _agf.TraceToDirectObject(_gfbd.Get(1))
	_fbef, _cagab := _bfcff.(*_agf.PdfObjectDictionary)
	if !_cagab {
		return nil, _b.Errorf("c\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063\u0065\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061r\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020or\u0020\u0069\u006ev\u0061l\u0069\u0064")
	}
	_bfcff = _fbef.Get("\u0057\u0068\u0069\u0074\u0065\u0050\u006f\u0069\u006e\u0074")
	_bfcff = _agf.TraceToDirectObject(_bfcff)
	_gbdae, _cagab := _bfcff.(*_agf.PdfObjectArray)
	if !_cagab {
		return nil, _b.Errorf("\u004c\u0061\u0062\u0020In\u0076\u0061\u006c\u0069\u0064\u0020\u0057\u0068\u0069\u0074\u0065\u0050\u006f\u0069n\u0074")
	}
	if _gbdae.Len() != 3 {
		return nil, _b.Errorf("\u004c\u0061b\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0057\u0068\u0069\u0074\u0065\u0050\u006f\u0069\u006e\u0074\u0020\u0061rr\u0061\u0079")
	}
	_fcbb, _gbcd := _gbdae.GetAsFloat64Slice()
	if _gbcd != nil {
		return nil, _gbcd
	}
	_abgca.WhitePoint = _fcbb
	_bfcff = _fbef.Get("\u0042\u006c\u0061\u0063\u006b\u0050\u006f\u0069\u006e\u0074")
	if _bfcff != nil {
		_bfcff = _agf.TraceToDirectObject(_bfcff)
		_eefc, _bbda := _bfcff.(*_agf.PdfObjectArray)
		if !_bbda {
			return nil, _b.Errorf("\u004c\u0061\u0062: \u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u006c\u0061\u0063\u006b\u0050\u006f\u0069\u006e\u0074")
		}
		if _eefc.Len() != 3 {
			return nil, _b.Errorf("\u004c\u0061b\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u006c\u0061\u0063\u006b\u0050\u006f\u0069\u006e\u0074\u0020\u0061rr\u0061\u0079")
		}
		_fdfe, _cfddc := _eefc.GetAsFloat64Slice()
		if _cfddc != nil {
			return nil, _cfddc
		}
		_abgca.BlackPoint = _fdfe
	}
	_bfcff = _fbef.Get("\u0052\u0061\u006eg\u0065")
	if _bfcff != nil {
		_bfcff = _agf.TraceToDirectObject(_bfcff)
		_cbebd, _daba := _bfcff.(*_agf.PdfObjectArray)
		if !_daba {
			_fd.Log.Error("\u0052\u0061n\u0067\u0065\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
			return nil, _b.Errorf("\u004ca\u0062:\u0020\u0054\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
		}
		if _cbebd.Len() != 4 {
			_fd.Log.Error("\u0052\u0061\u006e\u0067\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u0020e\u0072\u0072\u006f\u0072")
			return nil, _b.Errorf("\u004c\u0061b\u003a\u0020\u0052a\u006e\u0067\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
		}
		_eedgd, _bdf := _cbebd.GetAsFloat64Slice()
		if _bdf != nil {
			return nil, _bdf
		}
		_abgca.Range = _eedgd
	}
	return _abgca, nil
}

// GetFontDescriptor returns the font descriptor for `font`.
func (_dgdc PdfFont) GetFontDescriptor() (*PdfFontDescriptor, error) {
	return _dgdc._effaa.getFontDescriptor(), nil
}

// PdfColorPattern represents a pattern color.
type PdfColorPattern struct {
	Color       PdfColor
	PatternName _agf.PdfObjectName
}

// NewPdfColorLab returns a new Lab color.
func NewPdfColorLab(l, a, b float64) *PdfColorLab { _fgfd := PdfColorLab{l, a, b}; return &_fgfd }
func (_dabaf *PdfAcroForm) fillImageWithAppearance(_aeff FieldImageProvider, _eebbe FieldAppearanceGenerator) error {
	if _dabaf == nil {
		return nil
	}
	_feeeb, _aabb := _aeff.FieldImageValues()
	if _aabb != nil {
		return _aabb
	}
	for _, _bcca := range _dabaf.AllFields() {
		_ccffba := _bcca.PartialName()
		_eadc, _caed := _feeeb[_ccffba]
		if !_caed {
			if _eefcf, _dbcd := _bcca.FullName(); _dbcd == nil {
				_eadc, _caed = _feeeb[_eefcf]
			}
		}
		if !_caed {
			_fd.Log.Debug("\u0057\u0041\u0052\u004e\u003a\u0020f\u006f\u0072\u006d \u0066\u0069\u0065l\u0064\u0020\u0025\u0073\u0020\u006e\u006f\u0074\u0020\u0066o\u0075\u006e\u0064\u0020\u0069n \u0074\u0068\u0065\u0020\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0072\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e", _ccffba)
			continue
		}
		switch _dfafa := _bcca.GetContext().(type) {
		case *PdfFieldButton:
			if _dfafa.IsPush() {
				_dfafa.SetFillImage(_eadc)
			}
		}
		if _eebbe == nil {
			continue
		}
		for _, _fbed := range _bcca.Annotations {
			_bbbb, _becad := _eebbe.GenerateAppearanceDict(_dabaf, _bcca, _fbed)
			if _becad != nil {
				return _becad
			}
			_fbed.AP = _bbbb
			_fbed.ToPdfObject()
		}
	}
	return nil
}

// ToPdfObject returns the PDF representation of the colorspace.
func (_efdc *PdfColorspaceDeviceRGB) ToPdfObject() _agf.PdfObject {
	return _agf.MakeName("\u0044e\u0076\u0069\u0063\u0065\u0052\u0047B")
}

// DecodeArray returns the range of color component values in DeviceGray colorspace.
func (_bggf *PdfColorspaceDeviceGray) DecodeArray() []float64 { return []float64{0, 1.0} }

// GetCatalogMetadata gets the catalog defined XMP Metadata.
func (_efeea *PdfReader) GetCatalogMetadata() (_agf.PdfObject, bool) {
	if _efeea._ceaadd == nil {
		return nil, false
	}
	_bbcfd := _efeea._ceaadd.Get("\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061")
	return _bbcfd, _bbcfd != nil
}

// NewPdfColorspaceDeviceCMYK returns a new CMYK32 colorspace object.
func NewPdfColorspaceDeviceCMYK() *PdfColorspaceDeviceCMYK { return &PdfColorspaceDeviceCMYK{} }

// Resample resamples the image data converting from current BitsPerComponent to a target BitsPerComponent
// value.  Sets the image's BitsPerComponent to the target value following resampling.
//
// For example, converting an 8-bit RGB image to 1-bit grayscale (common for scanned images):
//
//	// Convert RGB image to grayscale.
//	rgbColorSpace := pdf.NewPdfColorspaceDeviceRGB()
//	grayImage, err := rgbColorSpace.ImageToGray(rgbImage)
//	if err != nil {
//	  return err
//	}
//	// Resample as 1 bit.
//	grayImage.Resample(1)
func (_cdeg *Image) Resample(targetBitsPerComponent int64) {
	if _cdeg.BitsPerComponent == targetBitsPerComponent {
		return
	}
	_afbf := _cdeg.GetSamples()
	if targetBitsPerComponent < _cdeg.BitsPerComponent {
		_ccedc := _cdeg.BitsPerComponent - targetBitsPerComponent
		for _eebef := range _afbf {
			_afbf[_eebef] >>= uint(_ccedc)
		}
	} else if targetBitsPerComponent > _cdeg.BitsPerComponent {
		_fdeb := targetBitsPerComponent - _cdeg.BitsPerComponent
		for _agff := range _afbf {
			_afbf[_agff] <<= uint(_fdeb)
		}
	}
	_cdeg.BitsPerComponent = targetBitsPerComponent
	if _cdeg.BitsPerComponent < 8 {
		_cdeg.resampleLowBits(_afbf)
		return
	}
	_agcb := _ged.BytesPerLine(int(_cdeg.Width), int(_cdeg.BitsPerComponent), _cdeg.ColorComponents)
	_bdcb := make([]byte, _agcb*int(_cdeg.Height))
	var (
		_bfda, _bdeg, _fcdae, _gefb int
		_bgbdf                      uint32
	)
	for _fcdae = 0; _fcdae < int(_cdeg.Height); _fcdae++ {
		_bfda = _fcdae * _agcb
		_bdeg = (_fcdae+1)*_agcb - 1
		_bfged := _db.ResampleUint32(_afbf[_bfda:_bdeg], int(targetBitsPerComponent), 8)
		for _gefb, _bgbdf = range _bfged {
			_bdcb[_gefb+_bfda] = byte(_bgbdf)
		}
	}
	_cdeg.Data = _bdcb
}
func (_beg *PdfReader) newPdfActionFromIndirectObject(_edgb *_agf.PdfIndirectObject) (*PdfAction, error) {
	_gfd, _agfd := _edgb.PdfObject.(*_agf.PdfObjectDictionary)
	if !_agfd {
		return nil, _b.Errorf("\u0061\u0063\u0074\u0069\u006f\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062j\u0065\u0063\u0074\u0020\u006e\u006f\u0074 \u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020a\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079")
	}
	if model := _beg._dcdeb.GetModelFromPrimitive(_gfd); model != nil {
		_fgd, _gcdf := model.(*PdfAction)
		if !_gcdf {
			return nil, _b.Errorf("\u0063\u0061c\u0068\u0065\u0064\u0020\u006d\u006f\u0064\u0065\u006c\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0050\u0044\u0046\u0020\u0061\u0063ti\u006f\u006e")
		}
		return _fgd, nil
	}
	_geg := &PdfAction{}
	_geg._caf = _edgb
	_beg._dcdeb.Register(_gfd, _geg)
	if _cda := _gfd.Get("\u0054\u0079\u0070\u0065"); _cda != nil {
		_da, _ffda := _cda.(*_agf.PdfObjectName)
		if !_ffda {
			_fd.Log.Trace("\u0049\u006e\u0063\u006f\u006d\u0070\u0061\u0074\u0069\u0062\u0069\u006c\u0069\u0074\u0079\u0021\u0020\u0049\u006e\u0076a\u006c\u0069\u0064\u0020\u0074\u0079\u0070\u0065\u0020\u006f\u0066\u0020\u0054\u0079\u0070\u0065\u0020\u0028\u0025\u0054\u0029\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064 \u0062\u0065\u0020\u004e\u0061m\u0065", _cda)
		} else {
			if *_da != "\u0041\u0063\u0074\u0069\u006f\u006e" {
				_fd.Log.Trace("\u0055\u006e\u0073u\u0073\u0070\u0065\u0063t\u0065\u0064\u0020\u0054\u0079\u0070\u0065 \u0021\u003d\u0020\u0041\u0063\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029", *_da)
			}
			_geg.Type = _da
		}
	}
	if _ebc := _gfd.Get("\u004e\u0065\u0078\u0074"); _ebc != nil {
		_geg.Next = _ebc
	}
	if _gbc := _gfd.Get("\u0053"); _gbc != nil {
		_geg.S = _gbc
	}
	_ced, _aeb := _geg.S.(*_agf.PdfObjectName)
	if !_aeb {
		_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052:\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0053\u0020\u006f\u0062j\u0065\u0063\u0074\u0020\u0074\u0079\u0070\u0065\u0020\u0021\u003d\u0020\u006e\u0061\u006d\u0065\u0020\u0028\u0025\u0054\u0029", _geg.S)
		return nil, _b.Errorf("\u0069\u006e\u0076al\u0069\u0064\u0020\u0053\u0020\u006f\u0062\u006a\u0065c\u0074 \u0074y\u0070e\u0020\u0021\u003d\u0020\u006e\u0061\u006d\u0065\u0020\u0028\u0025\u0054\u0029", _geg.S)
	}
	_fbf := PdfActionType(_ced.String())
	switch _fbf {
	case ActionTypeGoTo:
		_eed, _eea := _beg.newPdfActionGotoFromDict(_gfd)
		if _eea != nil {
			return nil, _eea
		}
		_eed.PdfAction = _geg
		_geg._ae = _eed
		return _geg, nil
	case ActionTypeGoToR:
		_cga, _dfgd := _beg.newPdfActionGotoRFromDict(_gfd)
		if _dfgd != nil {
			return nil, _dfgd
		}
		_cga.PdfAction = _geg
		_geg._ae = _cga
		return _geg, nil
	case ActionTypeGoToE:
		_gfg, _fcf := _beg.newPdfActionGotoEFromDict(_gfd)
		if _fcf != nil {
			return nil, _fcf
		}
		_gfg.PdfAction = _geg
		_geg._ae = _gfg
		return _geg, nil
	case ActionTypeLaunch:
		_bag, _cgac := _beg.newPdfActionLaunchFromDict(_gfd)
		if _cgac != nil {
			return nil, _cgac
		}
		_bag.PdfAction = _geg
		_geg._ae = _bag
		return _geg, nil
	case ActionTypeThread:
		_bda, _fee := _beg.newPdfActionThreadFromDict(_gfd)
		if _fee != nil {
			return nil, _fee
		}
		_bda.PdfAction = _geg
		_geg._ae = _bda
		return _geg, nil
	case ActionTypeURI:
		_gba, _gcdc := _beg.newPdfActionURIFromDict(_gfd)
		if _gcdc != nil {
			return nil, _gcdc
		}
		_gba.PdfAction = _geg
		_geg._ae = _gba
		return _geg, nil
	case ActionTypeSound:
		_gca, _aaae := _beg.newPdfActionSoundFromDict(_gfd)
		if _aaae != nil {
			return nil, _aaae
		}
		_gca.PdfAction = _geg
		_geg._ae = _gca
		return _geg, nil
	case ActionTypeMovie:
		_eab, _acb := _beg.newPdfActionMovieFromDict(_gfd)
		if _acb != nil {
			return nil, _acb
		}
		_eab.PdfAction = _geg
		_geg._ae = _eab
		return _geg, nil
	case ActionTypeHide:
		_gdc, _gcf := _beg.newPdfActionHideFromDict(_gfd)
		if _gcf != nil {
			return nil, _gcf
		}
		_gdc.PdfAction = _geg
		_geg._ae = _gdc
		return _geg, nil
	case ActionTypeNamed:
		_gfdc, _eeg := _beg.newPdfActionNamedFromDict(_gfd)
		if _eeg != nil {
			return nil, _eeg
		}
		_gfdc.PdfAction = _geg
		_geg._ae = _gfdc
		return _geg, nil
	case ActionTypeSubmitForm:
		_ebe, _dbd := _beg.newPdfActionSubmitFormFromDict(_gfd)
		if _dbd != nil {
			return nil, _dbd
		}
		_ebe.PdfAction = _geg
		_geg._ae = _ebe
		return _geg, nil
	case ActionTypeResetForm:
		_gbb, _caag := _beg.newPdfActionResetFormFromDict(_gfd)
		if _caag != nil {
			return nil, _caag
		}
		_gbb.PdfAction = _geg
		_geg._ae = _gbb
		return _geg, nil
	case ActionTypeImportData:
		_aaad, _gaa := _beg.newPdfActionImportDataFromDict(_gfd)
		if _gaa != nil {
			return nil, _gaa
		}
		_aaad.PdfAction = _geg
		_geg._ae = _aaad
		return _geg, nil
	case ActionTypeSetOCGState:
		_agb, _faa := _beg.newPdfActionSetOCGStateFromDict(_gfd)
		if _faa != nil {
			return nil, _faa
		}
		_agb.PdfAction = _geg
		_geg._ae = _agb
		return _geg, nil
	case ActionTypeRendition:
		_bfd, _bgb := _beg.newPdfActionRenditionFromDict(_gfd)
		if _bgb != nil {
			return nil, _bgb
		}
		_bfd.PdfAction = _geg
		_geg._ae = _bfd
		return _geg, nil
	case ActionTypeTrans:
		_abg, _dad := _beg.newPdfActionTransFromDict(_gfd)
		if _dad != nil {
			return nil, _dad
		}
		_abg.PdfAction = _geg
		_geg._ae = _abg
		return _geg, nil
	case ActionTypeGoTo3DView:
		_dab, _cdag := _beg.newPdfActionGoTo3DViewFromDict(_gfd)
		if _cdag != nil {
			return nil, _cdag
		}
		_dab.PdfAction = _geg
		_geg._ae = _dab
		return _geg, nil
	case ActionTypeJavaScript:
		_egf, _fcd := _beg.newPdfActionJavaScriptFromDict(_gfd)
		if _fcd != nil {
			return nil, _fcd
		}
		_egf.PdfAction = _geg
		_geg._ae = _egf
		return _geg, nil
	}
	_fd.Log.Debug("\u0045\u0052\u0052OR\u003a\u0020\u0049\u0067\u006e\u006f\u0072\u0069\u006eg\u0020u\u006ek\u006eo\u0077\u006e\u0020\u0061\u0063\u0074\u0069\u006f\u006e\u003a\u0020\u0025\u0073", _fbf)
	return nil, nil
}

// SetColorspaceByName adds the provided colorspace to the page resources.
func (_bebe *PdfPageResources) SetColorspaceByName(keyName _agf.PdfObjectName, cs PdfColorspace) error {
	_gcfdd, _dega := _bebe.GetColorspaces()
	if _dega != nil {
		_fd.Log.Debug("\u0045\u0052R\u004f\u0052\u0020\u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0072\u0061\u0063\u0065: \u0025\u0076", _dega)
		return _dega
	}
	if _gcfdd == nil {
		_gcfdd = NewPdfPageResourcesColorspaces()
		_bebe.SetColorSpace(_gcfdd)
	}
	_gcfdd.Set(keyName, cs)
	return nil
}
func (_acbec *PdfColorspaceCalRGB) String() string { return "\u0043\u0061\u006c\u0052\u0047\u0042" }

// String returns a string that describes `base`.
func (_cdgf fontCommon) String() string {
	return _b.Sprintf("\u0046\u004f\u004e\u0054\u007b\u0025\u0073\u007d", _cdgf.coreString())
}

// L returns the value of the L component of the color.
func (_ecfdg *PdfColorLab) L() float64 { return _ecfdg[0] }

// ToPdfOutline returns a low level PdfOutline object, based on the current
// instance.
func (_bbcfe *Outline) ToPdfOutline() *PdfOutline {
	_gcbdd := NewPdfOutline()
	var _bgbgb []*PdfOutlineItem
	var _dgac int64
	var _adee *PdfOutlineItem
	for _, _dbdae := range _bbcfe.Entries {
		_aaffg, _gebf := _dbdae.ToPdfOutlineItem()
		_aaffg.Parent = &_gcbdd.PdfOutlineTreeNode
		if _adee != nil {
			_adee.Next = &_aaffg.PdfOutlineTreeNode
			_aaffg.Prev = &_adee.PdfOutlineTreeNode
		}
		_bgbgb = append(_bgbgb, _aaffg)
		_dgac += _gebf
		_adee = _aaffg
	}
	_bbaf := int64(len(_bgbgb))
	_dgac += _bbaf
	if _bbaf > 0 {
		_gcbdd.First = &_bgbgb[0].PdfOutlineTreeNode
		_gcbdd.Last = &_bgbgb[_bbaf-1].PdfOutlineTreeNode
		_gcbdd.Count = &_dgac
	}
	return _gcbdd
}
func (_gdfd *PdfReader) newPdfAnnotationTrapNetFromDict(_abgg *_agf.PdfObjectDictionary) (*PdfAnnotationTrapNet, error) {
	_gcaa := PdfAnnotationTrapNet{}
	return &_gcaa, nil
}

// NewPdfActionSound returns a new "sound" action.
func NewPdfActionSound() *PdfActionSound {
	_cac := NewPdfAction()
	_aeec := &PdfActionSound{}
	_aeec.PdfAction = _cac
	_cac.SetContext(_aeec)
	return _aeec
}

// Write writes the Appender output to io.Writer.
// It can only be called once and further invocations will result in an error.
func (_daefd *PdfAppender) Write(w _cf.Writer) error {
	if _daefd._ffae {
		return _gcd.New("\u0061\u0070\u0070\u0065\u006e\u0064\u0065\u0072\u0020\u0077\u0072\u0069\u0074e\u0020\u0063\u0061\u006e\u0020\u006fn\u006c\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0076\u006f\u006b\u0065\u0064 \u006f\u006e\u0063\u0065")
	}
	_cfdd := NewPdfWriter()
	_gegf, _fffa := _agf.GetDict(_cfdd._dgbbfe)
	if !_fffa {
		return _gcd.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0061g\u0065\u0073\u0020\u006f\u0062\u006a\u0020(\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0029")
	}
	_babc, _fffa := _gegf.Get("\u004b\u0069\u0064\u0073").(*_agf.PdfObjectArray)
	if !_fffa {
		return _gcd.New("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0050\u0061g\u0065\u0073\u0020\u004b\u0069\u0064\u0073\u0020o\u0062\u006a\u0020\u0028\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072\u0061\u0079\u0029")
	}
	_caaeg, _fffa := _gegf.Get("\u0043\u006f\u0075n\u0074").(*_agf.PdfObjectInteger)
	if !_fffa {
		return _gcd.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064 \u0050\u0061\u0067e\u0073\u0020\u0043\u006fu\u006e\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0028\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0029")
	}
	_defa := _daefd._gdeb._egdga
	_fcfagf := _defa.GetTrailer()
	if _fcfagf == nil {
		return _gcd.New("\u006di\u0073s\u0069\u006e\u0067\u0020\u0074\u0072\u0061\u0069\u006c\u0065\u0072")
	}
	_abfbd, _fffa := _agf.GetIndirect(_fcfagf.Get("\u0052\u006f\u006f\u0074"))
	if !_fffa {
		return _gcd.New("c\u0061\u0074\u0061\u006c\u006f\u0067 \u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072 \u006e\u006f\u0074 \u0066o\u0075\u006e\u0064")
	}
	_gccc, _fffa := _agf.GetDict(_abfbd)
	if !_fffa {
		_fd.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u004d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0063\u0061\u0074\u0061\u006c\u006f\u0067\u003a\u0020\u0028\u0072\u006f\u006f\u0074\u0020\u0025\u0071\u0029\u0020\u0028\u0074\u0072\u0061\u0069\u006c\u0065\u0072\u0020\u0025\u0073\u0029", _abfbd, *_fcfagf)
		return _gcd.New("\u006di\u0073s\u0069\u006e\u0067\u0020\u0063\u0061\u0074\u0061\u006c\u006f\u0067")
	}
	for _, _eeab := range _gccc.Keys() {
		if _cfdd._bagbb.Get(_eeab) == nil {
			_gcgb := _gccc.Get(_eeab)
			_cfdd._bagbb.Set(_eeab, _gcgb)
		}
	}
	if _daefd._edcb != nil {
		if _daefd._edcb._agfed {
			if _ebdd := _agf.TraceToDirectObject(_daefd._edcb.ToPdfObject()); !_agf.IsNullObject(_ebdd) {
				_cfdd._bagbb.Set("\u0041\u0063\u0072\u006f\u0046\u006f\u0072\u006d", _ebdd)
				_daefd.updateObjectsDeep(_ebdd, nil)
			} else {
				_fd.Log.Debug("\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020t\u0072\u0061\u0063e\u0020\u0041\u0063\u0072\u006f\u0046\u006f\u0072\u006d\u0020o\u0062\u006a\u0065\u0063\u0074, \u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0061\u0064\u0064\u0020\u0041\u0063\u0072\u006f\u0046\u006f\u0072\u006d\u002e")
			}
		} else {
			_cfdd._bagbb.Set("\u0041\u0063\u0072\u006f\u0046\u006f\u0072\u006d", _daefd._edcb.ToPdfObject())
			_daefd.updateObjectsDeep(_daefd._edcb.ToPdfObject(), nil)
		}
	}
	if _daefd._caae != nil {
		_daefd.updateObjectsDeep(_daefd._caae.ToPdfObject(), nil)
		_cfdd._bagbb.Set("\u0044\u0053\u0053", _daefd._caae.GetContainingPdfObject())
	}
	if _daefd._cfcg != nil {
		_cfdd._bagbb.Set("\u0050\u0065\u0072m\u0073", _daefd._cfcg.ToPdfObject())
		_daefd.updateObjectsDeep(_daefd._cfcg.ToPdfObject(), nil)
	}
	if _cfdd._bcdfgg.Major < 2 {
		_cfdd.AddExtension("\u0045\u0053\u0049\u0043", "\u0031\u002e\u0037", 5)
		_cfdd.AddExtension("\u0041\u0044\u0042\u0045", "\u0031\u002e\u0037", 8)
	}
	if _cbg, _gcca := _agf.GetDict(_fcfagf.Get("\u0049\u006e\u0066\u006f")); _gcca {
		if _babed, _fgfe := _agf.GetDict(_cfdd._eaaaab); _fgfe {
			for _, _dbaf := range _cbg.Keys() {
				if _babed.Get(_dbaf) == nil {
					_babed.Set(_dbaf, _cbg.Get(_dbaf))
				}
			}
		}
	}
	if _daefd._bgeg != nil {
		_cfdd._eaaaab = _agf.MakeIndirectObject(_daefd._bgeg.ToPdfObject())
	}
	_daefd.addNewObject(_cfdd._eaaaab)
	_daefd.addNewObject(_cfdd._eccfaf)
	_gdde := false
	if len(_daefd._gdeb.PageList) != len(_daefd._dfaf) {
		_gdde = true
	} else {
		for _effb := range _daefd._gdeb.PageList {
			switch {
			case _daefd._dfaf[_effb] == _daefd._gdeb.PageList[_effb]:
			case _daefd._dfaf[_effb] == _daefd.Reader.PageList[_effb]:
			default:
				_gdde = true
			}
			if _gdde {
				break
			}
		}
	}
	if _gdde {
		_daefd.updateObjectsDeep(_cfdd._dgbbfe, nil)
	} else {
		_daefd._abca[_cfdd._dgbbfe] = struct{}{}
	}
	_cfdd._dgbbfe.ObjectNumber = _daefd.Reader._afgbb.ObjectNumber
	_daefd._agc[_cfdd._dgbbfe] = _daefd.Reader._afgbb.ObjectNumber
	_gaae := []_agf.PdfObjectName{"\u0052e\u0073\u006f\u0075\u0072\u0063\u0065s", "\u004d\u0065\u0064\u0069\u0061\u0042\u006f\u0078", "\u0043r\u006f\u0070\u0042\u006f\u0078", "\u0052\u006f\u0074\u0061\u0074\u0065"}
	for _, _egbe := range _daefd._dfaf {
		_cgga := _egbe.ToPdfObject()
		*_caaeg = *_caaeg + 1
		if _gdfg, _cgba := _cgga.(*_agf.PdfIndirectObject); _cgba && _gdfg.GetParser() == _daefd._gdeb._egdga {
			_babc.Append(&_gdfg.PdfObjectReference)
			continue
		}
		if _acaf, _faad := _agf.GetDict(_cgga); _faad {
			_dcg, _agbe := _acaf.Get("\u0050\u0061\u0072\u0065\u006e\u0074").(*_agf.PdfIndirectObject)
			for _agbe {
				_fd.Log.Trace("\u0050a\u0067e\u0020\u0050\u0061\u0072\u0065\u006e\u0074\u003a\u0020\u0025\u0054", _dcg)
				_ccbg, _cbdda := _dcg.PdfObject.(*_agf.PdfObjectDictionary)
				if !_cbdda {
					return _gcd.New("i\u006e\u0076\u0061\u006cid\u0020P\u0061\u0072\u0065\u006e\u0074 \u006f\u0062\u006a\u0065\u0063\u0074")
				}
				for _, _deda := range _gaae {
					_fd.Log.Trace("\u0046\u0069\u0065\u006c\u0064\u0020\u0025\u0073", _deda)
					if _dfd := _acaf.Get(_deda); _dfd != nil {
						_fd.Log.Trace("\u002d \u0070a\u0067\u0065\u0020\u0068\u0061s\u0020\u0061l\u0072\u0065\u0061\u0064\u0079")
						if len(_egbe._gabcc.Keys()) > 0 && !_gdde {
							_bbea := _egbe._gabcc
							if _ecdg := _bbea.Get(_deda); _ecdg != nil {
								if _dfd != _ecdg {
									_fd.Log.Trace("\u0049\u006e\u0068\u0065\u0072\u0069\u0074\u0069\u006e\u0067\u0020\u006f\u0072\u0069\u0067i\u006ea\u006c\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0025\u0073\u002c\u0020\u0025\u0054", _deda, _ecdg)
									_acaf.Set(_deda, _ecdg)
								}
							}
						}
						continue
					}
					if _ecee := _ccbg.Get(_deda); _ecee != nil {
						_fd.Log.Trace("\u0049\u006e\u0068\u0065ri\u0074\u0069\u006e\u0067\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0025\u0073", _deda)
						_acaf.Set(_deda, _ecee)
					}
				}
				_dcg, _agbe = _ccbg.Get("\u0050\u0061\u0072\u0065\u006e\u0074").(*_agf.PdfIndirectObject)
				_fd.Log.Trace("\u004ee\u0078t\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u003a\u0020\u0025\u0054", _ccbg.Get("\u0050\u0061\u0072\u0065\u006e\u0074"))
			}
			_acaf.Set("\u0050\u0061\u0072\u0065\u006e\u0074", _cfdd._dgbbfe)
		}
		_daefd.updateObjectsDeep(_cgga, nil)
		_babc.Append(_cgga)
	}
	if _, _abecb := _daefd._dcac.Seek(0, _cf.SeekStart); _abecb != nil {
		return _abecb
	}
	_eeba := make(map[SignatureHandler]_cf.Writer)
	_cacb := _agf.MakeArray()
	for _, _geace := range _daefd._bfbg {
		if _bdcc, _abfd := _agf.GetIndirect(_geace); _abfd {
			if _adfd, _gcegc := _bdcc.PdfObject.(*pdfSignDictionary); _gcegc {
				_bdeb := *_adfd._adfab
				var _gacg error
				_eeba[_bdeb], _gacg = _bdeb.NewDigest(_adfd._ecaged)
				if _gacg != nil {
					return _gacg
				}
				_cacb.Append(_agf.MakeInteger(0xfffff), _agf.MakeInteger(0xfffff))
			}
		}
	}
	if _cacb.Len() > 0 {
		_cacb.Append(_agf.MakeInteger(0xfffff), _agf.MakeInteger(0xfffff))
	}
	for _, _bfc := range _daefd._bfbg {
		if _gagd, _faec := _agf.GetIndirect(_bfc); _faec {
			if _bcgb, _gbebf := _gagd.PdfObject.(*pdfSignDictionary); _gbebf {
				_bcgb.Set("\u0042y\u0074\u0065\u0052\u0061\u006e\u0067e", _cacb)
			}
		}
	}
	_ebfb := len(_eeba) > 0
	var _edfa _cf.Reader = _daefd._dcac
	if _ebfb {
		_ebgf := make([]_cf.Writer, 0, len(_eeba))
		for _, _bdef := range _eeba {
			_ebgf = append(_ebgf, _bdef)
		}
		_edfa = _cf.TeeReader(_daefd._dcac, _cf.MultiWriter(_ebgf...))
	}
	_cbff, _cgae := _cf.Copy(w, _edfa)
	if _cgae != nil {
		return _cgae
	}
	if len(_daefd._bfbg) == 0 {
		return nil
	}
	_cfdd._gdfa = _cbff
	_cfdd.ObjNumOffset = _daefd._bada
	_cfdd._accad = true
	_cfdd._gcec = _daefd._dafg
	_cfdd._bdcea = _daefd._aede
	_cfdd._dbafe = _daefd._cdf
	_cfdd._bcdfgg = _daefd._gdeb.PdfVersion()
	_cfdd._efgaf = _daefd._agc
	_cfdd._cecgd = _daefd._dafc.GetCrypter()
	_cfdd._gdcbf = _daefd._dafc.GetEncryptObj()
	_gfae := _daefd._dafc.GetXrefType()
	if _gfae != nil {
		_bfce := *_gfae == _agf.XrefTypeObjectStream
		_cfdd._cbbed = &_bfce
	}
	_cfdd._ccbbf = map[_agf.PdfObject]struct{}{}
	_cfdd._dgbd = []_agf.PdfObject{}
	for _, _bfgc := range _daefd._bfbg {
		if _, _dabdd := _daefd._abca[_bfgc]; _dabdd {
			continue
		}
		_cfdd.addObject(_bfgc)
	}
	_dccb := w
	if _ebfb {
		_dccb = _gg.NewBuffer(nil)
	}
	if _daefd._ccdg != "" && _cfdd._cecgd == nil {
		_cfdd.Encrypt([]byte(_daefd._ccdg), []byte(_daefd._ccdg), _daefd._eeee)
	}
	if _bfca := _fcfagf.Get("\u0049\u0044"); _bfca != nil {
		if _egbfd, _fcbcd := _agf.GetArray(_bfca); _fcbcd {
			_cfdd._fcgdbd = _egbfd
		}
	}
	if _eabdb := _cfdd.Write(_dccb); _eabdb != nil {
		return _eabdb
	}
	if _ebfb {
		_cdfc := _dccb.(*_gg.Buffer).Bytes()
		_ceeaa := _agf.MakeArray()
		var _aaggf []*pdfSignDictionary
		var _gabf int64
		for _, _edga := range _cfdd._dgbd {
			if _cdg, _cccc := _agf.GetIndirect(_edga); _cccc {
				if _ceba, _affg := _cdg.PdfObject.(*pdfSignDictionary); _affg {
					_aaggf = append(_aaggf, _ceba)
					_ccfd := _ceba._deebd + int64(_ceba._cbfbge)
					_ceeaa.Append(_agf.MakeInteger(_gabf), _agf.MakeInteger(_ccfd-_gabf))
					_gabf = _ceba._deebd + int64(_ceba._dbdbd)
				}
			}
		}
		_ceeaa.Append(_agf.MakeInteger(_gabf), _agf.MakeInteger(_cbff+int64(len(_cdfc))-_gabf))
		_acad := []byte(_ceeaa.WriteString())
		for _, _gbebff := range _aaggf {
			_eded := int(_gbebff._deebd - _cbff)
			for _bdcg := _gbebff._bgdee; _bdcg < _gbebff._dbeeb; _bdcg++ {
				_cdfc[_eded+_bdcg] = ' '
			}
			_adab := _cdfc[_eded+_gbebff._bgdee : _eded+_gbebff._dbeeb]
			copy(_adab, _acad)
		}
		var _affc int
		for _, _effa := range _aaggf {
			_gefc := int(_effa._deebd - _cbff)
			_efee := _cdfc[_affc : _gefc+_effa._cbfbge]
			_bcff := *_effa._adfab
			_eeba[_bcff].Write(_efee)
			_affc = _gefc + _effa._dbdbd
		}
		for _, _fbcb := range _aaggf {
			_cbfec := _cdfc[_affc:]
			_aced := *_fbcb._adfab
			_eeba[_aced].Write(_cbfec)
		}
		for _, _facg := range _aaggf {
			_gdgg := int(_facg._deebd - _cbff)
			_agce := *_facg._adfab
			_cgd := _eeba[_agce]
			if _cdfg := _agce.Sign(_facg._ecaged, _cgd); _cdfg != nil {
				return _cdfg
			}
			_facg._ecaged.ByteRange = _ceeaa
			_faca := []byte(_facg._ecaged.Contents.WriteString())
			for _ccgb := _facg._bgdee; _ccgb < _facg._dbeeb; _ccgb++ {
				_cdfc[_gdgg+_ccgb] = ' '
			}
			for _ebgfc := _facg._cbfbge; _ebgfc < _facg._dbdbd; _ebgfc++ {
				_cdfc[_gdgg+_ebgfc] = ' '
			}
			_dcb := _cdfc[_gdgg+_facg._bgdee : _gdgg+_facg._dbeeb]
			copy(_dcb, _acad)
			_dcb = _cdfc[_gdgg+_facg._cbfbge : _gdgg+_facg._dbdbd]
			copy(_dcb, _faca)
		}
		_bfdg := _gg.NewBuffer(_cdfc)
		_, _cgae = _cf.Copy(w, _bfdg)
		if _cgae != nil {
			return _cgae
		}
	}
	_daefd._ffae = true
	return nil
}

// ToOutlineTree returns a low level PdfOutlineTreeNode object, based on
// the current instance.
func (_dfgf *Outline) ToOutlineTree() *PdfOutlineTreeNode {
	return &_dfgf.ToPdfOutline().PdfOutlineTreeNode
}

// PdfSignature represents a PDF signature dictionary and is used for signing via form signature fields.
// (Section 12.8, Table 252 - Entries in a signature dictionary p. 475 in PDF32000_2008).
type PdfSignature struct {
	Handler SignatureHandler
	_ceeec  *_agf.PdfIndirectObject

	// Type: Sig/DocTimeStamp
	Type         *_agf.PdfObjectName
	Filter       *_agf.PdfObjectName
	SubFilter    *_agf.PdfObjectName
	Contents     *_agf.PdfObjectString
	Cert         _agf.PdfObject
	ByteRange    *_agf.PdfObjectArray
	Reference    *_agf.PdfObjectArray
	Changes      *_agf.PdfObjectArray
	Name         *_agf.PdfObjectString
	M            *_agf.PdfObjectString
	Location     *_agf.PdfObjectString
	Reason       *_agf.PdfObjectString
	ContactInfo  *_agf.PdfObjectString
	R            *_agf.PdfObjectInteger
	V            *_agf.PdfObjectInteger
	PropBuild    *_agf.PdfObjectDictionary
	PropAuthTime *_agf.PdfObjectInteger
	PropAuthType *_agf.PdfObjectName
}

// ToPdfObject implements interface PdfModel.
func (_ddgbd *PdfTransformParamsDocMDP) ToPdfObject() _agf.PdfObject {
	_cdeaf := _agf.MakeDict()
	_cdeaf.SetIfNotNil("\u0054\u0079\u0070\u0065", _ddgbd.Type)
	_cdeaf.SetIfNotNil("\u0056", _ddgbd.V)
	_cdeaf.SetIfNotNil("\u0050", _ddgbd.P)
	return _cdeaf
}

// GetPdfName returns the PDF name used to indicate the border style.
// (Table 166 p. 395).
func (_eca *BorderStyle) GetPdfName() string {
	switch *_eca {
	case BorderStyleSolid:
		return "\u0053"
	case BorderStyleDashed:
		return "\u0044"
	case BorderStyleBeveled:
		return "\u0042"
	case BorderStyleInset:
		return "\u0049"
	case BorderStyleUnderline:
		return "\u0055"
	}
	return ""
}

// ColorToRGB only converts color used with uncolored patterns (defined in underlying colorspace).  Does not go into the
// pattern objects and convert those.  If that is desired, needs to be done separately.  See for example
// grayscale conversion example in unidoc-examples repo.
func (_dgfbg *PdfColorspaceSpecialPattern) ColorToRGB(color PdfColor) (PdfColor, error) {
	_daeg, _fbbg := color.(*PdfColorPattern)
	if !_fbbg {
		_fd.Log.Debug("\u0043\u006f\u006c\u006f\u0072\u0020\u006e\u006f\u0074\u0020\u0070a\u0074\u0074\u0065\u0072\u006e\u0020\u0028\u0067\u006f\u0074 \u0025\u0054\u0029", color)
		return nil, ErrTypeCheck
	}
	if _daeg.Color == nil {
		return color, nil
	}
	if _dgfbg.UnderlyingCS == nil {
		return nil, _gcd.New("\u0075n\u0064\u0065\u0072\u006cy\u0069\u006e\u0067\u0020\u0043S\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d")
	}
	return _dgfbg.UnderlyingCS.ColorToRGB(_daeg.Color)
}

// ImageToRGB returns the passed in image. Method exists in order to satisfy
// the PdfColorspace interface.
func (_gfad *PdfColorspaceDeviceRGB) ImageToRGB(img Image) (Image, error) { return img, nil }
func _bcba(_dcdc *_agf.PdfObjectDictionary) (*PdfFieldButton, error) {
	_efda := &PdfFieldButton{}
	_efda.PdfField = NewPdfField()
	_efda.PdfField.SetContext(_efda)
	_efda.Opt, _ = _agf.GetArray(_dcdc.Get("\u004f\u0070\u0074"))
	_ccag := NewPdfAnnotationWidget()
	_ccag.A, _ = _agf.GetDict(_dcdc.Get("\u0041"))
	_ccag.AP, _ = _agf.GetDict(_dcdc.Get("\u0041\u0050"))
	_ccag.SetContext(_efda)
	_efda.PdfField.Annotations = append(_efda.PdfField.Annotations, _ccag)
	return _efda, nil
}
func (_febb *PdfReader) newPdfAnnotationFileAttachmentFromDict(_fdc *_agf.PdfObjectDictionary) (*PdfAnnotationFileAttachment, error) {
	_fegb := PdfAnnotationFileAttachment{}
	_fgec, _cabg := _febb.newPdfAnnotationMarkupFromDict(_fdc)
	if _cabg != nil {
		return nil, _cabg
	}
	_fegb.PdfAnnotationMarkup = _fgec
	_fegb.FS = _fdc.Get("\u0046\u0053")
	_fegb.Name = _fdc.Get("\u004e\u0061\u006d\u0065")
	return &_fegb, nil
}

// ColorFromFloats returns a new PdfColorDevice based on the input slice of
// color components. The slice should contain four elements representing the
// cyan, magenta, yellow and key components of the color. The values of the
// elements should be between 0 and 1.
func (_gcee *PdfColorspaceDeviceCMYK) ColorFromFloats(vals []float64) (PdfColor, error) {
	if len(vals) != 4 {
		return nil, _gcd.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_fdef := vals[0]
	if _fdef < 0.0 || _fdef > 1.0 {
		_fd.Log.Debug("\u0063\u006f\u006cor\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0043\u0053\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020", _fdef)
		return nil, ErrColorOutOfRange
	}
	_cff := vals[1]
	if _cff < 0.0 || _cff > 1.0 {
		_fd.Log.Debug("\u0063\u006f\u006cor\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0043\u0053\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020", _cff)
		return nil, ErrColorOutOfRange
	}
	_fffba := vals[2]
	if _fffba < 0.0 || _fffba > 1.0 {
		_fd.Log.Debug("\u0063\u006f\u006cor\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0043\u0053\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020", _fffba)
		return nil, ErrColorOutOfRange
	}
	_ebdbc := vals[3]
	if _ebdbc < 0.0 || _ebdbc > 1.0 {
		_fd.Log.Debug("\u0063\u006f\u006cor\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0043\u0053\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020", _ebdbc)
		return nil, ErrColorOutOfRange
	}
	_eggcc := NewPdfColorDeviceCMYK(_fdef, _cff, _fffba, _ebdbc)
	return _eggcc, nil
}
func (_fcaf *DSS) generateHashMaps() error {
	_bcfg, _gbfg := _fcaf.generateHashMap(_fcaf.Certs)
	if _gbfg != nil {
		return _gbfg
	}
	_ccgbc, _gbfg := _fcaf.generateHashMap(_fcaf.OCSPs)
	if _gbfg != nil {
		return _gbfg
	}
	_fddf, _gbfg := _fcaf.generateHashMap(_fcaf.CRLs)
	if _gbfg != nil {
		return _gbfg
	}
	_fcaf._agbeg = _bcfg
	_fcaf._ecgfe = _ccgbc
	_fcaf._gegg = _fddf
	return nil
}

type fontFile struct {
	_febf  string
	_bcbfa string
	_aggb  _fcg.SimpleEncoder
}

// ToGoImage converts the unidoc Image to a golang Image structure.
func (_dfgdf *Image) ToGoImage() (_fe.Image, error) {
	_fd.Log.Trace("\u0043\u006f\u006e\u0076er\u0074\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0067\u006f\u0020\u0069\u006d\u0061g\u0065")
	_acaag, _ebedc := _ged.NewImage(int(_dfgdf.Width), int(_dfgdf.Height), int(_dfgdf.BitsPerComponent), _dfgdf.ColorComponents, _dfgdf.Data, _dfgdf._gdga, _dfgdf._abacg)
	if _ebedc != nil {
		return nil, _ebedc
	}
	return _acaag, nil
}
func (_bab *PdfReader) newPdfAnnotationStampFromDict(_babe *_agf.PdfObjectDictionary) (*PdfAnnotationStamp, error) {
	_fecd := PdfAnnotationStamp{}
	_afa, _gfag := _bab.newPdfAnnotationMarkupFromDict(_babe)
	if _gfag != nil {
		return nil, _gfag
	}
	_fecd.PdfAnnotationMarkup = _afa
	_fecd.Name = _babe.Get("\u004e\u0061\u006d\u0065")
	return &_fecd, nil
}

// ImageHandler interface implements common image loading and processing tasks.
// Implementing as an interface allows for the possibility to use non-standard libraries for faster
// loading and processing of images.
type ImageHandler interface {

	// Read any image type and load into a new Image object.
	Read(_aeceeg _cf.Reader) (*Image, error)

	// NewImageFromGoImage loads a NRGBA32 unidoc Image from a standard Go image structure.
	NewImageFromGoImage(_dbbg _fe.Image) (*Image, error)

	// NewGrayImageFromGoImage loads a grayscale unidoc Image from a standard Go image structure.
	NewGrayImageFromGoImage(_geafa _fe.Image) (*Image, error)

	// Compress an image.
	Compress(_aggce *Image, _gbeca int64) (*Image, error)
}

// PdfActionGoToE represents a GoToE action.
type PdfActionGoToE struct {
	*PdfAction
	F         *PdfFilespec
	D         _agf.PdfObject
	NewWindow _agf.PdfObject
	T         _agf.PdfObject
}

// PdfFieldSignature signature field represents digital signatures and optional data for authenticating
// the name of the signer and verifying document contents.
type PdfFieldSignature struct {
	*PdfField
	*PdfAnnotationWidget
	V    *PdfSignature
	Lock *_agf.PdfIndirectObject
	SV   *_agf.PdfIndirectObject
}

func (_fff *PdfReader) newPdfActionTransFromDict(_fga *_agf.PdfObjectDictionary) (*PdfActionTrans, error) {
	return &PdfActionTrans{Trans: _fga.Get("\u0054\u0072\u0061n\u0073")}, nil
}

// ReplaceAcroForm replaces the acrobat form. It appends a new form to the Pdf which
// replaces the original AcroForm.
func (_gbef *PdfAppender) ReplaceAcroForm(acroForm *PdfAcroForm) {
	if acroForm != nil {
		_gbef.updateObjectsDeep(acroForm.ToPdfObject(), nil)
	}
	_gbef._edcb = acroForm
}

// SetForms sets the Acroform for a PDF file.
func (_aaafg *PdfWriter) SetForms(form *PdfAcroForm) error { _aaafg._eafgd = form; return nil }

// StandardApplier is the interface that performs optimization of the whole PDF document.
// As a result an input document is being changed by the optimizer.
// The writer than takes back all it's parts and overwrites it.
// NOTE: This implementation is in experimental development state.
//
//	Keep in mind that it might change in the subsequent minor versions.
type StandardApplier interface {
	ApplyStandard(_fdafbd *_bb.Document) error
}

func _cbca(_cggb _agf.PdfObject) (*PdfColorspaceSpecialIndexed, error) {
	_dafb := NewPdfColorspaceSpecialIndexed()
	if _cabge, _dcee := _cggb.(*_agf.PdfIndirectObject); _dcee {
		_dafb._fcgd = _cabge
	}
	_cggb = _agf.TraceToDirectObject(_cggb)
	_aebag, _acadb := _cggb.(*_agf.PdfObjectArray)
	if !_acadb {
		return nil, _b.Errorf("\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	if _aebag.Len() != 4 {
		return nil, _b.Errorf("\u0069\u006e\u0064\u0065\u0078\u0065\u0064\u0020\u0043\u0053\u003a\u0020\u0069\u006e\u0076a\u006ci\u0064\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u006c\u0065\u006e\u0067\u0074\u0068")
	}
	_cggb = _aebag.Get(0)
	_cgfc, _acadb := _cggb.(*_agf.PdfObjectName)
	if !_acadb {
		return nil, _b.Errorf("\u0069n\u0064\u0065\u0078\u0065\u0064\u0020\u0043\u0053\u003a\u0020\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u006e\u0061\u006d\u0065")
	}
	if *_cgfc != "\u0049n\u0064\u0065\u0078\u0065\u0064" {
		return nil, _b.Errorf("\u0069\u006e\u0064\u0065xe\u0064\u0020\u0043\u0053\u003a\u0020\u0077\u0072\u006f\u006e\u0067\u0020\u006e\u0061m\u0065")
	}
	_cggb = _aebag.Get(1)
	_efeeg, _gfagd := DetermineColorspaceNameFromPdfObject(_cggb)
	if _gfagd != nil {
		return nil, _gfagd
	}
	if _efeeg == "\u0049n\u0064\u0065\u0078\u0065\u0064" || _efeeg == "\u0050a\u0074\u0074\u0065\u0072\u006e" {
		_fd.Log.Debug("E\u0072\u0072o\u0072\u003a\u0020\u0049\u006e\u0064\u0065\u0078\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063e\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0068\u0061\u0076\u0065\u0020\u0049\u006e\u0064e\u0078\u0065\u0064\u002f\u0050\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u0043S\u0020\u0061\u0073\u0020\u0062\u0061\u0073\u0065\u0020\u0028\u0025v\u0029", _efeeg)
		return nil, _cffa
	}
	_cfaaf, _gfagd := NewPdfColorspaceFromPdfObject(_cggb)
	if _gfagd != nil {
		return nil, _gfagd
	}
	_dafb.Base = _cfaaf
	_cggb = _aebag.Get(2)
	_cbeda, _gfagd := _agf.GetNumberAsInt64(_cggb)
	if _gfagd != nil {
		return nil, _gfagd
	}
	if _cbeda > 255 {
		return nil, _b.Errorf("\u0069n\u0064\u0065\u0078\u0065d\u0020\u0043\u0053\u003a\u0020I\u006ev\u0061l\u0069\u0064\u0020\u0068\u0069\u0076\u0061l")
	}
	_dafb.HiVal = int(_cbeda)
	_cggb = _aebag.Get(3)
	_dafb.Lookup = _cggb
	_cggb = _agf.TraceToDirectObject(_cggb)
	var _ccbe []byte
	if _gfdacb, _egfa := _cggb.(*_agf.PdfObjectString); _egfa {
		_ccbe = _gfdacb.Bytes()
		_fd.Log.Trace("\u0049\u006e\u0064\u0065\u0078\u0065\u0064\u0020\u0073\u0074r\u0069\u006e\u0067\u0020\u0063\u006f\u006co\u0072\u0020\u0064\u0061\u0074\u0061\u003a\u0020\u0025\u0020\u0064", _ccbe)
	} else if _dfda, _fegbf := _cggb.(*_agf.PdfObjectStream); _fegbf {
		_fd.Log.Trace("\u0049n\u0064e\u0078\u0065\u0064\u0020\u0073t\u0072\u0065a\u006d\u003a\u0020\u0025\u0073", _cggb.String())
		_fd.Log.Trace("\u0045\u006e\u0063\u006fde\u0064\u0020\u0028\u0025\u0064\u0029\u0020\u003a\u0020\u0025\u0023\u0020\u0078", len(_dfda.Stream), _dfda.Stream)
		_feee, _ebab := _agf.DecodeStream(_dfda)
		if _ebab != nil {
			return nil, _ebab
		}
		_fd.Log.Trace("\u0044e\u0063o\u0064\u0065\u0064\u0020\u0028%\u0064\u0029 \u003a\u0020\u0025\u0020\u0058", len(_feee), _feee)
		_ccbe = _feee
	} else {
		_fd.Log.Debug("\u0054\u0079\u0070\u0065\u003a\u0020\u0025\u0054", _cggb)
		return nil, _b.Errorf("\u0069\u006e\u0064\u0065\u0078\u0065\u0064\u0020\u0043\u0053\u003a\u0020\u0049\u006e\u0076a\u006ci\u0064\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0066\u006f\u0072\u006d\u0061\u0074")
	}
	if len(_ccbe) < _dafb.Base.GetNumComponents()*(_dafb.HiVal+1) {
		_fd.Log.Debug("\u0050\u0044\u0046\u0020\u0049\u006e\u0063o\u006d\u0070\u0061t\u0069\u0062\u0069\u006ci\u0074\u0079\u003a\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0074\u006f\u006f\u0020\u0073\u0068\u006f\u0072\u0074")
		_fd.Log.Debug("\u0046\u0061i\u006c\u002c\u0020\u006c\u0065\u006e\u0028\u0064\u0061\u0074\u0061\u0029\u003a\u0020\u0025\u0064\u002c\u0020\u0063\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073\u003a\u0020\u0025\u0064\u002c\u0020\u0068\u0069\u0056\u0061\u006c\u003a\u0020\u0025\u0064", len(_ccbe), _dafb.Base.GetNumComponents(), _dafb.HiVal)
	} else {
		_ccbe = _ccbe[:_dafb.Base.GetNumComponents()*(_dafb.HiVal+1)]
	}
	_dafb._ababg = _ccbe
	return _dafb, nil
}
func _aadgc(_cgfce []byte) ([]byte, error) {
	_fbcf := _c.New()
	if _, _dadab := _cf.Copy(_fbcf, _gg.NewReader(_cgfce)); _dadab != nil {
		return nil, _dadab
	}
	return _fbcf.Sum(nil), nil
}

// NewPdfAnnotationLink returns a new link annotation.
func NewPdfAnnotationLink() *PdfAnnotationLink {
	_gccf := NewPdfAnnotation()
	_bad := &PdfAnnotationLink{}
	_bad.PdfAnnotation = _gccf
	_gccf.SetContext(_bad)
	return _bad
}

// GetBorderWidth returns the border style's width.
func (_bdba *PdfBorderStyle) GetBorderWidth() float64 {
	if _bdba.W == nil {
		return 1
	}
	return *_bdba.W
}

// PdfField contains the common attributes of a form field. The context object contains the specific field data
// which can represent a button, text, choice or signature.
// The PdfField is typically not used directly, but is encapsulated by the more specific field types such as
// PdfFieldButton etc (i.e. the context attribute).
type PdfField struct {
	_eaggd       PdfModel
	_fcgcc       *_agf.PdfIndirectObject
	Parent       *PdfField
	Annotations  []*PdfAnnotationWidget
	Kids         []*PdfField
	FT           *_agf.PdfObjectName
	T            *_agf.PdfObjectString
	TU           *_agf.PdfObjectString
	TM           *_agf.PdfObjectString
	Ff           *_agf.PdfObjectInteger
	V            _agf.PdfObject
	DV           _agf.PdfObject
	AA           _agf.PdfObject
	VariableText *VariableText
}

// ToPdfObject implements interface PdfModel.
func (_aecee *PdfAnnotationCaret) ToPdfObject() _agf.PdfObject {
	_aecee.PdfAnnotation.ToPdfObject()
	_edec := _aecee._aeee
	_cfee := _edec.PdfObject.(*_agf.PdfObjectDictionary)
	_aecee.PdfAnnotationMarkup.appendToPdfDictionary(_cfee)
	_cfee.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _agf.MakeName("\u0043\u0061\u0072e\u0074"))
	_cfee.SetIfNotNil("\u0052\u0044", _aecee.RD)
	_cfee.SetIfNotNil("\u0053\u0079", _aecee.Sy)
	return _edec
}

// GetOptimizer returns current PDF optimizer.
func (_decd *PdfWriter) GetOptimizer() Optimizer { return _decd._dafgfa }

// ToPdfObject implements interface PdfModel.
func (_ffg *PdfActionSetOCGState) ToPdfObject() _agf.PdfObject {
	_ffg.PdfAction.ToPdfObject()
	_fdg := _ffg._caf
	_cfacc := _fdg.PdfObject.(*_agf.PdfObjectDictionary)
	_cfacc.SetIfNotNil("\u0053", _agf.MakeName(string(ActionTypeSetOCGState)))
	_cfacc.SetIfNotNil("\u0053\u0074\u0061t\u0065", _ffg.State)
	_cfacc.SetIfNotNil("\u0050\u0072\u0065\u0073\u0065\u0072\u0076\u0065\u0052\u0042", _ffg.PreserveRB)
	return _fdg
}

// ColorFromFloats returns a new PdfColor based on the input slice of color
// components. The slice should contain a single element.
func (_gdeeb *PdfColorspaceSpecialIndexed) ColorFromFloats(vals []float64) (PdfColor, error) {
	if len(vals) != 1 {
		return nil, _gcd.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	N := _gdeeb.Base.GetNumComponents()
	_eabdd := int(vals[0]) * N
	if _eabdd < 0 || (_eabdd+N-1) >= len(_gdeeb._ababg) {
		_fd.Log.Debug("\u0063\u006f\u006cor\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0043\u0053\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020", _eabdd)
		return nil, ErrColorOutOfRange
	}
	_dfgdb := _gdeeb._ababg[_eabdd : _eabdd+N]
	var _ecfa []float64
	for _, _affa := range _dfgdb {
		_ecfa = append(_ecfa, float64(_affa)/255.0)
	}
	_ebfc, _adgd := _gdeeb.Base.ColorFromFloats(_ecfa)
	if _adgd != nil {
		return nil, _adgd
	}
	return _ebfc, nil
}

// Evaluate runs the function on the passed in slice and returns the results.
func (_fggff *PdfFunctionType2) Evaluate(x []float64) ([]float64, error) {
	if len(x) != 1 {
		_fd.Log.Error("\u004f\u006e\u006c\u0079 o\u006e\u0065\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0061\u006c\u006c\u006f\u0077e\u0064")
		return nil, _gcd.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_gcege := []float64{0.0}
	if _fggff.C0 != nil {
		_gcege = _fggff.C0
	}
	_gfgcf := []float64{1.0}
	if _fggff.C1 != nil {
		_gfgcf = _fggff.C1
	}
	var _dged []float64
	for _acbab := 0; _acbab < len(_gcege); _acbab++ {
		_bgdf := _gcege[_acbab] + _afb.Pow(x[0], _fggff.N)*(_gfgcf[_acbab]-_gcege[_acbab])
		_dged = append(_dged, _bgdf)
	}
	return _dged, nil
}

// PdfAnnotationProjection represents Projection annotations.
type PdfAnnotationProjection struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
}

// Size returns the width and the height of the page. The method reports
// the page dimensions as displayed by a PDF viewer (i.e. page rotation is
// taken into account).
func (_gagfg *PdfPage) Size() (float64, float64, error) {
	_bbcda, _cdbcga := _gagfg.GetMediaBox()
	if _cdbcga != nil {
		return 0, 0, _cdbcga
	}
	_eedca, _dadfe := _bbcda.Width(), _bbcda.Height()
	_dgbe, _cdbcga := _gagfg.GetRotate()
	if _cdbcga != nil {
		_fd.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u0025\u0073\u0020\u002d\u0020\u0069\u0067\u006e\u006f\u0072\u0069\u006e\u0067\u0020\u0061\u006e\u0064\u0020\u0061\u0073\u0073\u0075\u006d\u0069\u006e\u0067\u0020\u006e\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u000a", _cdbcga.Error())
	}
	if _fcabd := _dgbe; _fcabd%360 != 0 && _fcabd%90 == 0 {
		if _gfgf := (360 + _fcabd%360) % 360; _gfgf == 90 || _gfgf == 270 {
			_eedca, _dadfe = _dadfe, _eedca
		}
	}
	return _eedca, _dadfe, nil
}

// Field returns the parent form field of the widget annotation, if one exists.
// NOTE: the method returns nil if the parent form field has not been parsed.
func (_cecd *PdfAnnotationWidget) Field() *PdfField { return _cecd._efe }
func _ffbba(_dabe _agf.PdfObject) (map[_fcg.CharCode]float64, error) {
	if _dabe == nil {
		return nil, nil
	}
	_ecdf, _fbbbd := _agf.GetArray(_dabe)
	if !_fbbbd {
		return nil, nil
	}
	_agggb := map[_fcg.CharCode]float64{}
	_caabg := _ecdf.Len()
	for _gfbff := 0; _gfbff < _caabg-1; _gfbff++ {
		_faged := _agf.TraceToDirectObject(_ecdf.Get(_gfbff))
		_facd, _dcgg := _agf.GetIntVal(_faged)
		if !_dcgg {
			return nil, _b.Errorf("\u0042a\u0064\u0020\u0066\u006fn\u0074\u0020\u0057\u0020\u006fb\u006a0\u003a \u0069\u003d\u0025\u0064\u0020\u0025\u0023v", _gfbff, _faged)
		}
		_gfbff++
		if _gfbff > _caabg-1 {
			return nil, _b.Errorf("\u0042\u0061\u0064\u0020\u0066\u006f\u006e\u0074\u0020\u0057\u0020a\u0072\u0072\u0061\u0079\u003a\u0020\u0061\u0072\u0072\u0032=\u0025\u002b\u0076", _ecdf)
		}
		_bacf := _agf.TraceToDirectObject(_ecdf.Get(_gfbff))
		switch _bacf.(type) {
		case *_agf.PdfObjectArray:
			_bedaa, _ := _agf.GetArray(_bacf)
			if _cccff, _fceedf := _bedaa.ToFloat64Array(); _fceedf == nil {
				for _dbeg := 0; _dbeg < len(_cccff); _dbeg++ {
					_agggb[_fcg.CharCode(_facd+_dbeg)] = _cccff[_dbeg]
				}
			} else {
				return nil, _b.Errorf("\u0042\u0061\u0064 \u0066\u006f\u006e\u0074 \u0057\u0020\u0061\u0072\u0072\u0061\u0079 \u006f\u0062\u006a\u0031\u003a\u0020\u0069\u003d\u0025\u0064\u0020\u0025\u0023\u0076", _gfbff, _bacf)
			}
		case *_agf.PdfObjectInteger:
			_dggg, _cggga := _agf.GetIntVal(_bacf)
			if !_cggga {
				return nil, _b.Errorf("\u0042\u0061d\u0020\u0066\u006f\u006e\u0074\u0020\u0057\u0020\u0069\u006e\u0074\u0020\u006f\u0062\u006a\u0031\u003a\u0020\u0069\u003d\u0025\u0064 %\u0023\u0076", _gfbff, _bacf)
			}
			_gfbff++
			if _gfbff > _caabg-1 {
				return nil, _b.Errorf("\u0042\u0061\u0064\u0020\u0066\u006f\u006e\u0074\u0020\u0057\u0020a\u0072\u0072\u0061\u0079\u003a\u0020\u0061\u0072\u0072\u0032=\u0025\u002b\u0076", _ecdf)
			}
			_bdaf := _ecdf.Get(_gfbff)
			_egbg, _bbcbf := _agf.GetNumberAsFloat(_bdaf)
			if _bbcbf != nil {
				return nil, _b.Errorf("\u0042\u0061d\u0020\u0066\u006f\u006e\u0074\u0020\u0057\u0020\u0069\u006e\u0074\u0020\u006f\u0062\u006a\u0032\u003a\u0020\u0069\u003d\u0025\u0064 %\u0023\u0076", _gfbff, _bdaf)
			}
			for _cbcgb := _facd; _cbcgb <= _dggg; _cbcgb++ {
				_agggb[_fcg.CharCode(_cbcgb)] = _egbg
			}
		default:
			return nil, _b.Errorf("\u0042\u0061\u0064\u0020\u0066\u006f\u006e\u0074\u0020\u0057 \u006f\u0062\u006a\u0031\u0020\u0074\u0079p\u0065\u003a\u0020\u0069\u003d\u0025\u0064\u0020\u0025\u0023\u0076", _gfbff, _bacf)
		}
	}
	return _agggb, nil
}

// String returns a string representation of what flags are set.
func (_ebacga FieldFlag) String() string {
	_fgad := ""
	if _ebacga == FieldFlagClear {
		_fgad = "\u0043\u006c\u0065a\u0072"
		return _fgad
	}
	if _ebacga&FieldFlagReadOnly > 0 {
		_fgad += "\u007cR\u0065\u0061\u0064\u004f\u006e\u006cy"
	}
	if _ebacga&FieldFlagRequired > 0 {
		_fgad += "\u007cR\u0065\u0071\u0075\u0069\u0072\u0065d"
	}
	if _ebacga&FieldFlagNoExport > 0 {
		_fgad += "\u007cN\u006f\u0045\u0078\u0070\u006f\u0072t"
	}
	if _ebacga&FieldFlagNoToggleToOff > 0 {
		_fgad += "\u007c\u004e\u006f\u0054\u006f\u0067\u0067\u006c\u0065T\u006f\u004f\u0066\u0066"
	}
	if _ebacga&FieldFlagRadio > 0 {
		_fgad += "\u007c\u0052\u0061\u0064\u0069\u006f"
	}
	if _ebacga&FieldFlagPushbutton > 0 {
		_fgad += "|\u0050\u0075\u0073\u0068\u0062\u0075\u0074\u0074\u006f\u006e"
	}
	if _ebacga&FieldFlagRadiosInUnision > 0 {
		_fgad += "\u007c\u0052a\u0064\u0069\u006fs\u0049\u006e\u0055\u006e\u0069\u0073\u0069\u006f\u006e"
	}
	if _ebacga&FieldFlagMultiline > 0 {
		_fgad += "\u007c\u004d\u0075\u006c\u0074\u0069\u006c\u0069\u006e\u0065"
	}
	if _ebacga&FieldFlagPassword > 0 {
		_fgad += "\u007cP\u0061\u0073\u0073\u0077\u006f\u0072d"
	}
	if _ebacga&FieldFlagFileSelect > 0 {
		_fgad += "|\u0046\u0069\u006c\u0065\u0053\u0065\u006c\u0065\u0063\u0074"
	}
	if _ebacga&FieldFlagDoNotScroll > 0 {
		_fgad += "\u007c\u0044\u006fN\u006f\u0074\u0053\u0063\u0072\u006f\u006c\u006c"
	}
	if _ebacga&FieldFlagComb > 0 {
		_fgad += "\u007c\u0043\u006fm\u0062"
	}
	if _ebacga&FieldFlagRichText > 0 {
		_fgad += "\u007cR\u0069\u0063\u0068\u0054\u0065\u0078t"
	}
	if _ebacga&FieldFlagDoNotSpellCheck > 0 {
		_fgad += "\u007c\u0044o\u004e\u006f\u0074S\u0070\u0065\u006c\u006c\u0043\u0068\u0065\u0063\u006b"
	}
	if _ebacga&FieldFlagCombo > 0 {
		_fgad += "\u007c\u0043\u006f\u006d\u0062\u006f"
	}
	if _ebacga&FieldFlagEdit > 0 {
		_fgad += "\u007c\u0045\u0064i\u0074"
	}
	if _ebacga&FieldFlagSort > 0 {
		_fgad += "\u007c\u0053\u006fr\u0074"
	}
	if _ebacga&FieldFlagMultiSelect > 0 {
		_fgad += "\u007c\u004d\u0075l\u0074\u0069\u0053\u0065\u006c\u0065\u0063\u0074"
	}
	if _ebacga&FieldFlagCommitOnSelChange > 0 {
		_fgad += "\u007cC\u006fm\u006d\u0069\u0074\u004f\u006eS\u0065\u006cC\u0068\u0061\u006e\u0067\u0065"
	}
	return _gc.Trim(_fgad, "\u007c")
}

// NewPdfPageResources returns a new PdfPageResources object.
func NewPdfPageResources() *PdfPageResources {
	_eafdg := &PdfPageResources{}
	_eafdg._ebga = _agf.MakeDict()
	return _eafdg
}
func (_ggdd *PdfPage) setContainer(_bacde *_agf.PdfIndirectObject) {
	_bacde.PdfObject = _ggdd._ececfb
	_ggdd._edegf = _bacde
}

// NewOutlineDest returns a new outline destination which can be used
// with outline items.
func NewOutlineDest(page int64, x, y float64) OutlineDest {
	return OutlineDest{Page: page, Mode: "\u0058\u0059\u005a", X: x, Y: y}
}

// ToPdfObject returns the PDF representation of the colorspace.
func (_fdbb *PdfPageResourcesColorspaces) ToPdfObject() _agf.PdfObject {
	_ceaad := _agf.MakeDict()
	for _, _abfg := range _fdbb.Names {
		_ceaad.Set(_agf.PdfObjectName(_abfg), _fdbb.Colorspaces[_abfg].ToPdfObject())
	}
	if _fdbb._dafcd != nil {
		_fdbb._dafcd.PdfObject = _ceaad
		return _fdbb._dafcd
	}
	return _ceaad
}

// ToPdfObject implements interface PdfModel.
func (_cca *PdfActionJavaScript) ToPdfObject() _agf.PdfObject {
	_cca.PdfAction.ToPdfObject()
	_cacc := _cca._caf
	_aec := _cacc.PdfObject.(*_agf.PdfObjectDictionary)
	_aec.SetIfNotNil("\u0053", _agf.MakeName(string(ActionTypeJavaScript)))
	_aec.SetIfNotNil("\u004a\u0053", _cca.JS)
	return _cacc
}

// NewPdfActionImportData returns a new "import data" action.
func NewPdfActionImportData() *PdfActionImportData {
	_gbdg := NewPdfAction()
	_cfc := &PdfActionImportData{}
	_cfc.PdfAction = _gbdg
	_gbdg.SetContext(_cfc)
	return _cfc
}

// GetNameDictionary returns the Names entry in the PDF catalog.
// See section 7.7.4 "Name Dictionary" (p. 80 PDF32000_2008).
func (_gbead *PdfReader) GetNameDictionary() (_agf.PdfObject, error) {
	_ggcbce := _agf.ResolveReference(_gbead._ceaadd.Get("\u004e\u0061\u006de\u0073"))
	if _ggcbce == nil {
		return nil, nil
	}
	if !_gbead._ccage {
		_cgbee := _gbead.traverseObjectData(_ggcbce)
		if _cgbee != nil {
			return nil, _cgbee
		}
	}
	return _ggcbce, nil
}

// NewXObjectImageFromStream builds the image xobject from a stream object.
// An image dictionary is the dictionary portion of a stream object representing an image XObject.
func NewXObjectImageFromStream(stream *_agf.PdfObjectStream) (*XObjectImage, error) {
	_ccgce := &XObjectImage{}
	_ccgce._gdggg = stream
	_fecae := *(stream.PdfObjectDictionary)
	_adcge, _fgeeg := _agf.NewEncoderFromStream(stream)
	if _fgeeg != nil {
		return nil, _fgeeg
	}
	_ccgce.Filter = _adcge
	if _gdbcf := _agf.TraceToDirectObject(_fecae.Get("\u0057\u0069\u0064t\u0068")); _gdbcf != nil {
		_ffefb, _fabcf := _gdbcf.(*_agf.PdfObjectInteger)
		if !_fabcf {
			return nil, _gcd.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006d\u0061g\u0065\u0020\u0077\u0069\u0064\u0074\u0068\u0020\u006f\u0062j\u0065\u0063\u0074")
		}
		_geafag := int64(*_ffefb)
		_ccgce.Width = &_geafag
	} else {
		return nil, _gcd.New("\u0077\u0069\u0064\u0074\u0068\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067")
	}
	if _bfbfg := _agf.TraceToDirectObject(_fecae.Get("\u0048\u0065\u0069\u0067\u0068\u0074")); _bfbfg != nil {
		_cdeec, _dddbg := _bfbfg.(*_agf.PdfObjectInteger)
		if !_dddbg {
			return nil, _gcd.New("i\u006e\u0076\u0061\u006c\u0069\u0064 \u0069\u006d\u0061\u0067\u0065\u0020\u0068\u0065\u0069g\u0068\u0074\u0020o\u0062j\u0065\u0063\u0074")
		}
		_dgedg := int64(*_cdeec)
		_ccgce.Height = &_dgedg
	} else {
		return nil, _gcd.New("\u0068\u0065\u0069\u0067\u0068\u0074\u0020\u006d\u0069s\u0073\u0069\u006e\u0067")
	}
	if _fbagd := _agf.TraceToDirectObject(_fecae.Get("\u0043\u006f\u006c\u006f\u0072\u0053\u0070\u0061\u0063\u0065")); _fbagd != nil {
		_ggdgbf, _bafgc := NewPdfColorspaceFromPdfObject(_fbagd)
		if _bafgc != nil {
			return nil, _bafgc
		}
		_ccgce.ColorSpace = _ggdgbf
	} else {
		_fd.Log.Debug("\u0058O\u0062\u006a\u0065c\u0074\u0020\u0049m\u0061ge\u0020\u0063\u006f\u006c\u006f\u0072\u0073p\u0061\u0063\u0065\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064\u0020\u002d\u0020\u0061\u0073\u0073\u0075\u006d\u0069\u006e\u0067 1\u0020c\u006f\u006c\u006f\u0072\u0020\u0063o\u006d\u0070\u006f\u006e\u0065n\u0074\u0020\u002d\u0020\u0044\u0065\u0076\u0069\u0063\u0065\u0047r\u0061\u0079")
		_ccgce.ColorSpace = NewPdfColorspaceDeviceGray()
	}
	if _eeeffg := _agf.TraceToDirectObject(_fecae.Get("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074")); _eeeffg != nil {
		_ggac, _fbddc := _eeeffg.(*_agf.PdfObjectInteger)
		if !_fbddc {
			return nil, _gcd.New("i\u006e\u0076\u0061\u006c\u0069\u0064 \u0069\u006d\u0061\u0067\u0065\u0020\u0068\u0065\u0069g\u0068\u0074\u0020o\u0062j\u0065\u0063\u0074")
		}
		_gcbgf := int64(*_ggac)
		_ccgce.BitsPerComponent = &_gcbgf
	}
	_ccgce.Intent = _fecae.Get("\u0049\u006e\u0074\u0065\u006e\u0074")
	_ccgce.ImageMask = _fecae.Get("\u0049m\u0061\u0067\u0065\u004d\u0061\u0073k")
	_ccgce.Mask = _fecae.Get("\u004d\u0061\u0073\u006b")
	_ccgce.Decode = _fecae.Get("\u0044\u0065\u0063\u006f\u0064\u0065")
	_ccgce.Interpolate = _fecae.Get("I\u006e\u0074\u0065\u0072\u0070\u006f\u006c\u0061\u0074\u0065")
	_ccgce.Alternatives = _fecae.Get("\u0041\u006c\u0074e\u0072\u006e\u0061\u0074\u0069\u0076\u0065\u0073")
	_ccgce.SMask = _fecae.Get("\u0053\u004d\u0061s\u006b")
	_ccgce.SMaskInData = _fecae.Get("S\u004d\u0061\u0073\u006b\u0049\u006e\u0044\u0061\u0074\u0061")
	_ccgce.Matte = _fecae.Get("\u004d\u0061\u0074t\u0065")
	_ccgce.Name = _fecae.Get("\u004e\u0061\u006d\u0065")
	_ccgce.StructParent = _fecae.Get("\u0053\u0074\u0072u\u0063\u0074\u0050\u0061\u0072\u0065\u006e\u0074")
	_ccgce.ID = _fecae.Get("\u0049\u0044")
	_ccgce.OPI = _fecae.Get("\u004f\u0050\u0049")
	_ccgce.Metadata = _fecae.Get("\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061")
	_ccgce.OC = _fecae.Get("\u004f\u0043")
	_ccgce.Stream = stream.Stream
	return _ccgce, nil
}

// NewPdfSignatureReferenceDocMDP returns PdfSignatureReference for the transformParams.
func NewPdfSignatureReferenceDocMDP(transformParams *PdfTransformParamsDocMDP) *PdfSignatureReference {
	return &PdfSignatureReference{Type: _agf.MakeName("\u0053\u0069\u0067\u0052\u0065\u0066"), TransformMethod: _agf.MakeName("\u0044\u006f\u0063\u004d\u0044\u0050"), TransformParams: transformParams.ToPdfObject()}
}

var ErrColorOutOfRange = _gcd.New("\u0063o\u006co\u0072\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065")

// BorderStyle defines border type, typically used for annotations.
type BorderStyle int

func (_gecg *PdfReader) newPdfAcroFormFromDict(_edfgcg *_agf.PdfIndirectObject, _dfdbca *_agf.PdfObjectDictionary) (*PdfAcroForm, error) {
	_aedcg := NewPdfAcroForm()
	if _edfgcg != nil {
		_aedcg._dfdbc = _edfgcg
		_edfgcg.PdfObject = _agf.MakeDict()
	}
	if _caba := _dfdbca.Get("\u0046\u0069\u0065\u006c\u0064\u0073"); _caba != nil && !_agf.IsNullObject(_caba) {
		_bgbb, _fcadc := _agf.GetArray(_caba)
		if !_fcadc {
			return nil, _b.Errorf("\u0066i\u0065\u006c\u0064\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u006e \u0061\u0072\u0072\u0061\u0079\u0020\u0028\u0025\u0054\u0029", _caba)
		}
		var _cffdcg []*PdfField
		for _, _febaa := range _bgbb.Elements() {
			_adgaf, _cfgeb := _agf.GetIndirect(_febaa)
			if !_cfgeb {
				if _, _bcac := _febaa.(*_agf.PdfObjectNull); _bcac {
					_fd.Log.Trace("\u0053k\u0069\u0070\u0070\u0069\u006e\u0067\u0020\u006f\u0076\u0065\u0072 \u006e\u0075\u006c\u006c\u0020\u0066\u0069\u0065\u006c\u0064")
					continue
				}
				_fd.Log.Debug("\u0046\u0069\u0065\u006c\u0064 \u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0064 \u0069\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0025\u0054", _febaa)
				return nil, _b.Errorf("\u0066\u0069\u0065l\u0064\u0020\u006e\u006ft\u0020\u0069\u006e\u0020\u0061\u006e\u0020i\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074")
			}
			_bcgbb, _aaca := _gecg.newPdfFieldFromIndirectObject(_adgaf, nil)
			if _aaca != nil {
				return nil, _aaca
			}
			_fd.Log.Trace("\u0041\u0063\u0072\u006fFo\u0072\u006d\u0020\u0046\u0069\u0065\u006c\u0064\u003a\u0020\u0025\u002b\u0076", *_bcgbb)
			_cffdcg = append(_cffdcg, _bcgbb)
		}
		_aedcg.Fields = &_cffdcg
	}
	if _fbga := _dfdbca.Get("\u004ee\u0065d\u0041\u0070\u0070\u0065\u0061\u0072\u0061\u006e\u0063\u0065\u0073"); _fbga != nil {
		_eageff, _gdbfd := _agf.GetBool(_fbga)
		if _gdbfd {
			_aedcg.NeedAppearances = _eageff
		} else {
			_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u004e\u0065\u0065\u0064\u0041\u0070p\u0065\u0061\u0072\u0061\u006e\u0063e\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0067\u006ft\u0020\u0025\u0054\u0029", _fbga)
		}
	}
	if _cgfca := _dfdbca.Get("\u0053\u0069\u0067\u0046\u006c\u0061\u0067\u0073"); _cgfca != nil {
		_fagd, _aeab := _agf.GetInt(_cgfca)
		if _aeab {
			_aedcg.SigFlags = _fagd
		} else {
			_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0053\u0069\u0067\u0046\u006c\u0061\u0067\u0073 \u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", _cgfca)
		}
	}
	if _gaab := _dfdbca.Get("\u0043\u004f"); _gaab != nil {
		_accga, _bgedd := _agf.GetArray(_gaab)
		if _bgedd {
			_aedcg.CO = _accga
		} else {
			_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043\u004f\u0020\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0067\u006f\u0074 \u0025\u0054\u0029", _gaab)
		}
	}
	if _eaaa := _dfdbca.Get("\u0044\u0052"); _eaaa != nil {
		if _cgee, _gfcaf := _agf.GetDict(_eaaa); _gfcaf {
			_defc, _gbfb := NewPdfPageResourcesFromDict(_cgee)
			if _gbfb != nil {
				_fd.Log.Error("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0044R\u003a\u0020\u0025\u0076", _gbfb)
				return nil, _gbfb
			}
			_aedcg.DR = _defc
		} else {
			_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0044\u0052\u0020\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0067\u006f\u0074 \u0025\u0054\u0029", _eaaa)
		}
	}
	if _bbdfd := _dfdbca.Get("\u0044\u0041"); _bbdfd != nil {
		_cffe, _gbgc := _agf.GetString(_bbdfd)
		if _gbgc {
			_aedcg.DA = _cffe
		} else {
			_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0044\u0041\u0020\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0067\u006f\u0074 \u0025\u0054\u0029", _bbdfd)
		}
	}
	if _defg := _dfdbca.Get("\u0051"); _defg != nil {
		_gcegb, _fbea := _agf.GetInt(_defg)
		if _fbea {
			_aedcg.Q = _gcegb
		} else {
			_fd.Log.Debug("\u0045R\u0052\u004f\u0052\u003a \u0051\u0020\u0069\u006e\u0076a\u006ci\u0064 \u0028\u0067\u006f\u0074\u0020\u0025\u0054)", _defg)
		}
	}
	if _gecd := _dfdbca.Get("\u0058\u0046\u0041"); _gecd != nil {
		_aedcg.XFA = _gecd
	}
	if _eecdd := _dfdbca.Get("\u0041\u0044\u0042\u0045\u005f\u0045\u0063\u0068\u006f\u0053\u0069\u0067\u006e"); _eecdd != nil {
		_aedcg.ADBEEchoSign = _eecdd
	}
	_aedcg.ToPdfObject()
	return _aedcg, nil
}

// SetDocInfo sets the document /Info metadata.
// This will overwrite any globally declared document info.
func (_gfeg *PdfAppender) SetDocInfo(info *PdfInfo) { _gfeg._bgeg = info }

// String returns a string describing the font descriptor.
func (_bdcdc *PdfFontDescriptor) String() string {
	var _caaf []string
	if _bdcdc.FontName != nil {
		_caaf = append(_caaf, _bdcdc.FontName.String())
	}
	if _bdcdc.FontFamily != nil {
		_caaf = append(_caaf, _bdcdc.FontFamily.String())
	}
	if _bdcdc.fontFile != nil {
		_caaf = append(_caaf, _bdcdc.fontFile.String())
	}
	if _bdcdc._fdddd != nil {
		_caaf = append(_caaf, _bdcdc._fdddd.String())
	}
	_caaf = append(_caaf, _b.Sprintf("\u0046\u006f\u006et\u0046\u0069\u006c\u0065\u0033\u003d\u0025\u0074", _bdcdc.FontFile3 != nil))
	return _b.Sprintf("\u0046\u004f\u004e\u0054_D\u0045\u0053\u0043\u0052\u0049\u0050\u0054\u004f\u0052\u007b\u0025\u0073\u007d", _gc.Join(_caaf, "\u002c\u0020"))
}

// PdfBorderEffect represents a PDF border effect.
type PdfBorderEffect struct {
	S *BorderEffect
	I *float64
}

// Set sets the colorspace corresponding to key. Add to Names if not set.
func (_fdbf *PdfPageResourcesColorspaces) Set(key _agf.PdfObjectName, val PdfColorspace) {
	if _, _gegeg := _fdbf.Colorspaces[string(key)]; !_gegeg {
		_fdbf.Names = append(_fdbf.Names, string(key))
	}
	_fdbf.Colorspaces[string(key)] = val
}

// NewPdfFontFromTTFFile loads a TTF font file and returns a PdfFont type
// that can be used in text styling functions.
// Uses a WinAnsiTextEncoder and loads only character codes 32-255.
// NOTE: For composite fonts such as used in symbolic languages, use NewCompositePdfFontFromTTFFile.
func NewPdfFontFromTTFFile(filePath string) (*PdfFont, error) {
	_eeccf, _fabg := _fb.Open(filePath)
	if _fabg != nil {
		_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0072\u0065\u0061\u0064\u0069\u006e\u0067\u0020T\u0054F\u0020\u0066\u006f\u006e\u0074\u0020\u0066\u0069\u006c\u0065\u003a\u0020\u0025\u0076", _fabg)
		return nil, _fabg
	}
	defer _eeccf.Close()
	return NewPdfFontFromTTF(_eeccf)
}
func (_cad *PdfReader) newPdfActionURIFromDict(_bebf *_agf.PdfObjectDictionary) (*PdfActionURI, error) {
	return &PdfActionURI{URI: _bebf.Get("\u0055\u0052\u0049"), IsMap: _bebf.Get("\u0049\u0073\u004da\u0070")}, nil
}

// GetCharMetrics returns the char metrics for character code `code`.
func (_dfdg pdfCIDFontType2) GetCharMetrics(code _fcg.CharCode) (_aa.CharMetrics, bool) {
	if _acbag, _dcfbf := _dfdg._egaaf[code]; _dcfbf {
		return _aa.CharMetrics{Wx: _acbag}, true
	}
	_acbg := rune(code)
	_gefab, _cedgeg := _dfdg._dbae[_acbg]
	if !_cedgeg {
		_gefab = int(_dfdg._fgecb)
	}
	return _aa.CharMetrics{Wx: float64(_gefab)}, true
}

// PdfAnnotationFreeText represents FreeText annotations.
// (Section 12.5.6.6).
type PdfAnnotationFreeText struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	DA _agf.PdfObject
	Q  _agf.PdfObject
	RC _agf.PdfObject
	DS _agf.PdfObject
	CL _agf.PdfObject
	IT _agf.PdfObject
	BE _agf.PdfObject
	RD _agf.PdfObject
	BS _agf.PdfObject
	LE _agf.PdfObject
}

func _ddgg(_bgbge *_ged.ImageBase) (_agabe Image) {
	_agabe.Width = int64(_bgbge.Width)
	_agabe.Height = int64(_bgbge.Height)
	_agabe.BitsPerComponent = int64(_bgbge.BitsPerComponent)
	_agabe.ColorComponents = _bgbge.ColorComponents
	_agabe.Data = _bgbge.Data
	_agabe._abacg = _bgbge.Decode
	_agabe._gdga = _bgbge.Alpha
	return _agabe
}
func (_fddd *PdfReader) newPdfFieldSignatureFromDict(_abda *_agf.PdfObjectDictionary) (*PdfFieldSignature, error) {
	_ffge := &PdfFieldSignature{}
	_dbdf, _ggbc := _agf.GetIndirect(_abda.Get("\u0056"))
	if _ggbc {
		var _adcb error
		_ffge.V, _adcb = _fddd.newPdfSignatureFromIndirect(_dbdf)
		if _adcb != nil {
			return nil, _adcb
		}
	}
	_ffge.Lock, _ = _agf.GetIndirect(_abda.Get("\u004c\u006f\u0063\u006b"))
	_ffge.SV, _ = _agf.GetIndirect(_abda.Get("\u0053\u0056"))
	return _ffge, nil
}

// ValidateSignatures validates digital signatures in the document.
func (_cedga *PdfReader) ValidateSignatures(handlers []SignatureHandler) ([]SignatureValidationResult, error) {
	if _cedga.AcroForm == nil {
		return nil, nil
	}
	if _cedga.AcroForm.Fields == nil {
		return nil, nil
	}
	type sigFieldPair struct {
		_bbba  *PdfSignature
		_gdfee *PdfField
		_dgddc SignatureHandler
	}
	var _dgbbf []*sigFieldPair
	for _, _baga := range _cedga.AcroForm.AllFields() {
		if _baga.V == nil {
			continue
		}
		if _fcdf, _acdd := _agf.GetDict(_baga.V); _acdd {
			if _ebee, _bdbga := _agf.GetNameVal(_fcdf.Get("\u0054\u0079\u0070\u0065")); _bdbga && _ebee == "\u0053\u0069\u0067" {
				_ceegg, _dfacd := _agf.GetIndirect(_baga.V)
				if !_dfacd {
					_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0063\u006f\u006et\u0061\u0069\u006e\u0065\u0072\u0020\u0069s\u0020\u006e\u0069\u006c")
					return nil, ErrTypeCheck
				}
				_eaeb, _bebfe := _cedga.newPdfSignatureFromIndirect(_ceegg)
				if _bebfe != nil {
					return nil, _bebfe
				}
				var _aggca SignatureHandler
				for _, _bbefe := range handlers {
					if _bbefe.IsApplicable(_eaeb) {
						_aggca = _bbefe
						break
					}
				}
				_dgbbf = append(_dgbbf, &sigFieldPair{_bbba: _eaeb, _gdfee: _baga, _dgddc: _aggca})
			}
		}
	}
	var _fagdg []SignatureValidationResult
	for _, _gedge := range _dgbbf {
		_ccbea := SignatureValidationResult{IsSigned: true, Fields: []*PdfField{_gedge._gdfee}}
		if _gedge._dgddc == nil {
			_ccbea.Errors = append(_ccbea.Errors, "\u0068a\u006ed\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0073\u0065\u0074")
			_fagdg = append(_fagdg, _ccbea)
			continue
		}
		_ffde, _befadb := _gedge._dgddc.NewDigest(_gedge._bbba)
		if _befadb != nil {
			_ccbea.Errors = append(_ccbea.Errors, "\u0064\u0069\u0067e\u0073\u0074\u0020\u0065\u0072\u0072\u006f\u0072", _befadb.Error())
			_fagdg = append(_fagdg, _ccbea)
			continue
		}
		_dcag := _gedge._bbba.ByteRange
		if _dcag == nil {
			_ccbea.Errors = append(_ccbea.Errors, "\u0042\u0079\u0074\u0065\u0052\u0061\u006e\u0067\u0065\u0020\u006e\u006ft\u0020\u0073\u0065\u0074")
			_fagdg = append(_fagdg, _ccbea)
			continue
		}
		for _feedf := 0; _feedf < _dcag.Len(); _feedf = _feedf + 2 {
			_caddb, _ := _agf.GetNumberAsInt64(_dcag.Get(_feedf))
			_dceee, _ := _agf.GetIntVal(_dcag.Get(_feedf + 1))
			if _, _gaggb := _cedga._bggga.Seek(_caddb, _cf.SeekStart); _gaggb != nil {
				return nil, _gaggb
			}
			_gddg := make([]byte, _dceee)
			if _, _fegf := _cedga._bggga.Read(_gddg); _fegf != nil {
				return nil, _fegf
			}
			_ffde.Write(_gddg)
		}
		var _ccdd SignatureValidationResult
		if _fbgd, _fdbfa := _gedge._dgddc.(SignatureHandlerDocMDP); _fdbfa {
			_ccdd, _befadb = _fbgd.ValidateWithOpts(_gedge._bbba, _ffde, SignatureHandlerDocMDPParams{Parser: _cedga._egdga})
		} else {
			_ccdd, _befadb = _gedge._dgddc.Validate(_gedge._bbba, _ffde)
		}
		if _befadb != nil {
			_fd.Log.Debug("E\u0052\u0052\u004f\u0052: \u0025v\u0020\u0028\u0025\u0054\u0029 \u002d\u0020\u0073\u006b\u0069\u0070", _befadb, _gedge._dgddc)
			_ccdd.Errors = append(_ccdd.Errors, _befadb.Error())
		}
		_ccdd.Name = _gedge._bbba.Name.Decoded()
		_ccdd.Reason = _gedge._bbba.Reason.Decoded()
		if _gedge._bbba.M != nil {
			_cfcd, _abgga := NewPdfDate(_gedge._bbba.M.String())
			if _abgga != nil {
				_fd.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _abgga)
				_ccdd.Errors = append(_ccdd.Errors, _abgga.Error())
				continue
			}
			_ccdd.Date = _cfcd
		}
		_ccdd.ContactInfo = _gedge._bbba.ContactInfo.Decoded()
		_ccdd.Location = _gedge._bbba.Location.Decoded()
		_ccdd.Fields = _ccbea.Fields
		_fagdg = append(_fagdg, _ccdd)
	}
	return _fagdg, nil
}
func _dgda(_fcacc *_agf.PdfObjectDictionary) (*PdfShadingPattern, error) {
	_effge := &PdfShadingPattern{}
	_ecbed := _fcacc.Get("\u0053h\u0061\u0064\u0069\u006e\u0067")
	if _ecbed == nil {
		_fd.Log.Debug("\u0053h\u0061d\u0069\u006e\u0067\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067")
		return nil, ErrRequiredAttributeMissing
	}
	_acdfa, _gfaffe := _abbd(_ecbed)
	if _gfaffe != nil {
		_fd.Log.Debug("\u0045r\u0072\u006f\u0072\u0020l\u006f\u0061\u0064\u0069\u006eg\u0020s\u0068a\u0064\u0069\u006e\u0067\u003a\u0020\u0025v", _gfaffe)
		return nil, _gfaffe
	}
	_effge.Shading = _acdfa
	if _gbde := _fcacc.Get("\u004d\u0061\u0074\u0072\u0069\u0078"); _gbde != nil {
		_daebcc, _ddab := _gbde.(*_agf.PdfObjectArray)
		if !_ddab {
			_fd.Log.Debug("\u004d\u0061\u0074\u0072i\u0078\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072a\u0079\u0020\u0028\u0067\u006f\u0074\u0020%\u0054\u0029", _gbde)
			return nil, _agf.ErrTypeError
		}
		_effge.Matrix = _daebcc
	}
	if _fbbaa := _fcacc.Get("\u0045x\u0074\u0047\u0053\u0074\u0061\u0074e"); _fbbaa != nil {
		_effge.ExtGState = _fbbaa
	}
	return _effge, nil
}

// GetNumComponents returns the number of color components of the colorspace device.
// Returns 3 for a Lab device.
func (_febc *PdfColorspaceLab) GetNumComponents() int { return 3 }

// ToInteger convert to an integer format.
func (_fbgfa *PdfColorDeviceCMYK) ToInteger(bits int) [4]uint32 {
	_caef := _afb.Pow(2, float64(bits)) - 1
	return [4]uint32{uint32(_caef * _fbgfa.C()), uint32(_caef * _fbgfa.M()), uint32(_caef * _fbgfa.Y()), uint32(_caef * _fbgfa.K())}
}

// SetFilter sets compression filter. Decodes with current filter sets and
// encodes the data with the new filter.
func (_gafb *XObjectImage) SetFilter(encoder _agf.StreamEncoder) error {
	_eafec := _gafb.Stream
	_gffdb, _acefgc := _gafb.Filter.DecodeBytes(_eafec)
	if _acefgc != nil {
		return _acefgc
	}
	_gafb.Filter = encoder
	encoder.UpdateParams(_gafb.getParamsDict())
	_eafec, _acefgc = encoder.EncodeBytes(_gffdb)
	if _acefgc != nil {
		return _acefgc
	}
	_gafb.Stream = _eafec
	return nil
}

// EnableChain adds the specified certificate chain and validation data (OCSP
// and CRL information) for it to the global scope of the document DSS. The
// added data is used for validating any of the signatures present in the
// document. The LTV client attempts to build the certificate chain up to a
// trusted root by downloading any missing certificates.
func (_eedeb *LTV) EnableChain(chain []*_ed.Certificate) error { return _eedeb.enable(nil, chain, "") }

// ToPdfObject returns a PdfObject representation of PdfColorspaceDeviceNAttributes as a PdfObjectDictionary directly
// or indirectly within an indirect object container.
func (_aafea *PdfColorspaceDeviceNAttributes) ToPdfObject() _agf.PdfObject {
	_gfbge := _agf.MakeDict()
	if _aafea.Subtype != nil {
		_gfbge.Set("\u0053u\u0062\u0074\u0079\u0070\u0065", _aafea.Subtype)
	}
	_gfbge.SetIfNotNil("\u0043o\u006c\u006f\u0072\u0061\u006e\u0074s", _aafea.Colorants)
	_gfbge.SetIfNotNil("\u0050r\u006f\u0063\u0065\u0073\u0073", _aafea.Process)
	_gfbge.SetIfNotNil("M\u0069\u0078\u0069\u006e\u0067\u0048\u0069\u006e\u0074\u0073", _aafea.MixingHints)
	if _aafea._dea != nil {
		_aafea._dea.PdfObject = _gfbge
		return _aafea._dea
	}
	return _gfbge
}

// FlattenFieldsWithOpts flattens the AcroForm fields of the reader using the
// provided field appearance generator and the specified options. If no options
// are specified, all form fields are flattened.
// If a filter function is provided using the opts parameter, only the filtered
// fields are flattened. Otherwise, all form fields are flattened.
// At the end of the process, the AcroForm contains all the fields which were
// not flattened. If all fields are flattened, the reader's AcroForm field
// is set to nil.
func (_egfcd *PdfReader) FlattenFieldsWithOpts(appgen FieldAppearanceGenerator, opts *FieldFlattenOpts) error {
	return _egfcd.flattenFieldsWithOpts(false, appgen, opts)
}

// String returns a string representation of PdfTransformParamsDocMDP.
func (_aabec *PdfTransformParamsDocMDP) String() string {
	return _b.Sprintf("\u0025\u0073\u0020\u0050\u003a\u0020\u0025\u0073\u0020V\u003a\u0020\u0025\u0073", _aabec.Type, _aabec.P, _aabec.V)
}
func (_bbee *PdfAcroForm) fill(_fbebd FieldValueProvider, _acag FieldAppearanceGenerator) error {
	if _bbee == nil {
		return nil
	}
	_fbbff, _dgaef := _fbebd.FieldValues()
	if _dgaef != nil {
		return _dgaef
	}
	for _, _gdeac := range _bbee.AllFields() {
		_dceb := _gdeac.PartialName()
		_dedcb, _eecab := _fbbff[_dceb]
		if !_eecab {
			if _caegb, _edceg := _gdeac.FullName(); _edceg == nil {
				_dedcb, _eecab = _fbbff[_caegb]
			}
		}
		if !_eecab {
			_fd.Log.Debug("\u0057\u0041\u0052\u004e\u003a\u0020f\u006f\u0072\u006d \u0066\u0069\u0065l\u0064\u0020\u0025\u0073\u0020\u006e\u006f\u0074\u0020\u0066o\u0075\u006e\u0064\u0020\u0069n \u0074\u0068\u0065\u0020\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0072\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e", _dceb)
			continue
		}
		if _fbcdf := _geb(_gdeac, _dedcb); _fbcdf != nil {
			return _fbcdf
		}
		if _acag == nil {
			continue
		}
		for _, _fdegb := range _gdeac.Annotations {
			_gcdce, _face := _acag.GenerateAppearanceDict(_bbee, _gdeac, _fdegb)
			if _face != nil {
				return _face
			}
			_fdegb.AP = _gcdce
			_fdegb.ToPdfObject()
		}
	}
	return nil
}

// NewPdfPageResourcesColorspaces returns a new PdfPageResourcesColorspaces object.
func NewPdfPageResourcesColorspaces() *PdfPageResourcesColorspaces {
	_afac := &PdfPageResourcesColorspaces{}
	_afac.Names = []string{}
	_afac.Colorspaces = map[string]PdfColorspace{}
	_afac._dafcd = &_agf.PdfIndirectObject{}
	return _afac
}

// PdfTilingPattern is a Tiling pattern that consists of repetitions of a pattern cell with defined intervals.
// It is a type 1 pattern. (PatternType = 1).
// A tiling pattern is represented by a stream object, where the stream content is
// a content stream that describes the pattern cell.
type PdfTilingPattern struct {
	*PdfPattern
	PaintType  *_agf.PdfObjectInteger
	TilingType *_agf.PdfObjectInteger
	BBox       *PdfRectangle
	XStep      *_agf.PdfObjectFloat
	YStep      *_agf.PdfObjectFloat
	Resources  *PdfPageResources
	Matrix     *_agf.PdfObjectArray
}

// ToPdfObject implements interface PdfModel.
func (_aecd *PdfAnnotationTrapNet) ToPdfObject() _agf.PdfObject {
	_aecd.PdfAnnotation.ToPdfObject()
	_gafge := _aecd._aeee
	_eage := _gafge.PdfObject.(*_agf.PdfObjectDictionary)
	_eage.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _agf.MakeName("\u0054r\u0061\u0070\u004e\u0065\u0074"))
	return _gafge
}

// ToPdfObject returns the PDF representation of the shading dictionary.
func (_dcbaa *PdfShadingType3) ToPdfObject() _agf.PdfObject {
	_dcbaa.PdfShading.ToPdfObject()
	_cfaef, _faceb := _dcbaa.getShadingDict()
	if _faceb != nil {
		_fd.Log.Error("\u0055\u006ea\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0061\u0063\u0063\u0065\u0073\u0073\u0020\u0073\u0068\u0061\u0064\u0069\u006e\u0067\u0020di\u0063\u0074")
		return nil
	}
	if _dcbaa.Coords != nil {
		_cfaef.Set("\u0043\u006f\u006f\u0072\u0064\u0073", _dcbaa.Coords)
	}
	if _dcbaa.Domain != nil {
		_cfaef.Set("\u0044\u006f\u006d\u0061\u0069\u006e", _dcbaa.Domain)
	}
	if _dcbaa.Function != nil {
		if len(_dcbaa.Function) == 1 {
			_cfaef.Set("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e", _dcbaa.Function[0].ToPdfObject())
		} else {
			_fcfcg := _agf.MakeArray()
			for _, _eedgag := range _dcbaa.Function {
				_fcfcg.Append(_eedgag.ToPdfObject())
			}
			_cfaef.Set("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e", _fcfcg)
		}
	}
	if _dcbaa.Extend != nil {
		_cfaef.Set("\u0045\u0078\u0074\u0065\u006e\u0064", _dcbaa.Extend)
	}
	return _dcbaa._ggbge
}

// GetNumComponents returns the number of color components (3 for CalRGB).
func (_bdefa *PdfColorCalRGB) GetNumComponents() int { return 3 }

// NewPdfActionTrans returns a new "trans" action.
func NewPdfActionTrans() *PdfActionTrans {
	_ac := NewPdfAction()
	_cc := &PdfActionTrans{}
	_cc.PdfAction = _ac
	_ac.SetContext(_cc)
	return _cc
}

// ImageToRGB returns an error since an image cannot be defined in a pattern colorspace.
func (_ecgb *PdfColorspaceSpecialPattern) ImageToRGB(img Image) (Image, error) {
	_fd.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0049\u006d\u0061\u0067\u0065\u0020\u0063\u0061n\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u0073\u0070\u0065\u0063\u0069\u0066i\u0065\u0064\u0020\u0069\u006e\u0020\u0050\u0061\u0074\u0074\u0065\u0072n \u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063\u0065")
	return img, _gcd.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063\u0065\u0020\u0066\u006f\u0072\u0020\u0069m\u0061\u0067\u0065\u0020\u0028p\u0061\u0074t\u0065\u0072\u006e\u0029")
}

// ColorFromFloats returns a new PdfColor based on the input slice of color
// components. The slice should contain three elements representing the
// L (range 0-100), A (range -100-100) and B (range -100-100) components of
// the color.
func (_dbfd *PdfColorspaceLab) ColorFromFloats(vals []float64) (PdfColor, error) {
	if len(vals) != 3 {
		return nil, _gcd.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_ade := vals[0]
	if _ade < 0.0 || _ade > 100.0 {
		_fd.Log.Debug("\u004c\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067e\u0020\u0028\u0067\u006f\u0074\u0020%\u0076\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0030-\u0031\u0030\u0030\u0029", _ade)
		return nil, ErrColorOutOfRange
	}
	_bfbcg := vals[1]
	_bgdg := float64(-100)
	_efbg := float64(100)
	if len(_dbfd.Range) > 1 {
		_bgdg = _dbfd.Range[0]
		_efbg = _dbfd.Range[1]
	}
	if _bfbcg < _bgdg || _bfbcg > _efbg {
		_fd.Log.Debug("\u0041\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067e\u0020\u0028\u0067\u006f\u0074\u0020%\u0076\u003b\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0025\u0076\u0020\u0074o\u0020\u0025\u0076\u0029", _bfbcg, _bgdg, _efbg)
		return nil, ErrColorOutOfRange
	}
	_fbad := vals[2]
	_gddc := float64(-100)
	_effg := float64(100)
	if len(_dbfd.Range) > 3 {
		_gddc = _dbfd.Range[2]
		_effg = _dbfd.Range[3]
	}
	if _fbad < _gddc || _fbad > _effg {
		_fd.Log.Debug("\u0062\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067e\u0020\u0028\u0067\u006f\u0074\u0020%\u0076\u003b\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0025\u0076\u0020\u0074o\u0020\u0025\u0076\u0029", _fbad, _gddc, _effg)
		return nil, ErrColorOutOfRange
	}
	_fegc := NewPdfColorLab(_ade, _bfbcg, _fbad)
	return _fegc, nil
}

// PdfAnnotationSound represents Sound annotations.
// (Section 12.5.6.16).
type PdfAnnotationSound struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	Sound _agf.PdfObject
	Name  _agf.PdfObject
}

// SignatureHandler interface defines the common functionality for PDF signature handlers, which
// need to be capable of validating digital signatures and signing PDF documents.
type SignatureHandler interface {

	// IsApplicable checks if a given signature dictionary `sig` is applicable for the signature handler.
	// For example a signature of type `adbe.pkcs7.detached` might not fit for a rsa.sha1 handler.
	IsApplicable(_dgedbg *PdfSignature) bool

	// Validate validates a PDF signature against a given digest (hash) such as that determined
	// for an input file. Returns validation results.
	Validate(_efcdg *PdfSignature, _bedcg Hasher) (SignatureValidationResult, error)

	// InitSignature prepares the signature dictionary for signing. This involves setting all
	// necessary fields, and also allocating sufficient space to the Contents so that the
	// finalized signature can be inserted once the hash is calculated.
	InitSignature(_dgccg *PdfSignature) error

	// NewDigest creates a new digest/hasher based on the signature dictionary and handler.
	NewDigest(_gbfca *PdfSignature) (Hasher, error)

	// Sign receives the hash `digest` (for example hash of an input file), and signs based
	// on the signature dictionary `sig` and applies the signature data to the signature
	// dictionary Contents field.
	Sign(_fbccb *PdfSignature, _ggdfd Hasher) error
}

// PdfAnnotationScreen represents Screen annotations.
// (Section 12.5.6.18).
type PdfAnnotationScreen struct {
	*PdfAnnotation
	T  _agf.PdfObject
	MK _agf.PdfObject
	A  _agf.PdfObject
	AA _agf.PdfObject
}

func (_bbefg *PdfWriter) hasObject(_bgbf _agf.PdfObject) bool {
	_, _gcccc := _bbefg._ccbbf[_bgbf]
	return _gcccc
}

// NewPdfAnnotationStamp returns a new stamp annotation.
func NewPdfAnnotationStamp() *PdfAnnotationStamp {
	_adfb := NewPdfAnnotation()
	_abcf := &PdfAnnotationStamp{}
	_abcf.PdfAnnotation = _adfb
	_abcf.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_adfb.SetContext(_abcf)
	return _abcf
}

// GetOutlinesFlattened returns a flattened list of tree nodes and titles.
// NOTE: for most use cases, it is recommended to use the high-level GetOutlines
// method instead, which also provides information regarding the destination
// of the outline items.
func (_edaa *PdfReader) GetOutlinesFlattened() ([]*PdfOutlineTreeNode, []string, error) {
	var _aeca []*PdfOutlineTreeNode
	var _cagcb []string
	var _ggbeg func(*PdfOutlineTreeNode, *[]*PdfOutlineTreeNode, *[]string, int)
	_ggbeg = func(_cfebfd *PdfOutlineTreeNode, _cacfa *[]*PdfOutlineTreeNode, _bbef *[]string, _geddb int) {
		if _cfebfd == nil {
			return
		}
		if _cfebfd._cgaaa == nil {
			_fd.Log.Debug("E\u0052\u0052\u004f\u0052\u003a\u0020M\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u006e\u006fd\u0065\u002e\u0063o\u006et\u0065\u0078\u0074")
			return
		}
		_gdfbc, _fbfe := _cfebfd._cgaaa.(*PdfOutlineItem)
		if _fbfe {
			*_cacfa = append(*_cacfa, &_gdfbc.PdfOutlineTreeNode)
			_cdeff := _gc.Repeat("\u0020", _geddb*2) + _gdfbc.Title.Decoded()
			*_bbef = append(*_bbef, _cdeff)
		}
		if _cfebfd.First != nil {
			_befaf := _gc.Repeat("\u0020", _geddb*2) + "\u002b"
			*_bbef = append(*_bbef, _befaf)
			_ggbeg(_cfebfd.First, _cacfa, _bbef, _geddb+1)
		}
		if _fbfe && _gdfbc.Next != nil {
			_ggbeg(_gdfbc.Next, _cacfa, _bbef, _geddb)
		}
	}
	_ggbeg(_edaa._gfdaa, &_aeca, &_cagcb, 0)
	return _aeca, _cagcb, nil
}

// String implements interface PdfObject.
func (_bee *PdfAction) String() string {
	_ec, _fg := _bee.ToPdfObject().(*_agf.PdfIndirectObject)
	if _fg {
		return _b.Sprintf("\u0025\u0054\u003a\u0020\u0025\u0073", _bee._ae, _ec.PdfObject.String())
	}
	return ""
}

// ToPdfObject converts PdfAcroForm to a PdfObject, i.e. an indirect object containing the
// AcroForm dictionary.
func (_bcdd *PdfAcroForm) ToPdfObject() _agf.PdfObject {
	_dgdce := _bcdd._dfdbc
	_gbca := _dgdce.PdfObject.(*_agf.PdfObjectDictionary)
	if _bcdd.Fields != nil {
		_cgfb := _agf.PdfObjectArray{}
		for _, _cgde := range *_bcdd.Fields {
			_dbab := _cgde.GetContext()
			if _dbab != nil {
				_cgfb.Append(_dbab.ToPdfObject())
			} else {
				_cgfb.Append(_cgde.ToPdfObject())
			}
		}
		_gbca.Set("\u0046\u0069\u0065\u006c\u0064\u0073", &_cgfb)
	}
	if _bcdd.NeedAppearances != nil {
		_gbca.Set("\u004ee\u0065d\u0041\u0070\u0070\u0065\u0061\u0072\u0061\u006e\u0063\u0065\u0073", _bcdd.NeedAppearances)
	}
	if _bcdd.SigFlags != nil {
		_gbca.Set("\u0053\u0069\u0067\u0046\u006c\u0061\u0067\u0073", _bcdd.SigFlags)
	}
	if _bcdd.CO != nil {
		_gbca.Set("\u0043\u004f", _bcdd.CO)
	}
	if _bcdd.DR != nil {
		_gbca.Set("\u0044\u0052", _bcdd.DR.ToPdfObject())
	}
	if _bcdd.DA != nil {
		_gbca.Set("\u0044\u0041", _bcdd.DA)
	}
	if _bcdd.Q != nil {
		_gbca.Set("\u0051", _bcdd.Q)
	}
	if _bcdd.XFA != nil {
		_gbca.Set("\u0058\u0046\u0041", _bcdd.XFA)
	}
	if _bcdd.ADBEEchoSign != nil {
		_gbca.Set("\u0041\u0044\u0042\u0045\u005f\u0045\u0063\u0068\u006f\u0053\u0069\u0067\u006e", _bcdd.ADBEEchoSign)
	}
	return _dgdce
}
func (_daegg *pdfCIDFontType2) baseFields() *fontCommon { return &_daegg.fontCommon }

// Add appends a top level outline item to the outline.
func (_bdecff *Outline) Add(item *OutlineItem) { _bdecff.Entries = append(_bdecff.Entries, item) }

// AlphaMap performs mapping of alpha data for transformations. Allows custom filtering of alpha data etc.
func (_cbeaf *Image) AlphaMap(mapFunc AlphaMapFunc) {
	for _dgeg, _bfdca := range _cbeaf._gdga {
		_cbeaf._gdga[_dgeg] = mapFunc(_bfdca)
	}
}

// SetDecode sets the decode image float slice.
func (_cgcbc *Image) SetDecode(decode []float64) { _cgcbc._abacg = decode }

// ToPdfObject returns the PDF representation of the shading pattern.
func (_egffa *PdfShadingPatternType3) ToPdfObject() _agf.PdfObject {
	_egffa.PdfPattern.ToPdfObject()
	_cgbaf := _egffa.getDict()
	if _egffa.Shading != nil {
		_cgbaf.Set("\u0053h\u0061\u0064\u0069\u006e\u0067", _egffa.Shading.ToPdfObject())
	}
	if _egffa.Matrix != nil {
		_cgbaf.Set("\u004d\u0061\u0074\u0072\u0069\u0078", _egffa.Matrix)
	}
	if _egffa.ExtGState != nil {
		_cgbaf.Set("\u0045x\u0074\u0047\u0053\u0074\u0061\u0074e", _egffa.ExtGState)
	}
	return _egffa._efed
}
func _aaaf(_fbab _agf.PdfObject) (*PdfColorspaceCalGray, error) {
	_cdc := NewPdfColorspaceCalGray()
	if _adga, _gggf := _fbab.(*_agf.PdfIndirectObject); _gggf {
		_cdc._gec = _adga
	}
	_fbab = _agf.TraceToDirectObject(_fbab)
	_bddc, _cbgd := _fbab.(*_agf.PdfObjectArray)
	if !_cbgd {
		return nil, _b.Errorf("\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	if _bddc.Len() != 2 {
		return nil, _b.Errorf("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0043\u0061\u006cG\u0072\u0061\u0079\u0020\u0063\u006f\u006c\u006f\u0072\u0073p\u0061\u0063\u0065")
	}
	_fbab = _agf.TraceToDirectObject(_bddc.Get(0))
	_dgcb, _cbgd := _fbab.(*_agf.PdfObjectName)
	if !_cbgd {
		return nil, _b.Errorf("\u0043\u0061\u006c\u0047\u0072\u0061\u0079\u0020\u006e\u0061m\u0065\u0020\u006e\u006f\u0074\u0020\u0061 \u004e\u0061\u006d\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074")
	}
	if *_dgcb != "\u0043a\u006c\u0047\u0072\u0061\u0079" {
		return nil, _b.Errorf("\u006eo\u0074\u0020\u0061\u0020\u0043\u0061\u006c\u0047\u0072\u0061\u0079 \u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063\u0065")
	}
	_fbab = _agf.TraceToDirectObject(_bddc.Get(1))
	_cgf, _cbgd := _fbab.(*_agf.PdfObjectDictionary)
	if !_cbgd {
		return nil, _b.Errorf("\u0043\u0061lG\u0072\u0061\u0079 \u0064\u0069\u0063\u0074 no\u0074 a\u0020\u0044\u0069\u0063\u0074\u0069\u006fna\u0072\u0079\u0020\u006f\u0062\u006a\u0065c\u0074")
	}
	_fbab = _cgf.Get("\u0057\u0068\u0069\u0074\u0065\u0050\u006f\u0069\u006e\u0074")
	_fbab = _agf.TraceToDirectObject(_fbab)
	_fab, _cbgd := _fbab.(*_agf.PdfObjectArray)
	if !_cbgd {
		return nil, _b.Errorf("C\u0061\u006c\u0047\u0072\u0061\u0079:\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020W\u0068\u0069\u0074e\u0050o\u0069\u006e\u0074")
	}
	if _fab.Len() != 3 {
		return nil, _b.Errorf("\u0043\u0061\u006c\u0047\u0072\u0061y\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0057\u0068\u0069t\u0065\u0050\u006f\u0069\u006e\u0074\u0020a\u0072\u0072\u0061\u0079")
	}
	_agfcg, _cgeb := _fab.GetAsFloat64Slice()
	if _cgeb != nil {
		return nil, _cgeb
	}
	_cdc.WhitePoint = _agfcg
	_fbab = _cgf.Get("\u0042\u006c\u0061\u0063\u006b\u0050\u006f\u0069\u006e\u0074")
	if _fbab != nil {
		_fbab = _agf.TraceToDirectObject(_fbab)
		_gfgc, _aagb := _fbab.(*_agf.PdfObjectArray)
		if !_aagb {
			return nil, _b.Errorf("C\u0061\u006c\u0047\u0072\u0061\u0079:\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020B\u006c\u0061\u0063k\u0050o\u0069\u006e\u0074")
		}
		if _gfgc.Len() != 3 {
			return nil, _b.Errorf("\u0043\u0061\u006c\u0047\u0072\u0061y\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u006c\u0061c\u006b\u0050\u006f\u0069\u006e\u0074\u0020a\u0072\u0072\u0061\u0079")
		}
		_gggd, _bcgg := _gfgc.GetAsFloat64Slice()
		if _bcgg != nil {
			return nil, _bcgg
		}
		_cdc.BlackPoint = _gggd
	}
	_fbab = _cgf.Get("\u0047\u0061\u006dm\u0061")
	if _fbab != nil {
		_fbab = _agf.TraceToDirectObject(_fbab)
		_ggaa, _caad := _agf.GetNumberAsFloat(_fbab)
		if _caad != nil {
			return nil, _b.Errorf("C\u0061\u006c\u0047\u0072\u0061\u0079:\u0020\u0067\u0061\u006d\u006d\u0061\u0020\u006e\u006ft\u0020\u0061\u0020n\u0075m\u0062\u0065\u0072")
		}
		_cdc.Gamma = _ggaa
	}
	return _cdc, nil
}

// ColorToRGB converts an Indexed color to an RGB color.
func (_gaag *PdfColorspaceSpecialIndexed) ColorToRGB(color PdfColor) (PdfColor, error) {
	if _gaag.Base == nil {
		return nil, _gcd.New("\u0069\u006e\u0064\u0065\u0078\u0065d\u0020\u0062\u0061\u0073\u0065\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070a\u0063\u0065\u0020\u0075\u006e\u0064\u0065f\u0069\u006e\u0065\u0064")
	}
	return _gaag.Base.ColorToRGB(color)
}

// PdfAcroForm represents the AcroForm dictionary used for representation of form data in PDF.
type PdfAcroForm struct {
	Fields          *[]*PdfField
	NeedAppearances *_agf.PdfObjectBool
	SigFlags        *_agf.PdfObjectInteger
	CO              *_agf.PdfObjectArray
	DR              *PdfPageResources
	DA              *_agf.PdfObjectString
	Q               *_agf.PdfObjectInteger
	XFA             _agf.PdfObject

	// ADBEEchoSign extra objects from Adobe Acrobat, causing signature invalid if not exists.
	ADBEEchoSign _agf.PdfObject
	_dfdbc       *_agf.PdfIndirectObject
	_agfed       bool
}

// NewPdfAcroForm returns a new PdfAcroForm with an intialized container (indirect object).
func NewPdfAcroForm() *PdfAcroForm {
	return &PdfAcroForm{Fields: &[]*PdfField{}, _dfdbc: _agf.MakeIndirectObject(_agf.MakeDict())}
}

// GetEncryptionMethod returns a descriptive information string about the encryption method used.
func (_ceefc *PdfReader) GetEncryptionMethod() string {
	_edgbd := _ceefc._egdga.GetCrypter()
	return _edgbd.String()
}

// ToPdfObject implements interface PdfModel.
func (_dbfe *PdfAnnotationSound) ToPdfObject() _agf.PdfObject {
	_dbfe.PdfAnnotation.ToPdfObject()
	_cafeg := _dbfe._aeee
	_gceg := _cafeg.PdfObject.(*_agf.PdfObjectDictionary)
	_dbfe.PdfAnnotationMarkup.appendToPdfDictionary(_gceg)
	_gceg.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _agf.MakeName("\u0053\u006f\u0075n\u0064"))
	_gceg.SetIfNotNil("\u0053\u006f\u0075n\u0064", _dbfe.Sound)
	_gceg.SetIfNotNil("\u004e\u0061\u006d\u0065", _dbfe.Name)
	return _cafeg
}
func (_cgdgd *PdfWriter) copyObject(_egcdg _agf.PdfObject, _geeeg map[_agf.PdfObject]_agf.PdfObject, _ffcc map[_agf.PdfObject]struct{}, _dgdge bool) _agf.PdfObject {
	_fcecg := !_cgdgd._accad && _ffcc != nil
	if _fafcd, _gcffd := _geeeg[_egcdg]; _gcffd {
		if _fcecg && !_dgdge {
			delete(_ffcc, _egcdg)
		}
		return _fafcd
	}
	if _egcdg == nil {
		_cgedg := _agf.MakeNull()
		return _cgedg
	}
	_ggdbc := _egcdg
	switch _ebdf := _egcdg.(type) {
	case *_agf.PdfObjectArray:
		_facaac := _agf.MakeArray()
		_ggdbc = _facaac
		_geeeg[_egcdg] = _ggdbc
		for _, _ddcgc := range _ebdf.Elements() {
			_facaac.Append(_cgdgd.copyObject(_ddcgc, _geeeg, _ffcc, _dgdge))
		}
	case *_agf.PdfObjectStreams:
		_fegbfe := &_agf.PdfObjectStreams{PdfObjectReference: _ebdf.PdfObjectReference}
		_ggdbc = _fegbfe
		_geeeg[_egcdg] = _ggdbc
		for _, _dddeg := range _ebdf.Elements() {
			_fegbfe.Append(_cgdgd.copyObject(_dddeg, _geeeg, _ffcc, _dgdge))
		}
	case *_agf.PdfObjectStream:
		_gfeedc := &_agf.PdfObjectStream{Stream: _ebdf.Stream, PdfObjectReference: _ebdf.PdfObjectReference}
		_ggdbc = _gfeedc
		_geeeg[_egcdg] = _ggdbc
		_gfeedc.PdfObjectDictionary = _cgdgd.copyObject(_ebdf.PdfObjectDictionary, _geeeg, _ffcc, _dgdge).(*_agf.PdfObjectDictionary)
	case *_agf.PdfObjectDictionary:
		var _eefab bool
		if _fcecg && !_dgdge {
			if _cgdee, _ := _agf.GetNameVal(_ebdf.Get("\u0054\u0079\u0070\u0065")); _cgdee == "\u0050\u0061\u0067\u0065" {
				_, _deeg := _cgdgd._adec[_ebdf]
				_dgdge = !_deeg
				_eefab = _dgdge
			}
		}
		_gacde := _agf.MakeDict()
		_ggdbc = _gacde
		_geeeg[_egcdg] = _ggdbc
		for _, _bgdca := range _ebdf.Keys() {
			_gacde.Set(_bgdca, _cgdgd.copyObject(_ebdf.Get(_bgdca), _geeeg, _ffcc, _dgdge))
		}
		if _eefab {
			_ggdbc = _agf.MakeNull()
			_dgdge = false
		}
	case *_agf.PdfIndirectObject:
		_bdfgb := &_agf.PdfIndirectObject{PdfObjectReference: _ebdf.PdfObjectReference}
		_ggdbc = _bdfgb
		_geeeg[_egcdg] = _ggdbc
		_bdfgb.PdfObject = _cgdgd.copyObject(_ebdf.PdfObject, _geeeg, _ffcc, _dgdge)
	case *_agf.PdfObjectString:
		_bfegc := *_ebdf
		_ggdbc = &_bfegc
		_geeeg[_egcdg] = _ggdbc
	case *_agf.PdfObjectName:
		_eeecbf := *_ebdf
		_ggdbc = &_eeecbf
		_geeeg[_egcdg] = _ggdbc
	case *_agf.PdfObjectNull:
		_ggdbc = _agf.MakeNull()
		_geeeg[_egcdg] = _ggdbc
	case *_agf.PdfObjectInteger:
		_cefef := *_ebdf
		_ggdbc = &_cefef
		_geeeg[_egcdg] = _ggdbc
	case *_agf.PdfObjectReference:
		_ccde := *_ebdf
		_ggdbc = &_ccde
		_geeeg[_egcdg] = _ggdbc
	case *_agf.PdfObjectFloat:
		_cbeaff := *_ebdf
		_ggdbc = &_cbeaff
		_geeeg[_egcdg] = _ggdbc
	case *_agf.PdfObjectBool:
		_edgea := *_ebdf
		_ggdbc = &_edgea
		_geeeg[_egcdg] = _ggdbc
	case *pdfSignDictionary:
		_ffce := &pdfSignDictionary{PdfObjectDictionary: _agf.MakeDict(), _adfab: _ebdf._adfab, _ecaged: _ebdf._ecaged}
		_ggdbc = _ffce
		_geeeg[_egcdg] = _ggdbc
		for _, _fdfceb := range _ebdf.Keys() {
			_ffce.Set(_fdfceb, _cgdgd.copyObject(_ebdf.Get(_fdfceb), _geeeg, _ffcc, _dgdge))
		}
	default:
		_fd.Log.Info("\u0054\u004f\u0044\u004f\u0028\u0061\u0035\u0069\u0029\u003a\u0020\u0069\u006dp\u006c\u0065\u006d\u0065\u006e\u0074 \u0063\u006f\u0070\u0079\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0066\u006fr\u0020\u0025\u002b\u0076", _egcdg)
	}
	if _fcecg && _dgdge {
		_ffcc[_egcdg] = struct{}{}
	}
	return _ggdbc
}

// Normalize swaps (Llx,Urx) if Urx < Llx, and (Lly,Ury) if Ury < Lly.
func (_cbeef *PdfRectangle) Normalize() {
	if _cbeef.Llx > _cbeef.Urx {
		_cbeef.Llx, _cbeef.Urx = _cbeef.Urx, _cbeef.Llx
	}
	if _cbeef.Lly > _cbeef.Ury {
		_cbeef.Lly, _cbeef.Ury = _cbeef.Ury, _cbeef.Lly
	}
}
func _gcgff(_dfgbe string) (string, error) {
	var _bdbcg _gg.Buffer
	_bdbcg.WriteString(_dfgbe)
	_eeeeb := make([]byte, 8+16)
	_gffd := _e.Now().UTC().UnixNano()
	_bf.BigEndian.PutUint64(_eeeeb, uint64(_gffd))
	_, _acddg := _af.Read(_eeeeb[8:])
	if _acddg != nil {
		return "", _acddg
	}
	_bdbcg.WriteString(_ad.EncodeToString(_eeeeb))
	return _bdbcg.String(), nil
}

// ToPdfObject converts the font to a PDF representation.
func (_efga *pdfFontType3) ToPdfObject() _agf.PdfObject {
	if _efga._afea == nil {
		_efga._afea = &_agf.PdfIndirectObject{}
	}
	_fcag := _efga.baseFields().asPdfObjectDictionary("\u0054\u0079\u0070e\u0033")
	_efga._afea.PdfObject = _fcag
	if _efga.FirstChar != nil {
		_fcag.Set("\u0046i\u0072\u0073\u0074\u0043\u0068\u0061r", _efga.FirstChar)
	}
	if _efga.LastChar != nil {
		_fcag.Set("\u004c\u0061\u0073\u0074\u0043\u0068\u0061\u0072", _efga.LastChar)
	}
	if _efga.Widths != nil {
		_fcag.Set("\u0057\u0069\u0064\u0074\u0068\u0073", _efga.Widths)
	}
	if _efga.Encoding != nil {
		_fcag.Set("\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067", _efga.Encoding)
	} else if _efga._gfffe != nil {
		_bbbc := _efga._gfffe.ToPdfObject()
		if _bbbc != nil {
			_fcag.Set("\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067", _bbbc)
		}
	}
	if _efga.FontBBox != nil {
		_fcag.Set("\u0046\u006f\u006e\u0074\u0042\u0042\u006f\u0078", _efga.FontBBox)
	}
	if _efga.FontMatrix != nil {
		_fcag.Set("\u0046\u006f\u006e\u0074\u004d\u0061\u0074\u0069\u0072\u0078", _efga.FontMatrix)
	}
	if _efga.CharProcs != nil {
		_fcag.Set("\u0043h\u0061\u0072\u0050\u0072\u006f\u0063s", _efga.CharProcs)
	}
	if _efga.Resources != nil {
		_fcag.Set("\u0052e\u0073\u006f\u0075\u0072\u0063\u0065s", _efga.Resources)
	}
	return _efga._afea
}

// PdfAnnotationPolygon represents Polygon annotations.
// (Section 12.5.6.9).
type PdfAnnotationPolygon struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	Vertices _agf.PdfObject
	LE       _agf.PdfObject
	BS       _agf.PdfObject
	IC       _agf.PdfObject
	BE       _agf.PdfObject
	IT       _agf.PdfObject
	Measure  _agf.PdfObject
}

// ToPdfObject returns the PDF representation of the VRI dictionary.
func (_ffgae *VRI) ToPdfObject() *_agf.PdfObjectDictionary {
	_acbfd := _agf.MakeDict()
	_acbfd.SetIfNotNil(_agf.PdfObjectName("\u0043\u0065\u0072\u0074"), _gbcae(_ffgae.Cert))
	_acbfd.SetIfNotNil(_agf.PdfObjectName("\u004f\u0043\u0053\u0050"), _gbcae(_ffgae.OCSP))
	_acbfd.SetIfNotNil(_agf.PdfObjectName("\u0043\u0052\u004c"), _gbcae(_ffgae.CRL))
	_acbfd.SetIfNotNil("\u0054\u0055", _ffgae.TU)
	_acbfd.SetIfNotNil("\u0054\u0053", _ffgae.TS)
	return _acbfd
}

// GetCerts returns the signature certificate chain.
func (_bafe *PdfSignature) GetCerts() ([]*_ed.Certificate, error) {
	var _eefcfa []func() ([]*_ed.Certificate, error)
	switch _aabeg, _ := _agf.GetNameVal(_bafe.SubFilter); _aabeg {
	case "\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064", "\u0045\u0054\u0053\u0049.C\u0041\u0064\u0045\u0053\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064":
		_eefcfa = append(_eefcfa, _bafe.extractChainFromPKCS7, _bafe.extractChainFromCert)
	case "\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031":
		_eefcfa = append(_eefcfa, _bafe.extractChainFromCert)
	case "\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031":
		_eefcfa = append(_eefcfa, _bafe.extractChainFromPKCS7)
	default:
		return nil, _b.Errorf("\u0075n\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020S\u0075b\u0046i\u006c\u0074\u0065\u0072\u003a\u0020\u0025s", _aabeg)
	}
	for _, _fgafa := range _eefcfa {
		_cbbee, _bgfgf := _fgafa()
		if _bgfgf != nil {
			return nil, _bgfgf
		}
		if len(_cbbee) > 0 {
			return _cbbee, nil
		}
	}
	return nil, ErrSignNoCertificates
}
func (_cce *PdfReader) newPdfAnnotationMovieFromDict(_ggcc *_agf.PdfObjectDictionary) (*PdfAnnotationMovie, error) {
	_cedc := PdfAnnotationMovie{}
	_cedc.T = _ggcc.Get("\u0054")
	_cedc.Movie = _ggcc.Get("\u004d\u006f\u0076i\u0065")
	_cedc.A = _ggcc.Get("\u0041")
	return &_cedc, nil
}
func (_dfefd *LTV) enable(_fcab, _gadfe []*_ed.Certificate, _bedg string) error {
	_dadac, _dcgef, _dgfd := _dfefd.buildCertChain(_fcab, _gadfe)
	if _dgfd != nil {
		return _dgfd
	}
	_gagfd, _dgfd := _dfefd.getCerts(_dadac)
	if _dgfd != nil {
		return _dgfd
	}
	var _dgbgb, _cgfcd [][]byte
	if _dfefd.OCSPClient != nil {
		_dgbgb, _dgfd = _dfefd.getOCSPs(_dadac, _dcgef)
		if _dgfd != nil {
			return _dgfd
		}
	}
	if _dfefd.CRLClient != nil {
		_cgfcd, _dgfd = _dfefd.getCRLs(_dadac)
		if _dgfd != nil {
			return _dgfd
		}
	}
	_dfagg := _dfefd._cbbe
	_dbgf, _dgfd := _dfagg.addCerts(_gagfd)
	if _dgfd != nil {
		return _dgfd
	}
	_fecad, _dgfd := _dfagg.addOCSPs(_dgbgb)
	if _dgfd != nil {
		return _dgfd
	}
	_ffee, _dgfd := _dfagg.addCRLs(_cgfcd)
	if _dgfd != nil {
		return _dgfd
	}
	if _bedg != "" {
		_dfagg.VRI[_bedg] = &VRI{Cert: _dbgf, OCSP: _fecad, CRL: _ffee}
	}
	_dfefd._daebc.SetDSS(_dfagg)
	return nil
}

// SetShadingByName sets a shading resource specified by keyName.
func (_aaac *PdfPageResources) SetShadingByName(keyName _agf.PdfObjectName, shadingObj _agf.PdfObject) error {
	if _aaac.Shading == nil {
		_aaac.Shading = _agf.MakeDict()
	}
	_aegdc, _fbcbdc := _agf.GetDict(_aaac.Shading)
	if !_fbcbdc {
		return _agf.ErrTypeError
	}
	_aegdc.Set(keyName, shadingObj)
	return nil
}

// NewPdfColorPattern returns an empty color pattern.
func NewPdfColorPattern() *PdfColorPattern { _bfgff := &PdfColorPattern{}; return _bfgff }

// ToPdfObject returns the PDF representation of the shading pattern.
func (_gggg *PdfShadingPattern) ToPdfObject() _agf.PdfObject {
	_gggg.PdfPattern.ToPdfObject()
	_fadcg := _gggg.getDict()
	if _gggg.Shading != nil {
		_fadcg.Set("\u0053h\u0061\u0064\u0069\u006e\u0067", _gggg.Shading.ToPdfObject())
	}
	if _gggg.Matrix != nil {
		_fadcg.Set("\u004d\u0061\u0074\u0072\u0069\u0078", _gggg.Matrix)
	}
	if _gggg.ExtGState != nil {
		_fadcg.Set("\u0045x\u0074\u0047\u0053\u0074\u0061\u0074e", _gggg.ExtGState)
	}
	return _gggg._efed
}

// GetNumComponents returns the number of color components (1 for grayscale).
func (_aacbg *PdfColorDeviceGray) GetNumComponents() int { return 1 }

// ParserMetadata gets the parser  metadata.
func (_adfa *CompliancePdfReader) ParserMetadata() _agf.ParserMetadata {
	if _adfa._eecd == (_agf.ParserMetadata{}) {
		_adfa._eecd, _ = _adfa._egdga.ParserMetadata()
	}
	return _adfa._eecd
}

// GetPage returns the PdfPage model for the specified page number.
func (_egeeg *PdfReader) GetPage(pageNumber int) (*PdfPage, error) {
	if _egeeg._egdga.GetCrypter() != nil && !_egeeg._egdga.IsAuthenticated() {
		return nil, _b.Errorf("\u0066\u0069\u006c\u0065\u0020\u006e\u0065\u0065\u0064\u0073\u0020\u0074\u006f\u0020\u0062e\u0020d\u0065\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0020\u0066\u0069\u0072\u0073\u0074")
	}
	if len(_egeeg._eddcd) < pageNumber {
		return nil, _gcd.New("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0070\u0061\u0067\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0028\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u0075\u006e\u0074\u0020\u0074o\u006f\u0020\u0073\u0068\u006f\u0072\u0074\u0029")
	}
	_fccfe := pageNumber - 1
	if _fccfe < 0 {
		return nil, _b.Errorf("\u0070\u0061\u0067\u0065\u0020\u006e\u0075\u006d\u0062\u0065r\u0069\u006e\u0067\u0020\u006d\u0075\u0073t\u0020\u0073\u0074\u0061\u0072\u0074\u0020\u0061\u0074\u0020\u0031")
	}
	_bbdeb := _egeeg.PageList[_fccfe]
	return _bbdeb, nil
}
func (_bcfd *DSS) addOCSPs(_bdgg [][]byte) ([]*_agf.PdfObjectStream, error) {
	return _bcfd.add(&_bcfd.OCSPs, _bcfd._ecgfe, _bdgg)
}

// GetDescent returns the Descent of the font `descriptor`.
func (_cfccg *PdfFontDescriptor) GetDescent() (float64, error) {
	return _agf.GetNumberAsFloat(_cfccg.Descent)
}

// GetContainingPdfObject returns the container of the resources object (indirect object).
func (_dfeg *PdfPageResources) GetContainingPdfObject() _agf.PdfObject { return _dfeg._ebga }

// FieldFilterFunc represents a PDF field filtering function. If the function
// returns true, the PDF field is kept, otherwise it is discarded.
type FieldFilterFunc func(*PdfField) bool

// FillWithAppearance populates `form` with values provided by `provider`.
// If not nil, `appGen` is used to generate appearance dictionaries for the
// field annotations, based on the specified settings. Otherwise, appearance
// generation is skipped.
// e.g.: appGen := annotator.FieldAppearance{OnlyIfMissing: true, RegenerateTextFields: true}
// NOTE: In next major version this functionality will be part of Fill. (v4)
func (_bgfff *PdfAcroForm) FillWithAppearance(provider FieldValueProvider, appGen FieldAppearanceGenerator) error {
	_fgae := _bgfff.fill(provider, appGen)
	if _fgae != nil {
		return _fgae
	}
	if _, _eeeff := provider.(FieldImageProvider); _eeeff {
		_fgae = _bgfff.fillImageWithAppearance(provider.(FieldImageProvider), appGen)
	}
	return _fgae
}
func (_ecdc *PdfReader) newPdfAnnotationLinkFromDict(_cgaf *_agf.PdfObjectDictionary) (*PdfAnnotationLink, error) {
	_dbg := PdfAnnotationLink{}
	_dbg.A = _cgaf.Get("\u0041")
	_dbg.Dest = _cgaf.Get("\u0044\u0065\u0073\u0074")
	_dbg.H = _cgaf.Get("\u0048")
	_dbg.PA = _cgaf.Get("\u0050\u0041")
	_dbg.QuadPoints = _cgaf.Get("\u0051\u0075\u0061\u0064\u0050\u006f\u0069\u006e\u0074\u0073")
	_dbg.BS = _cgaf.Get("\u0042\u0053")
	return &_dbg, nil
}

// AnnotFilterFunc represents a PDF annotation filtering function. If the function
// returns true, the annotation is kept, otherwise it is discarded.
type AnnotFilterFunc func(*PdfAnnotation) bool

// NewPdfColorCalGray returns a new CalGray color.
func NewPdfColorCalGray(grayVal float64) *PdfColorCalGray {
	_edecc := PdfColorCalGray(grayVal)
	return &_edecc
}

// PdfShadingPatternType3 is shading patterns that will use a Type 3 shading pattern (Radial).
type PdfShadingPatternType3 struct {
	*PdfPattern
	Shading   *PdfShadingType3
	Matrix    *_agf.PdfObjectArray
	ExtGState _agf.PdfObject
}

// GetRuneMetrics returns the character metrics for the rune.
// A bool flag is returned to indicate whether or not the entry was found.
func (_cafad pdfFontSimple) GetRuneMetrics(r rune) (_aa.CharMetrics, bool) {
	if _cafad._fbgbg != nil {
		_fecb, _cbbg := _cafad._fbgbg.Read(r)
		if _cbbg {
			return _fecb, true
		}
	}
	_agdac := _cafad.Encoder()
	if _agdac == nil {
		_fd.Log.Debug("\u004e\u006f\u0020en\u0063\u006f\u0064\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0066\u006f\u006e\u0074\u0073\u003d\u0025\u0073", _cafad)
		return _aa.CharMetrics{}, false
	}
	_fgfeg, _ddfce := _agdac.RuneToCharcode(r)
	if !_ddfce {
		if r != ' ' {
			_fd.Log.Trace("\u004e\u006f\u0020c\u0068\u0061\u0072\u0063o\u0064\u0065\u0020\u0066\u006f\u0072\u0020r\u0075\u006e\u0065\u003d\u0025\u0076\u0020\u0066\u006f\u006e\u0074\u003d\u0025\u0073", r, _cafad)
		}
		return _aa.CharMetrics{}, false
	}
	_edcge, _fgdag := _cafad.GetCharMetrics(_fgfeg)
	return _edcge, _fgdag
}

// GetNumPages returns the number of pages in the document.
func (_fgedc *PdfReader) GetNumPages() (int, error) {
	if _fgedc._egdga.GetCrypter() != nil && !_fgedc._egdga.IsAuthenticated() {
		return 0, _b.Errorf("\u0066\u0069\u006ce\u0020\u006e\u0065\u0065d\u0020\u0074\u006f\u0020\u0062\u0065\u0020d\u0065\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0020\u0066\u0069\u0072\u0073\u0074")
	}
	return len(_fgedc._eddcd), nil
}

// ToPdfObject implements interface PdfModel.
func (_fbba *PdfAnnotationUnderline) ToPdfObject() _agf.PdfObject {
	_fbba.PdfAnnotation.ToPdfObject()
	_cccb := _fbba._aeee
	_fbfaf := _cccb.PdfObject.(*_agf.PdfObjectDictionary)
	_fbba.PdfAnnotationMarkup.appendToPdfDictionary(_fbfaf)
	_fbfaf.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _agf.MakeName("\u0055n\u0064\u0065\u0072\u006c\u0069\u006ee"))
	_fbfaf.SetIfNotNil("\u0051\u0075\u0061\u0064\u0050\u006f\u0069\u006e\u0074\u0073", _fbba.QuadPoints)
	return _cccb
}
func _ccfac() string { return _fd.Version }

// AlphaMapFunc represents a alpha mapping function: byte -> byte. Can be used for
// thresholding the alpha channel, i.e. setting all alpha values below threshold to transparent.
type AlphaMapFunc func(_gacf byte) byte

// ToPdfObject implements interface PdfModel.
func (_ead *PdfAnnotationPolygon) ToPdfObject() _agf.PdfObject {
	_ead.PdfAnnotation.ToPdfObject()
	_edcd := _ead._aeee
	_bfbc := _edcd.PdfObject.(*_agf.PdfObjectDictionary)
	_ead.PdfAnnotationMarkup.appendToPdfDictionary(_bfbc)
	_bfbc.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _agf.MakeName("\u0050o\u006c\u0079\u0067\u006f\u006e"))
	_bfbc.SetIfNotNil("\u0056\u0065\u0072\u0074\u0069\u0063\u0065\u0073", _ead.Vertices)
	_bfbc.SetIfNotNil("\u004c\u0045", _ead.LE)
	_bfbc.SetIfNotNil("\u0042\u0053", _ead.BS)
	_bfbc.SetIfNotNil("\u0049\u0043", _ead.IC)
	_bfbc.SetIfNotNil("\u0042\u0045", _ead.BE)
	_bfbc.SetIfNotNil("\u0049\u0054", _ead.IT)
	_bfbc.SetIfNotNil("\u004de\u0061\u0073\u0075\u0072\u0065", _ead.Measure)
	return _edcd
}

type modelManager struct {
	_bggfd map[PdfModel]_agf.PdfObject
	_ccbc  map[_agf.PdfObject]PdfModel
}

// ColorFromPdfObjects returns a new PdfColor based on the input slice of color
// components. The slice should contain three PdfObjectFloat elements representing
// the L, A and B components of the color.
func (_fdfa *PdfColorspaceLab) ColorFromPdfObjects(objects []_agf.PdfObject) (PdfColor, error) {
	if len(objects) != 3 {
		return nil, _gcd.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_egc, _agfe := _agf.GetNumbersAsFloat(objects)
	if _agfe != nil {
		return nil, _agfe
	}
	return _fdfa.ColorFromFloats(_egc)
}

// NewPdfAnnotationSound returns a new sound annotation.
func NewPdfAnnotationSound() *PdfAnnotationSound {
	_gge := NewPdfAnnotation()
	_cafe := &PdfAnnotationSound{}
	_cafe.PdfAnnotation = _gge
	_cafe.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_gge.SetContext(_cafe)
	return _cafe
}

// HasShadingByName checks whether a shading is defined by the specified keyName.
func (_ecdaa *PdfPageResources) HasShadingByName(keyName _agf.PdfObjectName) bool {
	_, _gebfg := _ecdaa.GetShadingByName(keyName)
	return _gebfg
}
func (_fdgd *PdfReader) newPdfActionSoundFromDict(_def *_agf.PdfObjectDictionary) (*PdfActionSound, error) {
	return &PdfActionSound{Sound: _def.Get("\u0053\u006f\u0075n\u0064"), Volume: _def.Get("\u0056\u006f\u006c\u0075\u006d\u0065"), Synchronous: _def.Get("S\u0079\u006e\u0063\u0068\u0072\u006f\u006e\u006f\u0075\u0073"), Repeat: _def.Get("\u0052\u0065\u0070\u0065\u0061\u0074"), Mix: _def.Get("\u004d\u0069\u0078")}, nil
}

// GetContainingPdfObject implements interface PdfModel.
func (_gace *PdfFilespec) GetContainingPdfObject() _agf.PdfObject { return _gace._bfdc }

// NewPdfActionGoToR returns a new "go to remote" action.
func NewPdfActionGoToR() *PdfActionGoToR {
	_ea := NewPdfAction()
	_bg := &PdfActionGoToR{}
	_bg.PdfAction = _ea
	_ea.SetContext(_bg)
	return _bg
}
func _gbdgfa(_bfde *_agf.PdfObjectDictionary) (*PdfFieldChoice, error) {
	_dacde := &PdfFieldChoice{}
	_dacde.Opt, _ = _agf.GetArray(_bfde.Get("\u004f\u0070\u0074"))
	_dacde.TI, _ = _agf.GetInt(_bfde.Get("\u0054\u0049"))
	_dacde.I, _ = _agf.GetArray(_bfde.Get("\u0049"))
	return _dacde, nil
}

// B returns the value of the blue component of the color.
func (_bdgd *PdfColorDeviceRGB) B() float64 { return _bdgd[2] }

// HasColorspaceByName checks if the colorspace with the specified name exists in the page resources.
func (_dfbea *PdfPageResources) HasColorspaceByName(keyName _agf.PdfObjectName) bool {
	_abag, _dgedb := _dfbea.GetColorspaces()
	if _dgedb != nil {
		_fd.Log.Debug("\u0045\u0052R\u004f\u0052\u0020\u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0072\u0061\u0063\u0065: \u0025\u0076", _dgedb)
		return false
	}
	if _abag == nil {
		return false
	}
	_, _aacc := _abag.Colorspaces[string(keyName)]
	return _aacc
}
func (_bafaf *pdfFontSimple) getFontEncoding() (_cdebg string, _fdcdc map[_fcg.CharCode]_fcg.GlyphName, _efadc error) {
	_cdebg = "\u0053\u0074a\u006e\u0064\u0061r\u0064\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067"
	if _dabc, _bdeafe := _dadae[_bafaf._fccf]; _bdeafe {
		_cdebg = _dabc
	} else if _bafaf.fontFlags()&_eggb != 0 {
		for _fgecbe, _cdbd := range _dadae {
			if _gc.Contains(_bafaf._fccf, _fgecbe) {
				_cdebg = _cdbd
				break
			}
		}
	}
	if _bafaf.Encoding == nil {
		return _cdebg, nil, nil
	}
	switch _agcag := _bafaf.Encoding.(type) {
	case *_agf.PdfObjectName:
		return string(*_agcag), nil, nil
	case *_agf.PdfObjectDictionary:
		_ggfaa, _ggge := _agf.GetName(_agcag.Get("\u0042\u0061\u0073e\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067"))
		if _ggge {
			_cdebg = _ggfaa.String()
		}
		if _cgbce := _agcag.Get("D\u0069\u0066\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0073"); _cgbce != nil {
			_ffaf, _ddeeb := _agf.GetArray(_cgbce)
			if !_ddeeb {
				_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0042a\u0064\u0020\u0066on\u0074\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0064\u0069\u0063\u0074\u003d\u0025\u002b\u0076\u0020\u0044\u0069f\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0073=\u0025\u0054", _agcag, _agcag.Get("D\u0069\u0066\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0073"))
				return "", nil, _agf.ErrTypeError
			}
			_fdcdc, _efadc = _fcg.FromFontDifferences(_ffaf)
		}
		return _cdebg, _fdcdc, _efadc
	default:
		_fd.Log.Debug("\u0045\u0052\u0052O\u0052\u003a\u0020\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006e\u0061\u006d\u0065\u0020\u006f\u0072\u0020\u0064\u0069\u0063t\u0020\u0028\u0025\u0054\u0029\u0020\u0025\u0073", _bafaf.Encoding, _bafaf.Encoding)
		return "", nil, _agf.ErrTypeError
	}
}
func (_fcfagfg *XObjectImage) getParamsDict() *_agf.PdfObjectDictionary {
	_dgegd := _agf.MakeDict()
	_dgegd.Set("\u0057\u0069\u0064t\u0068", _agf.MakeInteger(*_fcfagfg.Width))
	_dgegd.Set("\u0048\u0065\u0069\u0067\u0068\u0074", _agf.MakeInteger(*_fcfagfg.Height))
	_dgegd.Set("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073", _agf.MakeInteger(int64(_fcfagfg.ColorSpace.GetNumComponents())))
	_dgegd.Set("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074", _agf.MakeInteger(*_fcfagfg.BitsPerComponent))
	return _dgegd
}

// Evaluate runs the function on the passed in slice and returns the results.
func (_egaad *PdfFunctionType3) Evaluate(x []float64) ([]float64, error) {
	if len(x) != 1 {
		_fd.Log.Error("\u004f\u006e\u006c\u0079 o\u006e\u0065\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0061\u006c\u006c\u006f\u0077e\u0064")
		return nil, _gcd.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	return nil, _gcd.New("\u006e\u006f\u0074\u0020im\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074")
}

// PdfFieldText represents a text field where user can enter text.
type PdfFieldText struct {
	*PdfField
	DA     *_agf.PdfObjectString
	Q      *_agf.PdfObjectInteger
	DS     *_agf.PdfObjectString
	RV     _agf.PdfObject
	MaxLen *_agf.PdfObjectInteger
}

func _dbde(_addf []byte) []byte {
	const _cabd = 52845
	const _gfeb = 22719
	_eedff := 55665
	for _, _beegd := range _addf[:4] {
		_eedff = (int(_beegd)+_eedff)*_cabd + _gfeb
	}
	_fcaca := make([]byte, len(_addf)-4)
	for _bfcfb, _egfd := range _addf[4:] {
		_fcaca[_bfcfb] = byte(int(_egfd) ^ _eedff>>8)
		_eedff = (int(_egfd)+_eedff)*_cabd + _gfeb
	}
	return _fcaca
}

// IsPush returns true if the button field represents a push button, false otherwise.
func (_dggb *PdfFieldButton) IsPush() bool { return _dggb.GetType() == ButtonTypePush }

// PdfAnnotationMarkup represents additional fields for mark-up annotations.
// (Section 12.5.6.2 p. 399).
type PdfAnnotationMarkup struct {
	T            _agf.PdfObject
	Popup        *PdfAnnotationPopup
	CA           _agf.PdfObject
	RC           _agf.PdfObject
	CreationDate _agf.PdfObject
	IRT          _agf.PdfObject
	Subj         _agf.PdfObject
	RT           _agf.PdfObject
	IT           _agf.PdfObject
	ExData       _agf.PdfObject
}

func _cagaf(_dggdd _agf.PdfObject) (*_agf.PdfObjectDictionary, *fontCommon, error) {
	_eddgb := &fontCommon{}
	if _dbgd, _ccfc := _dggdd.(*_agf.PdfIndirectObject); _ccfc {
		_eddgb._gcdfc = _dbgd.ObjectNumber
	}
	_cbad, _dfee := _agf.GetDict(_dggdd)
	if !_dfee {
		_fd.Log.Debug("\u0045\u0052\u0052O\u0052\u003a\u0020\u0046\u006f\u006e\u0074\u0020\u006e\u006f\u0074\u0020\u0067\u0069\u0076\u0065\u006e\u0020\u0062\u0079\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069\u006fn\u0061\u0072\u0079\u0020\u0028\u0025\u0054\u0029", _dggdd)
		return nil, nil, ErrFontNotSupported
	}
	_ceaa, _dfee := _agf.GetNameVal(_cbad.Get("\u0054\u0079\u0070\u0065"))
	if !_dfee {
		_fd.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u0046o\u006e\u0074\u0020\u0049\u006ec\u006f\u006d\u0070\u0061\u0074\u0069\u0062\u0069\u006c\u0069\u0074\u0079\u002e\u0020\u0054\u0079\u0070\u0065\u0020\u0028\u0052\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0029\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067")
		return nil, nil, ErrRequiredAttributeMissing
	}
	if _ceaa != "\u0046\u006f\u006e\u0074" {
		_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052:\u0020\u0046\u006f\u006e\u0074\u0020\u0049\u006e\u0063\u006f\u006d\u0070\u0061t\u0069\u0062\u0069\u006c\u0069\u0074\u0079\u002e\u0020\u0054\u0079\u0070\u0065\u003d\u0025\u0071\u002e\u0020\u0053\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0025\u0071.", _ceaa, "\u0046\u006f\u006e\u0074")
		return nil, nil, _agf.ErrTypeError
	}
	_dfcdf, _dfee := _agf.GetNameVal(_cbad.Get("\u0053u\u0062\u0074\u0079\u0070\u0065"))
	if !_dfee {
		_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020F\u006f\u006e\u0074 \u0049\u006e\u0063o\u006d\u0070a\u0074\u0069\u0062\u0069\u006c\u0069t\u0079. \u0053\u0075\u0062\u0074\u0079\u0070\u0065\u0020\u0028\u0052\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0029\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067")
		return nil, nil, ErrRequiredAttributeMissing
	}
	_eddgb._bcbfd = _dfcdf
	_aafg, _dfee := _agf.GetNameVal(_cbad.Get("\u004e\u0061\u006d\u0065"))
	if _dfee {
		_eddgb._afbeb = _aafg
	}
	_bggd := _cbad.Get("\u0054o\u0055\u006e\u0069\u0063\u006f\u0064e")
	if _bggd != nil {
		_eddgb._ebabcd = _agf.TraceToDirectObject(_bggd)
		_edfe, _aade := _eaeg(_eddgb._ebabcd, _eddgb)
		if _aade != nil {
			return _cbad, _eddgb, _aade
		}
		_eddgb._egfbf = _edfe
	} else if _dfcdf == "\u0043\u0049\u0044F\u006f\u006e\u0074\u0054\u0079\u0070\u0065\u0030" || _dfcdf == "\u0043\u0049\u0044F\u006f\u006e\u0074\u0054\u0079\u0070\u0065\u0032" {
		_dfea, _gaedc := _ce.NewCIDSystemInfo(_cbad.Get("\u0043\u0049\u0044\u0053\u0079\u0073\u0074\u0065\u006d\u0049\u006e\u0066\u006f"))
		if _gaedc != nil {
			return _cbad, _eddgb, _gaedc
		}
		_ffgf := _b.Sprintf("\u0025\u0073\u002d\u0025\u0073\u002d\u0055\u0043\u0053\u0032", _dfea.Registry, _dfea.Ordering)
		if _ce.IsPredefinedCMap(_ffgf) {
			_eddgb._egfbf, _gaedc = _ce.LoadPredefinedCMap(_ffgf)
			if _gaedc != nil {
				_fd.Log.Debug("\u0057\u0041\u0052\u004e\u003a\u0020\u0063o\u0075\u006c\u0064 \u006e\u006f\u0074\u0020l\u006f\u0061\u0064\u0020\u0070\u0072\u0065\u0064\u0065\u0066\u0069\u006e\u0065\u0064\u0020\u0043\u004d\u0061\u0070\u0020\u0025\u0073\u003a\u0020\u0025\u0076", _ffgf, _gaedc)
			}
		}
	}
	_fcdc := _cbad.Get("\u0046\u006f\u006e\u0074\u0044\u0065\u0073\u0063\u0072i\u0070\u0074\u006f\u0072")
	if _fcdc != nil {
		_gfbe, _faef := _gefdc(_fcdc)
		if _faef != nil {
			_fd.Log.Debug("\u0045\u0052\u0052OR\u003a\u0020\u0042\u0061\u0064\u0020\u0066\u006f\u006et\u0020d\u0065s\u0063r\u0069\u0070\u0074\u006f\u0072\u002e\u0020\u0065\u0072\u0072\u003d\u0025\u0076", _faef)
			return _cbad, _eddgb, _faef
		}
		_eddgb._dcfcb = _gfbe
	}
	if _dfcdf != "\u0054\u0079\u0070e\u0033" {
		_dgdcc, _fceed := _agf.GetNameVal(_cbad.Get("\u0042\u0061\u0073\u0065\u0046\u006f\u006e\u0074"))
		if !_fceed {
			_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u006f\u006et\u0020\u0049\u006ec\u006f\u006d\u0070\u0061\u0074\u0069\u0062\u0069\u006c\u0069t\u0079\u002e\u0020\u0042\u0061se\u0046\u006f\u006e\u0074\u0020\u0028\u0052\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0029\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067")
			return _cbad, _eddgb, ErrRequiredAttributeMissing
		}
		_eddgb._fccf = _dgdcc
	}
	return _cbad, _eddgb, nil
}
func (_bgd *PdfReader) newPdfAnnotationWidgetFromDict(_abcc *_agf.PdfObjectDictionary) (*PdfAnnotationWidget, error) {
	_fdcc := PdfAnnotationWidget{}
	_fdcc.H = _abcc.Get("\u0048")
	_fdcc.MK = _abcc.Get("\u004d\u004b")
	_fdcc.A = _abcc.Get("\u0041")
	_fdcc.AA = _abcc.Get("\u0041\u0041")
	_fdcc.BS = _abcc.Get("\u0042\u0053")
	_fdcc.Parent = _abcc.Get("\u0050\u0061\u0072\u0065\u006e\u0074")
	return &_fdcc, nil
}

// GetContainingPdfObject returns the page as a dictionary within an PdfIndirectObject.
func (_eddfg *PdfPage) GetContainingPdfObject() _agf.PdfObject { return _eddfg._edegf }

// PdfAnnotationText represents Text annotations.
// (Section 12.5.6.4 p. 402).
type PdfAnnotationText struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	Open       _agf.PdfObject
	Name       _agf.PdfObject
	State      _agf.PdfObject
	StateModel _agf.PdfObject
}

// NewPdfActionRendition returns a new "rendition" action.
func NewPdfActionRendition() *PdfActionRendition {
	_cbb := NewPdfAction()
	_gcb := &PdfActionRendition{}
	_gcb.PdfAction = _cbb
	_cbb.SetContext(_gcb)
	return _gcb
}

var _eddb = map[string]struct{}{"\u0057i\u006eA\u006e\u0073\u0069\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067": {}, "\u004d\u0061c\u0052\u006f\u006da\u006e\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067": {}, "\u004d\u0061\u0063\u0045\u0078\u0070\u0065\u0072\u0074\u0045\u006e\u0063o\u0064\u0069\u006e\u0067": {}, "\u0053\u0074a\u006e\u0064\u0061r\u0064\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067": {}}

// PdfColorPatternType3 represents a color shading pattern type 3 (Radial).
type PdfColorPatternType3 struct {
	Color       PdfColor
	PatternName _agf.PdfObjectName
}

// PdfAction represents an action in PDF (section 12.6 p. 412).
type PdfAction struct {
	_ae  PdfModel
	Type _agf.PdfObject
	S    _agf.PdfObject
	Next _agf.PdfObject
	_caf *_agf.PdfIndirectObject
}

func (_beeec *Image) samplesAddPadding(_ecdb []uint32) []uint32 {
	_caafc := _ged.BytesPerLine(int(_beeec.Width), int(_beeec.BitsPerComponent), _beeec.ColorComponents) * (8 / int(_beeec.BitsPerComponent))
	_ecbc := _caafc * int(_beeec.Height)
	if len(_ecdb) == _ecbc {
		return _ecdb
	}
	_aeegg := make([]uint32, _ecbc)
	_eagd := int(_beeec.Width) * _beeec.ColorComponents
	for _fbdc := 0; _fbdc < int(_beeec.Height); _fbdc++ {
		_aaaec := _fbdc * int(_beeec.Width)
		_bffdee := _fbdc * _caafc
		for _fdefa := 0; _fdefa < _eagd; _fdefa++ {
			_aeegg[_bffdee+_fdefa] = _ecdb[_aaaec+_fdefa]
		}
	}
	return _aeegg
}

// NewPdfColorPatternType3 returns an empty color shading pattern type 3 (Radial).
func NewPdfColorPatternType3() *PdfColorPatternType3 {
	_fbefc := &PdfColorPatternType3{}
	return _fbefc
}

// SetContext set the sub annotation (context).
func (_dgdfbe *PdfShading) SetContext(ctx PdfModel) { _dgdfbe._gefcd = ctx }

// ToImage converts an object to an Image which can be transformed or saved out.
// The image data is decoded and the Image returned.
func (_edba *XObjectImage) ToImage() (*Image, error) {
	_gfdgb := &Image{}
	if _edba.Height == nil {
		return nil, _gcd.New("\u0068e\u0069\u0067\u0068\u0074\u0020\u0061\u0074\u0074\u0072\u0069\u0062u\u0074\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067")
	}
	_gfdgb.Height = *_edba.Height
	if _edba.Width == nil {
		return nil, _gcd.New("\u0077\u0069\u0064th\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067")
	}
	_gfdgb.Width = *_edba.Width
	if _edba.BitsPerComponent == nil {
		switch _edba.Filter.(type) {
		case *_agf.CCITTFaxEncoder, *_agf.JBIG2Encoder:
			_gfdgb.BitsPerComponent = 1
		case *_agf.LZWEncoder, *_agf.RunLengthEncoder:
			_gfdgb.BitsPerComponent = 8
		default:
			return nil, _gcd.New("\u0062\u0069\u0074\u0073\u0020\u0070\u0065\u0072\u0020\u0063\u006fm\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u006d\u0069\u0073s\u0069\u006e\u0067")
		}
	} else {
		_gfdgb.BitsPerComponent = *_edba.BitsPerComponent
	}
	_gfdgb.ColorComponents = _edba.ColorSpace.GetNumComponents()
	_edba._gdggg.Set("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073", _agf.MakeInteger(int64(_gfdgb.ColorComponents)))
	_caec, _baca := _agf.DecodeStream(_edba._gdggg)
	if _baca != nil {
		return nil, _baca
	}
	_gfdgb.Data = _caec
	if _edba.Decode != nil {
		_aaebf, _cbcc := _edba.Decode.(*_agf.PdfObjectArray)
		if !_cbcc {
			_fd.Log.Debug("I\u006e\u0076\u0061\u006cid\u0020D\u0065\u0063\u006f\u0064\u0065 \u006f\u0062\u006a\u0065\u0063\u0074")
			return nil, _gcd.New("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0074\u0079\u0070\u0065")
		}
		_fabff, _ecfed := _aaebf.ToFloat64Array()
		if _ecfed != nil {
			return nil, _ecfed
		}
		_gfdgb._abacg = _fabff
	}
	return _gfdgb, nil
}

// PdfAnnotationStamp represents Stamp annotations.
// (Section 12.5.6.12).
type PdfAnnotationStamp struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	Name _agf.PdfObject
}

// BaseFont returns the font's "BaseFont" field.
func (_fcgdg *PdfFont) BaseFont() string { return _fcgdg.baseFields()._fccf }

// Fill populates `form` with values provided by `provider`.
func (_abacd *PdfAcroForm) Fill(provider FieldValueProvider) error { return _abacd.fill(provider, nil) }
func _gcedb(_agdbf []byte) (_adbfd, _fgdad string, _adfeg error) {
	_fd.Log.Trace("g\u0065\u0074\u0041\u0053CI\u0049S\u0065\u0063\u0074\u0069\u006fn\u0073\u003a\u0020\u0025\u0064\u0020", len(_agdbf))
	_fbeg := _cgdgc.FindIndex(_agdbf)
	if _fbeg == nil {
		_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0067\u0065\u0074\u0041\u0053\u0043\u0049\u0049\u0053\u0065\u0063\u0074\u0069o\u006e\u0073\u002e\u0020\u004e\u006f\u0020d\u0069\u0063\u0074\u002e")
		return "", "", _agf.ErrTypeError
	}
	_eagef := _fbeg[1]
	_dabcf := _gc.Index(string(_agdbf[_eagef:]), _ccdbg)
	if _dabcf < 0 {
		_adbfd = string(_agdbf[_eagef:])
		return _adbfd, "", nil
	}
	_ddda := _eagef + _dabcf
	_adbfd = string(_agdbf[_eagef:_ddda])
	_bacd := _ddda
	_dabcf = _gc.Index(string(_agdbf[_bacd:]), _fadf)
	if _dabcf < 0 {
		_fd.Log.Debug("\u0045\u0052\u0052O\u0052\u003a\u0020\u0067e\u0074\u0041\u0053\u0043\u0049\u0049\u0053e\u0063\u0074\u0069\u006f\u006e\u0073\u002e\u0020\u0065\u0072\u0072\u003d\u0025\u0076", _adfeg)
		return "", "", _agf.ErrTypeError
	}
	_feced := _bacd + _dabcf
	_fgdad = string(_agdbf[_bacd:_feced])
	return _adbfd, _fgdad, nil
}

// Outline represents a PDF outline dictionary (Table 152 - p. 376).
// Currently, the Outline object can only be used to construct PDF outlines.
type Outline struct {
	Entries []*OutlineItem `json:"entries,omitempty"`
}

// ToInteger convert to an integer format.
func (_ggbg *PdfColorDeviceGray) ToInteger(bits int) uint32 {
	_ffe := _afb.Pow(2, float64(bits)) - 1
	return uint32(_ffe * _ggbg.Val())
}
func (_ggga *PdfReader) newPdfOutlineItemFromIndirectObject(_ccef *_agf.PdfIndirectObject) (*PdfOutlineItem, error) {
	_gcbddd, _fbdgb := _ccef.PdfObject.(*_agf.PdfObjectDictionary)
	if !_fbdgb {
		return nil, _b.Errorf("\u006f\u0075\u0074l\u0069\u006e\u0065\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u006eo\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079")
	}
	_dagf := NewPdfOutlineItem()
	_eagc := _gcbddd.Get("\u0054\u0069\u0074l\u0065")
	if _eagc == nil {
		return nil, _b.Errorf("\u006d\u0069\u0073s\u0069\u006e\u0067\u0020\u0054\u0069\u0074\u006c\u0065\u0020\u0066\u0072\u006f\u006d\u0020\u004f\u0075\u0074\u006c\u0069\u006e\u0065\u0020\u0049\u0074\u0065\u006d\u0020\u0028r\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0029")
	}
	_aeffe, _fbebc := _agf.GetString(_eagc)
	if !_fbebc {
		return nil, _b.Errorf("\u0074\u0069\u0074le\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0028\u0025\u0054\u0029", _eagc)
	}
	_dagf.Title = _aeffe
	if _bfcc := _gcbddd.Get("\u0043\u006f\u0075n\u0074"); _bfcc != nil {
		_gdae, _cgbe := _bfcc.(*_agf.PdfObjectInteger)
		if !_cgbe {
			return nil, _b.Errorf("\u0063o\u0075\u006e\u0074\u0020n\u006f\u0074\u0020\u0061\u006e \u0069n\u0074e\u0067\u0065\u0072\u0020\u0028\u0025\u0054)", _bfcc)
		}
		_gedcb := int64(*_gdae)
		_dagf.Count = &_gedcb
	}
	if _gegb := _gcbddd.Get("\u0044\u0065\u0073\u0074"); _gegb != nil {
		_dagf.Dest = _agf.ResolveReference(_gegb)
		if !_ggga._ccage {
			_cbcbg := _ggga.traverseObjectData(_dagf.Dest)
			if _cbcbg != nil {
				return nil, _cbcbg
			}
		}
	}
	if _cgaag := _gcbddd.Get("\u0041"); _cgaag != nil {
		_dagf.A = _agf.ResolveReference(_cgaag)
		if !_ggga._ccage {
			_dgaba := _ggga.traverseObjectData(_dagf.A)
			if _dgaba != nil {
				return nil, _dgaba
			}
		}
	}
	if _adffb := _gcbddd.Get("\u0053\u0045"); _adffb != nil {
		_dagf.SE = nil
	}
	if _aedeb := _gcbddd.Get("\u0043"); _aedeb != nil {
		_dagf.C = _agf.ResolveReference(_aedeb)
	}
	if _dbeb := _gcbddd.Get("\u0046"); _dbeb != nil {
		_dagf.F = _agf.ResolveReference(_dbeb)
	}
	return _dagf, nil
}

// ImageToRGB converts Lab colorspace image to RGB and returns the result.
func (_fdda *PdfColorspaceLab) ImageToRGB(img Image) (Image, error) {
	_fdbc := func(_gbeef float64) float64 {
		if _gbeef >= 6.0/29 {
			return _gbeef * _gbeef * _gbeef
		}
		return 108.0 / 841 * (_gbeef - 4.0/29.0)
	}
	_acba := img._abacg
	if len(_acba) != 6 {
		_fd.Log.Trace("\u0049\u006d\u0061\u0067\u0065\u0020\u002d\u0020\u004c\u0061\u0062\u0020\u0044e\u0063\u006f\u0064\u0065\u0020\u0072\u0061\u006e\u0067e\u0020\u0021\u003d\u0020\u0036\u002e\u002e\u002e\u0020\u0075\u0073\u0065\u0020\u005b0\u0020\u0031\u0030\u0030\u0020\u0061\u006d\u0069\u006e\u0020\u0061\u006d\u0061\u0078\u0020\u0062\u006d\u0069\u006e\u0020\u0062\u006d\u0061\u0078\u005d\u0020\u0064\u0065\u0066\u0061u\u006c\u0074\u0020\u0064\u0065\u0063\u006f\u0064\u0065 \u0061\u0072r\u0061\u0079")
		_acba = _fdda.DecodeArray()
	}
	_fbae := _db.NewReader(img.getBase())
	_dcdd := _ged.NewImageBase(int(img.Width), int(img.Height), int(img.BitsPerComponent), 3, nil, img._gdga, img._abacg)
	_ebbe := _db.NewWriter(_dcdd)
	_gdbe := _afb.Pow(2, float64(img.BitsPerComponent)) - 1
	_fggc := make([]uint32, 3)
	var (
		_beeg                                              error
		Ls, As, Bs, L, M, N, X, Y, Z, _dgef, _bdfa, _cgbgc float64
	)
	for {
		_beeg = _fbae.ReadSamples(_fggc)
		if _beeg == _cf.EOF {
			break
		} else if _beeg != nil {
			return img, _beeg
		}
		Ls = float64(_fggc[0]) / _gdbe
		As = float64(_fggc[1]) / _gdbe
		Bs = float64(_fggc[2]) / _gdbe
		Ls = _ged.LinearInterpolate(Ls, 0.0, 1.0, _acba[0], _acba[1])
		As = _ged.LinearInterpolate(As, 0.0, 1.0, _acba[2], _acba[3])
		Bs = _ged.LinearInterpolate(Bs, 0.0, 1.0, _acba[4], _acba[5])
		L = (Ls+16)/116 + As/500
		M = (Ls + 16) / 116
		N = (Ls+16)/116 - Bs/200
		X = _fdda.WhitePoint[0] * _fdbc(L)
		Y = _fdda.WhitePoint[1] * _fdbc(M)
		Z = _fdda.WhitePoint[2] * _fdbc(N)
		_dgef = 3.240479*X + -1.537150*Y + -0.498535*Z
		_bdfa = -0.969256*X + 1.875992*Y + 0.041556*Z
		_cgbgc = 0.055648*X + -0.204043*Y + 1.057311*Z
		_dgef = _afb.Min(_afb.Max(_dgef, 0), 1.0)
		_bdfa = _afb.Min(_afb.Max(_bdfa, 0), 1.0)
		_cgbgc = _afb.Min(_afb.Max(_cgbgc, 0), 1.0)
		_fggc[0] = uint32(_dgef * _gdbe)
		_fggc[1] = uint32(_bdfa * _gdbe)
		_fggc[2] = uint32(_cgbgc * _gdbe)
		if _beeg = _ebbe.WriteSamples(_fggc); _beeg != nil {
			return img, _beeg
		}
	}
	return _ddgg(&_dcdd), nil
}
func (_afgae *PdfWriter) writeObjects() {
	_fd.Log.Trace("\u0057\u0072\u0069\u0074\u0069\u006e\u0067\u0020\u0025d\u0020\u006f\u0062\u006a", len(_afgae._dgbd))
	_afgae._ddcg = make(map[int]crossReference)
	_afgae._ddcg[0] = crossReference{Type: 0, ObjectNumber: 0, Generation: 0xFFFF}
	if _afgae._gcec.ObjectMap != nil {
		for _eeedf, _dgcdbe := range _afgae._gcec.ObjectMap {
			if _eeedf == 0 {
				continue
			}
			if _dgcdbe.XType == _agf.XrefTypeObjectStream {
				_befcgc := crossReference{Type: 2, ObjectNumber: _dgcdbe.OsObjNumber, Index: _dgcdbe.OsObjIndex}
				_afgae._ddcg[_eeedf] = _befcgc
			}
			if _dgcdbe.XType == _agf.XrefTypeTableEntry {
				_cefcf := crossReference{Type: 1, ObjectNumber: _dgcdbe.ObjectNumber, Offset: _dgcdbe.Offset}
				_afgae._ddcg[_eeedf] = _cefcf
			}
		}
	}
}
func _bcef(_fagdf *_agf.PdfIndirectObject) (*PdfOutline, error) {
	_gdbag, _beaa := _fagdf.PdfObject.(*_agf.PdfObjectDictionary)
	if !_beaa {
		return nil, _b.Errorf("\u006f\u0075\u0074l\u0069\u006e\u0065\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u006eo\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079")
	}
	_adce := NewPdfOutline()
	if _gbea := _gdbag.Get("\u0054\u0079\u0070\u0065"); _gbea != nil {
		_gfeda, _aacef := _gbea.(*_agf.PdfObjectName)
		if _aacef {
			if *_gfeda != "\u004f\u0075\u0074\u006c\u0069\u006e\u0065\u0073" {
				_fd.Log.Debug("E\u0052\u0052\u004f\u0052\u0020\u0054y\u0070\u0065\u0020\u0021\u003d\u0020\u004f\u0075\u0074l\u0069\u006e\u0065s\u0020(\u0025\u0073\u0029", *_gfeda)
			}
		}
	}
	if _bffc := _gdbag.Get("\u0043\u006f\u0075n\u0074"); _bffc != nil {
		_deafa, _fbbfc := _agf.GetNumberAsInt64(_bffc)
		if _fbbfc != nil {
			return nil, _fbbfc
		}
		_adce.Count = &_deafa
	}
	return _adce, nil
}

// ToGoTime returns the date in time.Time format.
func (_fbfcga PdfDate) ToGoTime() _e.Time {
	_adef := int(_fbfcga._gddba*60*60 + _fbfcga._ebcf*60)
	switch _fbfcga._dfead {
	case '-':
		_adef = -_adef
	case 'Z':
		_adef = 0
	}
	_cffaf := _b.Sprintf("\u0055\u0054\u0043\u0025\u0063\u0025\u002e\u0032\u0064\u0025\u002e\u0032\u0064", _fbfcga._dfead, _fbfcga._gddba, _fbfcga._ebcf)
	_ecdgf := _e.FixedZone(_cffaf, _adef)
	return _e.Date(int(_fbfcga._dcggc), _e.Month(_fbfcga._fccbd), int(_fbfcga._ggca), int(_fbfcga._cfgfg), int(_fbfcga._dgaab), int(_fbfcga._gdebc), 0, _ecdgf)
}

// PdfShadingType2 is an Axial shading.
type PdfShadingType2 struct {
	*PdfShading
	Coords   *_agf.PdfObjectArray
	Domain   *_agf.PdfObjectArray
	Function []PdfFunction
	Extend   *_agf.PdfObjectArray
}

// GetContentStream returns the pattern cell's content stream
func (_afbea *PdfTilingPattern) GetContentStream() ([]byte, error) {
	_aabff, _, _bgddg := _afbea.GetContentStreamWithEncoder()
	return _aabff, _bgddg
}
func (_cebea *PdfReader) lookupPageByObject(_bdca _agf.PdfObject) (*PdfPage, error) {
	return nil, _gcd.New("\u0070\u0061\u0067\u0065\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064")
}

// AddAnnotation appends `annot` to the list of page annotations.
func (_dfgfe *PdfPage) AddAnnotation(annot *PdfAnnotation) {
	if _dfgfe._abffa == nil {
		_dfgfe.GetAnnotations()
	}
	_dfgfe._abffa = append(_dfgfe._abffa, annot)
}

// PdfShadingType6 is a Coons patch mesh.
type PdfShadingType6 struct {
	*PdfShading
	BitsPerCoordinate *_agf.PdfObjectInteger
	BitsPerComponent  *_agf.PdfObjectInteger
	BitsPerFlag       *_agf.PdfObjectInteger
	Decode            *_agf.PdfObjectArray
	Function          []PdfFunction
}

// ColorToRGB converts a CMYK32 color to an RGB color.
func (_adbf *PdfColorspaceDeviceCMYK) ColorToRGB(color PdfColor) (PdfColor, error) {
	_aeaa, _ccga := color.(*PdfColorDeviceCMYK)
	if !_ccga {
		_fd.Log.Debug("I\u006e\u0070\u0075\u0074\u0020\u0063o\u006c\u006f\u0072\u0020\u006e\u006f\u0074\u0020\u0064e\u0076\u0069\u0063e\u0020c\u006d\u0079\u006b")
		return nil, _gcd.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	_aceg := _aeaa.C()
	_dbad := _aeaa.M()
	_gbfef := _aeaa.Y()
	_afaa := _aeaa.K()
	_aceg = _aceg*(1-_afaa) + _afaa
	_dbad = _dbad*(1-_afaa) + _afaa
	_gbfef = _gbfef*(1-_afaa) + _afaa
	_aae := 1 - _aceg
	_abfa := 1 - _dbad
	_cacdd := 1 - _gbfef
	return NewPdfColorDeviceRGB(_aae, _abfa, _cacdd), nil
}

// WatermarkImageOptions contains options for configuring the watermark process.
type WatermarkImageOptions struct {
	Alpha               float64
	FitToWidth          bool
	PreserveAspectRatio bool
}

// SetAction sets the PDF action for the annotation link.
func (_acbf *PdfAnnotationLink) SetAction(action *PdfAction) {
	_acbf._bbdg = action
	if action == nil {
		_acbf.A = nil
	}
}

// ColorFromPdfObjects returns a new PdfColor based on the input slice of color
// components. The slice should contain a single PdfObjectFloat element in
// range 0-1.
func (_agebg *PdfColorspaceCalGray) ColorFromPdfObjects(objects []_agf.PdfObject) (PdfColor, error) {
	if len(objects) != 1 {
		return nil, _gcd.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_bdaab, _gdgba := _agf.GetNumbersAsFloat(objects)
	if _gdgba != nil {
		return nil, _gdgba
	}
	return _agebg.ColorFromFloats(_bdaab)
}

// NewOutlineBookmark returns an initialized PdfOutlineItem for a given bookmark title and page.
func NewOutlineBookmark(title string, page *_agf.PdfIndirectObject) *PdfOutlineItem {
	_cebff := PdfOutlineItem{}
	_cebff._cgaaa = &_cebff
	_cebff.Title = _agf.MakeString(title)
	_gbbgb := _agf.MakeArray()
	_gbbgb.Append(page)
	_gbbgb.Append(_agf.MakeName("\u0046\u0069\u0074"))
	_cebff.Dest = _gbbgb
	return &_cebff
}

// PdfColorspaceCalRGB stores A, B, C components
type PdfColorspaceCalRGB struct {
	WhitePoint []float64
	BlackPoint []float64
	Gamma      []float64
	Matrix     []float64
	_bccff     *_agf.PdfObjectDictionary
	_febbc     *_agf.PdfIndirectObject
}

// XObjectType represents the type of an XObject.
type XObjectType int

// ToPdfObject implements interface PdfModel.
func (_aaadd *PdfAnnotation3D) ToPdfObject() _agf.PdfObject {
	_aaadd.PdfAnnotation.ToPdfObject()
	_ega := _aaadd._aeee
	_accf := _ega.PdfObject.(*_agf.PdfObjectDictionary)
	_accf.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _agf.MakeName("\u0033\u0044"))
	_accf.SetIfNotNil("\u0033\u0044\u0044", _aaadd.T3DD)
	_accf.SetIfNotNil("\u0033\u0044\u0056", _aaadd.T3DV)
	_accf.SetIfNotNil("\u0033\u0044\u0041", _aaadd.T3DA)
	_accf.SetIfNotNil("\u0033\u0044\u0049", _aaadd.T3DI)
	_accf.SetIfNotNil("\u0033\u0044\u0042", _aaadd.T3DB)
	return _ega
}

// ToPdfObject implements interface PdfModel.
func (_bbdfb *PdfAnnotationHighlight) ToPdfObject() _agf.PdfObject {
	_bbdfb.PdfAnnotation.ToPdfObject()
	_caac := _bbdfb._aeee
	_gee := _caac.PdfObject.(*_agf.PdfObjectDictionary)
	_bbdfb.PdfAnnotationMarkup.appendToPdfDictionary(_gee)
	_gee.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _agf.MakeName("\u0048i\u0067\u0068\u006c\u0069\u0067\u0068t"))
	_gee.SetIfNotNil("\u0051\u0075\u0061\u0064\u0050\u006f\u0069\u006e\u0074\u0073", _bbdfb.QuadPoints)
	return _caac
}
func (_acce *LTV) getOCSPs(_fcfad []*_ed.Certificate, _abcag map[string]*_ed.Certificate) ([][]byte, error) {
	_gafd := make([][]byte, 0, len(_fcfad))
	for _, _efebe := range _fcfad {
		for _, _cafef := range _efebe.OCSPServer {
			if _acce.CertClient.IsCA(_efebe) {
				continue
			}
			_dafbb, _abbaf := _abcag[_efebe.Issuer.CommonName]
			if !_abbaf {
				_fd.Log.Debug("\u0057\u0041\u0052\u004e:\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067 \u004f\u0043\u0053\u0050\u0020\u0072\u0065\u0071\u0075\u0065\u0073\u0074\u003a\u0020\u0069\u0073\u0073\u0075e\u0072\u0020\u0063\u0065\u0072t\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064")
				continue
			}
			_, _dacda, _eccdc := _acce.OCSPClient.MakeRequest(_cafef, _efebe, _dafbb)
			if _eccdc != nil {
				_fd.Log.Debug("\u0057\u0041\u0052\u004e:\u0020\u004f\u0043\u0053\u0050\u0020\u0072\u0065\u0071\u0075e\u0073t\u0020\u0065\u0072\u0072\u006f\u0072\u003a \u0025\u0076", _eccdc)
				continue
			}
			_gafd = append(_gafd, _dacda)
		}
	}
	return _gafd, nil
}

// GetContainingPdfObject implements interface PdfModel.
func (_gbcc *PdfAnnotation) GetContainingPdfObject() _agf.PdfObject { return _gbcc._aeee }

var (
	_cgdgc = _aga.MustCompile("\u005cd\u002b\u0020\u0064\u0069c\u0074\u005c\u0073\u002b\u0028d\u0075p\u005cs\u002b\u0029\u003f\u0062\u0065\u0067\u0069n")
	_feaf  = _aga.MustCompile("\u005e\u005cs\u002a\u002f\u0028\u005c\u0053\u002b\u003f\u0029\u005c\u0073\u002b\u0028\u002e\u002b\u003f\u0029\u005c\u0073\u002b\u0064\u0065\u0066\\s\u002a\u0024")
	_ceaaa = _aga.MustCompile("\u005e\u005c\u0073*\u0064\u0075\u0070\u005c\u0073\u002b\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002a\u002f\u0028\u005c\u0077\u002b\u003f\u0029\u0028\u003f\u003a\u005c\u002e\u005c\u0064\u002b)\u003f\u005c\u0073\u002b\u0070\u0075\u0074\u0024")
	_ccdbg = "\u002f\u0045\u006e\u0063od\u0069\u006e\u0067\u0020\u0032\u0035\u0036\u0020\u0061\u0072\u0072\u0061\u0079"
	_fadf  = "\u0072\u0065\u0061d\u006f\u006e\u006c\u0079\u0020\u0064\u0065\u0066"
	_becdd = "\u0063\u0075\u0072\u0072\u0065\u006e\u0074\u0066\u0069\u006c\u0065\u0020e\u0065\u0078\u0065\u0063"
)

// SetDocInfo set document info.
// This will overwrite any globally declared document info.
func (_dadgf *PdfWriter) SetDocInfo(info *PdfInfo) { _dadgf.setDocInfo(info.ToPdfObject()) }

// PdfFont represents an underlying font structure which can be of type:
// - Type0
// - Type1
// - TrueType
// etc.
type PdfFont struct{ _effaa pdfFont }

// ImageToRGB converts an Image in a given PdfColorspace to an RGB image.
func (_ffaac *PdfColorspaceDeviceN) ImageToRGB(img Image) (Image, error) {
	_cbae := _db.NewReader(img.getBase())
	_dfdc := _ged.NewImageBase(int(img.Width), int(img.Height), int(img.BitsPerComponent), img.ColorComponents, nil, img._gdga, img._abacg)
	_cffb := _db.NewWriter(_dfdc)
	_cabb := _afb.Pow(2, float64(img.BitsPerComponent)) - 1
	_cffc := _ffaac.GetNumComponents()
	_fegdf := make([]uint32, _cffc)
	_dfadb := make([]float64, _cffc)
	for {
		_ccac := _cbae.ReadSamples(_fegdf)
		if _ccac == _cf.EOF {
			break
		} else if _ccac != nil {
			return img, _ccac
		}
		for _ggag := 0; _ggag < _cffc; _ggag++ {
			_adgcc := float64(_fegdf[_ggag]) / _cabb
			_dfadb[_ggag] = _adgcc
		}
		_afcg, _ccac := _ffaac.TintTransform.Evaluate(_dfadb)
		if _ccac != nil {
			return img, _ccac
		}
		for _, _dcba := range _afcg {
			_dcba = _afb.Min(_afb.Max(0, _dcba), 1.0)
			if _ccac = _cffb.WriteSample(uint32(_dcba * _cabb)); _ccac != nil {
				return img, _ccac
			}
		}
	}
	return _ffaac.AlternateSpace.ImageToRGB(_ddgg(&_dfdc))
}

// PdfActionRendition represents a Rendition action.
type PdfActionRendition struct {
	*PdfAction
	R  _agf.PdfObject
	AN _agf.PdfObject
	OP _agf.PdfObject
	JS _agf.PdfObject
}

// GetContainingPdfObject implements interface PdfModel.
func (_egga *PdfSignatureReference) GetContainingPdfObject() _agf.PdfObject { return _egga._feaaf }

// ToPdfObject returns the PDF representation of the shading pattern.
func (_gacbc *PdfShadingPatternType2) ToPdfObject() _agf.PdfObject {
	_gacbc.PdfPattern.ToPdfObject()
	_dbegba := _gacbc.getDict()
	if _gacbc.Shading != nil {
		_dbegba.Set("\u0053h\u0061\u0064\u0069\u006e\u0067", _gacbc.Shading.ToPdfObject())
	}
	if _gacbc.Matrix != nil {
		_dbegba.Set("\u004d\u0061\u0074\u0072\u0069\u0078", _gacbc.Matrix)
	}
	if _gacbc.ExtGState != nil {
		_dbegba.Set("\u0045x\u0074\u0047\u0053\u0074\u0061\u0074e", _gacbc.ExtGState)
	}
	return _gacbc._efed
}

// ColorFromPdfObjects returns a new PdfColor based on input color components. The input PdfObjects should
// be numeric.
func (_ffed *PdfColorspaceDeviceN) ColorFromPdfObjects(objects []_agf.PdfObject) (PdfColor, error) {
	if len(objects) != _ffed.GetNumComponents() {
		return nil, _gcd.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_dceg, _agggc := _agf.GetNumbersAsFloat(objects)
	if _agggc != nil {
		return nil, _agggc
	}
	return _ffed.ColorFromFloats(_dceg)
}

// PdfAnnotationMovie represents Movie annotations.
// (Section 12.5.6.17).
type PdfAnnotationMovie struct {
	*PdfAnnotation
	T     _agf.PdfObject
	Movie _agf.PdfObject
	A     _agf.PdfObject
}

func (_dffbg *PdfWriter) writeOutlines() error {
	if _dffbg._dfcbdg == nil {
		return nil
	}
	_fd.Log.Trace("\u004f\u0075t\u006c\u0069\u006ee\u0054\u0072\u0065\u0065\u003a\u0020\u0025\u002b\u0076", _dffbg._dfcbdg)
	_aeadg := _dffbg._dfcbdg.ToPdfObject()
	_fd.Log.Trace("\u004fu\u0074\u006c\u0069\u006e\u0065\u0073\u003a\u0020\u0025\u002b\u0076 \u0028\u0025\u0054\u002c\u0020\u0070\u003a\u0025\u0070\u0029", _aeadg, _aeadg, _aeadg)
	_dffbg._bagbb.Set("\u004f\u0075\u0074\u006c\u0069\u006e\u0065\u0073", _aeadg)
	_ddgaf := _dffbg.addObjects(_aeadg)
	if _ddgaf != nil {
		return _ddgaf
	}
	return nil
}

// ToPdfObject converts the PdfFont object to its PDF representation.
func (_agag *PdfFont) ToPdfObject() _agf.PdfObject {
	if _agag._effaa == nil {
		_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0066\u006f\u006e\u0074 \u0063\u006f\u006e\u0074\u0065\u0078\u0074\u0020\u0069\u0073 \u006e\u0069\u006c")
		return _agf.MakeNull()
	}
	return _agag._effaa.ToPdfObject()
}
func _aaeeg() *modelManager {
	_gfbffb := modelManager{}
	_gfbffb._bggfd = map[PdfModel]_agf.PdfObject{}
	_gfbffb._ccbc = map[_agf.PdfObject]PdfModel{}
	return &_gfbffb
}

var _cbfbe = map[string]struct{}{"\u0054\u0069\u0074l\u0065": {}, "\u0041\u0075\u0074\u0068\u006f\u0072": {}, "\u0053u\u0062\u006a\u0065\u0063\u0074": {}, "\u004b\u0065\u0079\u0077\u006f\u0072\u0064\u0073": {}, "\u0043r\u0065\u0061\u0074\u006f\u0072": {}, "\u0050\u0072\u006f\u0064\u0075\u0063\u0065\u0072": {}, "\u0054r\u0061\u0070\u0070\u0065\u0064": {}, "\u0043\u0072\u0065a\u0074\u0069\u006f\u006e\u0044\u0061\u0074\u0065": {}, "\u004do\u0064\u0044\u0061\u0074\u0065": {}}

// Image interface is a basic representation of an image used in PDF.
// The colorspace is not specified, but must be known when handling the image.
type Image struct {
	Width            int64
	Height           int64
	BitsPerComponent int64
	ColorComponents  int
	Data             []byte
	_gdga            []byte
	_abacg           []float64
}

// HasXObjectByName checks if has XObject resource by name.
func (_fceff *PdfPage) HasXObjectByName(name _agf.PdfObjectName) bool {
	_abdbe, _ccbcd := _fceff.Resources.XObject.(*_agf.PdfObjectDictionary)
	if !_ccbcd {
		return false
	}
	if _dacc := _abdbe.Get(name); _dacc != nil {
		return true
	}
	return false
}

// Encrypt encrypts the output file with a specified user/owner password.
func (_fbagb *PdfWriter) Encrypt(userPass, ownerPass []byte, options *EncryptOptions) error {
	_fgbga := RC4_128bit
	if options != nil {
		_fgbga = options.Algorithm
	}
	_cdegf := _bfb.PermOwner
	if options != nil {
		_cdegf = options.Permissions
	}
	var _fbeee _cg.Filter
	switch _fgbga {
	case RC4_128bit:
		_fbeee = _cg.NewFilterV2(16)
	case AES_128bit:
		_fbeee = _cg.NewFilterAESV2()
	case AES_256bit:
		_fbeee = _cg.NewFilterAESV3()
	default:
		return _b.Errorf("\u0075n\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020a\u006cg\u006fr\u0069\u0074\u0068\u006d\u003a\u0020\u0025v", options.Algorithm)
	}
	_bbfde, _eceae, _dgff := _agf.PdfCryptNewEncrypt(_fbeee, userPass, ownerPass, _cdegf)
	if _dgff != nil {
		return _dgff
	}
	_fbagb._cecgd = _bbfde
	if _eceae.Major != 0 {
		_fbagb.SetVersion(_eceae.Major, _eceae.Minor)
	}
	_fbagb._ccebfc = _eceae.Encrypt
	_fbagb._bedbef, _fbagb._daddd = _eceae.ID0, _eceae.ID1
	_gagc := _agf.MakeIndirectObject(_eceae.Encrypt)
	_fbagb._gdcbf = _gagc
	_fbagb.addObject(_gagc)
	return nil
}

// FullName returns the full name of the field as in rootname.parentname.partialname.
func (_ddee *PdfField) FullName() (string, error) {
	var _dbbd _gg.Buffer
	_gfggee := []string{}
	if _ddee.T != nil {
		_gfggee = append(_gfggee, _ddee.T.Decoded())
	}
	_gdcg := map[*PdfField]bool{}
	_gdcg[_ddee] = true
	_bdff := _ddee.Parent
	for _bdff != nil {
		if _, _bbbd := _gdcg[_bdff]; _bbbd {
			return _dbbd.String(), _gcd.New("\u0072\u0065\u0063\u0075rs\u0069\u0076\u0065\u0020\u0074\u0072\u0061\u0076\u0065\u0072\u0073\u0061\u006c")
		}
		if _bdff.T == nil {
			return _dbbd.String(), _gcd.New("\u0066\u0069el\u0064\u0020\u0070a\u0072\u0074\u0069\u0061l n\u0061me\u0020\u0028\u0054\u0029\u0020\u006e\u006ft \u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064")
		}
		_gfggee = append(_gfggee, _bdff.T.Decoded())
		_gdcg[_bdff] = true
		_bdff = _bdff.Parent
	}
	for _dadg := len(_gfggee) - 1; _dadg >= 0; _dadg-- {
		_dbbd.WriteString(_gfggee[_dadg])
		if _dadg > 0 {
			_dbbd.WriteString("\u002e")
		}
	}
	return _dbbd.String(), nil
}

// ToPdfObject implements interface PdfModel.
func (_cbea *PdfAnnotationPolyLine) ToPdfObject() _agf.PdfObject {
	_cbea.PdfAnnotation.ToPdfObject()
	_gedd := _cbea._aeee
	_acbb := _gedd.PdfObject.(*_agf.PdfObjectDictionary)
	_cbea.PdfAnnotationMarkup.appendToPdfDictionary(_acbb)
	_acbb.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _agf.MakeName("\u0050\u006f\u006c\u0079\u004c\u0069\u006e\u0065"))
	_acbb.SetIfNotNil("\u0056\u0065\u0072\u0074\u0069\u0063\u0065\u0073", _cbea.Vertices)
	_acbb.SetIfNotNil("\u004c\u0045", _cbea.LE)
	_acbb.SetIfNotNil("\u0042\u0053", _cbea.BS)
	_acbb.SetIfNotNil("\u0049\u0043", _cbea.IC)
	_acbb.SetIfNotNil("\u0042\u0045", _cbea.BE)
	_acbb.SetIfNotNil("\u0049\u0054", _cbea.IT)
	_acbb.SetIfNotNil("\u004de\u0061\u0073\u0075\u0072\u0065", _cbea.Measure)
	return _gedd
}

// ToPdfObject implements model.PdfModel interface.
func (_cbfeef *PdfOutputIntent) ToPdfObject() _agf.PdfObject {
	if _cbfeef._cebc == nil {
		_cbfeef._cebc = _agf.MakeDict()
	}
	_fbcbe := _cbfeef._cebc
	if _cbfeef.Type != "" {
		_fbcbe.Set("\u0054\u0079\u0070\u0065", _agf.MakeName(_cbfeef.Type))
	}
	_fbcbe.Set("\u0053", _agf.MakeName(_cbfeef.S.String()))
	if _cbfeef.OutputCondition != "" {
		_fbcbe.Set("\u004fu\u0074p\u0075\u0074\u0043\u006f\u006e\u0064\u0069\u0074\u0069\u006f\u006e", _agf.MakeString(_cbfeef.OutputCondition))
	}
	_fbcbe.Set("\u004fu\u0074\u0070\u0075\u0074C\u006f\u006e\u0064\u0069\u0074i\u006fn\u0049d\u0065\u006e\u0074\u0069\u0066\u0069\u0065r", _agf.MakeString(_cbfeef.OutputConditionIdentifier))
	_fbcbe.Set("\u0052\u0065\u0067i\u0073\u0074\u0072\u0079\u004e\u0061\u006d\u0065", _agf.MakeString(_cbfeef.RegistryName))
	if _cbfeef.Info != "" {
		_fbcbe.Set("\u0049\u006e\u0066\u006f", _agf.MakeString(_cbfeef.Info))
	}
	if len(_cbfeef.DestOutputProfile) != 0 {
		_gfeae, _agcaa := _agf.MakeStream(_cbfeef.DestOutputProfile, _agf.NewFlateEncoder())
		if _agcaa != nil {
			_fd.Log.Error("\u004d\u0061\u006b\u0065\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0044\u0065s\u0074\u004f\u0075\u0074\u0070\u0075t\u0050\u0072\u006f\u0066\u0069\u006c\u0065\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076", _agcaa)
		}
		_gfeae.PdfObjectDictionary.Set("\u004e", _agf.MakeInteger(int64(_cbfeef.ColorComponents)))
		_cfdb := make([]float64, _cbfeef.ColorComponents*2)
		for _eedgc := 0; _eedgc < _cbfeef.ColorComponents*2; _eedgc++ {
			_agbdb := 0.0
			if _eedgc%2 != 0 {
				_agbdb = 1.0
			}
			_cfdb[_eedgc] = _agbdb
		}
		_gfeae.PdfObjectDictionary.Set("\u0052\u0061\u006eg\u0065", _agf.MakeArrayFromFloats(_cfdb))
		_fbcbe.Set("\u0044\u0065\u0073\u0074\u004f\u0075\u0074\u0070\u0075\u0074\u0050\u0072o\u0066\u0069\u006c\u0065", _gfeae)
	}
	return _fbcbe
}

// NewPdfReaderFromFile creates a new PdfReader from the speficied PDF file.
// If ReaderOpts is nil it will be set to default value from NewReaderOpts.
func NewPdfReaderFromFile(pdfFile string, opts *ReaderOpts) (*PdfReader, *_fb.File, error) {
	const _feged = "\u006d\u006f\u0064\u0065\u006c\u003a\u004e\u0065\u0077\u0050\u0064f\u0052\u0065\u0061\u0064\u0065\u0072\u0046\u0072\u006f\u006dF\u0069\u006c\u0065"
	_abefg, _cgaaac := _fb.Open(pdfFile)
	if _cgaaac != nil {
		return nil, nil, _cgaaac
	}
	_bbbgc, _cgaaac := _dcab(_abefg, opts, true, _feged)
	if _cgaaac != nil {
		_abefg.Close()
		return nil, nil, _cgaaac
	}
	return _bbbgc, _abefg, nil
}

// SetPdfTitle sets the Title attribute of the output PDF.
func SetPdfTitle(title string) { _ecba.Lock(); defer _ecba.Unlock(); _abdfe = title }
func (_ffa *PdfReader) newPdfAnnotationSquigglyFromDict(_ebec *_agf.PdfObjectDictionary) (*PdfAnnotationSquiggly, error) {
	_afc := PdfAnnotationSquiggly{}
	_fcb, _cacdf := _ffa.newPdfAnnotationMarkupFromDict(_ebec)
	if _cacdf != nil {
		return nil, _cacdf
	}
	_afc.PdfAnnotationMarkup = _fcb
	_afc.QuadPoints = _ebec.Get("\u0051\u0075\u0061\u0064\u0050\u006f\u0069\u006e\u0074\u0073")
	return &_afc, nil
}

// NewPdfColorspaceCalGray returns a new CalGray colorspace object.
func NewPdfColorspaceCalGray() *PdfColorspaceCalGray {
	_ggfg := &PdfColorspaceCalGray{}
	_ggfg.BlackPoint = []float64{0.0, 0.0, 0.0}
	_ggfg.Gamma = 1
	return _ggfg
}

// PdfAnnotationHighlight represents Highlight annotations.
// (Section 12.5.6.10).
type PdfAnnotationHighlight struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	QuadPoints _agf.PdfObject
}

// PdfOutputIntentType is the subtype of the given PdfOutputIntent.
type PdfOutputIntentType int

// NewPdfColorDeviceCMYK returns a new CMYK32 color.
func NewPdfColorDeviceCMYK(c, m, y, k float64) *PdfColorDeviceCMYK {
	_dfab := PdfColorDeviceCMYK{c, m, y, k}
	return &_dfab
}

// PdfAnnotationSquiggly represents Squiggly annotations.
// (Section 12.5.6.10).
type PdfAnnotationSquiggly struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	QuadPoints _agf.PdfObject
}

func (_faaf *PdfReader) loadAnnotations(_dfbe _agf.PdfObject) ([]*PdfAnnotation, error) {
	_agece, _fcdaec := _agf.GetArray(_dfbe)
	if !_fcdaec {
		return nil, _b.Errorf("\u0041\u006e\u006e\u006fts\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079")
	}
	var _bgfbe []*PdfAnnotation
	for _, _cfeca := range _agece.Elements() {
		_cfeca = _agf.ResolveReference(_cfeca)
		if _, _adgab := _cfeca.(*_agf.PdfObjectNull); _adgab {
			continue
		}
		_gcedc, _cfcgge := _cfeca.(*_agf.PdfObjectDictionary)
		_afcgc, _fdfade := _cfeca.(*_agf.PdfIndirectObject)
		if _cfcgge {
			_afcgc = &_agf.PdfIndirectObject{}
			_afcgc.PdfObject = _gcedc
		} else {
			if !_fdfade {
				return nil, _b.Errorf("\u0061\u006eno\u0074\u0061\u0074i\u006f\u006e\u0020\u006eot \u0069n \u0061\u006e\u0020\u0069\u006e\u0064\u0069re\u0063\u0074\u0020\u006f\u0062\u006a\u0065c\u0074")
			}
		}
		_aaabb, _bbac := _faaf.newPdfAnnotationFromIndirectObject(_afcgc)
		if _bbac != nil {
			return nil, _bbac
		}
		switch _ddgbe := _aaabb.GetContext().(type) {
		case *PdfAnnotationWidget:
			for _, _fffad := range _faaf.AcroForm.AllFields() {
				if _fffad._fcgcc == _ddgbe.Parent {
					_ddgbe._efe = _fffad
					break
				}
			}
		}
		if _aaabb != nil {
			_bgfbe = append(_bgfbe, _aaabb)
		}
	}
	return _bgfbe, nil
}
func (_gccbd *PdfWriter) setDocumentIDs(_eccff, _bdeafa string) {
	_gccbd._fcgdbd = _agf.MakeArray(_agf.MakeHexString(_eccff), _agf.MakeHexString(_bdeafa))
}

// AcroFormNeedsRepair returns true if the document contains widget annotations
// linked to fields which are not referenced in the AcroForm. The AcroForm can
// be repaired using the RepairAcroForm method of the reader.
func (_gcgbd *PdfReader) AcroFormNeedsRepair() (bool, error) {
	var _bddcg []*PdfField
	if _gcgbd.AcroForm != nil {
		_bddcg = _gcgbd.AcroForm.AllFields()
	}
	_cdgb := make(map[*PdfField]struct{}, len(_bddcg))
	for _, _eacf := range _bddcg {
		_cdgb[_eacf] = struct{}{}
	}
	for _, _dgacc := range _gcgbd.PageList {
		_acedb, _edfc := _dgacc.GetAnnotations()
		if _edfc != nil {
			return false, _edfc
		}
		for _, _gbgbc := range _acedb {
			_ecfge, _gaafa := _gbgbc.GetContext().(*PdfAnnotationWidget)
			if !_gaafa {
				continue
			}
			_fgaef := _ecfge.Field()
			if _fgaef == nil {
				return true, nil
			}
			if _, _fdgcc := _cdgb[_fgaef]; !_fdgcc {
				return true, nil
			}
		}
	}
	return false, nil
}
func (_eabd *PdfAppender) mergeResources(_gabc, _eaf _agf.PdfObject, _dgfa map[_agf.PdfObjectName]_agf.PdfObjectName) _agf.PdfObject {
	if _eaf == nil && _gabc == nil {
		return nil
	}
	if _eaf == nil {
		return _gabc
	}
	_bgf, _eead := _agf.GetDict(_eaf)
	if !_eead {
		return _gabc
	}
	if _gabc == nil {
		_cdaf := _agf.MakeDict()
		_cdaf.Merge(_bgf)
		return _eaf
	}
	_gdea, _eead := _agf.GetDict(_gabc)
	if !_eead {
		_fd.Log.Error("\u0045\u0072\u0072or\u0020\u0072\u0065\u0073\u006f\u0075\u0072\u0063\u0065 \u0069s\u0020n\u006ft\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079")
		_gdea = _agf.MakeDict()
	}
	for _, _decg := range _bgf.Keys() {
		if _dggc, _gfgd := _dgfa[_decg]; _gfgd {
			_gdea.Set(_dggc, _bgf.Get(_decg))
		} else {
			_gdea.Set(_decg, _bgf.Get(_decg))
		}
	}
	return _gdea
}
func _efeee(_dabafg _agf.PdfObject) (*PdfPageResourcesColorspaces, error) {
	_egdb := &PdfPageResourcesColorspaces{}
	if _cbfcb, _agdeg := _dabafg.(*_agf.PdfIndirectObject); _agdeg {
		_egdb._dafcd = _cbfcb
		_dabafg = _cbfcb.PdfObject
	}
	_efccd, _dgeea := _agf.GetDict(_dabafg)
	if !_dgeea {
		return nil, _gcd.New("\u0043\u0053\u0020at\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	_egdb.Names = []string{}
	_egdb.Colorspaces = map[string]PdfColorspace{}
	for _, _cgdbg := range _efccd.Keys() {
		_ddfec := _efccd.Get(_cgdbg)
		_egdb.Names = append(_egdb.Names, string(_cgdbg))
		_daagcd, _feaef := NewPdfColorspaceFromPdfObject(_ddfec)
		if _feaef != nil {
			return nil, _feaef
		}
		_egdb.Colorspaces[string(_cgdbg)] = _daagcd
	}
	return _egdb, nil
}

// NewPdfFieldSignature returns an initialized signature field.
func NewPdfFieldSignature(signature *PdfSignature) *PdfFieldSignature {
	_dffe := &PdfFieldSignature{}
	_dffe.PdfField = NewPdfField()
	_dffe.PdfField.SetContext(_dffe)
	_dffe.PdfAnnotationWidget = NewPdfAnnotationWidget()
	_dffe.PdfAnnotationWidget.SetContext(_dffe)
	_dffe.PdfAnnotationWidget._aeee = _dffe.PdfField._fcgcc
	_dffe.T = _agf.MakeString("")
	_dffe.F = _agf.MakeInteger(132)
	_dffe.V = signature
	return _dffe
}
func (_bcd *PdfReader) newPdfAnnotationRichMediaFromDict(_aece *_agf.PdfObjectDictionary) (*PdfAnnotationRichMedia, error) {
	_gddb := &PdfAnnotationRichMedia{}
	_gddb.RichMediaSettings = _aece.Get("\u0052\u0069\u0063\u0068\u004d\u0065\u0064\u0069\u0061\u0053\u0065\u0074t\u0069\u006e\u0067\u0073")
	_gddb.RichMediaContent = _aece.Get("\u0052\u0069c\u0068\u004d\u0065d\u0069\u0061\u0043\u006f\u006e\u0074\u0065\u006e\u0074")
	return _gddb, nil
}

// NewReaderForText makes a new PdfReader for an input PDF content string. For use in testing.
func NewReaderForText(txt string) *PdfReader {
	return &PdfReader{_eggbg: map[_agf.PdfObject]struct{}{}, _dcdeb: _aaeeg(), _egdga: _agf.NewParserFromString(txt)}
}

// SetPdfAuthor sets the Author attribute of the output PDF.
func SetPdfAuthor(author string) { _ecba.Lock(); defer _ecba.Unlock(); _bebbe = author }
func (_dgffg *PdfWriter) checkCrossReferenceStream() bool {
	_adggbg := _dgffg._bcdfgg.Major > 1 || (_dgffg._bcdfgg.Major == 1 && _dgffg._bcdfgg.Minor > 4)
	if _dgffg._cbbed != nil {
		_adggbg = *_dgffg._cbbed
	}
	return _adggbg
}
func _abbd(_cfbf _agf.PdfObject) (*PdfShading, error) {
	_dbeagg := &PdfShading{}
	var _cabdc *_agf.PdfObjectDictionary
	if _gffaeb, _gbba := _agf.GetIndirect(_cfbf); _gbba {
		_dbeagg._ggbge = _gffaeb
		_dcaf, _cacddf := _gffaeb.PdfObject.(*_agf.PdfObjectDictionary)
		if !_cacddf {
			_fd.Log.Debug("\u004f\u0062\u006a\u0065c\u0074\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069c\u0074i\u006f\u006e\u0061\u0072\u0079\u0020\u0074y\u0070\u0065")
			return nil, _agf.ErrTypeError
		}
		_cabdc = _dcaf
	} else if _dcddf, _ggede := _agf.GetStream(_cfbf); _ggede {
		_dbeagg._ggbge = _dcddf
		_cabdc = _dcddf.PdfObjectDictionary
	} else if _begeec, _eecaa := _agf.GetDict(_cfbf); _eecaa {
		_dbeagg._ggbge = _begeec
		_cabdc = _begeec
	} else {
		_fd.Log.Debug("O\u0062\u006a\u0065\u0063\u0074\u0020t\u0079\u0070\u0065\u0020\u0075\u006e\u0065\u0078\u0070e\u0063\u0074\u0065d\u0020(\u0025\u0054\u0029", _cfbf)
		return nil, _agf.ErrTypeError
	}
	if _cabdc == nil {
		_fd.Log.Debug("\u0044i\u0063t\u0069\u006f\u006e\u0061\u0072y\u0020\u006di\u0073\u0073\u0069\u006e\u0067")
		return nil, _gcd.New("\u0064\u0069\u0063t\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067")
	}
	_cfbf = _cabdc.Get("S\u0068\u0061\u0064\u0069\u006e\u0067\u0054\u0079\u0070\u0065")
	if _cfbf == nil {
		_fd.Log.Debug("\u0052\u0065q\u0075\u0069\u0072\u0065\u0064\u0020\u0073\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u0074\u0079\u0070\u0065\u0020\u006d\u0069\u0073si\u006e\u0067")
		return nil, ErrRequiredAttributeMissing
	}
	_cfbf = _agf.TraceToDirectObject(_cfbf)
	_affea, _dbabf := _cfbf.(*_agf.PdfObjectInteger)
	if !_dbabf {
		_fd.Log.Debug("\u0049\u006e\u0076al\u0069\u0064\u0020\u0074\u0079\u0070\u0065\u0020\u0066o\u0072 \u0073h\u0061d\u0069\u006e\u0067\u0020\u0074\u0079\u0070\u0065\u0020\u0028\u0025\u0054\u0029", _cfbf)
		return nil, _agf.ErrTypeError
	}
	if *_affea < 1 || *_affea > 7 {
		_fd.Log.Debug("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0073\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u0074\u0079\u0070\u0065\u002c\u0020\u006e\u006ft\u0020\u0031\u002d\u0037\u0020(\u0067\u006ft\u0020\u0025\u0064\u0029", *_affea)
		return nil, _agf.ErrTypeError
	}
	_dbeagg.ShadingType = _affea
	_cfbf = _cabdc.Get("\u0043\u006f\u006c\u006f\u0072\u0053\u0070\u0061\u0063\u0065")
	if _cfbf == nil {
		_fd.Log.Debug("\u0052\u0065\u0071\u0075\u0069\u0072e\u0064\u0020\u0043\u006f\u006c\u006f\u0072\u0053\u0070\u0061\u0063\u0065\u0020e\u006e\u0074\u0072\u0079\u0020\u006d\u0069s\u0073\u0069\u006e\u0067")
		return nil, ErrRequiredAttributeMissing
	}
	_fdacf, _dgdfg := NewPdfColorspaceFromPdfObject(_cfbf)
	if _dgdfg != nil {
		_fd.Log.Debug("\u0046\u0061i\u006c\u0065\u0064\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063\u0065: \u0025\u0076", _dgdfg)
		return nil, _dgdfg
	}
	_dbeagg.ColorSpace = _fdacf
	_cfbf = _cabdc.Get("\u0042\u0061\u0063\u006b\u0067\u0072\u006f\u0075\u006e\u0064")
	if _cfbf != nil {
		_cfbf = _agf.TraceToDirectObject(_cfbf)
		_aggff, _fcccf := _cfbf.(*_agf.PdfObjectArray)
		if !_fcccf {
			_fd.Log.Debug("\u0042\u0061\u0063\u006b\u0067r\u006f\u0075\u006e\u0064\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062e\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064\u0020\u0062\u0079\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054)", _cfbf)
			return nil, _agf.ErrTypeError
		}
		_dbeagg.Background = _aggff
	}
	_cfbf = _cabdc.Get("\u0042\u0042\u006f\u0078")
	if _cfbf != nil {
		_cfbf = _agf.TraceToDirectObject(_cfbf)
		_adde, _fgdee := _cfbf.(*_agf.PdfObjectArray)
		if !_fgdee {
			_fd.Log.Debug("\u0042\u0061\u0063\u006b\u0067r\u006f\u0075\u006e\u0064\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062e\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064\u0020\u0062\u0079\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054)", _cfbf)
			return nil, _agf.ErrTypeError
		}
		_ffgbg, _cfadd := NewPdfRectangle(*_adde)
		if _cfadd != nil {
			_fd.Log.Debug("\u0042\u0042\u006f\u0078\u0020\u0065\u0072\u0072\u006fr\u003a\u0020\u0025\u0076", _cfadd)
			return nil, _cfadd
		}
		_dbeagg.BBox = _ffgbg
	}
	_cfbf = _cabdc.Get("\u0041n\u0074\u0069\u0041\u006c\u0069\u0061s")
	if _cfbf != nil {
		_cfbf = _agf.TraceToDirectObject(_cfbf)
		_abfdea, _cgbac := _cfbf.(*_agf.PdfObjectBool)
		if !_cgbac {
			_fd.Log.Debug("A\u006e\u0074\u0069\u0041\u006c\u0069\u0061\u0073\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020ty\u0070\u0065\u002c\u0020s\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020bo\u006f\u006c \u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", _cfbf)
			return nil, _agf.ErrTypeError
		}
		_dbeagg.AntiAlias = _abfdea
	}
	switch *_affea {
	case 1:
		_bdegd, _gfggd := _afed(_cabdc)
		if _gfggd != nil {
			return nil, _gfggd
		}
		_bdegd.PdfShading = _dbeagg
		_dbeagg._gefcd = _bdegd
		return _dbeagg, nil
	case 2:
		_bbfec, _bdbgb := _ddfa(_cabdc)
		if _bdbgb != nil {
			return nil, _bdbgb
		}
		_bbfec.PdfShading = _dbeagg
		_dbeagg._gefcd = _bbfec
		return _dbeagg, nil
	case 3:
		_aegg, _aeeeda := _cegad(_cabdc)
		if _aeeeda != nil {
			return nil, _aeeeda
		}
		_aegg.PdfShading = _dbeagg
		_dbeagg._gefcd = _aegg
		return _dbeagg, nil
	case 4:
		_dddea, _gafag := _dbdfe(_cabdc)
		if _gafag != nil {
			return nil, _gafag
		}
		_dddea.PdfShading = _dbeagg
		_dbeagg._gefcd = _dddea
		return _dbeagg, nil
	case 5:
		_bfgbb, _fgdcc := _babda(_cabdc)
		if _fgdcc != nil {
			return nil, _fgdcc
		}
		_bfgbb.PdfShading = _dbeagg
		_dbeagg._gefcd = _bfgbb
		return _dbeagg, nil
	case 6:
		_abae, _dece := _aacff(_cabdc)
		if _dece != nil {
			return nil, _dece
		}
		_abae.PdfShading = _dbeagg
		_dbeagg._gefcd = _abae
		return _dbeagg, nil
	case 7:
		_dbacf, _agfbf := _gcedbd(_cabdc)
		if _agfbf != nil {
			return nil, _agfbf
		}
		_dbacf.PdfShading = _dbeagg
		_dbeagg._gefcd = _dbacf
		return _dbeagg, nil
	}
	return nil, _gcd.New("u\u006ek\u006e\u006f\u0077\u006e\u0020\u0073\u0068\u0061d\u0069\u006e\u0067\u0020ty\u0070\u0065")
}

// SetNameDictionary sets the Names entry in the PDF catalog.
// See section 7.7.4 "Name Dictionary" (p. 80 PDF32000_2008).
func (_abdbf *PdfWriter) SetNameDictionary(names _agf.PdfObject) error {
	if names == nil {
		return nil
	}
	_fd.Log.Trace("\u0053e\u0074\u0074\u0069\u006e\u0067\u0020\u0063\u0061\u0074\u0061\u006co\u0067\u0020\u004e\u0061\u006d\u0065\u0073\u002e\u002e\u002e")
	_abdbf._bagbb.Set("\u004e\u0061\u006de\u0073", names)
	return _abdbf.addObjects(names)
}

// GetVersion gets the document version.
func (_dfbef *PdfWriter) GetVersion() _agf.Version { return _dfbef._bcdfgg }

// ToPdfObject implements interface PdfModel.
func (_bcde *PdfAnnotationProjection) ToPdfObject() _agf.PdfObject {
	_bcde.PdfAnnotation.ToPdfObject()
	_abec := _bcde._aeee
	_bdbd := _abec.PdfObject.(*_agf.PdfObjectDictionary)
	_bcde.PdfAnnotationMarkup.appendToPdfDictionary(_bdbd)
	return _abec
}

// ColorFromPdfObjects loads the color from PDF objects.
// The first objects (if present) represent the color in underlying colorspace.  The last one represents
// the name of the pattern.
func (_bdbcd *PdfColorspaceSpecialPattern) ColorFromPdfObjects(objects []_agf.PdfObject) (PdfColor, error) {
	if len(objects) < 1 {
		return nil, _gcd.New("\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066 \u0070\u0061\u0072\u0061\u006d\u0065\u0074e\u0072\u0073")
	}
	_cgecd := &PdfColorPattern{}
	_ffac, _efbb := objects[len(objects)-1].(*_agf.PdfObjectName)
	if !_efbb {
		_fd.Log.Debug("\u0050\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u006e\u0061\u006d\u0065\u0020\u006e\u006ft\u0020a\u0020\u006e\u0061\u006d\u0065\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", objects[len(objects)-1])
		return nil, ErrTypeCheck
	}
	_cgecd.PatternName = *_ffac
	if len(objects) > 1 {
		_bcece := objects[0 : len(objects)-1]
		if _bdbcd.UnderlyingCS == nil {
			_fd.Log.Debug("P\u0061\u0074t\u0065\u0072\u006e\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0077\u0069\u0074\u0068\u0020\u0064\u0065\u0066\u0069\u006ee\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0063\u006f\u006d\u0070\u006f\u006e\u0065\u006et\u0073\u0020\u0062\u0075\u0074\u0020\u0075\u006e\u0064\u0065\u0072\u006c\u0079i\u006e\u0067\u0020\u0063\u0073\u0020\u006d\u0069\u0073\u0073\u0069n\u0067")
			return nil, _gcd.New("\u0075n\u0064\u0065\u0072\u006cy\u0069\u006e\u0067\u0020\u0043S\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d")
		}
		_bbca, _acbbg := _bdbcd.UnderlyingCS.ColorFromPdfObjects(_bcece)
		if _acbbg != nil {
			_fd.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055n\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0076\u0069\u0061\u0020\u0075\u006e\u0064\u0065\u0072\u006c\u0079\u0069\u006e\u0067\u0020\u0063\u0073\u003a\u0020\u0025\u0076", _acbbg)
			return nil, _acbbg
		}
		_cgecd.Color = _bbca
	}
	return _cgecd, nil
}
func _cagbd(_bdgdg *_agf.PdfObjectStream) (*PdfFunctionType4, error) {
	_cbcf := &PdfFunctionType4{}
	_cbcf._bcfbb = _bdgdg
	_dfde := _bdgdg.PdfObjectDictionary
	_dffdf, _effc := _agf.TraceToDirectObject(_dfde.Get("\u0044\u006f\u006d\u0061\u0069\u006e")).(*_agf.PdfObjectArray)
	if !_effc {
		_fd.Log.Error("D\u006fm\u0061\u0069\u006e\u0020\u006e\u006f\u0074\u0020s\u0070\u0065\u0063\u0069fi\u0065\u0064")
		return nil, _gcd.New("\u0072\u0065q\u0075\u0069\u0072\u0065d\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020m\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u006f\u0072\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
	}
	if _dffdf.Len()%2 != 0 {
		_fd.Log.Error("\u0044\u006f\u006d\u0061\u0069\u006e\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
		return nil, _gcd.New("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0064\u006f\u006da\u0069\u006e\u0020\u0072an\u0067\u0065")
	}
	_ccgdf, _bead := _dffdf.ToFloat64Array()
	if _bead != nil {
		return nil, _bead
	}
	_cbcf.Domain = _ccgdf
	_dffdf, _effc = _agf.TraceToDirectObject(_dfde.Get("\u0052\u0061\u006eg\u0065")).(*_agf.PdfObjectArray)
	if _effc {
		if _dffdf.Len() < 0 || _dffdf.Len()%2 != 0 {
			return nil, _gcd.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u0061\u006e\u0067\u0065")
		}
		_ccgga, _abff := _dffdf.ToFloat64Array()
		if _abff != nil {
			return nil, _abff
		}
		_cbcf.Range = _ccgga
	}
	_bgfd, _bead := _agf.DecodeStream(_bdgdg)
	if _bead != nil {
		return nil, _bead
	}
	_cbcf._bfdde = _bgfd
	_aeecd := _bd.NewPSParser(_bgfd)
	_bbab, _bead := _aeecd.Parse()
	if _bead != nil {
		return nil, _bead
	}
	_cbcf.Program = _bbab
	return _cbcf, nil
}

// GetOutlineTree returns the outline tree.
func (_gfcde *PdfReader) GetOutlineTree() *PdfOutlineTreeNode { return _gfcde._gfdaa }
func (_dgafb *PdfWriter) addObject(_edbfe _agf.PdfObject) bool {
	_gbcdc := _dgafb.hasObject(_edbfe)
	if !_gbcdc {
		_gdaf := _agf.ResolveReferencesDeep(_edbfe, _dgafb._gbgbad)
		if _gdaf != nil {
			_fd.Log.Debug("E\u0052R\u004f\u0052\u003a\u0020\u0025\u0076\u0020\u002d \u0073\u006b\u0069\u0070pi\u006e\u0067", _gdaf)
		}
		_dgafb._dgbd = append(_dgafb._dgbd, _edbfe)
		_dgafb._ccbbf[_edbfe] = struct{}{}
		return true
	}
	return false
}

// AppendContentBytes creates a PDF stream from `cs` and appends it to the
// array of streams specified by the pages's Contents entry.
// If `wrapContents` is true, the content stream of the page is wrapped using
// a `q/Q` operator pair, so that its state does not affect the appended
// content stream.
func (_dcfd *PdfPage) AppendContentBytes(cs []byte, wrapContents bool) error {
	_bdcbb := _dcfd.GetContentStreamObjs()
	wrapContents = wrapContents && len(_bdcbb) > 0
	_fagb := _agf.NewFlateEncoder()
	_ggcbc := _agf.MakeArray()
	if wrapContents {
		_geged, _abgb := _agf.MakeStream([]byte("\u0071\u000a"), _fagb)
		if _abgb != nil {
			return _abgb
		}
		_ggcbc.Append(_geged)
	}
	_ggcbc.Append(_bdcbb...)
	if wrapContents {
		_cfedac, _gafaf := _agf.MakeStream([]byte("\u000a\u0051\u000a"), _fagb)
		if _gafaf != nil {
			return _gafaf
		}
		_ggcbc.Append(_cfedac)
	}
	_aagbb, _cdbaf := _agf.MakeStream(cs, _fagb)
	if _cdbaf != nil {
		return _cdbaf
	}
	_ggcbc.Append(_aagbb)
	_dcfd.Contents = _ggcbc
	return nil
}

// SetContentStreams sets the content streams based on a string array. Will make
// 1 object stream for each string and reference from the page Contents.
// Each stream will be encoded using the encoding specified by the StreamEncoder,
// if empty, will use identity encoding (raw data).
func (_gegfcc *PdfPage) SetContentStreams(cStreams []string, encoder _agf.StreamEncoder) error {
	if len(cStreams) == 0 {
		_gegfcc.Contents = nil
		return nil
	}
	if encoder == nil {
		encoder = _agf.NewRawEncoder()
	}
	var _ecbee []*_agf.PdfObjectStream
	for _, _bfaaf := range cStreams {
		_bbcca := &_agf.PdfObjectStream{}
		_fgdbf := encoder.MakeStreamDict()
		_gfcbb, _ggaac := encoder.EncodeBytes([]byte(_bfaaf))
		if _ggaac != nil {
			return _ggaac
		}
		_fgdbf.Set("\u004c\u0065\u006e\u0067\u0074\u0068", _agf.MakeInteger(int64(len(_gfcbb))))
		_bbcca.PdfObjectDictionary = _fgdbf
		_bbcca.Stream = _gfcbb
		_ecbee = append(_ecbee, _bbcca)
	}
	if len(_ecbee) == 1 {
		_gegfcc.Contents = _ecbee[0]
	} else {
		_ababdc := _agf.MakeArray()
		for _, _cbeag := range _ecbee {
			_ababdc.Append(_cbeag)
		}
		_gegfcc.Contents = _ababdc
	}
	return nil
}
func (_gfgbb *PdfWriter) mapObjectStreams(_cdbeg bool) (map[_agf.PdfObject]bool, bool) {
	_gecgd := make(map[_agf.PdfObject]bool)
	for _, _afeb := range _gfgbb._dgbd {
		if _afaefa, _cebfb := _afeb.(*_agf.PdfObjectStreams); _cebfb {
			_cdbeg = true
			for _, _edda := range _afaefa.Elements() {
				_gecgd[_edda] = true
				if _gceed, _ecdfa := _edda.(*_agf.PdfIndirectObject); _ecdfa {
					_gecgd[_gceed.PdfObject] = true
				}
			}
		}
	}
	return _gecgd, _cdbeg
}
func _gagg(_deeb _agf.PdfObject) (*PdfColorspaceSpecialSeparation, error) {
	_fbcg := NewPdfColorspaceSpecialSeparation()
	if _fgeb, _bdcd := _deeb.(*_agf.PdfIndirectObject); _bdcd {
		_fbcg._abeb = _fgeb
	}
	_deeb = _agf.TraceToDirectObject(_deeb)
	_gdff, _aadf := _deeb.(*_agf.PdfObjectArray)
	if !_aadf {
		return nil, _b.Errorf("\u0073\u0065p\u0061\u0072\u0061\u0074\u0069\u006f\u006e\u0020\u0043\u0053\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006f\u0062je\u0063\u0074")
	}
	if _gdff.Len() != 4 {
		return nil, _b.Errorf("\u0073\u0065p\u0061\u0072\u0061\u0074i\u006f\u006e \u0043\u0053\u003a\u0020\u0049\u006e\u0063\u006fr\u0072\u0065\u0063\u0074\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u006ce\u006e\u0067\u0074\u0068")
	}
	_deeb = _gdff.Get(0)
	_ebddg, _aadf := _deeb.(*_agf.PdfObjectName)
	if !_aadf {
		return nil, _b.Errorf("\u0073\u0065\u0070ar\u0061\u0074\u0069\u006f\u006e\u0020\u0043\u0053\u003a \u0069n\u0076a\u006ci\u0064\u0020\u0066\u0061\u006d\u0069\u006c\u0079\u0020\u006e\u0061\u006d\u0065")
	}
	if *_ebddg != "\u0053\u0065\u0070\u0061\u0072\u0061\u0074\u0069\u006f\u006e" {
		return nil, _b.Errorf("\u0073\u0065\u0070\u0061\u0072\u0061\u0074\u0069\u006f\u006e\u0020\u0043\u0053\u003a\u0020w\u0072o\u006e\u0067\u0020\u0066\u0061\u006d\u0069\u006c\u0079\u0020\u006e\u0061\u006d\u0065")
	}
	_deeb = _gdff.Get(1)
	_ebddg, _aadf = _deeb.(*_agf.PdfObjectName)
	if !_aadf {
		return nil, _b.Errorf("\u0073\u0065pa\u0072\u0061\u0074i\u006f\u006e\u0020\u0043S: \u0049nv\u0061\u006c\u0069\u0064\u0020\u0063\u006flo\u0072\u0061\u006e\u0074\u0020\u006e\u0061m\u0065")
	}
	_fbcg.ColorantName = _ebddg
	_deeb = _gdff.Get(2)
	_eac, _dfecb := NewPdfColorspaceFromPdfObject(_deeb)
	if _dfecb != nil {
		return nil, _dfecb
	}
	_fbcg.AlternateSpace = _eac
	_gdffg, _dfecb := _ccedb(_gdff.Get(3))
	if _dfecb != nil {
		return nil, _dfecb
	}
	_fbcg.TintTransform = _gdffg
	return _fbcg, nil
}

// NewPdfShadingPatternType3 creates an empty shading pattern type 3 object.
func NewPdfShadingPatternType3() *PdfShadingPatternType3 {
	_bdbcdd := &PdfShadingPatternType3{}
	_bdbcdd.Matrix = _agf.MakeArrayFromIntegers([]int{1, 0, 0, 1, 0, 0})
	_bdbcdd.PdfPattern = &PdfPattern{}
	_bdbcdd.PdfPattern.PatternType = int64(*_agf.MakeInteger(2))
	_bdbcdd.PdfPattern._dfed = _bdbcdd
	_bdbcdd.PdfPattern._efed = _agf.MakeIndirectObject(_agf.MakeDict())
	return _bdbcdd
}

// GetContext returns a reference to the subshading entry as represented by PdfShadingType1-7.
func (_ffbdd *PdfShading) GetContext() PdfModel { return _ffbdd._gefcd }

// GetAnnotations returns the list of page annotations for `page`. If not loaded attempts to load the
// annotations, otherwise returns the loaded list.
func (_ecgc *PdfPage) GetAnnotations() ([]*PdfAnnotation, error) {
	if _ecgc._abffa != nil {
		return _ecgc._abffa, nil
	}
	if _ecgc.Annots == nil {
		_ecgc._abffa = []*PdfAnnotation{}
		return nil, nil
	}
	if _ecgc._ecae == nil {
		_ecgc._abffa = []*PdfAnnotation{}
		return nil, nil
	}
	_fcfeb, _faaag := _ecgc._ecae.loadAnnotations(_ecgc.Annots)
	if _faaag != nil {
		return nil, _faaag
	}
	if _fcfeb == nil {
		_ecgc._abffa = []*PdfAnnotation{}
	}
	_ecgc._abffa = _fcfeb
	return _ecgc._abffa, nil
}

// C returns the value of the C component of the color.
func (_baed *PdfColorCalRGB) C() float64 { return _baed[2] }
func _ddeeg(_dgca *PdfPage) {
	_abcdg := _ede.GetLicenseKey()
	if _abcdg != nil && _abcdg.IsLicensed() {
		return
	}
	_ddabb := _agf.PdfObjectName("\u0055\u0046\u0031")
	if !_dgca.Resources.HasFontByName(_ddabb) {
		_dgca.Resources.SetFontByName(_ddabb, DefaultFont().ToPdfObject())
	}
	// var _edgag []string
	// _edgag = append(_edgag, "\u0071")
	// _edgag = append(_edgag, "\u0042\u0054")
	// _edgag = append(_edgag, _b.Sprintf("\u002f%\u0073\u0020\u0031\u0034\u0020\u0054f", _ddabb.String()))
	// _edgag = append(_edgag, "\u0031\u0020\u0030\u0020\u0030\u0020\u0072\u0067")
	// _edgag = append(_edgag, "\u0031\u0030\u0020\u0031\u0030\u0020\u0054\u0064")
	// _gbdab := "\u0055\u006e\u006c\u0069\u0063\u0065\u006e\u0073\u0065\u0064\u0020\u0055\u006e\u0069\u0044o\u0063\u0020\u002d\u0020\u0047\u0065\u0074\u0020\u0061\u0020\u006c\u0069\u0063e\u006e\u0073\u0065\u0020\u006f\u006e\u0020\u0068\u0074\u0074\u0070\u0073:/\u002f\u0075\u006e\u0069\u0064\u006f\u0063\u002e\u0069\u006f"
	// _edgag = append(_edgag, _b.Sprintf("\u0028%\u0073\u0029\u0020\u0054\u006a", _gbdab))
	// _edgag = append(_edgag, "\u0045\u0054")
	// _edgag = append(_edgag, "\u0051")
	// _dfbaf := _gc.Join(_edgag, "\u000a")
	// _dgca.AddContentStreamByString(_dfbaf)
	_dgca.ToPdfObject()
}

// GetParamsDict returns *core.PdfObjectDictionary with a set of basic image parameters.
func (_beac *Image) GetParamsDict() *_agf.PdfObjectDictionary {
	_dbcad := _agf.MakeDict()
	_dbcad.Set("\u0057\u0069\u0064t\u0068", _agf.MakeInteger(_beac.Width))
	_dbcad.Set("\u0048\u0065\u0069\u0067\u0068\u0074", _agf.MakeInteger(_beac.Height))
	_dbcad.Set("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073", _agf.MakeInteger(int64(_beac.ColorComponents)))
	_dbcad.Set("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074", _agf.MakeInteger(_beac.BitsPerComponent))
	return _dbcad
}
func (_cdbcd *pdfFontSimple) updateStandard14Font() {
	_abbac, _fbbcg := _cdbcd.Encoder().(_fcg.SimpleEncoder)
	if !_fbbcg {
		_fd.Log.Error("\u0057\u0072\u006f\u006e\u0067\u0020\u0065\u006e\u0063\u006f\u0064\u0065\u0072\u0020\u0074y\u0070e\u003a\u0020\u0025\u0054\u002e\u0020\u0066\u006f\u006e\u0074\u003d\u0025\u0073\u002e", _cdbcd.Encoder(), _cdbcd)
		return
	}
	_cfea := _abbac.Charcodes()
	_cdbcd._fcad = make(map[_fcg.CharCode]float64, len(_cfea))
	for _, _cfffd := range _cfea {
		_aaded, _ := _abbac.CharcodeToRune(_cfffd)
		_ffegd, _ := _cdbcd._fbgbg.Read(_aaded)
		_cdbcd._fcad[_cfffd] = _ffegd.Wx
	}
}

// GetContainingPdfObject returns the container of the outline tree node (indirect object).
func (_fgcfa *PdfOutlineTreeNode) GetContainingPdfObject() _agf.PdfObject {
	return _fgcfa.GetContext().GetContainingPdfObject()
}
func _bbcc(_ebfca *_agf.PdfIndirectObject, _gfcbf *_agf.PdfObjectDictionary) (*DSS, error) {
	if _ebfca == nil {
		_ebfca = _agf.MakeIndirectObject(nil)
	}
	_ebfca.PdfObject = _agf.MakeDict()
	_fcfg := map[string]*VRI{}
	if _aeefe, _fagcf := _agf.GetDict(_gfcbf.Get("\u0056\u0052\u0049")); _fagcf {
		for _, _adcdg := range _aeefe.Keys() {
			if _gfdb, _bgfgg := _agf.GetDict(_aeefe.Get(_adcdg)); _bgfgg {
				_fcfg[_gc.ToUpper(_adcdg.String())] = _beeeb(_gfdb)
			}
		}
	}
	return &DSS{Certs: _cdcfg(_gfcbf.Get("\u0043\u0065\u0072t\u0073")), OCSPs: _cdcfg(_gfcbf.Get("\u004f\u0043\u0053P\u0073")), CRLs: _cdcfg(_gfcbf.Get("\u0043\u0052\u004c\u0073")), VRI: _fcfg, _dgfbc: _ebfca}, nil
}

// SetAlpha sets the alpha layer for the image.
func (_cbeg *Image) SetAlpha(alpha []byte) { _cbeg._gdga = alpha }

// ToPdfObject returns the PDF representation of the tiling pattern.
func (_ffcb *PdfTilingPattern) ToPdfObject() _agf.PdfObject {
	_ffcb.PdfPattern.ToPdfObject()
	_ffagcb := _ffcb.getDict()
	if _ffcb.PaintType != nil {
		_ffagcb.Set("\u0050a\u0069\u006e\u0074\u0054\u0079\u0070e", _ffcb.PaintType)
	}
	if _ffcb.TilingType != nil {
		_ffagcb.Set("\u0054\u0069\u006c\u0069\u006e\u0067\u0054\u0079\u0070\u0065", _ffcb.TilingType)
	}
	if _ffcb.BBox != nil {
		_ffagcb.Set("\u0042\u0042\u006f\u0078", _ffcb.BBox.ToPdfObject())
	}
	if _ffcb.XStep != nil {
		_ffagcb.Set("\u0058\u0053\u0074e\u0070", _ffcb.XStep)
	}
	if _ffcb.YStep != nil {
		_ffagcb.Set("\u0059\u0053\u0074e\u0070", _ffcb.YStep)
	}
	if _ffcb.Resources != nil {
		_ffagcb.Set("\u0052e\u0073\u006f\u0075\u0072\u0063\u0065s", _ffcb.Resources.ToPdfObject())
	}
	if _ffcb.Matrix != nil {
		_ffagcb.Set("\u004d\u0061\u0074\u0072\u0069\u0078", _ffcb.Matrix)
	}
	return _ffcb._efed
}

// PdfActionGoTo3DView represents a GoTo3DView action.
type PdfActionGoTo3DView struct {
	*PdfAction
	TA _agf.PdfObject
	V  _agf.PdfObject
}

// ToPdfObject implements interface PdfModel.
func (_cgb *PdfActionLaunch) ToPdfObject() _agf.PdfObject {
	_cgb.PdfAction.ToPdfObject()
	_fce := _cgb._caf
	_feb := _fce.PdfObject.(*_agf.PdfObjectDictionary)
	_feb.SetIfNotNil("\u0053", _agf.MakeName(string(ActionTypeLaunch)))
	if _cgb.F != nil {
		_feb.Set("\u0046", _cgb.F.ToPdfObject())
	}
	_feb.SetIfNotNil("\u0057\u0069\u006e", _cgb.Win)
	_feb.SetIfNotNil("\u004d\u0061\u0063", _cgb.Mac)
	_feb.SetIfNotNil("\u0055\u006e\u0069\u0078", _cgb.Unix)
	_feb.SetIfNotNil("\u004ee\u0077\u0057\u0069\u006e\u0064\u006fw", _cgb.NewWindow)
	return _fce
}

// ToPdfObject returns the PDF representation of the colorspace.
func (_debe *PdfColorspaceSpecialPattern) ToPdfObject() _agf.PdfObject {
	if _debe.UnderlyingCS == nil {
		return _agf.MakeName("\u0050a\u0074\u0074\u0065\u0072\u006e")
	}
	_cfge := _agf.MakeArray(_agf.MakeName("\u0050a\u0074\u0074\u0065\u0072\u006e"))
	_cfge.Append(_debe.UnderlyingCS.ToPdfObject())
	if _debe._eecg != nil {
		_debe._eecg.PdfObject = _cfge
		return _debe._eecg
	}
	return _cfge
}

// Has checks if flag fl is set in flag and returns true if so, false otherwise.
func (_egdg FieldFlag) Has(fl FieldFlag) bool { return (_egdg.Mask() & fl.Mask()) > 0 }

// NewBorderStyle returns an initialized PdfBorderStyle.
func NewBorderStyle() *PdfBorderStyle { _geabd := &PdfBorderStyle{}; return _geabd }

// ToInteger convert to an integer format.
func (_acbe *PdfColorCalGray) ToInteger(bits int) uint32 {
	_caab := _afb.Pow(2, float64(bits)) - 1
	return uint32(_caab * _acbe.Val())
}

// GetObjectNums returns the object numbers of the PDF objects in the file
// Numbered objects are either indirect objects or stream objects.
// e.g. objNums := pdfReader.GetObjectNums()
// The underlying objects can then be accessed with
// pdfReader.GetIndirectObjectByNumber(objNums[0]) for the first available object.
func (_bedbe *PdfReader) GetObjectNums() []int { return _bedbe._egdga.GetObjectNums() }

// ToPdfObject implements interface PdfModel.
func (_ebgcf *PdfFilespec) ToPdfObject() _agf.PdfObject {
	_abdf := _ebgcf.getDict()
	_abdf.Clear()
	_abdf.Set("\u0054\u0079\u0070\u0065", _agf.MakeName("\u0046\u0069\u006c\u0065\u0073\u0070\u0065\u0063"))
	_abdf.SetIfNotNil("\u0046\u0053", _ebgcf.FS)
	_abdf.SetIfNotNil("\u0046", _ebgcf.F)
	_abdf.SetIfNotNil("\u0055\u0046", _ebgcf.UF)
	_abdf.SetIfNotNil("\u0044\u004f\u0053", _ebgcf.DOS)
	_abdf.SetIfNotNil("\u004d\u0061\u0063", _ebgcf.Mac)
	_abdf.SetIfNotNil("\u0055\u006e\u0069\u0078", _ebgcf.Unix)
	_abdf.SetIfNotNil("\u0049\u0044", _ebgcf.ID)
	_abdf.SetIfNotNil("\u0056", _ebgcf.V)
	_abdf.SetIfNotNil("\u0045\u0046", _ebgcf.EF)
	_abdf.SetIfNotNil("\u0052\u0046", _ebgcf.RF)
	_abdf.SetIfNotNil("\u0044\u0065\u0073\u0063", _ebgcf.Desc)
	_abdf.SetIfNotNil("\u0043\u0049", _ebgcf.CI)
	return _ebgcf._bfdc
}

// EnableAll LTV enables all signatures in the PDF document.
// The signing certificate chain is extracted from each signature dictionary.
// Optionally, additional certificates can be specified through the
// `extraCerts` parameter. The LTV client attempts to build the certificate
// chain up to a trusted root by downloading any missing certificates.
func (_feef *LTV) EnableAll(extraCerts []*_ed.Certificate) error {
	_cagdf := _feef._daebc._gdeb.AcroForm
	for _, _fbefa := range _cagdf.AllFields() {
		_decgb, _ := _fbefa.GetContext().(*PdfFieldSignature)
		if _decgb == nil {
			continue
		}
		_dedad := _decgb.V
		if _dfecbe := _feef.validateSig(_dedad); _dfecbe != nil {
			_fd.Log.Debug("\u0057\u0041\u0052N\u003a\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020f\u0069\u0065\u006c\u0064\u003a\u0020\u0025\u0076", _dfecbe)
		}
		if _bbada := _feef.Enable(_dedad, extraCerts); _bbada != nil {
			return _bbada
		}
	}
	return nil
}

// GetPreviousRevision returns the previous revision of PdfReader for the Pdf document
func (_abgbf *PdfReader) GetPreviousRevision() (*PdfReader, error) {
	if _abgbf._egdga.GetRevisionNumber() == 0 {
		return nil, _gcd.New("\u0070\u0072e\u0076\u0069\u006f\u0075\u0073\u0020\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0065xi\u0073\u0074")
	}
	if _bacdc, _fafcb := _abgbf._gaaabg[_abgbf]; _fafcb {
		return _bacdc, nil
	}
	_daccb, _fecc := _abgbf._egdga.GetPreviousRevisionReadSeeker()
	if _fecc != nil {
		return nil, _fecc
	}
	_ccaff, _fecc := _dcab(_daccb, _abgbf._ddgee, _abgbf._gdab, "\u006do\u0064\u0065\u006c\u003aG\u0065\u0074\u0050\u0072\u0065v\u0069o\u0075s\u0052\u0065\u0076\u0069\u0073\u0069\u006fn")
	if _fecc != nil {
		return nil, _fecc
	}
	_abgbf._fged[_abgbf._egdga.GetRevisionNumber()-1] = _ccaff
	_abgbf._gaaabg[_abgbf] = _ccaff
	_ccaff._gaaabg = _abgbf._gaaabg
	return _ccaff, nil
}

// SetFlag sets the flag for the field.
func (_dcbd *PdfField) SetFlag(flag FieldFlag) { _dcbd.Ff = _agf.MakeInteger(int64(flag)) }

// GetFontByName gets the font specified by keyName. Returns the PdfObject which
// the entry refers to. Returns a bool value indicating whether or not the entry was found.
func (_ecfag *PdfPageResources) GetFontByName(keyName _agf.PdfObjectName) (_agf.PdfObject, bool) {
	if _ecfag.Font == nil {
		return nil, false
	}
	_gcegea, _ebaa := _agf.TraceToDirectObject(_ecfag.Font).(*_agf.PdfObjectDictionary)
	if !_ebaa {
		_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u006f\u006e\u0074\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069\u006fn\u0061\u0072\u0079\u0021\u0020(\u0067\u006ft\u0020\u0025\u0054\u0029", _agf.TraceToDirectObject(_ecfag.Font))
		return nil, false
	}
	if _fbedd := _gcegea.Get(keyName); _fbedd != nil {
		return _fbedd, true
	}
	return nil, false
}

// C returns the value of the cyan component of the color.
func (_geec *PdfColorDeviceCMYK) C() float64 { return _geec[0] }

// B returns the value of the B component of the color.
func (_egae *PdfColorLab) B() float64 { return _egae[2] }

// ToPdfObject implements interface PdfModel.
func (_bca *PdfActionSound) ToPdfObject() _agf.PdfObject {
	_bca.PdfAction.ToPdfObject()
	_abc := _bca._caf
	_dg := _abc.PdfObject.(*_agf.PdfObjectDictionary)
	_dg.SetIfNotNil("\u0053", _agf.MakeName(string(ActionTypeSound)))
	_dg.SetIfNotNil("\u0053\u006f\u0075n\u0064", _bca.Sound)
	_dg.SetIfNotNil("\u0056\u006f\u006c\u0075\u006d\u0065", _bca.Volume)
	_dg.SetIfNotNil("S\u0079\u006e\u0063\u0068\u0072\u006f\u006e\u006f\u0075\u0073", _bca.Synchronous)
	_dg.SetIfNotNil("\u0052\u0065\u0070\u0065\u0061\u0074", _bca.Repeat)
	_dg.SetIfNotNil("\u004d\u0069\u0078", _bca.Mix)
	return _abc
}

// ToPdfObject implements interface PdfModel.
func (_gege *PdfAnnotationMovie) ToPdfObject() _agf.PdfObject {
	_gege.PdfAnnotation.ToPdfObject()
	_dbe := _gege._aeee
	_egff := _dbe.PdfObject.(*_agf.PdfObjectDictionary)
	_egff.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _agf.MakeName("\u004d\u006f\u0076i\u0065"))
	_egff.SetIfNotNil("\u0054", _gege.T)
	_egff.SetIfNotNil("\u004d\u006f\u0076i\u0065", _gege.Movie)
	_egff.SetIfNotNil("\u0041", _gege.A)
	return _dbe
}

// ToPdfObject returns the PDF representation of the function.
func (_dcgf *PdfFunctionType2) ToPdfObject() _agf.PdfObject {
	_cgbge := _agf.MakeDict()
	_cgbge.Set("\u0046\u0075\u006ec\u0074\u0069\u006f\u006e\u0054\u0079\u0070\u0065", _agf.MakeInteger(2))
	_ceag := &_agf.PdfObjectArray{}
	for _, _bgec := range _dcgf.Domain {
		_ceag.Append(_agf.MakeFloat(_bgec))
	}
	_cgbge.Set("\u0044\u006f\u006d\u0061\u0069\u006e", _ceag)
	if _dcgf.Range != nil {
		_efbcc := &_agf.PdfObjectArray{}
		for _, _abga := range _dcgf.Range {
			_efbcc.Append(_agf.MakeFloat(_abga))
		}
		_cgbge.Set("\u0052\u0061\u006eg\u0065", _efbcc)
	}
	if _dcgf.C0 != nil {
		_gebg := &_agf.PdfObjectArray{}
		for _, _bbfd := range _dcgf.C0 {
			_gebg.Append(_agf.MakeFloat(_bbfd))
		}
		_cgbge.Set("\u0043\u0030", _gebg)
	}
	if _dcgf.C1 != nil {
		_edcf := &_agf.PdfObjectArray{}
		for _, _ebaba := range _dcgf.C1 {
			_edcf.Append(_agf.MakeFloat(_ebaba))
		}
		_cgbge.Set("\u0043\u0031", _edcf)
	}
	_cgbge.Set("\u004e", _agf.MakeFloat(_dcgf.N))
	if _dcgf._ecgd != nil {
		_dcgf._ecgd.PdfObject = _cgbge
		return _dcgf._ecgd
	}
	return _cgbge
}

// GetContext returns the annotation context which contains the specific type-dependent context.
// The context represents the subannotation.
func (_gcc *PdfAnnotation) GetContext() PdfModel {
	if _gcc == nil {
		return nil
	}
	return _gcc._eef
}

// ToJBIG2Image converts current image to the core.JBIG2Image.
func (_bggce *Image) ToJBIG2Image() (*_agf.JBIG2Image, error) {
	_cbdfe, _gbcfc := _bggce.ToGoImage()
	if _gbcfc != nil {
		return nil, _gbcfc
	}
	return _agf.GoImageToJBIG2(_cbdfe, _agf.JB2ImageAutoThreshold)
}

// Val returns the value of the color.
func (_ccgbb *PdfColorCalGray) Val() float64 { return float64(*_ccgbb) }
func (_gbgg *PdfReader) newPdfAnnotationLineFromDict(_agfb *_agf.PdfObjectDictionary) (*PdfAnnotationLine, error) {
	_aeeg := PdfAnnotationLine{}
	_dgce, _cef := _gbgg.newPdfAnnotationMarkupFromDict(_agfb)
	if _cef != nil {
		return nil, _cef
	}
	_aeeg.PdfAnnotationMarkup = _dgce
	_aeeg.L = _agfb.Get("\u004c")
	_aeeg.BS = _agfb.Get("\u0042\u0053")
	_aeeg.LE = _agfb.Get("\u004c\u0045")
	_aeeg.IC = _agfb.Get("\u0049\u0043")
	_aeeg.LL = _agfb.Get("\u004c\u004c")
	_aeeg.LLE = _agfb.Get("\u004c\u004c\u0045")
	_aeeg.Cap = _agfb.Get("\u0043\u0061\u0070")
	_aeeg.IT = _agfb.Get("\u0049\u0054")
	_aeeg.LLO = _agfb.Get("\u004c\u004c\u004f")
	_aeeg.CP = _agfb.Get("\u0043\u0050")
	_aeeg.Measure = _agfb.Get("\u004de\u0061\u0073\u0075\u0072\u0065")
	_aeeg.CO = _agfb.Get("\u0043\u004f")
	return &_aeeg, nil
}

// ToPdfObject returns a PDF object representation of the outline item.
func (_fgfgg *OutlineItem) ToPdfObject() _agf.PdfObject {
	_ggaf, _ := _fgfgg.ToPdfOutlineItem()
	return _ggaf.ToPdfObject()
}

// ToPdfObject implements interface PdfModel.
func (_fcfcd *PdfAnnotationPopup) ToPdfObject() _agf.PdfObject {
	_fcfcd.PdfAnnotation.ToPdfObject()
	_faf := _fcfcd._aeee
	_gbdb := _faf.PdfObject.(*_agf.PdfObjectDictionary)
	_gbdb.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _agf.MakeName("\u0050\u006f\u0070u\u0070"))
	_gbdb.SetIfNotNil("\u0050\u0061\u0072\u0065\u006e\u0074", _fcfcd.Parent)
	_gbdb.SetIfNotNil("\u004f\u0070\u0065\u006e", _fcfcd.Open)
	return _faf
}

// GetContentStreamObjs returns a slice of PDF objects containing the content
// streams of the page.
func (_dgegb *PdfPage) GetContentStreamObjs() []_agf.PdfObject {
	if _dgegb.Contents == nil {
		return nil
	}
	_bfcdb := _agf.TraceToDirectObject(_dgegb.Contents)
	if _eccfb, _fcadf := _bfcdb.(*_agf.PdfObjectArray); _fcadf {
		return _eccfb.Elements()
	}
	return []_agf.PdfObject{_bfcdb}
}

const (
	TrappedUnknown PdfInfoTrapped = "\u0055n\u006b\u006e\u006f\u0077\u006e"
	TrappedTrue    PdfInfoTrapped = "\u0054\u0072\u0075\u0065"
	TrappedFalse   PdfInfoTrapped = "\u0046\u0061\u006cs\u0065"
)

// PdfAnnotationCircle represents Circle annotations.
// (Section 12.5.6.8).
type PdfAnnotationCircle struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	BS _agf.PdfObject
	IC _agf.PdfObject
	BE _agf.PdfObject
	RD _agf.PdfObject
}

// GetType returns the button field type which returns one of the following
// - PdfFieldButtonPush for push button fields
// - PdfFieldButtonCheckbox for checkbox fields
// - PdfFieldButtonRadio for radio button fields
func (_caee *PdfFieldButton) GetType() ButtonType {
	_ecaba := ButtonTypeCheckbox
	if _caee.Ff != nil {
		if (uint32(*_caee.Ff) & FieldFlagPushbutton.Mask()) > 0 {
			_ecaba = ButtonTypePush
		} else if (uint32(*_caee.Ff) & FieldFlagRadio.Mask()) > 0 {
			_ecaba = ButtonTypeRadio
		}
	}
	return _ecaba
}
func _afce(_aca _agf.PdfObject) (*PdfBorderStyle, error) {
	_gfaf := &PdfBorderStyle{}
	_gfaf._eegdd = _aca
	var _ebdb *_agf.PdfObjectDictionary
	_aca = _agf.TraceToDirectObject(_aca)
	_ebdb, _ecdec := _aca.(*_agf.PdfObjectDictionary)
	if !_ecdec {
		return nil, _gcd.New("\u0074\u0079\u0070\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	if _aefd := _ebdb.Get("\u0054\u0079\u0070\u0065"); _aefd != nil {
		_ccd, _adbb := _aefd.(*_agf.PdfObjectName)
		if !_adbb {
			_fd.Log.Debug("I\u006e\u0063\u006f\u006d\u0070\u0061\u0074\u0069\u0062i\u006c\u0069\u0074\u0079\u0020\u0077\u0069th\u0020\u0054\u0079\u0070e\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006e\u0061me\u0020\u006fb\u006a\u0065\u0063\u0074\u003a\u0020\u0025\u0054", _aefd)
		} else {
			if *_ccd != "\u0042\u006f\u0072\u0064\u0065\u0072" {
				_fd.Log.Debug("W\u0061\u0072\u006e\u0069\u006e\u0067,\u0020\u0054\u0079\u0070\u0065\u0020\u0021\u003d\u0020B\u006f\u0072\u0064e\u0072:\u0020\u0025\u0073", *_ccd)
			}
		}
	}
	if _ggfd := _ebdb.Get("\u0057"); _ggfd != nil {
		_dgea, _cefg := _agf.GetNumberAsFloat(_ggfd)
		if _cefg != nil {
			_fd.Log.Debug("\u0045\u0072\u0072\u006fr \u0072\u0065\u0074\u0072\u0069\u0065\u0076\u0069\u006e\u0067\u0020\u0057\u003a\u0020%\u0076", _cefg)
			return nil, _cefg
		}
		_gfaf.W = &_dgea
	}
	if _bbdd := _ebdb.Get("\u0053"); _bbdd != nil {
		_bffd, _fdab := _bbdd.(*_agf.PdfObjectName)
		if !_fdab {
			return nil, _gcd.New("\u0062\u006f\u0072\u0064\u0065\u0072\u0020\u0053\u0020\u006e\u006ft\u0020\u0061\u0020\u006e\u0061\u006d\u0065\u0020\u006f\u0062j\u0065\u0063\u0074")
		}
		var _daf BorderStyle
		switch *_bffd {
		case "\u0053":
			_daf = BorderStyleSolid
		case "\u0044":
			_daf = BorderStyleDashed
		case "\u0042":
			_daf = BorderStyleBeveled
		case "\u0049":
			_daf = BorderStyleInset
		case "\u0055":
			_daf = BorderStyleUnderline
		default:
			_fd.Log.Debug("I\u006e\u0076\u0061\u006cid\u0020s\u0074\u0079\u006c\u0065\u0020n\u0061\u006d\u0065\u0020\u0025\u0073", *_bffd)
			return nil, _gcd.New("\u0073\u0074\u0079\u006ce \u0074\u0079\u0070\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065c\u006b")
		}
		_gfaf.S = &_daf
	}
	if _acab := _ebdb.Get("\u0044"); _acab != nil {
		_dadb, _eedc := _acab.(*_agf.PdfObjectArray)
		if !_eedc {
			_fd.Log.Debug("\u0042\u006f\u0072\u0064\u0065\u0072\u0020\u0044\u0020\u0064a\u0073\u0068\u0020\u006e\u006f\u0074\u0020a\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u003a\u0020\u0025\u0054", _acab)
			return nil, _gcd.New("\u0062o\u0072\u0064\u0065\u0072 \u0044\u0020\u0074\u0079\u0070e\u0020c\u0068e\u0063\u006b\u0020\u0065\u0072\u0072\u006fr")
		}
		_dgfb, _ecbe := _dadb.ToIntegerArray()
		if _ecbe != nil {
			_fd.Log.Debug("\u0042\u006f\u0072\u0064\u0065\u0072\u0020\u0044 \u0050\u0072\u006fbl\u0065\u006d\u0020\u0063\u006f\u006ev\u0065\u0072\u0074\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0069\u006e\u0074\u0065\u0067e\u0072\u0020\u0061\u0072\u0072\u0061\u0079\u003a \u0025\u0076", _ecbe)
			return nil, _ecbe
		}
		_gfaf.D = &_dgfb
	}
	return _gfaf, nil
}

// GetPageAsIndirectObject returns the page as a dictionary within an PdfIndirectObject.
func (_ffdg *PdfPage) GetPageAsIndirectObject() *_agf.PdfIndirectObject { return _ffdg._edegf }
func (_gegbf *PdfWriter) copyObjects() {
	_ceaade := make(map[_agf.PdfObject]_agf.PdfObject)
	_gbdgc := make([]_agf.PdfObject, 0, len(_gegbf._dgbd))
	_dgbef := make(map[_agf.PdfObject]struct{}, len(_gegbf._dgbd))
	_cffgd := make(map[_agf.PdfObject]struct{})
	for _, _ddca := range _gegbf._dgbd {
		_begda := _gegbf.copyObject(_ddca, _ceaade, _cffgd, false)
		if _, _bgaf := _cffgd[_ddca]; _bgaf {
			continue
		}
		_gbdgc = append(_gbdgc, _begda)
		_dgbef[_begda] = struct{}{}
	}
	_gegbf._dgbd = _gbdgc
	_gegbf._ccbbf = _dgbef
	_gegbf._eaaaab = _gegbf.copyObject(_gegbf._eaaaab, _ceaade, nil, false).(*_agf.PdfIndirectObject)
	_gegbf._eccfaf = _gegbf.copyObject(_gegbf._eccfaf, _ceaade, nil, false).(*_agf.PdfIndirectObject)
	if _gegbf._gdcbf != nil {
		_gegbf._gdcbf = _gegbf.copyObject(_gegbf._gdcbf, _ceaade, nil, false).(*_agf.PdfIndirectObject)
	}
	if _gegbf._accad {
		_degfb := make(map[_agf.PdfObject]int64)
		for _agdca, _acbdg := range _gegbf._efgaf {
			if _dcbfgg, _bdfbg := _ceaade[_agdca]; _bdfbg {
				_degfb[_dcbfgg] = _acbdg
			} else {
				_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020a\u0070\u0070\u0065n\u0064\u0020\u006d\u006fd\u0065\u0020\u002d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0063\u006f\u0070\u0079\u0020\u006e\u006f\u0074\u0020\u0069\u006e\u0020\u006d\u0061\u0070")
			}
		}
		_gegbf._efgaf = _degfb
	}
}
func (_cded *PdfColorspaceSpecialIndexed) String() string {
	return "\u0049n\u0064\u0065\u0078\u0065\u0064"
}
func (_eaadg *PdfWriter) writeObjectsInStreams(_accd map[_agf.PdfObject]bool) error {
	for _, _ccefd := range _eaadg._dgbd {
		if _ccdee := _accd[_ccefd]; _ccdee {
			continue
		}
		_dffbdd := int64(0)
		switch _fdedg := _ccefd.(type) {
		case *_agf.PdfIndirectObject:
			_dffbdd = _fdedg.ObjectNumber
		case *_agf.PdfObjectStream:
			_dffbdd = _fdedg.ObjectNumber
		case *_agf.PdfObjectStreams:
			_dffbdd = _fdedg.ObjectNumber
		default:
			_fd.Log.Debug("\u0045R\u0052\u004fR\u003a\u0020\u0055n\u0073\u0075\u0070\u0070\u006f\u0072\u0074e\u0064\u0020\u0074\u0079\u0070\u0065 \u0069\u006e\u0020\u0077\u0072\u0069\u0074\u0065\u0072\u0020\u006fb\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0054", _ccefd)
			return ErrTypeCheck
		}
		if _eaadg._cecgd != nil && _ccefd != _eaadg._gdcbf {
			_ebdfg := _eaadg._cecgd.Encrypt(_ccefd, _dffbdd, 0)
			if _ebdfg != nil {
				_fd.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067\u0020(%\u0073\u0029", _ebdfg)
				return _ebdfg
			}
		}
		_eaadg.writeObject(int(_dffbdd), _ccefd)
	}
	return nil
}

// ToPdfObject returns colorspace in a PDF object format [name dictionary]
func (_agbf *PdfColorspaceCalRGB) ToPdfObject() _agf.PdfObject {
	_gbagd := &_agf.PdfObjectArray{}
	_gbagd.Append(_agf.MakeName("\u0043\u0061\u006c\u0052\u0047\u0042"))
	_bfgbf := _agf.MakeDict()
	if _agbf.WhitePoint != nil {
		_fcgc := _agf.MakeArray(_agf.MakeFloat(_agbf.WhitePoint[0]), _agf.MakeFloat(_agbf.WhitePoint[1]), _agf.MakeFloat(_agbf.WhitePoint[2]))
		_bfgbf.Set("\u0057\u0068\u0069\u0074\u0065\u0050\u006f\u0069\u006e\u0074", _fcgc)
	} else {
		_fd.Log.Error("\u0043\u0061l\u0052\u0047\u0042\u003a \u004d\u0069s\u0073\u0069\u006e\u0067\u0020\u0057\u0068\u0069t\u0065\u0050\u006f\u0069\u006e\u0074\u0020\u0028\u0052\u0065\u0071\u0075i\u0072\u0065\u0064\u0029")
	}
	if _agbf.BlackPoint != nil {
		_ffad := _agf.MakeArray(_agf.MakeFloat(_agbf.BlackPoint[0]), _agf.MakeFloat(_agbf.BlackPoint[1]), _agf.MakeFloat(_agbf.BlackPoint[2]))
		_bfgbf.Set("\u0042\u006c\u0061\u0063\u006b\u0050\u006f\u0069\u006e\u0074", _ffad)
	}
	if _agbf.Gamma != nil {
		_debge := _agf.MakeArray(_agf.MakeFloat(_agbf.Gamma[0]), _agf.MakeFloat(_agbf.Gamma[1]), _agf.MakeFloat(_agbf.Gamma[2]))
		_bfgbf.Set("\u0047\u0061\u006dm\u0061", _debge)
	}
	if _agbf.Matrix != nil {
		_dfec := _agf.MakeArray(_agf.MakeFloat(_agbf.Matrix[0]), _agf.MakeFloat(_agbf.Matrix[1]), _agf.MakeFloat(_agbf.Matrix[2]), _agf.MakeFloat(_agbf.Matrix[3]), _agf.MakeFloat(_agbf.Matrix[4]), _agf.MakeFloat(_agbf.Matrix[5]), _agf.MakeFloat(_agbf.Matrix[6]), _agf.MakeFloat(_agbf.Matrix[7]), _agf.MakeFloat(_agbf.Matrix[8]))
		_bfgbf.Set("\u004d\u0061\u0074\u0072\u0069\u0078", _dfec)
	}
	_gbagd.Append(_bfgbf)
	if _agbf._febbc != nil {
		_agbf._febbc.PdfObject = _gbagd
		return _agbf._febbc
	}
	return _gbagd
}

// DecodeArray returns the range of color component values in CalRGB colorspace.
func (_dcdb *PdfColorspaceCalRGB) DecodeArray() []float64 {
	return []float64{0.0, 1.0, 0.0, 1.0, 0.0, 1.0}
}

// ToPdfObject implements interface PdfModel.
func (_egdc *PdfActionNamed) ToPdfObject() _agf.PdfObject {
	_egdc.PdfAction.ToPdfObject()
	_cde := _egdc._caf
	_bce := _cde.PdfObject.(*_agf.PdfObjectDictionary)
	_bce.SetIfNotNil("\u0053", _agf.MakeName(string(ActionTypeNamed)))
	_bce.SetIfNotNil("\u004e", _egdc.N)
	return _cde
}

// GetRuneMetrics returns the character metrics for the specified rune.
// A bool flag is returned to indicate whether or not the entry was found.
func (_fgded pdfFontType3) GetRuneMetrics(r rune) (_aa.CharMetrics, bool) {
	_bggcf := _fgded.Encoder()
	if _bggcf == nil {
		_fd.Log.Debug("\u004e\u006f\u0020en\u0063\u006f\u0064\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0066\u006f\u006e\u0074\u0073\u003d\u0025\u0073", _fgded)
		return _aa.CharMetrics{}, false
	}
	_adcf, _eefagb := _bggcf.RuneToCharcode(r)
	if !_eefagb {
		if r != ' ' {
			_fd.Log.Trace("\u004e\u006f\u0020c\u0068\u0061\u0072\u0063o\u0064\u0065\u0020\u0066\u006f\u0072\u0020r\u0075\u006e\u0065\u003d\u0025\u0076\u0020\u0066\u006f\u006e\u0074\u003d\u0025\u0073", r, _fgded)
		}
		return _aa.CharMetrics{}, false
	}
	_dgdg, _fdfee := _fgded.GetCharMetrics(_adcf)
	return _dgdg, _fdfee
}

// DetermineColorspaceNameFromPdfObject determines PDF colorspace from a PdfObject.  Returns the colorspace name and
// an error on failure. If the colorspace was not found, will return an empty string.
func DetermineColorspaceNameFromPdfObject(obj _agf.PdfObject) (_agf.PdfObjectName, error) {
	var _edcdd *_agf.PdfObjectName
	var _ccaf *_agf.PdfObjectArray
	if _gfgg, _fdgg := obj.(*_agf.PdfIndirectObject); _fdgg {
		if _abba, _aacg := _gfgg.PdfObject.(*_agf.PdfObjectArray); _aacg {
			_ccaf = _abba
		} else if _ggeg, _dbff := _gfgg.PdfObject.(*_agf.PdfObjectName); _dbff {
			_edcdd = _ggeg
		}
	} else if _gbcg, _agac := obj.(*_agf.PdfObjectArray); _agac {
		_ccaf = _gbcg
	} else if _cbbf, _cfebf := obj.(*_agf.PdfObjectName); _cfebf {
		_edcdd = _cbbf
	}
	if _edcdd != nil {
		switch *_edcdd {
		case "\u0044\u0065\u0076\u0069\u0063\u0065\u0047\u0072\u0061\u0079", "\u0044e\u0076\u0069\u0063\u0065\u0052\u0047B", "\u0044\u0065\u0076\u0069\u0063\u0065\u0043\u004d\u0059\u004b":
			return *_edcdd, nil
		case "\u0050a\u0074\u0074\u0065\u0072\u006e":
			return *_edcdd, nil
		}
	}
	if _ccaf != nil && _ccaf.Len() > 0 {
		if _cdec, _ceef := _ccaf.Get(0).(*_agf.PdfObjectName); _ceef {
			switch *_cdec {
			case "\u0044\u0065\u0076\u0069\u0063\u0065\u0047\u0072\u0061\u0079", "\u0044e\u0076\u0069\u0063\u0065\u0052\u0047B", "\u0044\u0065\u0076\u0069\u0063\u0065\u0043\u004d\u0059\u004b":
				if _ccaf.Len() == 1 {
					return *_cdec, nil
				}
			case "\u0043a\u006c\u0047\u0072\u0061\u0079", "\u0043\u0061\u006c\u0052\u0047\u0042", "\u004c\u0061\u0062":
				return *_cdec, nil
			case "\u0049\u0043\u0043\u0042\u0061\u0073\u0065\u0064", "\u0050a\u0074\u0074\u0065\u0072\u006e", "\u0049n\u0064\u0065\u0078\u0065\u0064":
				return *_cdec, nil
			case "\u0053\u0065\u0070\u0061\u0072\u0061\u0074\u0069\u006f\u006e", "\u0044e\u0076\u0069\u0063\u0065\u004e":
				return *_cdec, nil
			}
		}
	}
	return "", nil
}

// SetRotation sets the rotation of all pages added to writer. The rotation is
// specified in degrees and must be a multiple of 90.
// The Rotate field of individual pages has priority over the global rotation.
func (_dbegbg *PdfWriter) SetRotation(rotate int64) error {
	_ccdcb, _bebeb := _agf.GetDict(_dbegbg._dgbbfe)
	if !_bebeb {
		return ErrTypeCheck
	}
	_ccdcb.Set("\u0052\u006f\u0074\u0061\u0074\u0065", _agf.MakeInteger(rotate))
	return nil
}

// ToPdfObject converts the pdfCIDFontType2 to a PDF representation.
func (_cffdg *pdfCIDFontType2) ToPdfObject() _agf.PdfObject {
	if _cffdg._efae == nil {
		_cffdg._efae = &_agf.PdfIndirectObject{}
	}
	_ggffb := _cffdg.baseFields().asPdfObjectDictionary("\u0043\u0049\u0044F\u006f\u006e\u0074\u0054\u0079\u0070\u0065\u0032")
	_cffdg._efae.PdfObject = _ggffb
	if _cffdg.CIDSystemInfo != nil {
		_ggffb.Set("\u0043\u0049\u0044\u0053\u0079\u0073\u0074\u0065\u006d\u0049\u006e\u0066\u006f", _cffdg.CIDSystemInfo)
	}
	if _cffdg.DW != nil {
		_ggffb.Set("\u0044\u0057", _cffdg.DW)
	}
	if _cffdg.DW2 != nil {
		_ggffb.Set("\u0044\u0057\u0032", _cffdg.DW2)
	}
	if _cffdg.W != nil {
		_ggffb.Set("\u0057", _cffdg.W)
	}
	if _cffdg.W2 != nil {
		_ggffb.Set("\u0057\u0032", _cffdg.W2)
	}
	if _cffdg.CIDToGIDMap != nil {
		_ggffb.Set("C\u0049\u0044\u0054\u006f\u0047\u0049\u0044\u004d\u0061\u0070", _cffdg.CIDToGIDMap)
	}
	return _cffdg._efae
}

// K returns the value of the key component of the color.
func (_gfbf *PdfColorDeviceCMYK) K() float64 { return _gfbf[3] }

// ColorToRGB converts a DeviceN color to an RGB color.
func (_dcbe *PdfColorspaceDeviceN) ColorToRGB(color PdfColor) (PdfColor, error) {
	if _dcbe.AlternateSpace == nil {
		return nil, _gcd.New("\u0044\u0065\u0076\u0069\u0063\u0065N\u0020\u0061\u006c\u0074\u0065\u0072\u006e\u0061\u0074\u0065\u0020\u0073\u0070a\u0063\u0065\u0020\u0075\u006e\u0064\u0065f\u0069\u006e\u0065\u0064")
	}
	return _dcbe.AlternateSpace.ColorToRGB(color)
}

// NewPdfActionLaunch returns a new "launch" action.
func NewPdfActionLaunch() *PdfActionLaunch {
	_aag := NewPdfAction()
	_aee := &PdfActionLaunch{}
	_aee.PdfAction = _aag
	_aag.SetContext(_aee)
	return _aee
}
func _dcbb(_cdca _agf.PdfObject) (string, error) {
	_cdca = _agf.TraceToDirectObject(_cdca)
	switch _deadbc := _cdca.(type) {
	case *_agf.PdfObjectString:
		return _deadbc.Str(), nil
	case *_agf.PdfObjectStream:
		_dccdg, _geegd := _agf.DecodeStream(_deadbc)
		if _geegd != nil {
			return "", _geegd
		}
		return string(_dccdg), nil
	}
	return "", _b.Errorf("\u0069\u006e\u0076\u0061\u006ci\u0064\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0073\u0074\u0072e\u0061\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0068\u006f\u006c\u0064\u0065\u0072\u0020\u0028\u0025\u0054\u0029", _cdca)
}

// GetXObjectByName gets XObject by name.
func (_ccec *PdfPage) GetXObjectByName(name _agf.PdfObjectName) (_agf.PdfObject, bool) {
	_adcea, _ccagg := _ccec.Resources.XObject.(*_agf.PdfObjectDictionary)
	if !_ccagg {
		return nil, false
	}
	if _gbbf := _adcea.Get(name); _gbbf != nil {
		return _gbbf, true
	}
	return nil, false
}

// ImageToRGB converts image in CalGray color space to RGB (A, B, C -> X, Y, Z).
func (_effbc *PdfColorspaceCalGray) ImageToRGB(img Image) (Image, error) {
	_eaga := _db.NewReader(img.getBase())
	_fdccc := _ged.NewImageBase(int(img.Width), int(img.Height), int(img.BitsPerComponent), 3, nil, nil, nil)
	_afda := _db.NewWriter(_fdccc)
	_cbeb := _afb.Pow(2, float64(img.BitsPerComponent)) - 1
	_bgebf := make([]uint32, 3)
	var (
		_eabdf                               uint32
		ANorm, X, Y, Z, _bebb, _adbga, _gadg float64
		_dcd                                 error
	)
	for {
		_eabdf, _dcd = _eaga.ReadSample()
		if _dcd == _cf.EOF {
			break
		} else if _dcd != nil {
			return img, _dcd
		}
		ANorm = float64(_eabdf) / _cbeb
		X = _effbc.WhitePoint[0] * _afb.Pow(ANorm, _effbc.Gamma)
		Y = _effbc.WhitePoint[1] * _afb.Pow(ANorm, _effbc.Gamma)
		Z = _effbc.WhitePoint[2] * _afb.Pow(ANorm, _effbc.Gamma)
		_bebb = 3.240479*X + -1.537150*Y + -0.498535*Z
		_adbga = -0.969256*X + 1.875992*Y + 0.041556*Z
		_gadg = 0.055648*X + -0.204043*Y + 1.057311*Z
		_bebb = _afb.Min(_afb.Max(_bebb, 0), 1.0)
		_adbga = _afb.Min(_afb.Max(_adbga, 0), 1.0)
		_gadg = _afb.Min(_afb.Max(_gadg, 0), 1.0)
		_bgebf[0] = uint32(_bebb * _cbeb)
		_bgebf[1] = uint32(_adbga * _cbeb)
		_bgebf[2] = uint32(_gadg * _cbeb)
		if _dcd = _afda.WriteSamples(_bgebf); _dcd != nil {
			return img, _dcd
		}
	}
	return _ddgg(&_fdccc), nil
}

type fontCommon struct {
	_fccf   string
	_bcbfd  string
	_afbeb  string
	_ebabcd _agf.PdfObject
	_egfbf  *_ce.CMap
	_dcfcb  *PdfFontDescriptor
	_gcdfc  int64
}

func (_bbgf *PdfReader) newPdfAnnotationWatermarkFromDict(_aac *_agf.PdfObjectDictionary) (*PdfAnnotationWatermark, error) {
	_fde := PdfAnnotationWatermark{}
	_fde.FixedPrint = _aac.Get("\u0046\u0069\u0078\u0065\u0064\u0050\u0072\u0069\u006e\u0074")
	return &_fde, nil
}

// PdfActionJavaScript represents a javaScript action.
type PdfActionJavaScript struct {
	*PdfAction
	JS _agf.PdfObject
}

// Register registers (caches) a model to primitive object relationship.
func (_edcc *modelManager) Register(primitive _agf.PdfObject, model PdfModel) {
	_edcc._bggfd[model] = primitive
	_edcc._ccbc[primitive] = model
}

// NewCompositePdfFontFromTTF loads a composite TTF font. Composite fonts can
// be used to represent unicode fonts which can have multi-byte character codes, representing a wide
// range of values. They are often used for symbolic languages, including Chinese, Japanese and Korean.
// It is represented by a Type0 Font with an underlying CIDFontType2 and an Identity-H encoding map.
// TODO: May be extended in the future to support a larger variety of CMaps and vertical fonts.
// NOTE: For simple fonts, use NewPdfFontFromTTF.
func NewCompositePdfFontFromTTF(r _cf.ReadSeeker) (*PdfFont, error) {
	_abdcd, _bagg := _gbd.ReadAll(r)
	if _bagg != nil {
		_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0072\u0065\u0061d\u0020\u0066\u006f\u006e\u0074\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074s\u003a\u0020\u0025\u0076", _bagg)
		return nil, _bagg
	}
	_fcfdd, _bagg := _aa.TtfParse(_gg.NewReader(_abdcd))
	if _bagg != nil {
		_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0077\u0068\u0069\u006c\u0065\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067 \u0074\u0074\u0066\u0020\u0066\u006f\u006et\u003a\u0020\u0025\u0076", _bagg)
		return nil, _bagg
	}
	_adgdda := &pdfCIDFontType2{fontCommon: fontCommon{_bcbfd: "\u0043\u0049\u0044F\u006f\u006e\u0074\u0054\u0079\u0070\u0065\u0032"}, CIDToGIDMap: _agf.MakeName("\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079")}
	if len(_fcfdd.Widths) <= 0 {
		return nil, _gcd.New("\u0045\u0052\u0052O\u0052\u003a\u0020\u004d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065 \u0028\u0057\u0069\u0064\u0074\u0068\u0073\u0029")
	}
	_dadc := 1000.0 / float64(_fcfdd.UnitsPerEm)
	_afdfa := _dadc * float64(_fcfdd.Widths[0])
	_cegg := make(map[rune]int)
	_cgaec := make(map[_aa.GID]int)
	_cacbe := _aa.GID(len(_fcfdd.Widths))
	for _dgbg, _bebg := range _fcfdd.Chars {
		if _bebg > _cacbe-1 {
			continue
		}
		_adfe := int(_dadc * float64(_fcfdd.Widths[_bebg]))
		_cegg[_dgbg] = _adfe
		_cgaec[_bebg] = _adfe
	}
	_adgdda._dbae = _cegg
	_adgdda.DW = _agf.MakeInteger(int64(_afdfa))
	_agec := _daed(_cgaec, uint16(_cacbe))
	_adgdda.W = _agf.MakeIndirectObject(_agec)
	_ebfdf := _agf.MakeDict()
	_ebfdf.Set("\u004f\u0072\u0064\u0065\u0072\u0069\u006e\u0067", _agf.MakeString("\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"))
	_ebfdf.Set("\u0052\u0065\u0067\u0069\u0073\u0074\u0072\u0079", _agf.MakeString("\u0041\u0064\u006fb\u0065"))
	_ebfdf.Set("\u0053\u0075\u0070\u0070\u006c\u0065\u006d\u0065\u006e\u0074", _agf.MakeInteger(0))
	_adgdda.CIDSystemInfo = _ebfdf
	_bgac := &PdfFontDescriptor{FontName: _agf.MakeName(_fcfdd.PostScriptName), Ascent: _agf.MakeFloat(_dadc * float64(_fcfdd.TypoAscender)), Descent: _agf.MakeFloat(_dadc * float64(_fcfdd.TypoDescender)), CapHeight: _agf.MakeFloat(_dadc * float64(_fcfdd.CapHeight)), FontBBox: _agf.MakeArrayFromFloats([]float64{_dadc * float64(_fcfdd.Xmin), _dadc * float64(_fcfdd.Ymin), _dadc * float64(_fcfdd.Xmax), _dadc * float64(_fcfdd.Ymax)}), ItalicAngle: _agf.MakeFloat(_fcfdd.ItalicAngle), MissingWidth: _agf.MakeFloat(_afdfa)}
	_egac, _bagg := _agf.MakeStream(_abdcd, _agf.NewFlateEncoder())
	if _bagg != nil {
		_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074o\u0020m\u0061\u006b\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u003a\u0020\u0025\u0076", _bagg)
		return nil, _bagg
	}
	_egac.PdfObjectDictionary.Set("\u004ce\u006e\u0067\u0074\u0068\u0031", _agf.MakeInteger(int64(len(_abdcd))))
	_bgac.FontFile2 = _egac
	if _fcfdd.Bold {
		_bgac.StemV = _agf.MakeInteger(120)
	} else {
		_bgac.StemV = _agf.MakeInteger(70)
	}
	_ddbb := _eggb
	if _fcfdd.IsFixedPitch {
		_ddbb |= _deab
	}
	if _fcfdd.ItalicAngle != 0 {
		_ddbb |= _ebfd
	}
	_bgac.Flags = _agf.MakeInteger(int64(_ddbb))
	_adgdda._fccf = _fcfdd.PostScriptName
	_adgdda._dcfcb = _bgac
	_ceed := pdfFontType0{fontCommon: fontCommon{_bcbfd: "\u0054\u0079\u0070e\u0030", _fccf: _fcfdd.PostScriptName}, DescendantFont: &PdfFont{_effaa: _adgdda}, Encoding: _agf.MakeName("\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079\u002d\u0048"), _gccd: _fcfdd.NewEncoder()}
	if len(_fcfdd.Chars) > 0 {
		_bgbdg := make(map[_ce.CharCode]rune, len(_fcfdd.Chars))
		for _abeee, _ddce := range _fcfdd.Chars {
			_gefea := _ce.CharCode(_ddce)
			if _dadcd, _gdac := _bgbdg[_gefea]; !_gdac || (_gdac && _dadcd > _abeee) {
				_bgbdg[_gefea] = _abeee
			}
		}
		_ceed._egfbf = _ce.NewToUnicodeCMap(_bgbdg)
	}
	_gdefg := PdfFont{_effaa: &_ceed}
	return &_gdefg, nil
}
func (_babea *PdfWriter) writeObject(_becfc int, _bbdcg _agf.PdfObject) {
	_fd.Log.Trace("\u0057\u0072\u0069\u0074\u0065\u0020\u006f\u0062\u006a \u0023\u0025\u0064\u000a", _becfc)
	if _adbfc, _ababe := _bbdcg.(*_agf.PdfIndirectObject); _ababe {
		_babea._ddcg[_becfc] = crossReference{Type: 1, Offset: _babea._fdce, Generation: _adbfc.GenerationNumber}
		_febdc := _b.Sprintf("\u0025d\u0020\u0030\u0020\u006f\u0062\u006a\n", _becfc)
		if _egfca, _fdfaa := _adbfc.PdfObject.(*pdfSignDictionary); _fdfaa {
			_egfca._deebd = _babea._fdce + int64(len(_febdc))
		}
		if _adbfc.PdfObject == nil {
			_fd.Log.Debug("E\u0072\u0072\u006fr\u003a\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0027\u0073\u0020\u0050\u0064\u0066\u004f\u0062j\u0065\u0063\u0074 \u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020b\u0065\u0020\u006e\u0069l\u0020\u002d\u0020\u0073e\u0074\u0074\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0050\u0064\u0066\u004f\u0062\u006a\u0065\u0063t\u004e\u0075\u006c\u006c")
			_adbfc.PdfObject = _agf.MakeNull()
		}
		_febdc += _adbfc.PdfObject.WriteString()
		_febdc += "\u000a\u0065\u006e\u0064\u006f\u0062\u006a\u000a"
		_babea.writeString(_febdc)
		return
	}
	if _dcega, _fcdgcf := _bbdcg.(*_agf.PdfObjectStream); _fcdgcf {
		_babea._ddcg[_becfc] = crossReference{Type: 1, Offset: _babea._fdce, Generation: _dcega.GenerationNumber}
		_cfged := _b.Sprintf("\u0025d\u0020\u0030\u0020\u006f\u0062\u006a\n", _becfc)
		_cfged += _dcega.PdfObjectDictionary.WriteString()
		_cfged += "\u000a\u0073\u0074\u0072\u0065\u0061\u006d\u000a"
		_babea.writeString(_cfged)
		_babea.writeBytes(_dcega.Stream)
		_babea.writeString("\u000ae\u006ed\u0073\u0074\u0072\u0065\u0061m\u000a\u0065n\u0064\u006f\u0062\u006a\u000a")
		return
	}
	if _fgfde, _eaccg := _bbdcg.(*_agf.PdfObjectStreams); _eaccg {
		_babea._ddcg[_becfc] = crossReference{Type: 1, Offset: _babea._fdce, Generation: _fgfde.GenerationNumber}
		_aebea := _b.Sprintf("\u0025d\u0020\u0030\u0020\u006f\u0062\u006a\n", _becfc)
		var _deae []string
		var _gaga string
		var _adaacf int64
		for _dfcbeb, _bfafe := range _fgfde.Elements() {
			_fbdad, _gbegb := _bfafe.(*_agf.PdfIndirectObject)
			if !_gbegb {
				_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065am\u0073 \u004e\u0020\u0025\u0064\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006es\u0020\u006e\u006f\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u0070\u0064\u0066 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0025\u0076", _becfc, _bfafe)
				continue
			}
			_fffc := _fbdad.PdfObject.WriteString() + "\u0020"
			_gaga = _gaga + _fffc
			_deae = append(_deae, _b.Sprintf("\u0025\u0064\u0020%\u0064", _fbdad.ObjectNumber, _adaacf))
			_babea._ddcg[int(_fbdad.ObjectNumber)] = crossReference{Type: 2, ObjectNumber: _becfc, Index: _dfcbeb}
			_adaacf = _adaacf + int64(len([]byte(_fffc)))
		}
		_bbcbe := _gc.Join(_deae, "\u0020") + "\u0020"
		_bafaa := _agf.NewFlateEncoder()
		_egbde := _bafaa.MakeStreamDict()
		_egbde.Set(_agf.PdfObjectName("\u0054\u0079\u0070\u0065"), _agf.MakeName("\u004f\u0062\u006a\u0053\u0074\u006d"))
		_bcfbf := int64(_fgfde.Len())
		_egbde.Set(_agf.PdfObjectName("\u004e"), _agf.MakeInteger(_bcfbf))
		_gefg := int64(len(_bbcbe))
		_egbde.Set(_agf.PdfObjectName("\u0046\u0069\u0072s\u0074"), _agf.MakeInteger(_gefg))
		_dfccg, _ := _bafaa.EncodeBytes([]byte(_bbcbe + _gaga))
		_ebgcc := int64(len(_dfccg))
		_egbde.Set(_agf.PdfObjectName("\u004c\u0065\u006e\u0067\u0074\u0068"), _agf.MakeInteger(_ebgcc))
		_aebea += _egbde.WriteString()
		_aebea += "\u000a\u0073\u0074\u0072\u0065\u0061\u006d\u000a"
		_babea.writeString(_aebea)
		_babea.writeBytes(_dfccg)
		_babea.writeString("\u000ae\u006ed\u0073\u0074\u0072\u0065\u0061m\u000a\u0065n\u0064\u006f\u0062\u006a\u000a")
		return
	}
	_babea.writeString(_bbdcg.WriteString())
}

// GetRuneMetrics returns the character metrics for the specified rune.
// A bool flag is returned to indicate whether or not the entry was found.
func (_cegd pdfCIDFontType0) GetRuneMetrics(r rune) (_aa.CharMetrics, bool) {
	return _aa.CharMetrics{Wx: _cegd._efcec}, true
}

// NewPdfActionSubmitForm returns a new "submit form" action.
func NewPdfActionSubmitForm() *PdfActionSubmitForm {
	_ecc := NewPdfAction()
	_dfb := &PdfActionSubmitForm{}
	_dfb.PdfAction = _ecc
	_ecc.SetContext(_dfb)
	return _dfb
}

// PdfOutputIntent provides a means for matching the color characteristics of a PDF document with
// those of a target output device.
// Multiple PdfOutputIntents allows the production process to be customized to the expected workflow and the specific
// tools available.
type PdfOutputIntent struct {

	// Type is an optional PDF object that this dictionary describes.
	// If present, must be OutputIntent for an output intent dictionary.
	Type string

	// S defines the OutputIntent subtype which should match the standard used in given document i.e:
	// for PDF/X use PdfOutputIntentTypeX.
	S PdfOutputIntentType

	// OutputCondition is an optional field that is identifying the intended output device or production condition in
	// human-readable form. This is preferred method of defining such a string for presentation to the user.
	OutputCondition string

	// OutputConditionIdentifier is a required field identifying the intended output device or production condition in
	// human or machine-readable form. If human-readable, this string may be used
	// in lieu of an OutputCondition for presentation to the user.
	// A typical value for this entry would be the name of a production condition  maintained
	// in  an  industry-standard registry such  as the ICC Characterization Data Registry
	// If the intended production condition is not a recognized standard, the value Custom is recommended for this entry.
	// the DestOutputProfile entry defines the ICC profile, and the Info entry is used for further
	// human-readable identification.
	OutputConditionIdentifier string

	// RegistryName is an optional string field (conventionally URI) identifying the registry in which the condition
	// designated by OutputConditionIdentifier is defined.
	RegistryName string

	// Info is a required field if OutputConditionIdentifier does not specify a standard production condition.
	// A human-readable text string containing additional information  or comments about intended
	// target device or production condition.
	Info string

	// DestOutputProfile is required if OutputConditionIdentifier does not specify a standard production condition.
	// It is an ICC profile stream defining the transformation from the PDF document's source colors to output device colorants.
	DestOutputProfile []byte

	// ColorComponents is the number of color components supported by given output profile.
	ColorComponents int
	_cebc           *_agf.PdfObjectDictionary
}

// PdfAnnotationLine represents Line annotations.
// (Section 12.5.6.7).
type PdfAnnotationLine struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	L       _agf.PdfObject
	BS      _agf.PdfObject
	LE      _agf.PdfObject
	IC      _agf.PdfObject
	LL      _agf.PdfObject
	LLE     _agf.PdfObject
	Cap     _agf.PdfObject
	IT      _agf.PdfObject
	LLO     _agf.PdfObject
	CP      _agf.PdfObject
	Measure _agf.PdfObject
	CO      _agf.PdfObject
}

// DecodeArray returns the component range values for the Indexed colorspace.
func (_efbf *PdfColorspaceSpecialIndexed) DecodeArray() []float64 {
	return []float64{0, float64(_efbf.HiVal)}
}
func (_bfga *PdfWriter) writeDocumentVersion() {
	if _bfga._accad {
		_bfga.writeString("\u000a")
	} else {
		_bfga.writeString(_b.Sprintf("\u0025\u0025\u0050D\u0046\u002d\u0025\u0064\u002e\u0025\u0064\u000a", _bfga._bcdfgg.Major, _bfga._bcdfgg.Minor))
		_bfga.writeString("\u0025\u00e2\u00e3\u00cf\u00d3\u000a")
	}
}

// AllFields returns a flattened list of all fields in the form.
func (_fccaa *PdfAcroForm) AllFields() []*PdfField {
	if _fccaa == nil {
		return nil
	}
	var _fgfed []*PdfField
	if _fccaa.Fields != nil {
		for _, _geggg := range *_fccaa.Fields {
			_fgfed = append(_fgfed, _edeg(_geggg)...)
		}
	}
	return _fgfed
}
func (_cfag *PdfAcroForm) signatureFields() []*PdfFieldSignature {
	var _fbbfa []*PdfFieldSignature
	for _, _bacgd := range _cfag.AllFields() {
		switch _dacgg := _bacgd.GetContext().(type) {
		case *PdfFieldSignature:
			_defbcf := _dacgg
			_fbbfa = append(_fbbfa, _defbcf)
		}
	}
	return _fbbfa
}
func _ebgg() string {
	_dbcc := "\u0051\u0057\u0045\u0052\u0054\u0059\u0055\u0049\u004f\u0050\u0041S\u0044\u0046\u0047\u0048\u004a\u004b\u004c\u005a\u0058\u0043V\u0042\u004e\u004d"
	var _ecaf _gg.Buffer
	for _cebd := 0; _cebd < 6; _cebd++ {
		_ecaf.WriteRune(rune(_dbcc[_dd.Intn(len(_dbcc))]))
	}
	return _ecaf.String()
}
func (_acc *PdfAnnotation) String() string {
	_eeaf := ""
	_gagb, _daa := _acc.ToPdfObject().(*_agf.PdfIndirectObject)
	if _daa {
		_eeaf = _b.Sprintf("\u0025\u0054\u003a\u0020\u0025\u0073", _acc._eef, _gagb.PdfObject.String())
	}
	return _eeaf
}

// GetSamples converts the raw byte slice into samples which are stored in a uint32 bit array.
// Each sample is represented by BitsPerComponent consecutive bits in the raw data.
// NOTE: The method resamples the image byte data before returning the result and
// this could lead to high memory usage, especially on large images. It should
// be avoided, when possible. It is recommended to access the Data field of the
// image directly or use the ColorAt method to extract individual pixels.
func (_gcdbc *Image) GetSamples() []uint32 {
	_gegfc := _db.ResampleBytes(_gcdbc.Data, int(_gcdbc.BitsPerComponent))
	if _gcdbc.BitsPerComponent < 8 {
		_gegfc = _gcdbc.samplesTrimPadding(_gegfc)
	}
	_bfffd := int(_gcdbc.Width) * int(_gcdbc.Height) * _gcdbc.ColorComponents
	if len(_gegfc) < _bfffd {
		_fd.Log.Debug("\u0045r\u0072\u006fr\u003a\u0020\u0054o\u006f\u0020\u0066\u0065\u0077\u0020\u0073a\u006d\u0070\u006c\u0065\u0073\u0020(\u0067\u006f\u0074\u0020\u0025\u0064\u002c\u0020\u0065\u0078\u0070e\u0063\u0074\u0069\u006e\u0067\u0020\u0025\u0064\u0029", len(_gegfc), _bfffd)
		return _gegfc
	} else if len(_gegfc) > _bfffd {
		_fd.Log.Debug("\u0045r\u0072\u006fr\u003a\u0020\u0054o\u006f\u0020\u006d\u0061\u006e\u0079\u0020s\u0061\u006d\u0070\u006c\u0065\u0073 \u0028\u0067\u006f\u0074\u0020\u0025\u0064\u002c\u0020\u0065\u0078p\u0065\u0063\u0074\u0069\u006e\u0067\u0020\u0025\u0064", len(_gegfc), _bfffd)
		_gegfc = _gegfc[:_bfffd]
	}
	return _gegfc
}

// GetAlphabet returns a map of the runes in `text` and their frequencies.
func GetAlphabet(text string) map[rune]int {
	_aegb := map[rune]int{}
	for _, _eacc := range text {
		_aegb[_eacc]++
	}
	return _aegb
}

// SetContext sets the specific fielddata type, e.g. would be PdfFieldButton for a button field.
func (_cafga *PdfField) SetContext(ctx PdfModel) { _cafga._eaggd = ctx }

// GetContainingPdfObject returns the container of the outline (indirect object).
func (_aeeed *PdfOutline) GetContainingPdfObject() _agf.PdfObject { return _aeeed._gbeea }
func _daed(_bedb map[_aa.GID]int, _affbe uint16) *_agf.PdfObjectArray {
	_cdeb := &_agf.PdfObjectArray{}
	_ecda := _aa.GID(_affbe)
	for _cceef := _aa.GID(0); _cceef < _ecda; {
		_daea, _bged := _bedb[_cceef]
		if !_bged {
			_cceef++
			continue
		}
		_egab := _cceef
		for _cffdc := _egab + 1; _cffdc < _ecda; _cffdc++ {
			if _cafca, _ceee := _bedb[_cffdc]; !_ceee || _daea != _cafca {
				break
			}
			_egab = _cffdc
		}
		_cdeb.Append(_agf.MakeInteger(int64(_cceef)))
		_cdeb.Append(_agf.MakeInteger(int64(_egab)))
		_cdeb.Append(_agf.MakeInteger(int64(_daea)))
		_cceef = _egab + 1
	}
	return _cdeb
}

// String returns a human readable description of `fontfile`.
func (_cecg *fontFile) String() string {
	_dgefe := "\u005b\u004e\u006f\u006e\u0065\u005d"
	if _cecg._aggb != nil {
		_dgefe = _cecg._aggb.String()
	}
	return _b.Sprintf("\u0046O\u004e\u0054\u0046\u0049\u004c\u0045\u007b\u0025\u0023\u0071\u0020e\u006e\u0063\u006f\u0064\u0065\u0072\u003d\u0025\u0073\u007d", _cecg._febf, _dgefe)
}

// GetAction returns the PDF action for the annotation link.
func (_aba *PdfAnnotationLink) GetAction() (*PdfAction, error) {
	if _aba._bbdg != nil {
		return _aba._bbdg, nil
	}
	if _aba.A == nil {
		return nil, nil
	}
	if _aba._accb == nil {
		return nil, nil
	}
	_cec, _becg := _aba._accb.loadAction(_aba.A)
	if _becg != nil {
		return nil, _becg
	}
	_aba._bbdg = _cec
	return _aba._bbdg, nil
}

// NewReaderOpts generates a default `ReaderOpts` instance.
func NewReaderOpts() *ReaderOpts { return &ReaderOpts{Password: "", LazyLoad: true} }

// GetPatternByName gets the pattern specified by keyName. Returns nil if not existing.
// The bool flag indicated whether it was found or not.
func (_ccgdff *PdfPageResources) GetPatternByName(keyName _agf.PdfObjectName) (*PdfPattern, bool) {
	if _ccgdff.Pattern == nil {
		return nil, false
	}
	_begd, _daddc := _agf.TraceToDirectObject(_ccgdff.Pattern).(*_agf.PdfObjectDictionary)
	if !_daddc {
		_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0061\u0074t\u0065\u0072\u006e\u0020\u0065\u006e\u0074r\u0079\u0020\u002d\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064i\u0063\u0074\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", _ccgdff.Pattern)
		return nil, false
	}
	if _daccg := _begd.Get(keyName); _daccg != nil {
		_badbf, _acfcc := _gaaab(_daccg)
		if _acfcc != nil {
			_fd.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020f\u0061\u0069l\u0065\u0064\u0020\u0074\u006f\u0020\u006c\u006fa\u0064\u0020\u0070\u0064\u0066\u0020\u0070\u0061\u0074\u0074\u0065\u0072n\u003a\u0020\u0025\u0076", _acfcc)
			return nil, false
		}
		return _badbf, true
	}
	return nil, false
}

// PdfTransformParamsDocMDP represents a transform parameters dictionary for the DocMDP method and is used to detect
// modifications relative to a signature field that is signed by the author of a document.
// (Section 12.8.2.2, Table 254 - Entries in the DocMDP transform parameters dictionary p. 471 in PDF32000_2008).
type PdfTransformParamsDocMDP struct {
	Type *_agf.PdfObjectName
	P    *_agf.PdfObjectInteger
	V    *_agf.PdfObjectName
}

func _egag(_baef StdFontName) (pdfFontSimple, error) {
	_fbcdd, _abbe := _aa.NewStdFontByName(_baef)
	if !_abbe {
		return pdfFontSimple{}, ErrFontNotSupported
	}
	_dcbeg := _gfgcd(_fbcdd)
	return _dcbeg, nil
}

// PdfColorCalRGB represents a color in the Colorimetric CIE RGB colorspace.
// A, B, C components
// Each component is defined in the range 0.0 - 1.0 where 1.0 is the primary intensity.
type PdfColorCalRGB [3]float64

// NewPdfReaderWithOpts creates a new PdfReader for an input io.ReadSeeker interface
// with a ReaderOpts.
// If ReaderOpts is nil it will be set to default value from NewReaderOpts.
func NewPdfReaderWithOpts(rs _cf.ReadSeeker, opts *ReaderOpts) (*PdfReader, error) {
	const _ffbaa = "\u006d\u006f\u0064\u0065\u006c\u003a\u004e\u0065\u0077\u0050\u0064f\u0052\u0065\u0061\u0064\u0065\u0072\u0057\u0069\u0074\u0068O\u0070\u0074\u0073"
	return _dcab(rs, opts, true, _ffbaa)
}
func (_fdaff *pdfFontType0) baseFields() *fontCommon { return &_fdaff.fontCommon }
func (_fgfag *PdfReader) newPdfActionThreadFromDict(_dda *_agf.PdfObjectDictionary) (*PdfActionThread, error) {
	_efb, _eec := _bdd(_dda.Get("\u0046"))
	if _eec != nil {
		return nil, _eec
	}
	return &PdfActionThread{D: _dda.Get("\u0044"), B: _dda.Get("\u0042"), F: _efb}, nil
}

// NewPdfColorspaceSpecialIndexed returns a new Indexed color.
func NewPdfColorspaceSpecialIndexed() *PdfColorspaceSpecialIndexed {
	return &PdfColorspaceSpecialIndexed{HiVal: 255}
}

// PdfFieldChoice represents a choice field which includes scrollable list boxes and combo boxes.
type PdfFieldChoice struct {
	*PdfField
	Opt *_agf.PdfObjectArray
	TI  *_agf.PdfObjectInteger
	I   *_agf.PdfObjectArray
}

// PdfInfo holds document information that will overwrite
// document information global variables defined above.
type PdfInfo struct {
	Title        *_agf.PdfObjectString
	Author       *_agf.PdfObjectString
	Subject      *_agf.PdfObjectString
	Keywords     *_agf.PdfObjectString
	Creator      *_agf.PdfObjectString
	Producer     *_agf.PdfObjectString
	CreationDate *PdfDate
	ModifiedDate *PdfDate
	Trapped      *_agf.PdfObjectName
	_adfbb       *_agf.PdfObjectDictionary
}

// NewImageFromGoImage creates a new NRGBA32 unidoc Image from a golang Image.
// If `goimg` is grayscale (*goimage.Gray8) then calls NewGrayImageFromGoImage instead.
func (_edfgg DefaultImageHandler) NewImageFromGoImage(goimg _fe.Image) (*Image, error) {
	_dadgd, _agdbe := _ged.FromGoImage(goimg)
	if _agdbe != nil {
		return nil, _agdbe
	}
	_gbggd := _ddgg(_dadgd.Base())
	return &_gbggd, nil
}

// Encoder returns the font's text encoder.
func (_edcac *PdfFont) Encoder() _fcg.TextEncoder {
	_deedf := _edcac.actualFont()
	if _deedf == nil {
		_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0045n\u0063\u006f\u0064er\u0020\u006e\u006f\u0074\u0020\u0069m\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0066\u006f\u0072\u0020\u0066o\u006e\u0074\u0020\u0074\u0079\u0070\u0065\u003d%\u0023\u0054", _edcac._effaa)
		return nil
	}
	return _deedf.Encoder()
}

// IsSimple returns true if `font` is a simple font.
func (_fafe *PdfFont) IsSimple() bool { _, _gfbgd := _fafe._effaa.(*pdfFontSimple); return _gfbgd }
func _dbdgce(_dfad *PdfPage) map[_agf.PdfObjectName]_agf.PdfObject {
	_ecg := make(map[_agf.PdfObjectName]_agf.PdfObject)
	if _dfad.Resources == nil {
		return _ecg
	}
	if _dfad.Resources.Font != nil {
		if _fadbb, _ebcg := _agf.GetDict(_dfad.Resources.Font); _ebcg {
			for _, _eddg := range _fadbb.Keys() {
				_ecg[_eddg] = _fadbb.Get(_eddg)
			}
		}
	}
	if _dfad.Resources.ExtGState != nil {
		if _fbbc, _ggdg := _agf.GetDict(_dfad.Resources.ExtGState); _ggdg {
			for _, _dgd := range _fbbc.Keys() {
				_ecg[_dgd] = _fbbc.Get(_dgd)
			}
		}
	}
	if _dfad.Resources.XObject != nil {
		if _gage, _dadd := _agf.GetDict(_dfad.Resources.XObject); _dadd {
			for _, _dbdc := range _gage.Keys() {
				_ecg[_dbdc] = _gage.Get(_dbdc)
			}
		}
	}
	if _dfad.Resources.Pattern != nil {
		if _afga, _gbag := _agf.GetDict(_dfad.Resources.Pattern); _gbag {
			for _, _eadg := range _afga.Keys() {
				_ecg[_eadg] = _afga.Get(_eadg)
			}
		}
	}
	if _dfad.Resources.Shading != nil {
		if _cccf, _bdc := _agf.GetDict(_dfad.Resources.Shading); _bdc {
			for _, _efd := range _cccf.Keys() {
				_ecg[_efd] = _cccf.Get(_efd)
			}
		}
	}
	if _dfad.Resources.ProcSet != nil {
		if _ebgb, _bggg := _agf.GetDict(_dfad.Resources.ProcSet); _bggg {
			for _, _cgbff := range _ebgb.Keys() {
				_ecg[_cgbff] = _ebgb.Get(_cgbff)
			}
		}
	}
	if _dfad.Resources.Properties != nil {
		if _ecge, _cbec := _agf.GetDict(_dfad.Resources.Properties); _cbec {
			for _, _gcaag := range _ecge.Keys() {
				_ecg[_gcaag] = _ecge.Get(_gcaag)
			}
		}
	}
	return _ecg
}

// SignatureHandlerDocMDPParams describe the specific parameters for the SignatureHandlerEx
// These parameters describe how to check the difference between revisions.
// Revisions of the document get from the PdfParser.
type SignatureHandlerDocMDPParams struct {
	Parser     *_agf.PdfParser
	DiffPolicy _ca.DiffPolicy
}

// ToPdfObject implements interface PdfModel.
func (_de *PdfActionSubmitForm) ToPdfObject() _agf.PdfObject {
	_de.PdfAction.ToPdfObject()
	_egge := _de._caf
	_efa := _egge.PdfObject.(*_agf.PdfObjectDictionary)
	_efa.SetIfNotNil("\u0053", _agf.MakeName(string(ActionTypeSubmitForm)))
	if _de.F != nil {
		_efa.Set("\u0046", _de.F.ToPdfObject())
	}
	_efa.SetIfNotNil("\u0046\u0069\u0065\u006c\u0064\u0073", _de.Fields)
	_efa.SetIfNotNil("\u0046\u006c\u0061g\u0073", _de.Flags)
	return _egge
}

// PdfShadingType4 is a Free-form Gouraud-shaded triangle mesh.
type PdfShadingType4 struct {
	*PdfShading
	BitsPerCoordinate *_agf.PdfObjectInteger
	BitsPerComponent  *_agf.PdfObjectInteger
	BitsPerFlag       *_agf.PdfObjectInteger
	Decode            *_agf.PdfObjectArray
	Function          []PdfFunction
}

func (_ccafgg *PdfReader) loadPerms() (*Permissions, error) {
	if _ffbag := _ccafgg._ceaadd.Get("\u0050\u0065\u0072m\u0073"); _ffbag != nil {
		if _dgdfb, _gabfg := _agf.GetDict(_ffbag); _gabfg {
			_faegb := _dgdfb.Get("\u0044\u006f\u0063\u004d\u0044\u0050")
			if _faegb == nil {
				return nil, nil
			}
			if _aegf, _aeaad := _agf.GetIndirect(_faegb); _aeaad {
				_faafa, _abcea := _ccafgg.newPdfSignatureFromIndirect(_aegf)
				if _abcea != nil {
					return nil, _abcea
				}
				return NewPermissions(_faafa), nil
			}
			return nil, _b.Errorf("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0044\u006f\u0063M\u0044\u0050\u0020\u0065nt\u0072\u0079")
		}
		return nil, _b.Errorf("\u0069\u006e\u0076\u0061li\u0064\u0020\u0050\u0065\u0072\u006d\u0073\u0020\u0065\u006e\u0074\u0072\u0079")
	}
	return nil, nil
}

// SetOptimizer sets the optimizer to optimize PDF before writing.
func (_efcf *PdfWriter) SetOptimizer(optimizer Optimizer) { _efcf._dafgfa = optimizer }

// NewPdfAnnotationHighlight returns a new text highlight annotation.
func NewPdfAnnotationHighlight() *PdfAnnotationHighlight {
	_gfb := NewPdfAnnotation()
	_bde := &PdfAnnotationHighlight{}
	_bde.PdfAnnotation = _gfb
	_bde.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_gfb.SetContext(_bde)
	return _bde
}

// ToPdfObject implements interface PdfModel.
func (_ddcdee *PdfSignature) ToPdfObject() _agf.PdfObject {
	_cdfe := _ddcdee._ceeec
	var _gfgcc *_agf.PdfObjectDictionary
	if _eeaa, _dabca := _cdfe.PdfObject.(*pdfSignDictionary); _dabca {
		_gfgcc = _eeaa.PdfObjectDictionary
	} else {
		_gfgcc = _cdfe.PdfObject.(*_agf.PdfObjectDictionary)
	}
	_gfgcc.SetIfNotNil("\u0054\u0079\u0070\u0065", _ddcdee.Type)
	_gfgcc.SetIfNotNil("\u0046\u0069\u006c\u0074\u0065\u0072", _ddcdee.Filter)
	_gfgcc.SetIfNotNil("\u0053u\u0062\u0046\u0069\u006c\u0074\u0065r", _ddcdee.SubFilter)
	_gfgcc.SetIfNotNil("\u0042y\u0074\u0065\u0052\u0061\u006e\u0067e", _ddcdee.ByteRange)
	_gfgcc.SetIfNotNil("\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073", _ddcdee.Contents)
	_gfgcc.SetIfNotNil("\u0043\u0065\u0072\u0074", _ddcdee.Cert)
	_gfgcc.SetIfNotNil("\u004e\u0061\u006d\u0065", _ddcdee.Name)
	_gfgcc.SetIfNotNil("\u0052\u0065\u0061\u0073\u006f\u006e", _ddcdee.Reason)
	_gfgcc.SetIfNotNil("\u004d", _ddcdee.M)
	_gfgcc.SetIfNotNil("\u0052e\u0066\u0065\u0072\u0065\u006e\u0063e", _ddcdee.Reference)
	_gfgcc.SetIfNotNil("\u0043h\u0061\u006e\u0067\u0065\u0073", _ddcdee.Changes)
	_gfgcc.SetIfNotNil("C\u006f\u006e\u0074\u0061\u0063\u0074\u0049\u006e\u0066\u006f", _ddcdee.ContactInfo)
	return _cdfe
}

// GetPageLabels returns the PageLabels entry in the PDF catalog.
// See section 12.4.2 "Page Labels" (p. 382 PDF32000_2008).
func (_abefc *PdfReader) GetPageLabels() (_agf.PdfObject, error) {
	_aefff := _agf.ResolveReference(_abefc._ceaadd.Get("\u0050\u0061\u0067\u0065\u004c\u0061\u0062\u0065\u006c\u0073"))
	if _aefff == nil {
		return nil, nil
	}
	if !_abefc._ccage {
		_caeeg := _abefc.traverseObjectData(_aefff)
		if _caeeg != nil {
			return nil, _caeeg
		}
	}
	return _aefff, nil
}

type crossReference struct {
	Type int

	// Type 1
	Offset     int64
	Generation int64

	// Type 2
	ObjectNumber int
	Index        int
}

// MergePageWith appends page content to source Pdf file page content.
func (_aaab *PdfAppender) MergePageWith(pageNum int, page *PdfPage) error {
	_dfag := pageNum - 1
	var _dbbc *PdfPage
	for _edgg, _dddg := range _aaab._dfaf {
		if _edgg == _dfag {
			_dbbc = _dddg
		}
	}
	if _dbbc == nil {
		return _b.Errorf("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0050\u0061\u0067\u0065\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061r\u0079\u0020\u0025\u0064\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064\u0020\u0069\u006e\u0020\u0074\u0068\u0065\u0020\u0073o\u0075\u0072\u0063\u0065\u0020\u0064o\u0063\u0075\u006de\u006e\u0074", pageNum)
	}
	if _dbbc._edegf != nil && _dbbc._edegf.GetParser() == _aaab._gdeb._egdga {
		_dbbc = _dbbc.Duplicate()
		_aaab._dfaf[_dfag] = _dbbc
	}
	page = page.Duplicate()
	_ddeeg(page)
	_gfdac := _dbdgce(_dbbc)
	_bcdf := _dbdgce(page)
	_gffa := make(map[_agf.PdfObjectName]_agf.PdfObjectName)
	for _fcfag := range _bcdf {
		if _, _ggbe := _gfdac[_fcfag]; _ggbe {
			for _fcbc := 1; true; _fcbc++ {
				_gfcb := _agf.PdfObjectName(string(_fcfag) + _ge.Itoa(_fcbc))
				if _, _ecga := _gfdac[_gfcb]; !_ecga {
					_gffa[_fcfag] = _gfcb
					break
				}
			}
		}
	}
	_cbaa, _ebffa := page.GetContentStreams()
	if _ebffa != nil {
		return _ebffa
	}
	_adff, _ebffa := _dbbc.GetContentStreams()
	if _ebffa != nil {
		return _ebffa
	}
	for _fdba, _bgca := range _cbaa {
		for _bbgb, _fada := range _gffa {
			_bgca = _gc.Replace(_bgca, "\u002f"+string(_bbgb), "\u002f"+string(_fada), -1)
		}
		_cbaa[_fdba] = _bgca
	}
	_adff = append(_adff, _cbaa...)
	if _decc := _dbbc.SetContentStreams(_adff, _agf.NewFlateEncoder()); _decc != nil {
		return _decc
	}
	_dbbc._abffa = append(_dbbc._abffa, page._abffa...)
	if _dbbc.Resources == nil {
		_dbbc.Resources = NewPdfPageResources()
	}
	if page.Resources != nil {
		_dbbc.Resources.Font = _aaab.mergeResources(_dbbc.Resources.Font, page.Resources.Font, _gffa)
		_dbbc.Resources.XObject = _aaab.mergeResources(_dbbc.Resources.XObject, page.Resources.XObject, _gffa)
		_dbbc.Resources.Properties = _aaab.mergeResources(_dbbc.Resources.Properties, page.Resources.Properties, _gffa)
		if _dbbc.Resources.ProcSet == nil {
			_dbbc.Resources.ProcSet = page.Resources.ProcSet
		}
		_dbbc.Resources.Shading = _aaab.mergeResources(_dbbc.Resources.Shading, page.Resources.Shading, _gffa)
		_dbbc.Resources.ExtGState = _aaab.mergeResources(_dbbc.Resources.ExtGState, page.Resources.ExtGState, _gffa)
	}
	_cbdd, _ebffa := _dbbc.GetMediaBox()
	if _ebffa != nil {
		return _ebffa
	}
	_ebcb, _ebffa := page.GetMediaBox()
	if _ebffa != nil {
		return _ebffa
	}
	var _ggdb bool
	if _cbdd.Llx > _ebcb.Llx {
		_cbdd.Llx = _ebcb.Llx
		_ggdb = true
	}
	if _cbdd.Lly > _ebcb.Lly {
		_cbdd.Lly = _ebcb.Lly
		_ggdb = true
	}
	if _cbdd.Urx < _ebcb.Urx {
		_cbdd.Urx = _ebcb.Urx
		_ggdb = true
	}
	if _cbdd.Ury < _ebcb.Ury {
		_cbdd.Ury = _ebcb.Ury
		_ggdb = true
	}
	if _ggdb {
		_dbbc.MediaBox = _cbdd
	}
	return nil
}

// DefaultFont returns the default font, which is currently the built in Helvetica.
func DefaultFont() *PdfFont {
	_gfee, _cedf := _aa.NewStdFontByName(HelveticaName)
	if !_cedf {
		panic("\u0048\u0065lv\u0065\u0074\u0069c\u0061\u0020\u0073\u0068oul\u0064 a\u006c\u0077\u0061\u0079\u0073\u0020\u0062e \u0061\u0076\u0061\u0069\u006c\u0061\u0062l\u0065")
	}
	_dffd := _gfgcd(_gfee)
	return &PdfFont{_effaa: &_dffd}
}

// IsEncrypted returns true if the PDF file is encrypted.
func (_fgdf *PdfReader) IsEncrypted() (bool, error) { return _fgdf._egdga.IsEncrypted() }

// ToPdfObject implements interface PdfModel.
func (_dde *PdfAnnotationSquiggly) ToPdfObject() _agf.PdfObject {
	_dde.PdfAnnotation.ToPdfObject()
	_gbfe := _dde._aeee
	_fbag := _gbfe.PdfObject.(*_agf.PdfObjectDictionary)
	_dde.PdfAnnotationMarkup.appendToPdfDictionary(_fbag)
	_fbag.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _agf.MakeName("\u0053\u0071\u0075\u0069\u0067\u0067\u006c\u0079"))
	_fbag.SetIfNotNil("\u0051\u0075\u0061\u0064\u0050\u006f\u0069\u006e\u0074\u0073", _dde.QuadPoints)
	return _gbfe
}

// ToPdfObject implements interface PdfModel.
func (_aff *PdfActionResetForm) ToPdfObject() _agf.PdfObject {
	_aff.PdfAction.ToPdfObject()
	_deg := _aff._caf
	_adb := _deg.PdfObject.(*_agf.PdfObjectDictionary)
	_adb.SetIfNotNil("\u0053", _agf.MakeName(string(ActionTypeResetForm)))
	_adb.SetIfNotNil("\u0046\u0069\u0065\u006c\u0064\u0073", _aff.Fields)
	_adb.SetIfNotNil("\u0046\u006c\u0061g\u0073", _aff.Flags)
	return _deg
}

// NewPdfAnnotationCaret returns a new caret annotation.
func NewPdfAnnotationCaret() *PdfAnnotationCaret {
	_deb := NewPdfAnnotation()
	_dccc := &PdfAnnotationCaret{}
	_dccc.PdfAnnotation = _deb
	_dccc.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_deb.SetContext(_dccc)
	return _dccc
}

// NewPdfColorspaceSpecialPattern returns a new pattern color.
func NewPdfColorspaceSpecialPattern() *PdfColorspaceSpecialPattern {
	return &PdfColorspaceSpecialPattern{}
}
func _dfff(_bdbea *_agf.PdfObjectDictionary, _ffeda *fontCommon) (*pdfFontType0, error) {
	_dgcca, _bgcg := _agf.GetArray(_bdbea.Get("\u0044e\u0073c\u0065\u006e\u0064\u0061\u006e\u0074\u0046\u006f\u006e\u0074\u0073"))
	if !_bgcg {
		_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049n\u0076\u0061\u006cid\u0020\u0044\u0065\u0073\u0063\u0065n\u0064\u0061\u006e\u0074\u0046\u006f\u006e\u0074\u0073\u0020\u002d\u0020\u006e\u006f\u0074 \u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079 \u0025\u0073", _ffeda)
		return nil, _agf.ErrRangeError
	}
	if _dgcca.Len() != 1 {
		_fd.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u0041\u0072\u0072\u0061\u0079\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0021\u003d\u0020\u0031\u0020(%\u0064\u0029", _dgcca.Len())
		return nil, _agf.ErrRangeError
	}
	_eaccb, _cbfgd := _fbffcc(_dgcca.Get(0), false)
	if _cbfgd != nil {
		_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046a\u0069\u006c\u0065d \u006c\u006f\u0061\u0064\u0069\u006eg\u0020\u0064\u0065\u0073\u0063\u0065\u006e\u0064\u0061\u006e\u0074\u0020\u0066\u006f\u006et\u003a\u0020\u0065\u0072\u0072\u003d\u0025\u0076 \u0025\u0073", _cbfgd, _ffeda)
		return nil, _cbfgd
	}
	_aadcb := _gcegd(_ffeda)
	_aadcb.DescendantFont = _eaccb
	_bebca, _bgcg := _agf.GetNameVal(_bdbea.Get("\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067"))
	if _bgcg {
		if _bebca == "\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079\u002d\u0048" || _bebca == "\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079\u002d\u0056" {
			_aadcb._gccd = _fcg.NewIdentityTextEncoder(_bebca)
		} else if _ce.IsPredefinedCMap(_bebca) {
			_aadcb._bgccg, _cbfgd = _ce.LoadPredefinedCMap(_bebca)
			if _cbfgd != nil {
				_fd.Log.Debug("\u0057\u0041\u0052\u004e\u003a\u0020\u0063o\u0075\u006c\u0064 \u006e\u006f\u0074\u0020l\u006f\u0061\u0064\u0020\u0070\u0072\u0065\u0064\u0065\u0066\u0069\u006e\u0065\u0064\u0020\u0043\u004d\u0061\u0070\u0020\u0025\u0073\u003a\u0020\u0025\u0076", _bebca, _cbfgd)
			}
		} else {
			_fd.Log.Debug("\u0055\u006e\u0068\u0061\u006e\u0064\u006c\u0065\u0064\u0020\u0063\u006da\u0070\u0020\u0025\u0071", _bebca)
		}
	}
	if _bfffb := _eaccb.baseFields()._egfbf; _bfffb != nil {
		if _addc := _bfffb.Name(); _addc == "\u0041d\u006fb\u0065\u002d\u0043\u004e\u0053\u0031\u002d\u0055\u0043\u0053\u0032" || _addc == "\u0041\u0064\u006f\u0062\u0065\u002d\u0047\u0042\u0031-\u0055\u0043\u0053\u0032" || _addc == "\u0041\u0064\u006f\u0062\u0065\u002d\u004a\u0061\u0070\u0061\u006e\u0031-\u0055\u0043\u0053\u0032" || _addc == "\u0041\u0064\u006f\u0062\u0065\u002d\u004b\u006f\u0072\u0065\u0061\u0031-\u0055\u0043\u0053\u0032" {
			_aadcb._gccd = _fcg.NewCMapEncoder(_bebca, _aadcb._bgccg, _bfffb)
		}
	}
	return _aadcb, nil
}

// PdfActionSetOCGState represents a SetOCGState action.
type PdfActionSetOCGState struct {
	*PdfAction
	State      _agf.PdfObject
	PreserveRB _agf.PdfObject
}

// GetXObjectFormByName returns the XObjectForm with the specified name from the
// page resources, if it exists.
func (_cbebdb *PdfPageResources) GetXObjectFormByName(keyName _agf.PdfObjectName) (*XObjectForm, error) {
	_dbec, _cbfdf := _cbebdb.GetXObjectByName(keyName)
	if _dbec == nil {
		return nil, nil
	}
	if _cbfdf != XObjectTypeForm {
		return nil, _gcd.New("\u006e\u006f\u0074\u0020\u0061\u0020\u0066\u006f\u0072\u006d")
	}
	_edcef, _adgff := NewXObjectFormFromStream(_dbec)
	if _adgff != nil {
		return nil, _adgff
	}
	return _edcef, nil
}

// AddExtension adds the specified extension to the Extensions dictionary.
// See section 7.1.2 "Extensions Dictionary" (pp. 108-109 PDF32000_2008).
func (_bdbb *PdfWriter) AddExtension(extName, baseVersion string, extLevel int) {
	_bagfb, _fegce := _agf.GetDict(_bdbb._bagbb.Get("\u0045\u0078\u0074\u0065\u006e\u0073\u0069\u006f\u006e\u0073"))
	if !_fegce {
		_bagfb = _agf.MakeDict()
		_bdbb._bagbb.Set("\u0045\u0078\u0074\u0065\u006e\u0073\u0069\u006f\u006e\u0073", _bagfb)
	}
	_aaccc, _fegce := _agf.GetDict(_bagfb.Get(_agf.PdfObjectName(extName)))
	if !_fegce {
		_aaccc = _agf.MakeDict()
		_bagfb.Set(_agf.PdfObjectName(extName), _aaccc)
	}
	if _edafa, _ := _agf.GetNameVal(_aaccc.Get("B\u0061\u0073\u0065\u0056\u0065\u0072\u0073\u0069\u006f\u006e")); _edafa != baseVersion {
		_aaccc.Set("B\u0061\u0073\u0065\u0056\u0065\u0072\u0073\u0069\u006f\u006e", _agf.MakeName(baseVersion))
	}
	if _ffabg, _ := _agf.GetIntVal(_aaccc.Get("\u0045\u0078\u0074\u0065\u006e\u0073\u0069\u006f\u006eL\u0065\u0076\u0065\u006c")); _ffabg != extLevel {
		_aaccc.Set("\u0045\u0078\u0074\u0065\u006e\u0073\u0069\u006f\u006eL\u0065\u0076\u0065\u006c", _agf.MakeInteger(int64(extLevel)))
	}
}

// PdfAnnotation3D represents 3D annotations.
// (Section 13.6.2).
type PdfAnnotation3D struct {
	*PdfAnnotation
	T3DD _agf.PdfObject
	T3DV _agf.PdfObject
	T3DA _agf.PdfObject
	T3DI _agf.PdfObject
	T3DB _agf.PdfObject
}

func _aaggd(_fdfeg _agf.PdfObject) {
	_fd.Log.Debug("\u006f\u0062\u006a\u003a\u0020\u0025\u0054\u0020\u0025\u0073", _fdfeg, _fdfeg.String())
	if _acac, _fgedf := _fdfeg.(*_agf.PdfObjectStream); _fgedf {
		_edgd, _fdffe := _agf.DecodeStream(_acac)
		if _fdffe != nil {
			_fd.Log.Debug("\u0045r\u0072\u006f\u0072\u003a\u0020\u0025v", _fdffe)
			return
		}
		_fd.Log.Debug("D\u0065\u0063\u006f\u0064\u0065\u0064\u003a\u0020\u0025\u0073", _edgd)
	} else if _aedfc, _gggbd := _fdfeg.(*_agf.PdfIndirectObject); _gggbd {
		_fd.Log.Debug("\u0025\u0054\u0020%\u0076", _aedfc.PdfObject, _aedfc.PdfObject)
		_fd.Log.Debug("\u0025\u0073", _aedfc.PdfObject.String())
	}
}
func (_gbbd *PdfReader) newPdfActionMovieFromDict(_ggd *_agf.PdfObjectDictionary) (*PdfActionMovie, error) {
	return &PdfActionMovie{Annotation: _ggd.Get("\u0041\u006e\u006e\u006f\u0074\u0061\u0074\u0069\u006f\u006e"), T: _ggd.Get("\u0054"), Operation: _ggd.Get("\u004fp\u0065\u0072\u0061\u0074\u0069\u006fn")}, nil
}

// BorderEffect represents a border effect (Table 167 p. 395).
type BorderEffect int

// NewPdfColorspaceICCBased returns a new ICCBased colorspace object.
func NewPdfColorspaceICCBased(N int) (*PdfColorspaceICCBased, error) {
	_ccfbc := &PdfColorspaceICCBased{}
	if N != 1 && N != 3 && N != 4 {
		return nil, _b.Errorf("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u004e\u0020\u0028\u0031/\u0033\u002f\u0034\u0029")
	}
	_ccfbc.N = N
	return _ccfbc, nil
}

// PdfShadingPatternType2 is shading patterns that will use a Type 2 shading pattern (Axial).
type PdfShadingPatternType2 struct {
	*PdfPattern
	Shading   *PdfShadingType2
	Matrix    *_agf.PdfObjectArray
	ExtGState _agf.PdfObject
}

const (
	ButtonTypeCheckbox ButtonType = iota
	ButtonTypePush     ButtonType = iota
	ButtonTypeRadio    ButtonType = iota
)

// ToPdfObject returns the PDF representation of the colorspace.
func (_fdff *PdfColorspaceDeviceCMYK) ToPdfObject() _agf.PdfObject {
	return _agf.MakeName("\u0044\u0065\u0076\u0069\u0063\u0065\u0043\u004d\u0059\u004b")
}
func (_gdbb *PdfReader) newPdfAnnotationCircleFromDict(_gede *_agf.PdfObjectDictionary) (*PdfAnnotationCircle, error) {
	_gef := PdfAnnotationCircle{}
	_cdba, _daaaf := _gdbb.newPdfAnnotationMarkupFromDict(_gede)
	if _daaaf != nil {
		return nil, _daaaf
	}
	_gef.PdfAnnotationMarkup = _cdba
	_gef.BS = _gede.Get("\u0042\u0053")
	_gef.IC = _gede.Get("\u0049\u0043")
	_gef.BE = _gede.Get("\u0042\u0045")
	_gef.RD = _gede.Get("\u0052\u0044")
	return &_gef, nil
}

// NewPdfShadingPatternType2 creates an empty shading pattern type 2 object.
func NewPdfShadingPatternType2() *PdfShadingPatternType2 {
	_agadg := &PdfShadingPatternType2{}
	_agadg.Matrix = _agf.MakeArrayFromIntegers([]int{1, 0, 0, 1, 0, 0})
	_agadg.PdfPattern = &PdfPattern{}
	_agadg.PdfPattern.PatternType = int64(*_agf.MakeInteger(2))
	_agadg.PdfPattern._dfed = _agadg
	_agadg.PdfPattern._efed = _agf.MakeIndirectObject(_agf.MakeDict())
	return _agadg
}
func (_bfgg *LTV) generateVRIKey(_ggfac *PdfSignature) (string, error) {
	_adfee, _aaeab := _aadgc(_ggfac.Contents.Bytes())
	if _aaeab != nil {
		return "", _aaeab
	}
	return _gc.ToUpper(_ad.EncodeToString(_adfee)), nil
}
func _gaaab(_ffgdd _agf.PdfObject) (*PdfPattern, error) {
	_fbcbd := &PdfPattern{}
	var _cfefd *_agf.PdfObjectDictionary
	if _agaga, _bgbcd := _agf.GetIndirect(_ffgdd); _bgbcd {
		_fbcbd._efed = _agaga
		_eced, _bdfb := _agaga.PdfObject.(*_agf.PdfObjectDictionary)
		if !_bdfb {
			_fd.Log.Debug("\u0050\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006fn\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079\u0020\u0028g\u006f\u0074\u0020%\u0054\u0029", _agaga.PdfObject)
			return nil, _agf.ErrTypeError
		}
		_cfefd = _eced
	} else if _fegadb, _aadgf := _agf.GetStream(_ffgdd); _aadgf {
		_fbcbd._efed = _fegadb
		_cfefd = _fegadb.PdfObjectDictionary
	} else {
		_fd.Log.Debug("\u0050a\u0074\u0074e\u0072\u006e\u0020\u006eo\u0074\u0020\u0061n\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074 o\u0062\u006a\u0065c\u0074\u0020o\u0072\u0020\u0073\u0074\u0072\u0065a\u006d\u002e \u0025\u0054", _ffgdd)
		return nil, _agf.ErrTypeError
	}
	_afge := _cfefd.Get("P\u0061\u0074\u0074\u0065\u0072\u006e\u0054\u0079\u0070\u0065")
	if _afge == nil {
		_fd.Log.Debug("\u0050\u0064\u0066\u0020\u0050\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069n\u0067\u0020\u0050\u0061\u0074t\u0065\u0072n\u0054\u0079\u0070\u0065")
		return nil, ErrRequiredAttributeMissing
	}
	_bgebb, _dfcdc := _afge.(*_agf.PdfObjectInteger)
	if !_dfcdc {
		_fd.Log.Debug("\u0050\u0061tt\u0065\u0072\u006e \u0074\u0079\u0070\u0065 no\u0074 a\u006e\u0020\u0069\u006e\u0074\u0065\u0067er\u0020\u0028\u0067\u006f\u0074\u0020\u0025T\u0029", _afge)
		return nil, _agf.ErrTypeError
	}
	if *_bgebb != 1 && *_bgebb != 2 {
		_fd.Log.Debug("\u0050\u0061\u0074\u0074e\u0072\u006e\u0020\u0074\u0079\u0070\u0065\u0020\u0021\u003d \u0031/\u0032\u0020\u0028\u0067\u006f\u0074\u0020%\u0064\u0029", *_bgebb)
		return nil, _agf.ErrRangeError
	}
	_fbcbd.PatternType = int64(*_bgebb)
	switch *_bgebb {
	case 1:
		_gegea, _fagcb := _fgbce(_cfefd)
		if _fagcb != nil {
			return nil, _fagcb
		}
		_gegea.PdfPattern = _fbcbd
		_fbcbd._dfed = _gegea
		return _fbcbd, nil
	case 2:
		_bcfbc, _cgecfg := _dgda(_cfefd)
		if _cgecfg != nil {
			return nil, _cgecfg
		}
		_bcfbc.PdfPattern = _fbcbd
		_fbcbd._dfed = _bcfbc
		return _fbcbd, nil
	}
	return nil, _gcd.New("\u0075n\u006bn\u006f\u0077\u006e\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e")
}

// FieldImageProvider provides fields images for specified fields.
type FieldImageProvider interface {
	FieldImageValues() (map[string]*Image, error)
}

// PdfDate represents a date, which is a PDF string of the form:
// (D:YYYYMMDDHHmmSSOHH'mm)
type PdfDate struct {
	_dcggc int64
	_fccbd int64
	_ggca  int64
	_cfgfg int64
	_dgaab int64
	_gdebc int64
	_dfead byte
	_gddba int64
	_ebcf  int64
}

func _geb(_ggeb *PdfField, _aebf _agf.PdfObject) error {
	switch _ggeb.GetContext().(type) {
	case *PdfFieldText:
		switch _bfebg := _aebf.(type) {
		case *_agf.PdfObjectName:
			_cedcce := _bfebg
			_fd.Log.Debug("\u0055\u006e\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u003a\u0020\u0047\u006f\u0074 \u0056\u0020\u0061\u0073\u0020\u006e\u0061\u006d\u0065\u0020\u002d\u003e\u0020c\u006f\u006e\u0076\u0065\u0072\u0074\u0069\u006e\u0067\u0020\u0074\u006f s\u0074\u0072\u0069\u006e\u0067\u0020\u0027\u0025\u0073\u0027", _cedcce.String())
			_ggeb.V = _agf.MakeEncodedString(_bfebg.String(), true)
		case *_agf.PdfObjectString:
			_ggeb.V = _agf.MakeEncodedString(_bfebg.String(), true)
		default:
			_fd.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0056\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u0028\u0025\u0023\u0076\u0029", _bfebg, _bfebg)
		}
	case *PdfFieldButton:
		switch _aebf.(type) {
		case *_agf.PdfObjectName:
			if len(_aebf.String()) > 0 {
				_ggeb.V = _aebf
				_ddba(_ggeb, _aebf)
			}
		case *_agf.PdfObjectString:
			if len(_aebf.String()) > 0 {
				_ggeb.V = _agf.MakeName(_aebf.String())
				_ddba(_ggeb, _ggeb.V)
			}
		default:
			_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u004e\u0045\u0058P\u0045\u0043\u0054\u0045\u0044\u0020\u0025\u0073\u0020\u002d>\u0020\u0025\u0076", _ggeb.PartialName(), _aebf)
			_ggeb.V = _aebf
		}
	case *PdfFieldChoice:
		switch _aebf.(type) {
		case *_agf.PdfObjectName:
			if len(_aebf.String()) > 0 {
				_ggeb.V = _agf.MakeString(_aebf.String())
				_ddba(_ggeb, _aebf)
			}
		case *_agf.PdfObjectString:
			if len(_aebf.String()) > 0 {
				_ggeb.V = _aebf
				_ddba(_ggeb, _agf.MakeName(_aebf.String()))
			}
		default:
			_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u004e\u0045\u0058P\u0045\u0043\u0054\u0045\u0044\u0020\u0025\u0073\u0020\u002d>\u0020\u0025\u0076", _ggeb.PartialName(), _aebf)
			_ggeb.V = _aebf
		}
	case *PdfFieldSignature:
		_fd.Log.Debug("\u0054\u004f\u0044\u004f\u003a \u0053\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0061\u0070\u0070e\u0061\u0072\u0061\u006e\u0063\u0065\u0020\u006e\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0079\u0065\u0074\u003a\u0020\u0025\u0073\u002f\u0025v", _ggeb.PartialName(), _aebf)
	}
	return nil
}

// ToPdfObject implements interface PdfModel.
func (_cd *PdfAction) ToPdfObject() _agf.PdfObject {
	_gdd := _cd._caf
	_edg := _gdd.PdfObject.(*_agf.PdfObjectDictionary)
	_edg.Clear()
	_edg.Set("\u0054\u0079\u0070\u0065", _agf.MakeName("\u0041\u0063\u0074\u0069\u006f\u006e"))
	_edg.SetIfNotNil("\u0053", _cd.S)
	_edg.SetIfNotNil("\u004e\u0065\u0078\u0074", _cd.Next)
	return _gdd
}

// GetContainingPdfObject returns the container of the shading object (indirect object).
func (_fccb *PdfShading) GetContainingPdfObject() _agf.PdfObject { return _fccb._ggbge }

// ApplyStandard is used to apply changes required on the document to match the rules required by the input standard.
// The writer's content would be changed after all the document parts are already established during the Write method.
// A good example of the StandardApplier could be a PDF/A Profile (i.e.: pdfa.Profile1A). In such a case PdfWriter would
// set up all rules required by that Profile.
func (_fbcbf *PdfWriter) ApplyStandard(optimizer StandardApplier)     { _fbcbf._fdfce = optimizer }
func (_facgb *pdfCIDFontType2) getFontDescriptor() *PdfFontDescriptor { return _facgb._dcfcb }

// AddExtGState add External Graphics State (GState). The gsDict can be specified
// either directly as a dictionary or an indirect object containing a dictionary.
func (_eeacd *PdfPageResources) AddExtGState(gsName _agf.PdfObjectName, gsDict _agf.PdfObject) error {
	if _eeacd.ExtGState == nil {
		_eeacd.ExtGState = _agf.MakeDict()
	}
	_ggafa := _eeacd.ExtGState
	_gdffdb, _dedcbc := _agf.TraceToDirectObject(_ggafa).(*_agf.PdfObjectDictionary)
	if !_dedcbc {
		_fd.Log.Debug("\u0045\u0078\u0074\u0047\u0053\u0074\u0061\u0074\u0065\u0020\u0074\u0079\u0070\u0065\u0020e\u0072r\u006f\u0072\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u002f\u0025\u0054\u0029", _ggafa, _agf.TraceToDirectObject(_ggafa))
		return _agf.ErrTypeError
	}
	_gdffdb.Set(gsName, gsDict)
	return nil
}

// PdfAnnotationStrikeOut represents StrikeOut annotations.
// (Section 12.5.6.10).
type PdfAnnotationStrikeOut struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	QuadPoints _agf.PdfObject
}

func (_ded *PdfReader) newPdfAnnotationPolygonFromDict(_defbc *_agf.PdfObjectDictionary) (*PdfAnnotationPolygon, error) {
	_dabf := PdfAnnotationPolygon{}
	_cafc, _gafg := _ded.newPdfAnnotationMarkupFromDict(_defbc)
	if _gafg != nil {
		return nil, _gafg
	}
	_dabf.PdfAnnotationMarkup = _cafc
	_dabf.Vertices = _defbc.Get("\u0056\u0065\u0072\u0074\u0069\u0063\u0065\u0073")
	_dabf.LE = _defbc.Get("\u004c\u0045")
	_dabf.BS = _defbc.Get("\u0042\u0053")
	_dabf.IC = _defbc.Get("\u0049\u0043")
	_dabf.BE = _defbc.Get("\u0042\u0045")
	_dabf.IT = _defbc.Get("\u0049\u0054")
	_dabf.Measure = _defbc.Get("\u004de\u0061\u0073\u0075\u0072\u0065")
	return &_dabf, nil
}
func _ddfa(_fecac *_agf.PdfObjectDictionary) (*PdfShadingType2, error) {
	_fbccf := PdfShadingType2{}
	_cgaeg := _fecac.Get("\u0043\u006f\u006f\u0072\u0064\u0073")
	if _cgaeg == nil {
		_fd.Log.Debug("R\u0065\u0071\u0075\u0069\u0072\u0065d\u0020\u0061\u0074\u0074\u0072\u0069b\u0075\u0074\u0065\u0020\u006d\u0069\u0073s\u0069\u006e\u0067\u003a\u0020\u0020\u0043\u006f\u006f\u0072d\u0073")
		return nil, ErrRequiredAttributeMissing
	}
	_eaffe, _fcgg := _cgaeg.(*_agf.PdfObjectArray)
	if !_fcgg {
		_fd.Log.Debug("\u0043\u006f\u006f\u0072d\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072a\u0079\u0020\u0028\u0067\u006f\u0074\u0020%\u0054\u0029", _cgaeg)
		return nil, _gcd.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	if _eaffe.Len() != 4 {
		_fd.Log.Debug("\u0043\u006f\u006f\u0072d\u0073\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074 \u0034\u0020\u0028\u0067\u006f\u0074\u0020%\u0064\u0029", _eaffe.Len())
		return nil, _gcd.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065")
	}
	_fbccf.Coords = _eaffe
	if _abeegb := _fecac.Get("\u0044\u006f\u006d\u0061\u0069\u006e"); _abeegb != nil {
		_abeegb = _agf.TraceToDirectObject(_abeegb)
		_feda, _badee := _abeegb.(*_agf.PdfObjectArray)
		if !_badee {
			_fd.Log.Debug("\u0044\u006f\u006d\u0061i\u006e\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072a\u0079\u0020\u0028\u0067\u006f\u0074\u0020%\u0054\u0029", _abeegb)
			return nil, _gcd.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
		}
		_fbccf.Domain = _feda
	}
	_cgaeg = _fecac.Get("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e")
	if _cgaeg == nil {
		_fd.Log.Debug("\u0052\u0065q\u0075\u0069\u0072\u0065d\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020m\u0069\u0073\u0073\u0069\u006e\u0067\u003a\u0020\u0020\u0046\u0075\u006ec\u0074\u0069\u006f\u006e")
		return nil, ErrRequiredAttributeMissing
	}
	_fbccf.Function = []PdfFunction{}
	if _begdb, _caff := _cgaeg.(*_agf.PdfObjectArray); _caff {
		for _, _caaae := range _begdb.Elements() {
			_gbfad, _dcfac := _ccedb(_caaae)
			if _dcfac != nil {
				_fd.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e:\u0020\u0025\u0076", _dcfac)
				return nil, _dcfac
			}
			_fbccf.Function = append(_fbccf.Function, _gbfad)
		}
	} else {
		_gfbce, _dbece := _ccedb(_cgaeg)
		if _dbece != nil {
			_fd.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e:\u0020\u0025\u0076", _dbece)
			return nil, _dbece
		}
		_fbccf.Function = append(_fbccf.Function, _gfbce)
	}
	if _cgadb := _fecac.Get("\u0045\u0078\u0074\u0065\u006e\u0064"); _cgadb != nil {
		_cgadb = _agf.TraceToDirectObject(_cgadb)
		_cfga, _addd := _cgadb.(*_agf.PdfObjectArray)
		if !_addd {
			_fd.Log.Debug("\u004d\u0061\u0074\u0072i\u0078\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072a\u0079\u0020\u0028\u0067\u006f\u0074\u0020%\u0054\u0029", _cgadb)
			return nil, _agf.ErrTypeError
		}
		if _cfga.Len() != 2 {
			_fd.Log.Debug("\u0045\u0078\u0074\u0065n\u0064\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074 \u0032\u0020\u0028\u0067\u006f\u0074\u0020%\u0064\u0029", _cfga.Len())
			return nil, ErrInvalidAttribute
		}
		_fbccf.Extend = _cfga
	}
	return &_fbccf, nil
}
func (_cagd *PdfReader) newPdfActionGoTo3DViewFromDict(_gag *_agf.PdfObjectDictionary) (*PdfActionGoTo3DView, error) {
	return &PdfActionGoTo3DView{TA: _gag.Get("\u0054\u0041"), V: _gag.Get("\u0056")}, nil
}
func _fbffcc(_ccdba _agf.PdfObject, _bcfbg bool) (*PdfFont, error) {
	_eggcg, _fdfbe, _dceca := _cagaf(_ccdba)
	if _eggcg != nil {
		_fcga(_eggcg)
	}
	if _dceca != nil {
		if _dceca == ErrType1CFontNotSupported {
			_eccd, _adfc := _bfgfd(_eggcg, _fdfbe, nil)
			if _adfc != nil {
				_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0057h\u0069\u006c\u0065 l\u006f\u0061\u0064\u0069\u006e\u0067 \u0073\u0069\u006d\u0070\u006c\u0065\u0020\u0066\u006f\u006e\u0074\u003a\u0020\u0066\u006fn\u0074\u003d\u0025\u0073\u0020\u0065\u0072\u0072=\u0025\u0076", _fdfbe, _adfc)
				return nil, _dceca
			}
			return &PdfFont{_effaa: _eccd}, _dceca
		}
		return nil, _dceca
	}
	_dcge := &PdfFont{}
	switch _fdfbe._bcbfd {
	case "\u0054\u0079\u0070e\u0030":
		if !_bcfbg {
			_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052:\u0020\u004c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0074\u0079\u0070\u00650\u0020\u006e\u006f\u0074\u0020\u0061\u006c\u006c\u006f\u0077\u0065\u0064\u002e\u0020\u0066\u006f\u006e\u0074\u003d\u0025\u0073", _fdfbe)
			return nil, _gcd.New("\u0063\u0079\u0063\u006cic\u0061\u006c\u0020\u0074\u0079\u0070\u0065\u0030\u0020\u006c\u006f\u0061\u0064\u0069n\u0067")
		}
		_bebcc, _egbdg := _dfff(_eggcg, _fdfbe)
		if _egbdg != nil {
			_fd.Log.Debug("E\u0052\u0052\u004f\u0052\u003a\u0020\u0057\u0068\u0069l\u0065\u0020\u006c\u006f\u0061\u0064\u0069ng\u0020\u0054\u0079\u0070e\u0030\u0020\u0066\u006f\u006e\u0074\u002e\u0020\u0066on\u0074\u003d%\u0073\u0020\u0065\u0072\u0072\u003d\u0025\u0076", _fdfbe, _egbdg)
			return nil, _egbdg
		}
		_dcge._effaa = _bebcc
	case "\u0054\u0079\u0070e\u0031", "\u004dM\u0054\u0079\u0070\u0065\u0031", "\u0054\u0072\u0075\u0065\u0054\u0079\u0070\u0065":
		var _daefb *pdfFontSimple
		_ecbd, _edce := _aa.NewStdFontByName(_aa.StdFontName(_fdfbe._fccf))
		if _edce {
			_fdbag := _gfgcd(_ecbd)
			_dcge._effaa = &_fdbag
			_ggagf := _agf.TraceToDirectObject(_fdbag.ToPdfObject())
			_fedbe, _ddaa, _abfde := _cagaf(_ggagf)
			if _abfde != nil {
				_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0042\u0061\u0064\u0020\u0053\u0074a\u006e\u0064\u0061\u0072\u0064\u00314\u000a\u0009\u0066\u006f\u006e\u0074\u003d\u0025\u0073\u000a\u0009\u0073\u0074d\u003d\u0025\u002b\u0076", _fdfbe, _fdbag)
				return nil, _abfde
			}
			for _, _dffbd := range _eggcg.Keys() {
				_fedbe.Set(_dffbd, _eggcg.Get(_dffbd))
			}
			_daefb, _abfde = _bfgfd(_fedbe, _ddaa, _fdbag._eebb)
			if _abfde != nil {
				_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0042\u0061\u0064\u0020\u0053\u0074a\u006e\u0064\u0061\u0072\u0064\u00314\u000a\u0009\u0066\u006f\u006e\u0074\u003d\u0025\u0073\u000a\u0009\u0073\u0074d\u003d\u0025\u002b\u0076", _fdfbe, _fdbag)
				return nil, _abfde
			}
			_daefb._fcad = _fdbag._fcad
			_daefb._fbgbg = _fdbag._fbgbg
			if _daefb._cfggc == nil {
				_daefb._cfggc = _fdbag._cfggc
			}
		} else {
			_daefb, _dceca = _bfgfd(_eggcg, _fdfbe, nil)
			if _dceca != nil {
				_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0057h\u0069\u006c\u0065 l\u006f\u0061\u0064\u0069\u006e\u0067 \u0073\u0069\u006d\u0070\u006c\u0065\u0020\u0066\u006f\u006e\u0074\u003a\u0020\u0066\u006fn\u0074\u003d\u0025\u0073\u0020\u0065\u0072\u0072=\u0025\u0076", _fdfbe, _dceca)
				return nil, _dceca
			}
		}
		_dceca = _daefb.addEncoding()
		if _dceca != nil {
			return nil, _dceca
		}
		if _edce {
			_daefb.updateStandard14Font()
		}
		if _edce && _daefb._dbgde == nil && _daefb._eebb == nil {
			_fd.Log.Error("\u0073\u0069\u006d\u0070\u006c\u0065\u0066\u006f\u006e\u0074\u003d\u0025\u0073", _daefb)
			_fd.Log.Error("\u0066n\u0074\u003d\u0025\u002b\u0076", _ecbd)
		}
		if len(_daefb._fcad) == 0 {
			_fd.Log.Debug("\u0045R\u0052\u004f\u0052\u003a \u004e\u006f\u0020\u0077\u0069d\u0074h\u0073.\u0020\u0066\u006f\u006e\u0074\u003d\u0025s", _daefb)
		}
		_dcge._effaa = _daefb
	case "\u0054\u0079\u0070e\u0033":
		_gfed, _eecb := _bbgcg(_eggcg, _fdfbe)
		if _eecb != nil {
			_fd.Log.Debug("E\u0052\u0052\u004f\u0052\u003a\u0020W\u0068\u0069\u006c\u0065\u0020\u006co\u0061\u0064\u0069\u006e\u0067\u0020\u0074y\u0070\u0065\u0033\u0020\u0066\u006f\u006e\u0074\u003a\u0020%\u0076", _eecb)
			return nil, _eecb
		}
		_dcge._effaa = _gfed
	case "\u0043\u0049\u0044F\u006f\u006e\u0074\u0054\u0079\u0070\u0065\u0030":
		_dgdf, _cbce := _bcdc(_eggcg, _fdfbe)
		if _cbce != nil {
			_fd.Log.Debug("\u0045R\u0052\u004fR\u003a\u0020\u0057\u0068i\u006c\u0065\u0020l\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0063\u0069d \u0066\u006f\u006et\u0020\u0074y\u0070\u0065\u0030\u0020\u0066\u006fn\u0074\u003a \u0025\u0076", _cbce)
			return nil, _cbce
		}
		_dcge._effaa = _dgdf
	case "\u0043\u0049\u0044F\u006f\u006e\u0074\u0054\u0079\u0070\u0065\u0032":
		_edfgc, _ffaad := _abef(_eggcg, _fdfbe)
		if _ffaad != nil {
			_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0057\u0068\u0069l\u0065\u0020\u006co\u0061\u0064\u0069\u006e\u0067\u0020\u0063\u0069\u0064\u0020f\u006f\u006e\u0074\u0020\u0074yp\u0065\u0032\u0020\u0066\u006f\u006e\u0074\u002e\u0020\u0066\u006f\u006e\u0074\u003d\u0025\u0073\u0020\u0065\u0072\u0072\u003d\u0025\u0076", _fdfbe, _ffaad)
			return nil, _ffaad
		}
		_dcge._effaa = _edfgc
	default:
		_fd.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020U\u006e\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020f\u006f\u006e\u0074\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0066\u006fn\u0074\u003d\u0025\u0073", _fdfbe)
		return nil, _b.Errorf("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0066\u006f\u006e\u0074\u0020\u0074y\u0070\u0065\u003a\u0020\u0066\u006f\u006e\u0074\u003d\u0025\u0073", _fdfbe)
	}
	return _dcge, nil
}

// PdfActionType represents an action type in PDF (section 12.6.4 p. 417).
type PdfActionType string

// A returns the value of the A component of the color.
func (_afae *PdfColorLab) A() float64 { return _afae[1] }

// NewPdfColorDeviceGray returns a new grayscale color based on an input grayscale float value in range [0-1].
func NewPdfColorDeviceGray(grayVal float64) *PdfColorDeviceGray {
	_ecfg := PdfColorDeviceGray(grayVal)
	return &_ecfg
}

// GetCatalogStructTreeRoot gets the catalog StructTreeRoot object.
func (_cadf *PdfReader) GetCatalogStructTreeRoot() (_agf.PdfObject, bool) {
	if _cadf._ceaadd == nil {
		return nil, false
	}
	_dagg := _cadf._ceaadd.Get("\u0053\u0074\u0072\u0075\u0063\u0074\u0054\u0072\u0065e\u0052\u006f\u006f\u0074")
	return _dagg, _dagg != nil
}

var (
	_ecba  _a.Mutex
	_bebbe = ""
	_acbaf _e.Time
	_agbb  = ""
	_dedfe = ""
	_bbaee _e.Time
	_badad = ""
	_dbdce = ""
	_abdfe = ""
)

// Items returns all children outline items.
func (_gdba *OutlineItem) Items() []*OutlineItem { return _gdba.Entries }

// G returns the value of the green component of the color.
func (_dddb *PdfColorDeviceRGB) G() float64 { return _dddb[1] }
func (_ecefd *PdfAcroForm) filteredFields(_bbegb FieldFilterFunc, _fbgbc bool) []*PdfField {
	if _ecefd == nil {
		return nil
	}
	return _bbddf(_ecefd.Fields, _bbegb, _fbgbc)
}

// ReaderToWriterOpts options used to generate a PdfWriter.
type ReaderToWriterOpts struct {
	SkipAcroForm        bool
	SkipInfo            bool
	SkipNameDictionary  bool
	SkipNamedDests      bool
	SkipOCProperties    bool
	SkipOutlines        bool
	SkipPageLabels      bool
	SkipRotation        bool
	SkipMetadata        bool
	PageProcessCallback PageProcessCallback

	// Deprecated: will be removed in v4. Use PageProcessCallback instead.
	PageCallback PageCallback
}

// String returns a string that describes `font`.
func (_cegaf *PdfFont) String() string {
	_acaa := ""
	if _cegaf._effaa.Encoder() != nil {
		_acaa = _cegaf._effaa.Encoder().String()
	}
	return _b.Sprintf("\u0046\u004f\u004e\u0054\u007b\u0025\u0054\u0020\u0025s\u0020\u0025\u0073\u007d", _cegaf._effaa, _cegaf.baseFields().coreString(), _acaa)
}

// SetFontByName sets the font specified by keyName to the given object.
func (_fabfg *PdfPageResources) SetFontByName(keyName _agf.PdfObjectName, obj _agf.PdfObject) error {
	if _fabfg.Font == nil {
		_fabfg.Font = _agf.MakeDict()
	}
	_cdgca, _gafcf := _agf.TraceToDirectObject(_fabfg.Font).(*_agf.PdfObjectDictionary)
	if !_gafcf {
		_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u006f\u006e\u0074\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069\u006fn\u0061\u0072\u0079\u0021\u0020(\u0067\u006ft\u0020\u0025\u0054\u0029", _agf.TraceToDirectObject(_fabfg.Font))
		return _agf.ErrTypeError
	}
	_cdgca.Set(keyName, obj)
	return nil
}

// WriteToFile writes the output PDF to file.
func (_cdedc *PdfWriter) WriteToFile(outputFilePath string) error {
	_cbfac, _agggf := _fb.Create(outputFilePath)
	if _agggf != nil {
		return _agggf
	}
	defer _cbfac.Close()
	return _cdedc.Write(_cbfac)
}

// NewPdfFilespec returns an initialized generic PDF filespec model.
func NewPdfFilespec() *PdfFilespec {
	_bdbfc := &PdfFilespec{}
	_bdbfc._bfdc = _agf.MakeIndirectObject(_agf.MakeDict())
	return _bdbfc
}

const (
	RC4_128bit = EncryptionAlgorithm(iota)
	AES_128bit
	AES_256bit
)

// PdfColorspaceDeviceGray represents a grayscale colorspace.
type PdfColorspaceDeviceGray struct{}

// FieldValueProvider provides field values from a data source such as FDF, JSON or any other.
type FieldValueProvider interface {
	FieldValues() (map[string]_agf.PdfObject, error)
}

// GetXObjectImageByName returns the XObjectImage with the specified name from the
// page resources, if it exists.
func (_dbeag *PdfPageResources) GetXObjectImageByName(keyName _agf.PdfObjectName) (*XObjectImage, error) {
	_acdfe, _egeaf := _dbeag.GetXObjectByName(keyName)
	if _acdfe == nil {
		return nil, nil
	}
	if _egeaf != XObjectTypeImage {
		return nil, _gcd.New("\u006e\u006f\u0074 \u0061\u006e\u0020\u0069\u006d\u0061\u0067\u0065")
	}
	_addfg, _bdaee := NewXObjectImageFromStream(_acdfe)
	if _bdaee != nil {
		return nil, _bdaee
	}
	return _addfg, nil
}

// ColorToRGB converts a color in Separation colorspace to RGB colorspace.
func (_cfda *PdfColorspaceSpecialSeparation) ColorToRGB(color PdfColor) (PdfColor, error) {
	if _cfda.AlternateSpace == nil {
		return nil, _gcd.New("\u0061\u006c\u0074\u0065\u0072\u006e\u0061\u0074\u0065\u0020c\u006f\u006c\u006f\u0072\u0073\u0070\u0061c\u0065\u0020\u0075\u006e\u0064\u0065\u0066\u0069\u006e\u0065\u0064")
	}
	return _cfda.AlternateSpace.ColorToRGB(color)
}
func (_bge *PdfReader) newPdfActionJavaScriptFromDict(_abb *_agf.PdfObjectDictionary) (*PdfActionJavaScript, error) {
	return &PdfActionJavaScript{JS: _abb.Get("\u004a\u0053")}, nil
}

// GetRuneMetrics returns the char metrics for a rune.
// TODO(peterwilliams97) There is nothing callers can do if no CharMetrics are found so we might as
// well give them 0 width. There is no need for the bool return.
func (_cfaccf *PdfFont) GetRuneMetrics(r rune) (CharMetrics, bool) {
	_cceg := _cfaccf.actualFont()
	if _cceg == nil {
		_fd.Log.Debug("ER\u0052\u004fR\u003a\u0020\u0047\u0065\u0074\u0047\u006c\u0079\u0070h\u0043\u0068\u0061\u0072\u004d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u004e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064\u0020f\u006fr\u0020\u0066\u006f\u006e\u0074\u0020\u0074\u0079p\u0065=\u0025\u0023T", _cfaccf._effaa)
		return _aa.CharMetrics{}, false
	}
	if _aabdd, _beffg := _cceg.GetRuneMetrics(r); _beffg {
		return _aabdd, true
	}
	if _fcebd, _gafcc := _cfaccf.GetFontDescriptor(); _gafcc == nil && _fcebd != nil {
		return _aa.CharMetrics{Wx: _fcebd._dgag}, true
	}
	_fd.Log.Debug("\u0047\u0065\u0074\u0047\u006c\u0079\u0070h\u0043\u0068\u0061r\u004d\u0065\u0074\u0072i\u0063\u0073\u003a\u0020\u004e\u006f\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u0066\u006f\u0072\u0020\u0066\u006f\u006e\u0074\u003d\u0025\u0073", _cfaccf)
	return _aa.CharMetrics{}, false
}

// PdfAnnotationSquare represents Square annotations.
// (Section 12.5.6.8).
type PdfAnnotationSquare struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	BS _agf.PdfObject
	IC _agf.PdfObject
	BE _agf.PdfObject
	RD _agf.PdfObject
}

// ToPdfObject returns the PdfFontDescriptor as a PDF dictionary inside an indirect object.
func (_fgcac *PdfFontDescriptor) ToPdfObject() _agf.PdfObject {
	_bbfb := _agf.MakeDict()
	if _fgcac._cfgc == nil {
		_fgcac._cfgc = &_agf.PdfIndirectObject{}
	}
	_fgcac._cfgc.PdfObject = _bbfb
	_bbfb.Set("\u0054\u0079\u0070\u0065", _agf.MakeName("\u0046\u006f\u006e\u0074\u0044\u0065\u0073\u0063\u0072i\u0070\u0074\u006f\u0072"))
	if _fgcac.FontName != nil {
		_bbfb.Set("\u0046\u006f\u006e\u0074\u004e\u0061\u006d\u0065", _fgcac.FontName)
	}
	if _fgcac.FontFamily != nil {
		_bbfb.Set("\u0046\u006f\u006e\u0074\u0046\u0061\u006d\u0069\u006c\u0079", _fgcac.FontFamily)
	}
	if _fgcac.FontStretch != nil {
		_bbfb.Set("F\u006f\u006e\u0074\u0053\u0074\u0072\u0065\u0074\u0063\u0068", _fgcac.FontStretch)
	}
	if _fgcac.FontWeight != nil {
		_bbfb.Set("\u0046\u006f\u006e\u0074\u0057\u0065\u0069\u0067\u0068\u0074", _fgcac.FontWeight)
	}
	if _fgcac.Flags != nil {
		_bbfb.Set("\u0046\u006c\u0061g\u0073", _fgcac.Flags)
	}
	if _fgcac.FontBBox != nil {
		_bbfb.Set("\u0046\u006f\u006e\u0074\u0042\u0042\u006f\u0078", _fgcac.FontBBox)
	}
	if _fgcac.ItalicAngle != nil {
		_bbfb.Set("I\u0074\u0061\u006c\u0069\u0063\u0041\u006e\u0067\u006c\u0065", _fgcac.ItalicAngle)
	}
	if _fgcac.Ascent != nil {
		_bbfb.Set("\u0041\u0073\u0063\u0065\u006e\u0074", _fgcac.Ascent)
	}
	if _fgcac.Descent != nil {
		_bbfb.Set("\u0044e\u0073\u0063\u0065\u006e\u0074", _fgcac.Descent)
	}
	if _fgcac.Leading != nil {
		_bbfb.Set("\u004ce\u0061\u0064\u0069\u006e\u0067", _fgcac.Leading)
	}
	if _fgcac.CapHeight != nil {
		_bbfb.Set("\u0043a\u0070\u0048\u0065\u0069\u0067\u0068t", _fgcac.CapHeight)
	}
	if _fgcac.XHeight != nil {
		_bbfb.Set("\u0058H\u0065\u0069\u0067\u0068\u0074", _fgcac.XHeight)
	}
	if _fgcac.StemV != nil {
		_bbfb.Set("\u0053\u0074\u0065m\u0056", _fgcac.StemV)
	}
	if _fgcac.StemH != nil {
		_bbfb.Set("\u0053\u0074\u0065m\u0048", _fgcac.StemH)
	}
	if _fgcac.AvgWidth != nil {
		_bbfb.Set("\u0041\u0076\u0067\u0057\u0069\u0064\u0074\u0068", _fgcac.AvgWidth)
	}
	if _fgcac.MaxWidth != nil {
		_bbfb.Set("\u004d\u0061\u0078\u0057\u0069\u0064\u0074\u0068", _fgcac.MaxWidth)
	}
	if _fgcac.MissingWidth != nil {
		_bbfb.Set("\u004d\u0069\u0073s\u0069\u006e\u0067\u0057\u0069\u0064\u0074\u0068", _fgcac.MissingWidth)
	}
	if _fgcac.FontFile != nil {
		_bbfb.Set("\u0046\u006f\u006e\u0074\u0046\u0069\u006c\u0065", _fgcac.FontFile)
	}
	if _fgcac.FontFile2 != nil {
		_bbfb.Set("\u0046o\u006e\u0074\u0046\u0069\u006c\u00652", _fgcac.FontFile2)
	}
	if _fgcac.FontFile3 != nil {
		_bbfb.Set("\u0046o\u006e\u0074\u0046\u0069\u006c\u00653", _fgcac.FontFile3)
	}
	if _fgcac.CharSet != nil {
		_bbfb.Set("\u0043h\u0061\u0072\u0053\u0065\u0074", _fgcac.CharSet)
	}
	if _fgcac.Style != nil {
		_bbfb.Set("\u0046\u006f\u006e\u0074\u004e\u0061\u006d\u0065", _fgcac.FontName)
	}
	if _fgcac.Lang != nil {
		_bbfb.Set("\u004c\u0061\u006e\u0067", _fgcac.Lang)
	}
	if _fgcac.FD != nil {
		_bbfb.Set("\u0046\u0044", _fgcac.FD)
	}
	if _fgcac.CIDSet != nil {
		_bbfb.Set("\u0043\u0049\u0044\u0053\u0065\u0074", _fgcac.CIDSet)
	}
	return _fgcac._cfgc
}
func (_gegc *LTV) getCRLs(_bdcga []*_ed.Certificate) ([][]byte, error) {
	_fege := make([][]byte, 0, len(_bdcga))
	for _, _ffaab := range _bdcga {
		for _, _fccdg := range _ffaab.CRLDistributionPoints {
			if _gegc.CertClient.IsCA(_ffaab) {
				continue
			}
			_ccccf, _fgdaga := _gegc.CRLClient.MakeRequest(_fccdg, _ffaab)
			if _fgdaga != nil {
				_fd.Log.Debug("W\u0041\u0052\u004e\u003a\u0020\u0043R\u004c\u0020\u0072\u0065\u0071\u0075\u0065\u0073\u0074 \u0065\u0072\u0072o\u0072:\u0020\u0025\u0076", _fgdaga)
				continue
			}
			_fege = append(_fege, _ccccf)
		}
	}
	return _fege, nil
}
func _ecbgg(_bggfb string) (map[_fcg.CharCode]_fcg.GlyphName, error) {
	_aegab := _gc.Split(_bggfb, "\u000a")
	_gcbb := make(map[_fcg.CharCode]_fcg.GlyphName)
	for _, _gaaf := range _aegab {
		_fgaca := _ceaaa.FindStringSubmatch(_gaaf)
		if _fgaca == nil {
			continue
		}
		_dccd, _bcad := _fgaca[1], _fgaca[2]
		_dcae, _badcf := _ge.Atoi(_dccd)
		if _badcf != nil {
			_fd.Log.Debug("\u0045\u0052\u0052\u004fR\u003a\u0020\u0042\u0061\u0064\u0020\u0065\u006e\u0063\u006fd\u0069n\u0067\u0020\u006c\u0069\u006e\u0065\u002e \u0025\u0071", _gaaf)
			return nil, _agf.ErrTypeError
		}
		_gcbb[_fcg.CharCode(_dcae)] = _fcg.GlyphName(_bcad)
	}
	_fd.Log.Trace("g\u0065\u0074\u0045\u006e\u0063\u006fd\u0069\u006e\u0067\u0073\u003a\u0020\u006b\u0065\u0079V\u0061\u006c\u0075e\u0073=\u0025\u0023\u0076", _gcbb)
	return _gcbb, nil
}

// PdfOutline represents a PDF outline dictionary (Table 152 - p. 376).
type PdfOutline struct {
	PdfOutlineTreeNode
	Parent *PdfOutlineTreeNode
	Count  *int64
	_gbeea *_agf.PdfIndirectObject
}

func (_egb *PdfReader) newPdfActionHideFromDict(_agab *_agf.PdfObjectDictionary) (*PdfActionHide, error) {
	return &PdfActionHide{T: _agab.Get("\u0054"), H: _agab.Get("\u0048")}, nil
}

var _aecab = false

// NewPdfAnnotationLine returns a new line annotation.
func NewPdfAnnotationLine() *PdfAnnotationLine {
	_gcce := NewPdfAnnotation()
	_ecf := &PdfAnnotationLine{}
	_ecf.PdfAnnotation = _gcce
	_ecf.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_gcce.SetContext(_ecf)
	return _ecf
}
func (_fbe *PdfColorspaceDeviceGray) String() string {
	return "\u0044\u0065\u0076\u0069\u0063\u0065\u0047\u0072\u0061\u0079"
}

// AddFont adds a font dictionary to the Font resources.
func (_afbc *PdfPage) AddFont(name _agf.PdfObjectName, font _agf.PdfObject) error {
	if _afbc.Resources == nil {
		_afbc.Resources = NewPdfPageResources()
	}
	if _afbc.Resources.Font == nil {
		_afbc.Resources.Font = _agf.MakeDict()
	}
	_fefb, _bacb := _agf.TraceToDirectObject(_afbc.Resources.Font).(*_agf.PdfObjectDictionary)
	if !_bacb {
		_fd.Log.Debug("\u0045\u0078\u0070\u0065\u0063\u0074\u0065\u0064 \u0066\u006f\u006et \u0064\u0069\u0063\u0074\u0069\u006fn\u0061\u0072\u0079\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069c\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u003a \u0025\u0076", _agf.TraceToDirectObject(_afbc.Resources.Font))
		return _gcd.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	_fefb.Set(name, font)
	return nil
}

// ToPdfObject implements interface PdfModel.
func (_ggcb *PdfAnnotationText) ToPdfObject() _agf.PdfObject {
	_ggcb.PdfAnnotation.ToPdfObject()
	_aef := _ggcb._aeee
	_cbe := _aef.PdfObject.(*_agf.PdfObjectDictionary)
	if _ggcb.PdfAnnotationMarkup != nil {
		_ggcb.PdfAnnotationMarkup.appendToPdfDictionary(_cbe)
	}
	_cbe.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _agf.MakeName("\u0054\u0065\u0078\u0074"))
	_cbe.SetIfNotNil("\u004f\u0070\u0065\u006e", _ggcb.Open)
	_cbe.SetIfNotNil("\u004e\u0061\u006d\u0065", _ggcb.Name)
	_cbe.SetIfNotNil("\u0053\u0074\u0061t\u0065", _ggcb.State)
	_cbe.SetIfNotNil("\u0053\u0074\u0061\u0074\u0065\u004d\u006f\u0064\u0065\u006c", _ggcb.StateModel)
	return _aef
}

// Insert adds a top level outline item in the outline,
// at the specified index.
func (_fccag *Outline) Insert(index uint, item *OutlineItem) {
	_bcecd := uint(len(_fccag.Entries))
	if index > _bcecd {
		index = _bcecd
	}
	_fccag.Entries = append(_fccag.Entries[:index], append([]*OutlineItem{item}, _fccag.Entries[index:]...)...)
}

// NewPermissions returns a new permissions object.
func NewPermissions(docMdp *PdfSignature) *Permissions {
	_fecfd := Permissions{}
	_fecfd.DocMDP = docMdp
	_ggbgd := _agf.MakeDict()
	_ggbgd.Set("\u0044\u006f\u0063\u004d\u0044\u0050", docMdp.ToPdfObject())
	_fecfd._gebec = _ggbgd
	return &_fecfd
}

// Compress is yet to be implemented.
// Should be able to compress in terms of JPEG quality parameter,
// and DPI threshold (need to know bounding area dimensions).
func (_deadb DefaultImageHandler) Compress(input *Image, quality int64) (*Image, error) {
	return input, nil
}

// Insert adds an outline item as a child of the current outline item,
// at the specified index.
func (_adggf *OutlineItem) Insert(index uint, item *OutlineItem) {
	_acbfdc := uint(len(_adggf.Entries))
	if index > _acbfdc {
		index = _acbfdc
	}
	_adggf.Entries = append(_adggf.Entries[:index], append([]*OutlineItem{item}, _adggf.Entries[index:]...)...)
}

// PdfColorspaceDeviceN represents a DeviceN color space. DeviceN color spaces are similar to Separation color
// spaces, except they can contain an arbitrary number of color components.
/*
	Format: [/DeviceN names alternateSpace tintTransform]
        or: [/DeviceN names alternateSpace tintTransform attributes]
*/
type PdfColorspaceDeviceN struct {
	ColorantNames  *_agf.PdfObjectArray
	AlternateSpace PdfColorspace
	TintTransform  PdfFunction
	Attributes     *PdfColorspaceDeviceNAttributes
	_bddcd         *_agf.PdfIndirectObject
}

func (_befe *pdfFontType0) bytesToCharcodes(_gagee []byte) ([]_fcg.CharCode, bool) {
	if _befe._bgccg == nil {
		return nil, false
	}
	_accg, _deedg := _befe._bgccg.BytesToCharcodes(_gagee)
	if !_deedg {
		return nil, false
	}
	_baffb := make([]_fcg.CharCode, len(_accg))
	for _ddff, _dbed := range _accg {
		_baffb[_ddff] = _fcg.CharCode(_dbed)
	}
	return _baffb, true
}

// SetContentStream updates the content stream with specified encoding.
// If encoding is null, will use the xform.Filter object or Raw encoding if not set.
func (_dcdca *XObjectForm) SetContentStream(content []byte, encoder _agf.StreamEncoder) error {
	_adagd := content
	if encoder == nil {
		if _dcdca.Filter != nil {
			encoder = _dcdca.Filter
		} else {
			encoder = _agf.NewRawEncoder()
		}
	}
	_fcdcf, _cdcab := encoder.EncodeBytes(_adagd)
	if _cdcab != nil {
		return _cdcab
	}
	_adagd = _fcdcf
	_dcdca.Stream = _adagd
	_dcdca.Filter = encoder
	return nil
}

const (
	_deab  = 0x00001
	_geeg  = 0x00002
	_eggb  = 0x00004
	_dbadf = 0x00008
	_ccdf  = 0x00020
	_ebfd  = 0x00040
	_dbbcc = 0x10000
	_aadg  = 0x20000
	_eada  = 0x40000
)

// SetFillImage attach a model.Image to push button.
func (_cbfbg *PdfFieldButton) SetFillImage(image *Image) {
	if _cbfbg.IsPush() {
		_cbfbg._ffb = image
	}
}

// B returns the value of the B component of the color.
func (_afgb *PdfColorCalRGB) B() float64 { return _afgb[1] }

// SetPdfKeywords sets the Keywords attribute of the output PDF.
func SetPdfKeywords(keywords string) { _ecba.Lock(); defer _ecba.Unlock(); _dedfe = keywords }

// SetColorSpace sets `r` colorspace object to `colorspace`.
func (_eggd *PdfPageResources) SetColorSpace(colorspace *PdfPageResourcesColorspaces) {
	_eggd._dgceaa = colorspace
}

// ToPdfObject implements interface PdfModel.
func (_geggc *PdfSignatureReference) ToPdfObject() _agf.PdfObject {
	_bggfe := _agf.MakeDict()
	_bggfe.SetIfNotNil("\u0054\u0079\u0070\u0065", _geggc.Type)
	_bggfe.SetIfNotNil("\u0054r\u0061n\u0073\u0066\u006f\u0072\u006d\u004d\u0065\u0074\u0068\u006f\u0064", _geggc.TransformMethod)
	_bggfe.SetIfNotNil("\u0054r\u0061n\u0073\u0066\u006f\u0072\u006d\u0050\u0061\u0072\u0061\u006d\u0073", _geggc.TransformParams)
	_bggfe.SetIfNotNil("\u0044\u0061\u0074\u0061", _geggc.Data)
	_bggfe.SetIfNotNil("\u0044\u0069\u0067e\u0073\u0074\u004d\u0065\u0074\u0068\u006f\u0064", _geggc.DigestMethod)
	return _bggfe
}
func (_gdeg *PdfWriter) optimize() error {
	if _gdeg._dafgfa == nil {
		return nil
	}
	var _gdcgd error
	_gdeg._dgbd, _gdcgd = _gdeg._dafgfa.Optimize(_gdeg._dgbd)
	if _gdcgd != nil {
		return _gdcgd
	}
	_gdfgc := make(map[_agf.PdfObject]struct{}, len(_gdeg._dgbd))
	for _, _bcbdfa := range _gdeg._dgbd {
		_gdfgc[_bcbdfa] = struct{}{}
	}
	_gdeg._ccbbf = _gdfgc
	return nil
}
func _ffeff(_dfbcc *XObjectImage) error {
	if _dfbcc.SMask == nil {
		return nil
	}
	_aebge, _agdfe := _dfbcc.SMask.(*_agf.PdfObjectStream)
	if !_agdfe {
		_fd.Log.Debug("\u0053\u004da\u0073\u006b\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u002a\u0050\u0064\u0066\u004f\u0062\u006a\u0065\u0063\u0074\u0053\u0074re\u0061\u006d")
		return _agf.ErrTypeError
	}
	_fbdbc := _aebge.PdfObjectDictionary
	_cdfbg := _fbdbc.Get("\u004d\u0061\u0074t\u0065")
	if _cdfbg == nil {
		return nil
	}
	_fgbgf, _dedae := _cbfgb(_cdfbg.(*_agf.PdfObjectArray))
	if _dedae != nil {
		return _dedae
	}
	_cdded := _agf.MakeArrayFromFloats([]float64{_fgbgf})
	_fbdbc.SetIfNotNil("\u004d\u0061\u0074t\u0065", _cdded)
	return nil
}

// GetContainingPdfObject returns the container of the PdfAcroForm (indirect object).
func (_faae *PdfAcroForm) GetContainingPdfObject() _agf.PdfObject { return _faae._dfdbc }

// Read reads an image and loads into a new Image object with an RGB
// colormap and 8 bits per component.
func (_effbcc DefaultImageHandler) Read(reader _cf.Reader) (*Image, error) {
	_afeg, _, _edfb := _fe.Decode(reader)
	if _edfb != nil {
		_fd.Log.Debug("\u0045\u0072\u0072or\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0065\u003a\u0020\u0025\u0073", _edfb)
		return nil, _edfb
	}
	return _effbcc.NewImageFromGoImage(_afeg)
}
func (_fbdd *pdfCIDFontType0) baseFields() *fontCommon { return &_fbdd.fontCommon }

// NewPdfShadingType3 creates an empty shading type 3 dictionary.
func NewPdfShadingType3() *PdfShadingType3 {
	_edgcf := &PdfShadingType3{}
	_edgcf.PdfShading = &PdfShading{}
	_edgcf.PdfShading._ggbge = _agf.MakeIndirectObject(_agf.MakeDict())
	_edgcf.PdfShading._gefcd = _edgcf
	return _edgcf
}
func (_bdgb *PdfShading) getShadingDict() (*_agf.PdfObjectDictionary, error) {
	_bffcg := _bdgb._ggbge
	if _fdged, _gfaee := _bffcg.(*_agf.PdfIndirectObject); _gfaee {
		_fcfaa, _fabaa := _fdged.PdfObject.(*_agf.PdfObjectDictionary)
		if !_fabaa {
			return nil, _agf.ErrTypeError
		}
		return _fcfaa, nil
	} else if _cbgb, _ccbfg := _bffcg.(*_agf.PdfObjectStream); _ccbfg {
		return _cbgb.PdfObjectDictionary, nil
	} else if _gaee, _faee := _bffcg.(*_agf.PdfObjectDictionary); _faee {
		return _gaee, nil
	} else {
		_fd.Log.Debug("U\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0061\u0063\u0063\u0065s\u0073\u0020\u0073\u0068\u0061\u0064\u0069n\u0067\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061r\u0079")
		return nil, _agf.ErrTypeError
	}
}
func (_adc *PdfReader) newPdfActionGotoFromDict(_gbf *_agf.PdfObjectDictionary) (*PdfActionGoTo, error) {
	return &PdfActionGoTo{D: _gbf.Get("\u0044")}, nil
}

// ToPdfObject returns the PDF representation of the colorspace.
func (_cagbg *PdfColorspaceDeviceGray) ToPdfObject() _agf.PdfObject {
	return _agf.MakeName("\u0044\u0065\u0076\u0069\u0063\u0065\u0047\u0072\u0061\u0079")
}
func _fcdg(_dcff *XObjectForm) (*PdfRectangle, error) {
	if _bcab, _cbfcg := _dcff.BBox.(*_agf.PdfObjectArray); _cbfcg {
		_agga, _bafa := NewPdfRectangle(*_bcab)
		if _bafa != nil {
			return nil, _bafa
		}
		if _agaa, _deeed := _dcff.Matrix.(*_agf.PdfObjectArray); _deeed {
			_egce, _ccace := _agaa.ToFloat64Array()
			if _ccace != nil {
				return nil, _ccace
			}
			_edbfg := _fba.IdentityMatrix()
			if len(_egce) == 6 {
				_edbfg = _fba.NewMatrix(_egce[0], _egce[1], _egce[2], _egce[3], _egce[4], _egce[5])
			}
			_agga.Transform(_edbfg)
			return _agga, nil
		}
	}
	return nil, _gcd.New("\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0061\u0070\u0070\u0065\u0061\u0072\u0061n\u0063e\u0020\u0042\u0042\u006f\u0078\u0020\u0074y\u0070\u0065")
}

// ToInteger convert to an integer format.
func (_beda *PdfColorLab) ToInteger(bits int) [3]uint32 {
	_beab := _afb.Pow(2, float64(bits)) - 1
	return [3]uint32{uint32(_beab * _beda.L()), uint32(_beab * _beda.A()), uint32(_beab * _beda.B())}
}

// ToPdfObject implements interface PdfModel.
func (_ddec *PdfAnnotationRichMedia) ToPdfObject() _agf.PdfObject {
	_ddec.PdfAnnotation.ToPdfObject()
	_faaga := _ddec._aeee
	_cbd := _faaga.PdfObject.(*_agf.PdfObjectDictionary)
	_cbd.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _agf.MakeName("\u0052i\u0063\u0068\u004d\u0065\u0064\u0069a"))
	_cbd.SetIfNotNil("\u0052\u0069\u0063\u0068\u004d\u0065\u0064\u0069\u0061\u0053\u0065\u0074t\u0069\u006e\u0067\u0073", _ddec.RichMediaSettings)
	_cbd.SetIfNotNil("\u0052\u0069c\u0068\u004d\u0065d\u0069\u0061\u0043\u006f\u006e\u0074\u0065\u006e\u0074", _ddec.RichMediaContent)
	return _faaga
}

const (
	XObjectTypeUndefined XObjectType = iota
	XObjectTypeImage
	XObjectTypeForm
	XObjectTypePS
	XObjectTypeUnknown
)

func (_gdbg *PdfColorspaceDeviceRGB) String() string {
	return "\u0044e\u0076\u0069\u0063\u0065\u0052\u0047B"
}
func (_aeegd *PdfReader) traverseObjectData(_ccbfa _agf.PdfObject) error {
	return _agf.ResolveReferencesDeep(_ccbfa, _aeegd._eggbg)
}

var _ pdfFont = (*pdfFontType0)(nil)

func (_dbce *PdfReader) newPdfAnnotation3DFromDict(_bcce *_agf.PdfObjectDictionary) (*PdfAnnotation3D, error) {
	_dfc := PdfAnnotation3D{}
	_dfc.T3DD = _bcce.Get("\u0033\u0044\u0044")
	_dfc.T3DV = _bcce.Get("\u0033\u0044\u0056")
	_dfc.T3DA = _bcce.Get("\u0033\u0044\u0041")
	_dfc.T3DI = _bcce.Get("\u0033\u0044\u0049")
	_dfc.T3DB = _bcce.Get("\u0033\u0044\u0042")
	return &_dfc, nil
}
func (_ebabg *LTV) getCerts(_ddbd []*_ed.Certificate) ([][]byte, error) {
	_fdaffd := make([][]byte, 0, len(_ddbd))
	for _, _ccaa := range _ddbd {
		_fdaffd = append(_fdaffd, _ccaa.Raw)
	}
	return _fdaffd, nil
}

// ImageToRGB converts an image in CMYK32 colorspace to an RGB image.
func (_bgfe *PdfColorspaceDeviceCMYK) ImageToRGB(img Image) (Image, error) {
	_fd.Log.Trace("\u0043\u004d\u0059\u004b\u0033\u0032\u0020\u002d\u003e\u0020\u0052\u0047\u0042")
	_fd.Log.Trace("I\u006d\u0061\u0067\u0065\u0020\u0042P\u0043\u003a\u0020\u0025\u0064\u002c \u0043\u006f\u006c\u006f\u0072\u0020\u0063o\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073\u003a\u0020%\u0064", img.BitsPerComponent, img.ColorComponents)
	_fd.Log.Trace("\u004c\u0065\u006e \u0064\u0061\u0074\u0061\u003a\u0020\u0025\u0064", len(img.Data))
	_fd.Log.Trace("H\u0065\u0069\u0067\u0068t:\u0020%\u0064\u002c\u0020\u0057\u0069d\u0074\u0068\u003a\u0020\u0025\u0064", img.Height, img.Width)
	_afdd, _fdga := _ged.NewImage(int(img.Width), int(img.Height), int(img.BitsPerComponent), img.ColorComponents, img.Data, img._gdga, img._abacg)
	if _fdga != nil {
		return Image{}, _fdga
	}
	_bdbc, _fdga := _ged.NRGBAConverter.Convert(_afdd)
	if _fdga != nil {
		return Image{}, _fdga
	}
	return _ddgg(_bdbc.Base()), nil
}

// FieldFlag represents form field flags. Some of the flags can apply to all types of fields whereas other
// flags are specific.
type FieldFlag uint32

// NewPdfActionJavaScript returns a new "javaScript" action.
func NewPdfActionJavaScript() *PdfActionJavaScript {
	_eb := NewPdfAction()
	_egg := &PdfActionJavaScript{}
	_egg.PdfAction = _eb
	_eb.SetContext(_egg)
	return _egg
}

// GetFillImage get attached model.Image in push button.
func (_facge *PdfFieldButton) GetFillImage() *Image {
	if _facge.IsPush() {
		return _facge._ffb
	}
	return nil
}
func _dbffb() string { _ecba.Lock(); defer _ecba.Unlock(); return _dbdce }
func (_acgbe *PdfWriter) writeXRefStreams(_ccfe int, _fgbbd int64) error {
	_cggfb := _ccfe + 1
	_acgbe._ddcg[_cggfb] = crossReference{Type: 1, ObjectNumber: _cggfb, Offset: _fgbbd}
	_agbfe := _gg.NewBuffer(nil)
	_cgge := _agf.MakeArray()
	for _eefagg := 0; _eefagg <= _ccfe; {
		for ; _eefagg <= _ccfe; _eefagg++ {
			_abdag, _ecddbf := _acgbe._ddcg[_eefagg]
			if _ecddbf && (!_acgbe._accad || _acgbe._accad && (_abdag.Type == 1 && _abdag.Offset >= _acgbe._dbafe || _abdag.Type == 0)) {
				break
			}
		}
		var _aedca int
		for _aedca = _eefagg + 1; _aedca <= _ccfe; _aedca++ {
			_dafd, _fceg := _acgbe._ddcg[_aedca]
			if _fceg && (!_acgbe._accad || _acgbe._accad && (_dafd.Type == 1 && _dafd.Offset > _acgbe._dbafe)) {
				continue
			}
			break
		}
		_cgge.Append(_agf.MakeInteger(int64(_eefagg)), _agf.MakeInteger(int64(_aedca-_eefagg)))
		for _egegf := _eefagg; _egegf < _aedca; _egegf++ {
			_dfgfd := _acgbe._ddcg[_egegf]
			switch _dfgfd.Type {
			case 0:
				_bf.Write(_agbfe, _bf.BigEndian, byte(0))
				_bf.Write(_agbfe, _bf.BigEndian, uint32(0))
				_bf.Write(_agbfe, _bf.BigEndian, uint16(0xFFFF))
			case 1:
				_bf.Write(_agbfe, _bf.BigEndian, byte(1))
				_bf.Write(_agbfe, _bf.BigEndian, uint32(_dfgfd.Offset))
				_bf.Write(_agbfe, _bf.BigEndian, uint16(_dfgfd.Generation))
			case 2:
				_bf.Write(_agbfe, _bf.BigEndian, byte(2))
				_bf.Write(_agbfe, _bf.BigEndian, uint32(_dfgfd.ObjectNumber))
				_bf.Write(_agbfe, _bf.BigEndian, uint16(_dfgfd.Index))
			}
		}
		_eefagg = _aedca + 1
	}
	_febdd, _ccefg := _agf.MakeStream(_agbfe.Bytes(), _agf.NewFlateEncoder())
	if _ccefg != nil {
		return _ccefg
	}
	_febdd.ObjectNumber = int64(_cggfb)
	_febdd.PdfObjectDictionary.Set("\u0054\u0079\u0070\u0065", _agf.MakeName("\u0058\u0052\u0065\u0066"))
	_febdd.PdfObjectDictionary.Set("\u0057", _agf.MakeArray(_agf.MakeInteger(1), _agf.MakeInteger(4), _agf.MakeInteger(2)))
	_febdd.PdfObjectDictionary.Set("\u0049\u006e\u0064e\u0078", _cgge)
	_febdd.PdfObjectDictionary.Set("\u0053\u0069\u007a\u0065", _agf.MakeInteger(int64(_cggfb+1)))
	_febdd.PdfObjectDictionary.Set("\u0049\u006e\u0066\u006f", _acgbe._eaaaab)
	_febdd.PdfObjectDictionary.Set("\u0052\u006f\u006f\u0074", _acgbe._eccfaf)
	if _acgbe._accad && _acgbe._bdcea > 0 {
		_febdd.PdfObjectDictionary.Set("\u0050\u0072\u0065\u0076", _agf.MakeInteger(_acgbe._bdcea))
	}
	if _acgbe._cecgd != nil {
		_febdd.Set("\u0045n\u0063\u0072\u0079\u0070\u0074", _acgbe._gdcbf)
	}
	if _acgbe._fcgdbd == nil && _acgbe._bedbef != "" && _acgbe._daddd != "" {
		_acgbe._fcgdbd = _agf.MakeArray(_agf.MakeHexString(_acgbe._bedbef), _agf.MakeHexString(_acgbe._daddd))
	}
	if _acgbe._fcgdbd != nil {
		_fd.Log.Trace("\u0049d\u0073\u003a\u0020\u0025\u0073", _acgbe._fcgdbd)
		_febdd.Set("\u0049\u0044", _acgbe._fcgdbd)
	}
	_acgbe.writeObject(int(_febdd.ObjectNumber), _febdd)
	return nil
}

// ToPdfObject returns the PDF representation of the function.
func (_fbebe *PdfFunctionType4) ToPdfObject() _agf.PdfObject {
	_fgbgb := _fbebe._bcfbb
	if _fgbgb == nil {
		_fbebe._bcfbb = &_agf.PdfObjectStream{}
		_fgbgb = _fbebe._bcfbb
	}
	_dfada := _agf.MakeDict()
	_dfada.Set("\u0046\u0075\u006ec\u0074\u0069\u006f\u006e\u0054\u0079\u0070\u0065", _agf.MakeInteger(4))
	_bebbf := &_agf.PdfObjectArray{}
	for _, _cagdc := range _fbebe.Domain {
		_bebbf.Append(_agf.MakeFloat(_cagdc))
	}
	_dfada.Set("\u0044\u006f\u006d\u0061\u0069\u006e", _bebbf)
	_dded := &_agf.PdfObjectArray{}
	for _, _cabf := range _fbebe.Range {
		_dded.Append(_agf.MakeFloat(_cabf))
	}
	_dfada.Set("\u0052\u0061\u006eg\u0065", _dded)
	if _fbebe._bfdde == nil && _fbebe.Program != nil {
		_fbebe._bfdde = []byte(_fbebe.Program.String())
	}
	_dfada.Set("\u004c\u0065\u006e\u0067\u0074\u0068", _agf.MakeInteger(int64(len(_fbebe._bfdde))))
	_fgbgb.Stream = _fbebe._bfdde
	_fgbgb.PdfObjectDictionary = _dfada
	return _fgbgb
}

// ColorFromFloats returns a new PdfColor based on input color components.
func (_bcgfg *PdfColorspaceDeviceN) ColorFromFloats(vals []float64) (PdfColor, error) {
	if len(vals) != _bcgfg.GetNumComponents() {
		return nil, _gcd.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_afaef, _cbecg := _bcgfg.TintTransform.Evaluate(vals)
	if _cbecg != nil {
		return nil, _cbecg
	}
	_gafcd, _cbecg := _bcgfg.AlternateSpace.ColorFromFloats(_afaef)
	if _cbecg != nil {
		return nil, _cbecg
	}
	return _gafcd, nil
}

// NewPdfAnnotationStrikeOut returns a new text strikeout annotation.
func NewPdfAnnotationStrikeOut() *PdfAnnotationStrikeOut {
	_fgc := NewPdfAnnotation()
	_eff := &PdfAnnotationStrikeOut{}
	_eff.PdfAnnotation = _fgc
	_eff.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_fgc.SetContext(_eff)
	return _eff
}

const (
	FieldFlagClear             FieldFlag = 0
	FieldFlagReadOnly          FieldFlag = 1
	FieldFlagRequired          FieldFlag = (1 << 1)
	FieldFlagNoExport          FieldFlag = (2 << 1)
	FieldFlagNoToggleToOff     FieldFlag = (1 << 14)
	FieldFlagRadio             FieldFlag = (1 << 15)
	FieldFlagPushbutton        FieldFlag = (1 << 16)
	FieldFlagRadiosInUnision   FieldFlag = (1 << 25)
	FieldFlagMultiline         FieldFlag = (1 << 12)
	FieldFlagPassword          FieldFlag = (1 << 13)
	FieldFlagFileSelect        FieldFlag = (1 << 20)
	FieldFlagDoNotScroll       FieldFlag = (1 << 23)
	FieldFlagComb              FieldFlag = (1 << 24)
	FieldFlagRichText          FieldFlag = (1 << 26)
	FieldFlagDoNotSpellCheck   FieldFlag = (1 << 22)
	FieldFlagCombo             FieldFlag = (1 << 17)
	FieldFlagEdit              FieldFlag = (1 << 18)
	FieldFlagSort              FieldFlag = (1 << 19)
	FieldFlagMultiSelect       FieldFlag = (1 << 21)
	FieldFlagCommitOnSelChange FieldFlag = (1 << 27)
)

// PdfRectangle is a definition of a rectangle.
type PdfRectangle struct {
	Llx float64
	Lly float64
	Urx float64
	Ury float64
}

func (_ccgbg PdfFont) actualFont() pdfFont {
	if _ccgbg._effaa == nil {
		_fd.Log.Debug("\u0045\u0052\u0052O\u0052\u003a\u0020\u0061\u0063\u0074\u0075\u0061\u006c\u0046\u006f\u006e\u0074\u002e\u0020\u0063\u006f\u006e\u0074\u0065\u0078\u0074\u0020\u0069\u0073\u0020\u006e\u0069\u006c.\u0020\u0066\u006f\u006e\u0074\u003d\u0025\u0073", _ccgbg)
	}
	return _ccgbg._effaa
}
func (_gabd *PdfReader) loadDSS() (*DSS, error) {
	if _gabd._egdga.GetCrypter() != nil && !_gabd._egdga.IsAuthenticated() {
		return nil, _b.Errorf("\u0066\u0069\u006ce\u0020\u006e\u0065\u0065d\u0020\u0074\u006f\u0020\u0062\u0065\u0020d\u0065\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0020\u0066\u0069\u0072\u0073\u0074")
	}
	_dcaa := _gabd._ceaadd.Get("\u0044\u0053\u0053")
	if _dcaa == nil {
		return nil, nil
	}
	_fbfcg, _ := _agf.GetIndirect(_dcaa)
	_dcaa = _agf.TraceToDirectObject(_dcaa)
	switch _adgde := _dcaa.(type) {
	case *_agf.PdfObjectNull:
		return nil, nil
	case *_agf.PdfObjectDictionary:
		return _bbcc(_fbfcg, _adgde)
	}
	return nil, _b.Errorf("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0044\u0053\u0053 \u0065\u006e\u0074\u0072y \u0025\u0054", _dcaa)
}

// Height returns the height of `rect`.
func (_gfggf *PdfRectangle) Height() float64 { return _afb.Abs(_gfggf.Ury - _gfggf.Lly) }
func _aaba(_cefeg *fontCommon) *pdfFontType3 { return &pdfFontType3{fontCommon: *_cefeg} }
func (_cfgdd *PdfReader) loadOutlines() (*PdfOutlineTreeNode, error) {
	if _cfgdd._egdga.GetCrypter() != nil && !_cfgdd._egdga.IsAuthenticated() {
		return nil, _b.Errorf("\u0066\u0069\u006ce\u0020\u006e\u0065\u0065d\u0020\u0074\u006f\u0020\u0062\u0065\u0020d\u0065\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0020\u0066\u0069\u0072\u0073\u0074")
	}
	_bgfge := _cfgdd._ceaadd
	_dgebc := _bgfge.Get("\u004f\u0075\u0074\u006c\u0069\u006e\u0065\u0073")
	if _dgebc == nil {
		return nil, nil
	}
	_fd.Log.Trace("\u002d\u0048\u0061\u0073\u0020\u006f\u0075\u0074\u006c\u0069\u006e\u0065\u0073")
	_ddde := _agf.ResolveReference(_dgebc)
	_fd.Log.Trace("\u004f\u0075t\u006c\u0069\u006ee\u0020\u0072\u006f\u006f\u0074\u003a\u0020\u0025\u0076", _ddde)
	if _cccad := _agf.IsNullObject(_ddde); _cccad {
		_fd.Log.Trace("\u004f\u0075\u0074li\u006e\u0065\u0020\u0072\u006f\u006f\u0074\u0020\u0069s\u0020n\u0075l\u006c \u002d\u0020\u006e\u006f\u0020\u006f\u0075\u0074\u006c\u0069\u006e\u0065\u0073")
		return nil, nil
	}
	_gefbe, _dfaba := _ddde.(*_agf.PdfIndirectObject)
	if !_dfaba {
		if _, _agdc := _agf.GetDict(_ddde); !_agdc {
			_fd.Log.Debug("\u0049\u006e\u0076a\u006c\u0069\u0064\u0020o\u0075\u0074\u006c\u0069\u006e\u0065\u0020r\u006f\u006f\u0074\u0020\u002d\u0020\u0073\u006b\u0069\u0070\u0070\u0069\u006e\u0067")
			return nil, nil
		}
		_fd.Log.Debug("\u004f\u0075t\u006c\u0069\u006e\u0065\u0020r\u006f\u006f\u0074\u0020\u0069s\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u002e\u0020\u0053\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074")
		_gefbe = _agf.MakeIndirectObject(_ddde)
	}
	_dbee, _dfaba := _gefbe.PdfObject.(*_agf.PdfObjectDictionary)
	if !_dfaba {
		return nil, _gcd.New("\u006f\u0075\u0074\u006c\u0069n\u0065\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062j\u0065\u0063\u0074\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072y")
	}
	_fd.Log.Trace("O\u0075\u0074\u006c\u0069ne\u0020r\u006f\u006f\u0074\u0020\u0064i\u0063\u0074\u003a\u0020\u0025\u0076", _dbee)
	_egfdc, _, _cgdc := _cfgdd.buildOutlineTree(_gefbe, nil, nil, nil)
	if _cgdc != nil {
		return nil, _cgdc
	}
	_fd.Log.Trace("\u0052\u0065\u0073\u0075\u006c\u0074\u0069\u006e\u0067\u0020\u006fu\u0074\u006c\u0069\u006e\u0065\u0020\u0074\u0072\u0065\u0065:\u0020\u0025\u0076", _egfdc)
	return _egfdc, nil
}

// NewPdfAnnotationInk returns a new ink annotation.
func NewPdfAnnotationInk() *PdfAnnotationInk {
	_ccff := NewPdfAnnotation()
	_gea := &PdfAnnotationInk{}
	_gea.PdfAnnotation = _ccff
	_gea.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_ccff.SetContext(_gea)
	return _gea
}

// PdfActionSound represents a sound action.
type PdfActionSound struct {
	*PdfAction
	Sound       _agf.PdfObject
	Volume      _agf.PdfObject
	Synchronous _agf.PdfObject
	Repeat      _agf.PdfObject
	Mix         _agf.PdfObject
}

func (_gdb *PdfReader) newPdfActionSetOCGStateFromDict(_gcbg *_agf.PdfObjectDictionary) (*PdfActionSetOCGState, error) {
	return &PdfActionSetOCGState{State: _gcbg.Get("\u0053\u0074\u0061t\u0065"), PreserveRB: _gcbg.Get("\u0050\u0072\u0065\u0073\u0065\u0072\u0076\u0065\u0052\u0042")}, nil
}
func (_age *PdfReader) newPdfAnnotationUnderlineFromDict(_egfc *_agf.PdfObjectDictionary) (*PdfAnnotationUnderline, error) {
	_gcbc := PdfAnnotationUnderline{}
	_dbda, _eee := _age.newPdfAnnotationMarkupFromDict(_egfc)
	if _eee != nil {
		return nil, _eee
	}
	_gcbc.PdfAnnotationMarkup = _dbda
	_gcbc.QuadPoints = _egfc.Get("\u0051\u0075\u0061\u0064\u0050\u006f\u0069\u006e\u0074\u0073")
	return &_gcbc, nil
}
func _cebg(_daca *fontCommon) *pdfFontSimple { return &pdfFontSimple{fontCommon: *_daca} }

// GetModelFromPrimitive returns the model corresponding to the `primitive` PdfObject.
func (_dgcdd *modelManager) GetModelFromPrimitive(primitive _agf.PdfObject) PdfModel {
	model, _adggb := _dgcdd._ccbc[primitive]
	if !_adggb {
		return nil
	}
	return model
}

// Encoder returns the font's text encoder.
func (_gecb pdfFontType3) Encoder() _fcg.TextEncoder { return _gecb._gfffe }

// NewPdfTransformParamsDocMDP create a PdfTransformParamsDocMDP with the specific permissions.
func NewPdfTransformParamsDocMDP(permission _ca.DocMDPPermission) *PdfTransformParamsDocMDP {
	return &PdfTransformParamsDocMDP{Type: _agf.MakeName("\u0054r\u0061n\u0073\u0066\u006f\u0072\u006d\u0050\u0061\u0072\u0061\u006d\u0073"), P: _agf.MakeInteger(int64(permission)), V: _agf.MakeName("\u0031\u002e\u0032")}
}

// NewPdfAnnotationProjection returns a new projection annotation.
func NewPdfAnnotationProjection() *PdfAnnotationProjection {
	_cfg := NewPdfAnnotation()
	_edee := &PdfAnnotationProjection{}
	_edee.PdfAnnotation = _cfg
	_edee.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_cfg.SetContext(_edee)
	return _edee
}

// AddOutlineTree adds outlines to a PDF file.
func (_degba *PdfWriter) AddOutlineTree(outlineTree *PdfOutlineTreeNode) {
	_degba._dfcbdg = outlineTree
}

// NewPdfWriter initializes a new PdfWriter.
func NewPdfWriter() PdfWriter {
	_agcea := PdfWriter{}
	_agcea._ccbbf = map[_agf.PdfObject]struct{}{}
	_agcea._dgbd = []_agf.PdfObject{}
	_agcea._afcfaf = map[_agf.PdfObject][]*_agf.PdfObjectDictionary{}
	_agcea._gbgbad = map[_agf.PdfObject]struct{}{}
	_agcea._bcdfgg.Major = 1
	_agcea._bcdfgg.Minor = 3
	_cade := _agf.MakeDict()
	_gfeed := []struct {
		_fffec _agf.PdfObjectName
		_ffeba string
	}{{"\u0050\u0072\u006f\u0064\u0075\u0063\u0065\u0072", _fcdge()}, {"\u0043r\u0065\u0061\u0074\u006f\u0072", _bacgc()}, {"\u0041\u0075\u0074\u0068\u006f\u0072", _cfffg()}, {"\u0053u\u0062\u006a\u0065\u0063\u0074", _dbffb()}, {"\u0054\u0069\u0074l\u0065", _fabcg()}, {"\u004b\u0065\u0079\u0077\u006f\u0072\u0064\u0073", _ddgeg()}}
	for _, _dbbb := range _gfeed {
		if _dbbb._ffeba != "" {
			_cade.Set(_dbbb._fffec, _agf.MakeString(_dbbb._ffeba))
		}
	}
	if _bffdg := _ccgge(); !_bffdg.IsZero() {
		if _bece, _cdff := NewPdfDateFromTime(_bffdg); _cdff == nil {
			_cade.Set("\u0043\u0072\u0065a\u0074\u0069\u006f\u006e\u0044\u0061\u0074\u0065", _bece.ToPdfObject())
		}
	}
	if _fafb := _beffgc(); !_fafb.IsZero() {
		if _bebadd, _dfcbg := NewPdfDateFromTime(_fafb); _dfcbg == nil {
			_cade.Set("\u004do\u0064\u0044\u0061\u0074\u0065", _bebadd.ToPdfObject())
		}
	}
	_ecgad := _agf.PdfIndirectObject{}
	_ecgad.PdfObject = _cade
	_agcea._eaaaab = &_ecgad
	_agcea.addObject(&_ecgad)
	_bagaa := _agf.PdfIndirectObject{}
	_abggaf := _agf.MakeDict()
	_abggaf.Set("\u0054\u0079\u0070\u0065", _agf.MakeName("\u0043a\u0074\u0061\u006c\u006f\u0067"))
	_bagaa.PdfObject = _abggaf
	_agcea._eccfaf = &_bagaa
	_agcea.addObject(_agcea._eccfaf)
	_fgage, _afecc := _gcgff("\u0077")
	if _afecc != nil {
		_fd.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _afecc)
	}
	_agcea._adaaa = _fgage
	_cdfgc := _agf.PdfIndirectObject{}
	_fbgg := _agf.MakeDict()
	_fbgg.Set("\u0054\u0079\u0070\u0065", _agf.MakeName("\u0050\u0061\u0067e\u0073"))
	_ggbb := _agf.PdfObjectArray{}
	_fbgg.Set("\u004b\u0069\u0064\u0073", &_ggbb)
	_fbgg.Set("\u0043\u006f\u0075n\u0074", _agf.MakeInteger(0))
	_cdfgc.PdfObject = _fbgg
	_agcea._dgbbfe = &_cdfgc
	_agcea._adec = map[_agf.PdfObject]struct{}{}
	_agcea.addObject(_agcea._dgbbfe)
	_abggaf.Set("\u0050\u0061\u0067e\u0073", &_cdfgc)
	_agcea._bagbb = _abggaf
	_fd.Log.Trace("\u0043\u0061\u0074\u0061\u006c\u006f\u0067\u0020\u0025\u0073", _bagaa)
	return _agcea
}

// GetNumComponents returns the number of color components of the colorspace device.
// Returns 3 for a CalRGB device.
func (_bdcf *PdfColorspaceCalRGB) GetNumComponents() int { return 3 }

// PdfFontDescriptor specifies metrics and other attributes of a font and can refer to a FontFile
// for embedded fonts.
// 9.8 Font Descriptors (page 281)
type PdfFontDescriptor struct {
	FontName     _agf.PdfObject
	FontFamily   _agf.PdfObject
	FontStretch  _agf.PdfObject
	FontWeight   _agf.PdfObject
	Flags        _agf.PdfObject
	FontBBox     _agf.PdfObject
	ItalicAngle  _agf.PdfObject
	Ascent       _agf.PdfObject
	Descent      _agf.PdfObject
	Leading      _agf.PdfObject
	CapHeight    _agf.PdfObject
	XHeight      _agf.PdfObject
	StemV        _agf.PdfObject
	StemH        _agf.PdfObject
	AvgWidth     _agf.PdfObject
	MaxWidth     _agf.PdfObject
	MissingWidth _agf.PdfObject
	FontFile     _agf.PdfObject
	FontFile2    _agf.PdfObject
	FontFile3    _agf.PdfObject
	CharSet      _agf.PdfObject
	_babge       int
	_dgag        float64
	*fontFile
	_fdddd *_aa.TtfType

	// Additional entries for CIDFonts
	Style  _agf.PdfObject
	Lang   _agf.PdfObject
	FD     _agf.PdfObject
	CIDSet _agf.PdfObject
	_cfgc  *_agf.PdfIndirectObject
}

func (_dcfb *PdfReader) newPdfAnnotationSoundFromDict(_fbb *_agf.PdfObjectDictionary) (*PdfAnnotationSound, error) {
	_afgd := PdfAnnotationSound{}
	_dcfc, _ggc := _dcfb.newPdfAnnotationMarkupFromDict(_fbb)
	if _ggc != nil {
		return nil, _ggc
	}
	_afgd.PdfAnnotationMarkup = _dcfc
	_afgd.Name = _fbb.Get("\u004e\u0061\u006d\u0065")
	_afgd.Sound = _fbb.Get("\u0053\u006f\u0075n\u0064")
	return &_afgd, nil
}
func _facgd(_fccg _agf.PdfObject) (*fontFile, error) {
	_fd.Log.Trace("\u006e\u0065\u0077\u0046\u006f\u006e\u0074\u0046\u0069\u006c\u0065\u0046\u0072\u006f\u006dP\u0064f\u004f\u0062\u006a\u0065\u0063\u0074\u003a\u0020\u006f\u0062\u006a\u003d\u0025\u0073", _fccg)
	_bbffc := &fontFile{}
	_fccg = _agf.TraceToDirectObject(_fccg)
	_aabdf, _egeg := _fccg.(*_agf.PdfObjectStream)
	if !_egeg {
		_fd.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020F\u006f\u006et\u0046\u0069\u006c\u0065\u0020\u006d\u0075\u0073t\u0020\u0062\u0065\u0020\u0061\u0020\u0073\u0074\u0072\u0065\u0061\u006d \u0028\u0025\u0054\u0029", _fccg)
		return nil, _agf.ErrTypeError
	}
	_dcda := _aabdf.PdfObjectDictionary
	_ebfeg, _becc := _agf.DecodeStream(_aabdf)
	if _becc != nil {
		return nil, _becc
	}
	_fega, _egeg := _agf.GetNameVal(_dcda.Get("\u0053u\u0062\u0074\u0079\u0070\u0065"))
	if !_egeg {
		_bbffc._bcbfa = _fega
		if _fega == "\u0054\u0079\u0070\u0065\u0031\u0043" {
			_fd.Log.Debug("T\u0079\u0070\u0065\u0031\u0043\u0020\u0066\u006f\u006e\u0074\u0073\u0020\u0061\u0072\u0065\u0020\u0063\u0075r\u0072\u0065\u006e\u0074\u006c\u0079\u0020\u006e\u006f\u0074 s\u0075\u0070\u0070o\u0072t\u0065\u0064")
			return nil, ErrType1CFontNotSupported
		}
	}
	_cefc, _ := _agf.GetIntVal(_dcda.Get("\u004ce\u006e\u0067\u0074\u0068\u0031"))
	_egbca, _ := _agf.GetIntVal(_dcda.Get("\u004ce\u006e\u0067\u0074\u0068\u0032"))
	if _cefc > len(_ebfeg) {
		_cefc = len(_ebfeg)
	}
	if _cefc+_egbca > len(_ebfeg) {
		_egbca = len(_ebfeg) - _cefc
	}
	_cfeba := _ebfeg[:_cefc]
	var _gfbbbg []byte
	if _egbca > 0 {
		_gfbbbg = _ebfeg[_cefc : _cefc+_egbca]
	}
	if _cefc > 0 && _egbca > 0 {
		_dfefa := _bbffc.loadFromSegments(_cfeba, _gfbbbg)
		if _dfefa != nil {
			return nil, _dfefa
		}
	}
	return _bbffc, nil
}
func (_gce *PdfReader) newPdfActionRenditionFromDict(_bbg *_agf.PdfObjectDictionary) (*PdfActionRendition, error) {
	return &PdfActionRendition{R: _bbg.Get("\u0052"), AN: _bbg.Get("\u0041\u004e"), OP: _bbg.Get("\u004f\u0050"), JS: _bbg.Get("\u004a\u0053")}, nil
}

// NewPdfColorDeviceRGB returns a new PdfColorDeviceRGB based on the r,g,b component values.
func NewPdfColorDeviceRGB(r, g, b float64) *PdfColorDeviceRGB {
	_afcb := PdfColorDeviceRGB{r, g, b}
	return &_afcb
}

// PdfActionTrans represents a trans action.
type PdfActionTrans struct {
	*PdfAction
	Trans _agf.PdfObject
}

func _ccgge() _e.Time { _ecba.Lock(); defer _ecba.Unlock(); return _acbaf }

// PdfShadingType7 is a Tensor-product patch mesh.
type PdfShadingType7 struct {
	*PdfShading
	BitsPerCoordinate *_agf.PdfObjectInteger
	BitsPerComponent  *_agf.PdfObjectInteger
	BitsPerFlag       *_agf.PdfObjectInteger
	Decode            *_agf.PdfObjectArray
	Function          []PdfFunction
}

// DecodeArray returns the component range values for the DeviceN colorspace.
// [0 1.0 0 1.0 ...] for each color component.
func (_gdffd *PdfColorspaceDeviceN) DecodeArray() []float64 {
	var _gcge []float64
	for _dgeb := 0; _dgeb < _gdffd.GetNumComponents(); _dgeb++ {
		_gcge = append(_gcge, 0.0, 1.0)
	}
	return _gcge
}

// NewPdfAnnotationSquiggly returns a new text squiggly annotation.
func NewPdfAnnotationSquiggly() *PdfAnnotationSquiggly {
	_dbf := NewPdfAnnotation()
	_bfe := &PdfAnnotationSquiggly{}
	_bfe.PdfAnnotation = _dbf
	_bfe.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_dbf.SetContext(_bfe)
	return _bfe
}

const (
	BorderEffectNoEffect BorderEffect = iota
	BorderEffectCloudy   BorderEffect = iota
)

func (_ddbggc *PdfReader) buildNameNodes(_fgfcf *_agf.PdfIndirectObject, _gfgdgg map[_agf.PdfObject]struct{}) error {
	if _fgfcf == nil {
		return nil
	}
	if _, _fffeb := _gfgdgg[_fgfcf]; _fffeb {
		_fd.Log.Debug("\u0043\u0079\u0063l\u0069\u0063\u0020\u0072e\u0063\u0075\u0072\u0073\u0069\u006f\u006e,\u0020\u0073\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u0020\u0028\u0025\u0076\u0029", _fgfcf.ObjectNumber)
		return nil
	}
	_gfgdgg[_fgfcf] = struct{}{}
	_afggg, _ddgad := _fgfcf.PdfObject.(*_agf.PdfObjectDictionary)
	if !_ddgad {
		return _gcd.New("n\u006f\u0064\u0065\u0020no\u0074 \u0061\u0020\u0064\u0069\u0063t\u0069\u006f\u006e\u0061\u0072\u0079")
	}
	if _eagae, _dbfda := _agf.GetDict(_afggg.Get("\u0044\u0065\u0073t\u0073")); _dbfda {
		_gabdf, _agbg := _agf.GetArray(_eagae.Get("\u004b\u0069\u0064\u0073"))
		if !_agbg {
			return _gcd.New("\u0049n\u0076\u0061\u006c\u0069d\u0020\u004b\u0069\u0064\u0073 \u0061r\u0072a\u0079\u0020\u006f\u0062\u006a\u0065\u0063t")
		}
		_fd.Log.Trace("\u004b\u0069\u0064\u0073\u003a\u0020\u0025\u0073", _gabdf)
		for _bedbd, _gcfg := range _gabdf.Elements() {
			_bceceb, _bcbee := _agf.GetIndirect(_gcfg)
			if !_bcbee {
				_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0063\u0068\u0069\u006c\u0064\u0020n\u006f\u0074\u0020\u0069\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u002d \u0028\u0025\u0073\u0029", _bceceb)
				return _gcd.New("\u0063h\u0069\u006c\u0064\u0020n\u006f\u0074\u0020\u0069\u006ed\u0069r\u0065c\u0074\u0020\u006f\u0062\u006a\u0065\u0063t")
			}
			_gabdf.Set(_bedbd, _bceceb)
			_aceb := _ddbggc.buildNameNodes(_bceceb, _gfgdgg)
			if _aceb != nil {
				return _aceb
			}
		}
	}
	if _cgeea, _fecbg := _agf.GetDict(_afggg); _fecbg {
		if !_agf.IsNullObject(_cgeea.Get("\u004b\u0069\u0064\u0073")) {
			if _bdaeg, _cgaed := _agf.GetArray(_cgeea.Get("\u004b\u0069\u0064\u0073")); _cgaed {
				for _bcea, _bgbbd := range _bdaeg.Elements() {
					if _begef, _ceefa := _agf.GetIndirect(_bgbbd); _ceefa {
						_bdaeg.Set(_bcea, _begef)
						_ececc := _ddbggc.buildNameNodes(_begef, _gfgdgg)
						if _ececc != nil {
							return _ececc
						}
					}
				}
			}
		}
	}
	return nil
}
func (_gdcb *PdfReader) loadAction(_abfb _agf.PdfObject) (*PdfAction, error) {
	if _gcg, _defb := _agf.GetIndirect(_abfb); _defb {
		_gae, _eagf := _gdcb.newPdfActionFromIndirectObject(_gcg)
		if _eagf != nil {
			return nil, _eagf
		}
		return _gae, nil
	} else if !_agf.IsNullObject(_abfb) {
		return nil, _gcd.New("\u0061\u0063\u0074\u0069\u006fn\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0070\u006f\u0069\u006e\u0074 \u0074\u006f\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074")
	}
	return nil, nil
}

// SetImageHandler sets the image handler used by the package.
func SetImageHandler(imgHandling ImageHandler) { ImageHandling = imgHandling }

// NewGrayImageFromGoImage creates a new grayscale unidoc Image from a golang Image.
func (_cgcbf DefaultImageHandler) NewGrayImageFromGoImage(goimg _fe.Image) (*Image, error) {
	_acbc := goimg.Bounds()
	_fabf := &Image{Width: int64(_acbc.Dx()), Height: int64(_acbc.Dy()), ColorComponents: 1, BitsPerComponent: 8}
	switch _bdecf := goimg.(type) {
	case *_fe.Gray:
		if len(_bdecf.Pix) != _acbc.Dx()*_acbc.Dy() {
			_bcgfgb, _fdcde := _ged.GrayConverter.Convert(goimg)
			if _fdcde != nil {
				return nil, _fdcde
			}
			_fabf.Data = _bcgfgb.Pix()
		} else {
			_fabf.Data = _bdecf.Pix
		}
	case *_fe.Gray16:
		_fabf.BitsPerComponent = 16
		if len(_bdecf.Pix) != _acbc.Dx()*_acbc.Dy()*2 {
			_gbcef, _abdbg := _ged.Gray16Converter.Convert(goimg)
			if _abdbg != nil {
				return nil, _abdbg
			}
			_fabf.Data = _gbcef.Pix()
		} else {
			_fabf.Data = _bdecf.Pix
		}
	case _ged.Image:
		_feaeb := _bdecf.Base()
		if _feaeb.ColorComponents == 1 {
			_fabf.BitsPerComponent = int64(_feaeb.BitsPerComponent)
			_fabf.Data = _feaeb.Data
			return _fabf, nil
		}
		_abgab, _bfcg := _ged.GrayConverter.Convert(goimg)
		if _bfcg != nil {
			return nil, _bfcg
		}
		_fabf.Data = _abgab.Pix()
	default:
		_gdcge, _fdffd := _ged.GrayConverter.Convert(goimg)
		if _fdffd != nil {
			return nil, _fdffd
		}
		_fabf.Data = _gdcge.Pix()
	}
	return _fabf, nil
}

// NewPdfAnnotationPopup returns a new popup annotation.
func NewPdfAnnotationPopup() *PdfAnnotationPopup {
	_bcbg := NewPdfAnnotation()
	_gdg := &PdfAnnotationPopup{}
	_gdg.PdfAnnotation = _bcbg
	_bcbg.SetContext(_gdg)
	return _gdg
}

// PdfShadingPattern is a Shading patterns that provide a smooth transition between colors across an area to be painted,
// i.e. color(x,y) = f(x,y) at each point.
// It is a type 2 pattern (PatternType = 2).
type PdfShadingPattern struct {
	*PdfPattern
	Shading   *PdfShading
	Matrix    *_agf.PdfObjectArray
	ExtGState _agf.PdfObject
}

// GetContainingPdfObject implements interface PdfModel.
func (_eadcd *PdfSignature) GetContainingPdfObject() _agf.PdfObject { return _eadcd._ceeec }

// NewPdfActionResetForm returns a new "reset form" action.
func NewPdfActionResetForm() *PdfActionResetForm {
	_ga := NewPdfAction()
	_ceb := &PdfActionResetForm{}
	_ceb.PdfAction = _ga
	_ga.SetContext(_ceb)
	return _ceb
}

// IsRadio returns true if the button field represents a radio button, false otherwise.
func (_ddga *PdfFieldButton) IsRadio() bool { return _ddga.GetType() == ButtonTypeRadio }
func (_dbgbf *PdfPage) getParentResources() (*PdfPageResources, error) {
	_edfbe := _dbgbf.Parent
	for _edfbe != nil {
		_bbgbc, _ecgg := _agf.GetDict(_edfbe)
		if !_ecgg {
			_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020n\u006f\u0064\u0065")
			return nil, _gcd.New("i\u006e\u0076\u0061\u006cid\u0020p\u0061\u0072\u0065\u006e\u0074 \u006f\u0062\u006a\u0065\u0063\u0074")
		}
		if _ffef := _bbgbc.Get("\u0052e\u0073\u006f\u0075\u0072\u0063\u0065s"); _ffef != nil {
			_abbaa, _ccagc := _agf.GetDict(_ffef)
			if !_ccagc {
				return nil, _gcd.New("i\u006e\u0076\u0061\u006cid\u0020r\u0065\u0073\u006f\u0075\u0072c\u0065\u0020\u0064\u0069\u0063\u0074")
			}
			_bcaeg, _ebcd := NewPdfPageResourcesFromDict(_abbaa)
			if _ebcd != nil {
				return nil, _ebcd
			}
			return _bcaeg, nil
		}
		_edfbe = _bbgbc.Get("\u0050\u0061\u0072\u0065\u006e\u0074")
	}
	return nil, nil
}

// NewPdfColorspaceCalRGB returns a new CalRGB colorspace object.
func NewPdfColorspaceCalRGB() *PdfColorspaceCalRGB {
	_acae := &PdfColorspaceCalRGB{}
	_acae.BlackPoint = []float64{0.0, 0.0, 0.0}
	_acae.Gamma = []float64{1.0, 1.0, 1.0}
	_acae.Matrix = []float64{1, 0, 0, 0, 1, 0, 0, 0, 1}
	return _acae
}

// GetNumComponents returns the number of color components (4 for CMYK32).
func (_fded *PdfColorDeviceCMYK) GetNumComponents() int { return 4 }
func (_eccgc *PdfReader) newPdfPageFromDict(_ffca *_agf.PdfObjectDictionary) (*PdfPage, error) {
	_fdec := NewPdfPage()
	_fdec._ececfb = _ffca
	_fdec._gabcc = *_ffca
	_bdafdb := *_ffca
	_cdbcdd, _cgff := _bdafdb.Get("\u0054\u0079\u0070\u0065").(*_agf.PdfObjectName)
	if !_cgff {
		return nil, _gcd.New("\u006d\u0069ss\u0069\u006e\u0067/\u0069\u006e\u0076\u0061lid\u0020Pa\u0067\u0065\u0020\u0064\u0069\u0063\u0074io\u006e\u0061\u0072\u0079\u0020\u0054\u0079p\u0065")
	}
	if *_cdbcdd != "\u0050\u0061\u0067\u0065" {
		return nil, _gcd.New("\u0070\u0061\u0067\u0065 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079 \u0054y\u0070\u0065\u0020\u0021\u003d\u0020\u0050a\u0067\u0065")
	}
	if _bbfaf := _bdafdb.Get("\u0050\u0061\u0072\u0065\u006e\u0074"); _bbfaf != nil {
		_fdec.Parent = _bbfaf
	}
	if _cgdec := _bdafdb.Get("\u004c\u0061\u0073t\u004d\u006f\u0064\u0069\u0066\u0069\u0065\u0064"); _cgdec != nil {
		_aebff, _edabe := _agf.GetString(_cgdec)
		if !_edabe {
			return nil, _gcd.New("\u0070\u0061\u0067\u0065\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u004c\u0061\u0073\u0074\u004d\u006f\u0064\u0069f\u0069\u0065\u0064\u0020\u0021=\u0020\u0073t\u0072\u0069\u006e\u0067")
		}
		_gdca, _afcec := NewPdfDate(_aebff.Str())
		if _afcec != nil {
			return nil, _afcec
		}
		_fdec.LastModified = &_gdca
	}
	if _gffeg := _bdafdb.Get("\u0052e\u0073\u006f\u0075\u0072\u0063\u0065s"); _gffeg != nil && !_agf.IsNullObject(_gffeg) {
		_ecegd, _ccca := _agf.GetDict(_gffeg)
		if !_ccca {
			return nil, _b.Errorf("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u0065\u0073\u006f\u0075\u0072\u0063e\u0020d\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0054\u0029", _gffeg)
		}
		var _cggde error
		_fdec.Resources, _cggde = NewPdfPageResourcesFromDict(_ecegd)
		if _cggde != nil {
			return nil, _cggde
		}
	} else {
		_cbbb, _cceb := _fdec.getParentResources()
		if _cceb != nil {
			return nil, _cceb
		}
		if _cbbb == nil {
			_cbbb = NewPdfPageResources()
		}
		_fdec.Resources = _cbbb
	}
	if _dbffd := _bdafdb.Get("\u004d\u0065\u0064\u0069\u0061\u0042\u006f\u0078"); _dbffd != nil {
		_geecd, _gbdac := _agf.GetArray(_dbffd)
		if !_gbdac {
			return nil, _gcd.New("\u0070\u0061\u0067\u0065\u0020\u004d\u0065\u0064\u0069\u0061\u0042o\u0078\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072\u0061\u0079")
		}
		var _becdg error
		_fdec.MediaBox, _becdg = NewPdfRectangle(*_geecd)
		if _becdg != nil {
			return nil, _becdg
		}
	}
	if _cecc := _bdafdb.Get("\u0043r\u006f\u0070\u0042\u006f\u0078"); _cecc != nil {
		_gffg, _dcgbf := _agf.GetArray(_cecc)
		if !_dcgbf {
			return nil, _gcd.New("\u0070a\u0067\u0065\u0020\u0043r\u006f\u0070\u0042\u006f\u0078 \u006eo\u0074 \u0061\u006e\u0020\u0061\u0072\u0072\u0061y")
		}
		var _cagac error
		_fdec.CropBox, _cagac = NewPdfRectangle(*_gffg)
		if _cagac != nil {
			return nil, _cagac
		}
	}
	if _befff := _bdafdb.Get("\u0042\u006c\u0065\u0065\u0064\u0042\u006f\u0078"); _befff != nil {
		_dfbac, _bega := _agf.GetArray(_befff)
		if !_bega {
			return nil, _gcd.New("\u0070\u0061\u0067\u0065\u0020\u0042\u006c\u0065\u0065\u0064\u0042o\u0078\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072\u0061\u0079")
		}
		var _ggcf error
		_fdec.BleedBox, _ggcf = NewPdfRectangle(*_dfbac)
		if _ggcf != nil {
			return nil, _ggcf
		}
	}
	if _ddbga := _bdafdb.Get("\u0054r\u0069\u006d\u0042\u006f\u0078"); _ddbga != nil {
		_bdebb, _cbcfd := _agf.GetArray(_ddbga)
		if !_cbcfd {
			return nil, _gcd.New("\u0070a\u0067\u0065\u0020\u0054r\u0069\u006d\u0042\u006f\u0078 \u006eo\u0074 \u0061\u006e\u0020\u0061\u0072\u0072\u0061y")
		}
		var _bbdb error
		_fdec.TrimBox, _bbdb = NewPdfRectangle(*_bdebb)
		if _bbdb != nil {
			return nil, _bbdb
		}
	}
	if _bebcd := _bdafdb.Get("\u0041\u0072\u0074\u0042\u006f\u0078"); _bebcd != nil {
		_aaafd, _fbccc := _agf.GetArray(_bebcd)
		if !_fbccc {
			return nil, _gcd.New("\u0070a\u0067\u0065\u0020\u0041\u0072\u0074\u0042\u006f\u0078\u0020\u006eo\u0074\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079")
		}
		var _fgag error
		_fdec.ArtBox, _fgag = NewPdfRectangle(*_aaafd)
		if _fgag != nil {
			return nil, _fgag
		}
	}
	if _cdbe := _bdafdb.Get("\u0042\u006f\u0078C\u006f\u006c\u006f\u0072\u0049\u006e\u0066\u006f"); _cdbe != nil {
		_fdec.BoxColorInfo = _cdbe
	}
	if _dgcba := _bdafdb.Get("\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"); _dgcba != nil {
		_fdec.Contents = _dgcba
	}
	if _afddc := _bdafdb.Get("\u0052\u006f\u0074\u0061\u0074\u0065"); _afddc != nil {
		_bggdg, _fccc := _agf.GetNumberAsInt64(_afddc)
		if _fccc != nil {
			return nil, _gcd.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0061\u0067e\u0020\u0052\u006f\u0074\u0061\u0074\u0065\u0020\u006f\u0062j\u0065\u0063\u0074")
		}
		_fdec.Rotate = &_bggdg
	}
	if _bbafd := _bdafdb.Get("\u0047\u0072\u006fu\u0070"); _bbafd != nil {
		_fdec.Group = _bbafd
	}
	if _fbabe := _bdafdb.Get("\u0054\u0068\u0075m\u0062"); _fbabe != nil {
		_fdec.Thumb = _fbabe
	}
	if _eabf := _bdafdb.Get("\u0042"); _eabf != nil {
		_fdec.B = _eabf
	}
	if _gaedcd := _bdafdb.Get("\u0044\u0075\u0072"); _gaedcd != nil {
		_fdec.Dur = _gaedcd
	}
	if _eeafeg := _bdafdb.Get("\u0054\u0072\u0061n\u0073"); _eeafeg != nil {
		_fdec.Trans = _eeafeg
	}
	if _gfgcdb := _bdafdb.Get("\u0041\u0041"); _gfgcdb != nil {
		_fdec.AA = _gfgcdb
	}
	if _cafgae := _bdafdb.Get("\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061"); _cafgae != nil {
		_fdec.Metadata = _cafgae
	}
	if _gadfa := _bdafdb.Get("\u0050i\u0065\u0063\u0065\u0049\u006e\u0066o"); _gadfa != nil {
		_fdec.PieceInfo = _gadfa
	}
	if _bebcab := _bdafdb.Get("\u0053\u0074\u0072\u0075\u0063\u0074\u0050\u0061\u0072\u0065\u006e\u0074\u0073"); _bebcab != nil {
		_fdec.StructParents = _bebcab
	}
	if _fdbcc := _bdafdb.Get("\u0049\u0044"); _fdbcc != nil {
		_fdec.ID = _fdbcc
	}
	if _facaa := _bdafdb.Get("\u0050\u005a"); _facaa != nil {
		_fdec.PZ = _facaa
	}
	if _ebbb := _bdafdb.Get("\u0053\u0065\u0070\u0061\u0072\u0061\u0074\u0069\u006fn\u0049\u006e\u0066\u006f"); _ebbb != nil {
		_fdec.SeparationInfo = _ebbb
	}
	if _bcda := _bdafdb.Get("\u0054\u0061\u0062\u0073"); _bcda != nil {
		_fdec.Tabs = _bcda
	}
	if _bgdec := _bdafdb.Get("T\u0065m\u0070\u006c\u0061\u0074\u0065\u0049\u006e\u0073t\u0061\u006e\u0074\u0069at\u0065\u0064"); _bgdec != nil {
		_fdec.TemplateInstantiated = _bgdec
	}
	if _cfeg := _bdafdb.Get("\u0050r\u0065\u0073\u0053\u0074\u0065\u0070s"); _cfeg != nil {
		_fdec.PresSteps = _cfeg
	}
	if _dadaf := _bdafdb.Get("\u0055\u0073\u0065\u0072\u0055\u006e\u0069\u0074"); _dadaf != nil {
		_fdec.UserUnit = _dadaf
	}
	if _bbag := _bdafdb.Get("\u0056\u0050"); _bbag != nil {
		_fdec.VP = _bbag
	}
	if _gfffd := _bdafdb.Get("\u0041\u006e\u006e\u006f\u0074\u0073"); _gfffd != nil {
		_fdec.Annots = _gfffd
	}
	_fdec._ecae = _eccgc
	return _fdec, nil
}

// GetCharMetrics returns the char metrics for character code `code`.
func (_babbb pdfFontType0) GetCharMetrics(code _fcg.CharCode) (_aa.CharMetrics, bool) {
	if _babbb.DescendantFont == nil {
		_fd.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u004e\u006f\u0020\u0064\u0065\u0073\u0063\u0065\u006e\u0064\u0061\u006e\u0074\u002e\u0020\u0066\u006f\u006et=\u0025\u0073", _babbb)
		return _aa.CharMetrics{}, false
	}
	return _babbb.DescendantFont.GetCharMetrics(code)
}

// SetLocation sets the `Location` field of the signature.
func (_fffde *PdfSignature) SetLocation(location string) { _fffde.Location = _agf.MakeString(location) }

// PdfAnnotation represents an annotation in PDF (section 12.5 p. 389).
type PdfAnnotation struct {
	_eef         PdfModel
	Rect         _agf.PdfObject
	Contents     _agf.PdfObject
	P            _agf.PdfObject
	NM           _agf.PdfObject
	M            _agf.PdfObject
	F            _agf.PdfObject
	AP           _agf.PdfObject
	AS           _agf.PdfObject
	Border       _agf.PdfObject
	C            _agf.PdfObject
	StructParent _agf.PdfObject
	OC           _agf.PdfObject
	_aeee        *_agf.PdfIndirectObject
}

// NewPdfAnnotationMovie returns a new movie annotation.
func NewPdfAnnotationMovie() *PdfAnnotationMovie {
	_gafc := NewPdfAnnotation()
	_gadf := &PdfAnnotationMovie{}
	_gadf.PdfAnnotation = _gafc
	_gafc.SetContext(_gadf)
	return _gadf
}

// SetDate sets the `M` field of the signature.
func (_fedf *PdfSignature) SetDate(date _e.Time, format string) {
	if format == "" {
		format = "\u0044\u003a\u003200\u0036\u0030\u0031\u0030\u0032\u0031\u0035\u0030\u0034\u0030\u0035\u002d\u0030\u0037\u0027\u0030\u0030\u0027"
	}
	_fedf.M = _agf.MakeString(date.Format(format))
}

// NewPdfReaderLazy creates a new PdfReader for `rs` in lazy-loading mode. The difference
// from NewPdfReader is that in lazy-loading mode, objects are only loaded into memory when needed
// rather than entire structure being loaded into memory on reader creation.
// Note that it may make sense to use the lazy-load reader when processing only parts of files,
// rather than loading entire file into memory. Example: splitting a few pages from a large PDF file.
func NewPdfReaderLazy(rs _cf.ReadSeeker) (*PdfReader, error) {
	const _gdcda = "\u006d\u006f\u0064\u0065l:\u004e\u0065\u0077\u0050\u0064\u0066\u0052\u0065\u0061\u0064\u0065\u0072\u004c\u0061z\u0079"
	return _dcab(rs, &ReaderOpts{LazyLoad: true}, false, _gdcda)
}
func _eaeg(_cbee _agf.PdfObject, _acedg *fontCommon) (*_ce.CMap, error) {
	_deag, _baac := _agf.GetStream(_cbee)
	if !_baac {
		_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052:\u0020\u0074\u006f\u0055\u006e\u0069\u0063\u006f\u0064\u0065\u0054\u006f\u0043m\u0061\u0070\u003a\u0020\u004e\u006f\u0074\u0020\u0061\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0028\u0025\u0054\u0029", _cbee)
		return nil, _agf.ErrTypeError
	}
	_gefdb, _fdafb := _agf.DecodeStream(_deag)
	if _fdafb != nil {
		return nil, _fdafb
	}
	_efea, _fdafb := _ce.LoadCmapFromData(_gefdb, !_acedg.isCIDFont())
	if _fdafb != nil {
		_fd.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u004e\u0075\u006d\u0062\u0065\u0072\u003d\u0025\u0064\u0020\u0065\u0072r=\u0025\u0076", _deag.ObjectNumber, _fdafb)
	}
	return _efea, _fdafb
}

// ToPdfObject returns a PDF object representation of the outline.
func (_cfgbb *Outline) ToPdfObject() _agf.PdfObject { return _cfgbb.ToPdfOutline().ToPdfObject() }

// ToPdfObject converts date to a PDF string object.
func (_cagce *PdfDate) ToPdfObject() _agf.PdfObject {
	_edgbe := _b.Sprintf("\u0044\u003a\u0025\u002e\u0034\u0064\u0025\u002e\u0032\u0064\u0025\u002e\u0032\u0064\u0025\u002e\u0032\u0064\u0025\u002e\u0032\u0064\u0025\u002e2\u0064\u0025\u0063\u0025\u002e2\u0064\u0027%\u002e\u0032\u0064\u0027", _cagce._dcggc, _cagce._fccbd, _cagce._ggca, _cagce._cfgfg, _cagce._dgaab, _cagce._gdebc, _cagce._dfead, _cagce._gddba, _cagce._ebcf)
	return _agf.MakeString(_edgbe)
}

// DecodeArray returns the range of color component values in the Lab colorspace.
func (_fddc *PdfColorspaceLab) DecodeArray() []float64 {
	_bgddf := []float64{0, 100}
	if _fddc.Range != nil && len(_fddc.Range) == 4 {
		_bgddf = append(_bgddf, _fddc.Range...)
	} else {
		_bgddf = append(_bgddf, -100, 100, -100, 100)
	}
	return _bgddf
}
func (_fccfeb *PdfWriter) updateObjectNumbers() {
	_gefec := _fccfeb.ObjNumOffset
	_gcdebb := 0
	for _, _bbbdd := range _fccfeb._dgbd {
		_ffeaaa := int64(_gcdebb + 1 + _gefec)
		_adgbag := true
		if _fccfeb._accad {
			if _dddbb, _bgbaf := _fccfeb._efgaf[_bbbdd]; _bgbaf {
				_ffeaaa = _dddbb
				_adgbag = false
			}
		}
		switch _ebaaf := _bbbdd.(type) {
		case *_agf.PdfIndirectObject:
			_ebaaf.ObjectNumber = _ffeaaa
			_ebaaf.GenerationNumber = 0
		case *_agf.PdfObjectStream:
			_ebaaf.ObjectNumber = _ffeaaa
			_ebaaf.GenerationNumber = 0
		case *_agf.PdfObjectStreams:
			_ebaaf.ObjectNumber = _ffeaaa
			_ebaaf.GenerationNumber = 0
		default:
			_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u0020%\u0054\u0020\u002d\u0020\u0073\u006b\u0069p\u0070\u0069\u006e\u0067", _ebaaf)
			continue
		}
		if _adgbag {
			_gcdebb++
		}
	}
	_fcabg := func(_eefbea _agf.PdfObject) int64 {
		switch _gbfaa := _eefbea.(type) {
		case *_agf.PdfIndirectObject:
			return _gbfaa.ObjectNumber
		case *_agf.PdfObjectStream:
			return _gbfaa.ObjectNumber
		case *_agf.PdfObjectStreams:
			return _gbfaa.ObjectNumber
		}
		return 0
	}
	_cb.SliceStable(_fccfeb._dgbd, func(_ffada, _fbddf int) bool { return _fcabg(_fccfeb._dgbd[_ffada]) < _fcabg(_fccfeb._dgbd[_fbddf]) })
}

// GetContext returns the PdfField context which is the more specific field data type, e.g. PdfFieldButton
// for a button field.
func (_bdce *PdfField) GetContext() PdfModel { return _bdce._eaggd }

// SetPatternByName sets a pattern resource specified by keyName.
func (_gfdacc *PdfPageResources) SetPatternByName(keyName _agf.PdfObjectName, pattern _agf.PdfObject) error {
	if _gfdacc.Pattern == nil {
		_gfdacc.Pattern = _agf.MakeDict()
	}
	_gcfa, _begb := _agf.GetDict(_gfdacc.Pattern)
	if !_begb {
		return _agf.ErrTypeError
	}
	_gcfa.Set(keyName, pattern)
	return nil
}
func _babda(_dfcbe *_agf.PdfObjectDictionary) (*PdfShadingType5, error) {
	_cbadd := PdfShadingType5{}
	_acff := _dfcbe.Get("\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006f\u0072\u0064i\u006e\u0061\u0074\u0065")
	if _acff == nil {
		_fd.Log.Debug("\u0052e\u0071\u0075i\u0072\u0065\u0064 \u0061\u0074\u0074\u0072\u0069\u0062\u0075t\u0065\u0020\u006d\u0069\u0073\u0073i\u006e\u0067\u003a\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072C\u006f\u006f\u0072\u0064\u0069\u006e\u0061\u0074\u0065")
		return nil, ErrRequiredAttributeMissing
	}
	_fdcb, _afgad := _acff.(*_agf.PdfObjectInteger)
	if !_afgad {
		_fd.Log.Debug("\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006f\u0072\u0064\u0069\u006e\u0061\u0074\u0065\u0020\u006eo\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", _acff)
		return nil, _agf.ErrTypeError
	}
	_cbadd.BitsPerCoordinate = _fdcb
	_acff = _dfcbe.Get("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074")
	if _acff == nil {
		_fd.Log.Debug("\u0052e\u0071\u0075i\u0072\u0065\u0064\u0020a\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u0020\u006d\u0069\u0073\u0073in\u0067\u003a\u0020B\u0069\u0074s\u0050\u0065\u0072\u0043\u006f\u006dp\u006f\u006ee\u006e\u0074")
		return nil, ErrRequiredAttributeMissing
	}
	_fdcb, _afgad = _acff.(*_agf.PdfObjectInteger)
	if !_afgad {
		_fd.Log.Debug("B\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065r \u0028\u0067\u006ft\u0020%\u0054\u0029", _acff)
		return nil, _agf.ErrTypeError
	}
	_cbadd.BitsPerComponent = _fdcb
	_acff = _dfcbe.Get("\u0056\u0065\u0072\u0074\u0069\u0063\u0065\u0073\u0050e\u0072\u0052\u006f\u0077")
	if _acff == nil {
		_fd.Log.Debug("\u0052\u0065\u0071u\u0069\u0072\u0065\u0064\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u003a\u0020\u0056\u0065\u0072\u0074\u0069c\u0065\u0073\u0050\u0065\u0072\u0052\u006f\u0077")
		return nil, ErrRequiredAttributeMissing
	}
	_fdcb, _afgad = _acff.(*_agf.PdfObjectInteger)
	if !_afgad {
		_fd.Log.Debug("\u0056\u0065\u0072\u0074\u0069\u0063\u0065\u0073\u0050\u0065\u0072\u0052\u006f\u0077\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006et\u0065\u0067\u0065\u0072\u0020(\u0067\u006ft\u0020\u0025\u0054\u0029", _acff)
		return nil, _agf.ErrTypeError
	}
	_cbadd.VerticesPerRow = _fdcb
	_acff = _dfcbe.Get("\u0044\u0065\u0063\u006f\u0064\u0065")
	if _acff == nil {
		_fd.Log.Debug("\u0052\u0065\u0071ui\u0072\u0065\u0064\u0020\u0061\u0074\u0074\u0072\u0069b\u0075t\u0065 \u006di\u0073\u0073\u0069\u006e\u0067\u003a\u0020\u0044\u0065\u0063\u006f\u0064\u0065")
		return nil, ErrRequiredAttributeMissing
	}
	_dedcbcd, _afgad := _acff.(*_agf.PdfObjectArray)
	if !_afgad {
		_fd.Log.Debug("\u0044\u0065\u0063\u006fd\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072a\u0079\u0020\u0028\u0067\u006f\u0074\u0020%\u0054\u0029", _acff)
		return nil, _agf.ErrTypeError
	}
	_cbadd.Decode = _dedcbcd
	if _efff := _dfcbe.Get("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e"); _efff != nil {
		_cbadd.Function = []PdfFunction{}
		if _ffgaed, _aecdb := _efff.(*_agf.PdfObjectArray); _aecdb {
			for _, _aacce := range _ffgaed.Elements() {
				_ggbee, _efcd := _ccedb(_aacce)
				if _efcd != nil {
					_fd.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e:\u0020\u0025\u0076", _efcd)
					return nil, _efcd
				}
				_cbadd.Function = append(_cbadd.Function, _ggbee)
			}
		} else {
			_cgdga, _geacc := _ccedb(_efff)
			if _geacc != nil {
				_fd.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e:\u0020\u0025\u0076", _geacc)
				return nil, _geacc
			}
			_cbadd.Function = append(_cbadd.Function, _cgdga)
		}
	}
	return &_cbadd, nil
}

// GetPerms returns the Permissions dictionary
func (_bbfeg *PdfReader) GetPerms() *Permissions { return _bbfeg._gbdc }

// ToPdfObject converts colorspace to a PDF object. [/Indexed base hival lookup]
func (_eefb *PdfColorspaceSpecialIndexed) ToPdfObject() _agf.PdfObject {
	_becd := _agf.MakeArray(_agf.MakeName("\u0049n\u0064\u0065\u0078\u0065\u0064"))
	_becd.Append(_eefb.Base.ToPdfObject())
	_becd.Append(_agf.MakeInteger(int64(_eefb.HiVal)))
	_becd.Append(_eefb.Lookup)
	if _eefb._fcgd != nil {
		_eefb._fcgd.PdfObject = _becd
		return _eefb._fcgd
	}
	return _becd
}
func _bacgc() string {
	_ecba.Lock()
	defer _ecba.Unlock()
	if len(_agbb) > 0 {
		return _agbb
	}
	return "\u0055n\u0069\u0044\u006f\u0063 \u002d\u0020\u0068\u0074\u0074p\u003a/\u002fu\u006e\u0069\u0064\u006f\u0063\u002e\u0069o"
}

// UpdateObject marks `obj` as updated and to be included in the following revision.
func (_gcbd *PdfAppender) UpdateObject(obj _agf.PdfObject) {
	_gcbd.replaceObject(obj, obj)
	if _, _bdgf := _gcbd._gacd[obj]; !_bdgf {
		_gcbd._bfbg = append(_gcbd._bfbg, obj)
		_gcbd._gacd[obj] = struct{}{}
	}
}

// ToPdfObject converts rectangle to a PDF object.
func (_gbdbb *PdfRectangle) ToPdfObject() _agf.PdfObject {
	return _agf.MakeArray(_agf.MakeFloat(_gbdbb.Llx), _agf.MakeFloat(_gbdbb.Lly), _agf.MakeFloat(_gbdbb.Urx), _agf.MakeFloat(_gbdbb.Ury))
}

// NewPdfAnnotationWatermark returns a new watermark annotation.
func NewPdfAnnotationWatermark() *PdfAnnotationWatermark {
	_bcf := NewPdfAnnotation()
	_gbga := &PdfAnnotationWatermark{}
	_gbga.PdfAnnotation = _bcf
	_bcf.SetContext(_gbga)
	return _gbga
}

// SetNamedDestinations sets the Dests entry in the PDF catalog.
// See section 12.3.2.3 "Named Destinations" (p. 367 PDF32000_2008).
func (_gabgg *PdfWriter) SetNamedDestinations(dests _agf.PdfObject) error {
	if dests == nil {
		return nil
	}
	_fd.Log.Trace("\u0053e\u0074\u0074\u0069\u006e\u0067\u0020\u0063\u0061\u0074\u0061\u006co\u0067\u0020\u0044\u0065\u0073\u0074\u0073\u002e\u002e\u002e")
	_gabgg._bagbb.Set("\u0044\u0065\u0073t\u0073", dests)
	return _gabgg.addObjects(dests)
}
func (_fbdada *PdfWriter) writeTrailer(_gebc int) {
	_fbdada.writeString("\u0078\u0072\u0065\u0066\u000d\u000a")
	for _cfccc := 0; _cfccc <= _gebc; {
		for ; _cfccc <= _gebc; _cfccc++ {
			_cccfg, _adgfb := _fbdada._ddcg[_cfccc]
			if _adgfb && (!_fbdada._accad || _fbdada._accad && (_cccfg.Type == 1 && _cccfg.Offset >= _fbdada._dbafe || _cccfg.Type == 0)) {
				break
			}
		}
		var _gbecd int
		for _gbecd = _cfccc + 1; _gbecd <= _gebc; _gbecd++ {
			_cebed, _bfbbb := _fbdada._ddcg[_gbecd]
			if _bfbbb && (!_fbdada._accad || _fbdada._accad && (_cebed.Type == 1 && _cebed.Offset > _fbdada._dbafe)) {
				continue
			}
			break
		}
		_cbdce := _b.Sprintf("\u0025d\u0020\u0025\u0064\u000d\u000a", _cfccc, _gbecd-_cfccc)
		_fbdada.writeString(_cbdce)
		for _ddade := _cfccc; _ddade < _gbecd; _ddade++ {
			_dedaf := _fbdada._ddcg[_ddade]
			switch _dedaf.Type {
			case 0:
				_cbdce = _b.Sprintf("\u0025\u002e\u0031\u0030\u0064\u0020\u0025\u002e\u0035d\u0020\u0066\u000d\u000a", 0, 65535)
				_fbdada.writeString(_cbdce)
			case 1:
				_cbdce = _b.Sprintf("\u0025\u002e\u0031\u0030\u0064\u0020\u0025\u002e\u0035d\u0020\u006e\u000d\u000a", _dedaf.Offset, 0)
				_fbdada.writeString(_cbdce)
			}
		}
		_cfccc = _gbecd + 1
	}
	_ebebf := _agf.MakeDict()
	_ebebf.Set("\u0049\u006e\u0066\u006f", _fbdada._eaaaab)
	_ebebf.Set("\u0052\u006f\u006f\u0074", _fbdada._eccfaf)
	_ebebf.Set("\u0053\u0069\u007a\u0065", _agf.MakeInteger(int64(_gebc+1)))
	if _fbdada._accad && _fbdada._bdcea > 0 {
		_ebebf.Set("\u0050\u0072\u0065\u0076", _agf.MakeInteger(_fbdada._bdcea))
	}
	if _fbdada._cecgd != nil {
		_ebebf.Set("\u0045n\u0063\u0072\u0079\u0070\u0074", _fbdada._gdcbf)
	}
	if _fbdada._fcgdbd == nil && _fbdada._bedbef != "" && _fbdada._daddd != "" {
		_fbdada._fcgdbd = _agf.MakeArray(_agf.MakeHexString(_fbdada._bedbef), _agf.MakeHexString(_fbdada._daddd))
	}
	if _fbdada._fcgdbd != nil {
		_ebebf.Set("\u0049\u0044", _fbdada._fcgdbd)
		_fd.Log.Trace("\u0049d\u0073\u003a\u0020\u0025\u0073", _fbdada._fcgdbd)
	}
	_fbdada.writeString("\u0074\u0072\u0061\u0069\u006c\u0065\u0072\u000a")
	_fbdada.writeString(_ebebf.WriteString())
	_fbdada.writeString("\u000a")
}

// String returns a string representation of the field.
func (_ccdb *PdfField) String() string {
	if _cdcb, _fffg := _ccdb.ToPdfObject().(*_agf.PdfIndirectObject); _fffg {
		return _b.Sprintf("\u0025\u0054\u003a\u0020\u0025\u0073", _ccdb._eaggd, _cdcb.PdfObject.String())
	}
	return ""
}

// NewPdfAnnotationFileAttachment returns a new file attachment annotation.
func NewPdfAnnotationFileAttachment() *PdfAnnotationFileAttachment {
	_ddd := NewPdfAnnotation()
	_fffb := &PdfAnnotationFileAttachment{}
	_fffb.PdfAnnotation = _ddd
	_fffb.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_ddd.SetContext(_fffb)
	return _fffb
}

// SetPageLabels sets the PageLabels entry in the PDF catalog.
// See section 12.4.2 "Page Labels" (p. 382 PDF32000_2008).
func (_aaaba *PdfWriter) SetPageLabels(pageLabels _agf.PdfObject) error {
	if pageLabels == nil {
		return nil
	}
	_fd.Log.Trace("\u0053\u0065t\u0074\u0069\u006e\u0067\u0020\u0063\u0061\u0074\u0061\u006c\u006f\u0067\u0020\u0050\u0061\u0067\u0065\u004c\u0061\u0062\u0065\u006cs.\u002e\u002e")
	_aaaba._bagbb.Set("\u0050\u0061\u0067\u0065\u004c\u0061\u0062\u0065\u006c\u0073", pageLabels)
	return _aaaba.addObjects(pageLabels)
}
func _aacff(_eeefa *_agf.PdfObjectDictionary) (*PdfShadingType6, error) {
	_abaec := PdfShadingType6{}
	_fdaa := _eeefa.Get("\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006f\u0072\u0064i\u006e\u0061\u0074\u0065")
	if _fdaa == nil {
		_fd.Log.Debug("\u0052e\u0071\u0075i\u0072\u0065\u0064 \u0061\u0074\u0074\u0072\u0069\u0062\u0075t\u0065\u0020\u006d\u0069\u0073\u0073i\u006e\u0067\u003a\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072C\u006f\u006f\u0072\u0064\u0069\u006e\u0061\u0074\u0065")
		return nil, ErrRequiredAttributeMissing
	}
	_ecdaf, _cgbdg := _fdaa.(*_agf.PdfObjectInteger)
	if !_cgbdg {
		_fd.Log.Debug("\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006f\u0072\u0064\u0069\u006e\u0061\u0074\u0065\u0020\u006eo\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", _fdaa)
		return nil, _agf.ErrTypeError
	}
	_abaec.BitsPerCoordinate = _ecdaf
	_fdaa = _eeefa.Get("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074")
	if _fdaa == nil {
		_fd.Log.Debug("\u0052e\u0071\u0075i\u0072\u0065\u0064\u0020a\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u0020\u006d\u0069\u0073\u0073in\u0067\u003a\u0020B\u0069\u0074s\u0050\u0065\u0072\u0043\u006f\u006dp\u006f\u006ee\u006e\u0074")
		return nil, ErrRequiredAttributeMissing
	}
	_ecdaf, _cgbdg = _fdaa.(*_agf.PdfObjectInteger)
	if !_cgbdg {
		_fd.Log.Debug("B\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065r \u0028\u0067\u006ft\u0020%\u0054\u0029", _fdaa)
		return nil, _agf.ErrTypeError
	}
	_abaec.BitsPerComponent = _ecdaf
	_fdaa = _eeefa.Get("B\u0069\u0074\u0073\u0050\u0065\u0072\u0046\u006c\u0061\u0067")
	if _fdaa == nil {
		_fd.Log.Debug("\u0052\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u0020\u006di\u0073\u0073\u0069\u006e\u0067\u003a\u0020\u0042\u0069\u0074\u0073\u0050\u0065r\u0046\u006c\u0061\u0067")
		return nil, ErrRequiredAttributeMissing
	}
	_ecdaf, _cgbdg = _fdaa.(*_agf.PdfObjectInteger)
	if !_cgbdg {
		_fd.Log.Debug("B\u0069\u0074\u0073\u0050\u0065\u0072F\u006c\u0061\u0067\u0020\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0074e\u0067\u0065\u0072\u0020\u0028\u0067\u006f\u0074\u0020\u0025T\u0029", _fdaa)
		return nil, _agf.ErrTypeError
	}
	_abaec.BitsPerComponent = _ecdaf
	_fdaa = _eeefa.Get("\u0044\u0065\u0063\u006f\u0064\u0065")
	if _fdaa == nil {
		_fd.Log.Debug("\u0052\u0065\u0071ui\u0072\u0065\u0064\u0020\u0061\u0074\u0074\u0072\u0069b\u0075t\u0065 \u006di\u0073\u0073\u0069\u006e\u0067\u003a\u0020\u0044\u0065\u0063\u006f\u0064\u0065")
		return nil, ErrRequiredAttributeMissing
	}
	_bbgbb, _cgbdg := _fdaa.(*_agf.PdfObjectArray)
	if !_cgbdg {
		_fd.Log.Debug("\u0044\u0065\u0063\u006fd\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072a\u0079\u0020\u0028\u0067\u006f\u0074\u0020%\u0054\u0029", _fdaa)
		return nil, _agf.ErrTypeError
	}
	_abaec.Decode = _bbgbb
	if _dafad := _eeefa.Get("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e"); _dafad != nil {
		_abaec.Function = []PdfFunction{}
		if _beabc, _fggca := _dafad.(*_agf.PdfObjectArray); _fggca {
			for _, _bgccb := range _beabc.Elements() {
				_eebeg, _bddd := _ccedb(_bgccb)
				if _bddd != nil {
					_fd.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e:\u0020\u0025\u0076", _bddd)
					return nil, _bddd
				}
				_abaec.Function = append(_abaec.Function, _eebeg)
			}
		} else {
			_cbdgc, _gcaae := _ccedb(_dafad)
			if _gcaae != nil {
				_fd.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e:\u0020\u0025\u0076", _gcaae)
				return nil, _gcaae
			}
			_abaec.Function = append(_abaec.Function, _cbdgc)
		}
	}
	return &_abaec, nil
}

// ColorToRGB converts a CalRGB color to an RGB color.
func (_fdfb *PdfColorspaceCalRGB) ColorToRGB(color PdfColor) (PdfColor, error) {
	_fgfea, _fgfeab := color.(*PdfColorCalRGB)
	if !_fgfeab {
		_fd.Log.Debug("\u0049\u006e\u0070ut\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u006e\u006f\u0074\u0020\u0063\u0061\u006c\u0020\u0072\u0067\u0062")
		return nil, _gcd.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	_gdcdf := _fgfea.A()
	_gcgf := _fgfea.B()
	_gbge := _fgfea.C()
	X := _fdfb.Matrix[0]*_afb.Pow(_gdcdf, _fdfb.Gamma[0]) + _fdfb.Matrix[3]*_afb.Pow(_gcgf, _fdfb.Gamma[1]) + _fdfb.Matrix[6]*_afb.Pow(_gbge, _fdfb.Gamma[2])
	Y := _fdfb.Matrix[1]*_afb.Pow(_gdcdf, _fdfb.Gamma[0]) + _fdfb.Matrix[4]*_afb.Pow(_gcgf, _fdfb.Gamma[1]) + _fdfb.Matrix[7]*_afb.Pow(_gbge, _fdfb.Gamma[2])
	Z := _fdfb.Matrix[2]*_afb.Pow(_gdcdf, _fdfb.Gamma[0]) + _fdfb.Matrix[5]*_afb.Pow(_gcgf, _fdfb.Gamma[1]) + _fdfb.Matrix[8]*_afb.Pow(_gbge, _fdfb.Gamma[2])
	_dabb := 3.240479*X + -1.537150*Y + -0.498535*Z
	_agfg := -0.969256*X + 1.875992*Y + 0.041556*Z
	_daag := 0.055648*X + -0.204043*Y + 1.057311*Z
	_dabb = _afb.Min(_afb.Max(_dabb, 0), 1.0)
	_agfg = _afb.Min(_afb.Max(_agfg, 0), 1.0)
	_daag = _afb.Min(_afb.Max(_daag, 0), 1.0)
	return NewPdfColorDeviceRGB(_dabb, _agfg, _daag), nil
}
func (_bcgac *PdfFilespec) getDict() *_agf.PdfObjectDictionary {
	if _efbffb, _gdadb := _bcgac._bfdc.(*_agf.PdfIndirectObject); _gdadb {
		_fadd, _ggef := _efbffb.PdfObject.(*_agf.PdfObjectDictionary)
		if !_ggef {
			return nil
		}
		return _fadd
	} else if _decfc, _gaed := _bcgac._bfdc.(*_agf.PdfObjectDictionary); _gaed {
		return _decfc
	} else {
		_fd.Log.Debug("\u0054\u0072\u0079\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0061\u0063\u0063\u0065\u0073\u0073\u0020F\u0069\u006c\u0065\u0073\u0070\u0065\u0063\u0020\u0064\u0069c\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006f\u0066\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064 \u006f\u0062\u006a\u0065\u0063\u0074 \u0074\u0079p\u0065\u0020(\u0025T\u0029", _bcgac._bfdc)
		return nil
	}
}

// PdfActionSubmitForm represents a submitForm action.
type PdfActionSubmitForm struct {
	*PdfAction
	F      *PdfFilespec
	Fields _agf.PdfObject
	Flags  _agf.PdfObject
}

// ToPdfObject returns the PDF representation of the page resources.
func (_caeec *PdfPageResources) ToPdfObject() _agf.PdfObject {
	_adgfc := _caeec._ebga
	_adgfc.SetIfNotNil("\u0045x\u0074\u0047\u0053\u0074\u0061\u0074e", _caeec.ExtGState)
	if _caeec._dgceaa != nil {
		_caeec.ColorSpace = _caeec._dgceaa.ToPdfObject()
	}
	_adgfc.SetIfNotNil("\u0043\u006f\u006c\u006f\u0072\u0053\u0070\u0061\u0063\u0065", _caeec.ColorSpace)
	_adgfc.SetIfNotNil("\u0050a\u0074\u0074\u0065\u0072\u006e", _caeec.Pattern)
	_adgfc.SetIfNotNil("\u0053h\u0061\u0064\u0069\u006e\u0067", _caeec.Shading)
	_adgfc.SetIfNotNil("\u0058O\u0062\u006a\u0065\u0063\u0074", _caeec.XObject)
	_adgfc.SetIfNotNil("\u0046\u006f\u006e\u0074", _caeec.Font)
	_adgfc.SetIfNotNil("\u0050r\u006f\u0063\u0053\u0065\u0074", _caeec.ProcSet)
	_adgfc.SetIfNotNil("\u0050\u0072\u006f\u0070\u0065\u0072\u0074\u0069\u0065\u0073", _caeec.Properties)
	return _adgfc
}

// NewPdfActionGoToE returns a new "go to embedded" action.
func NewPdfActionGoToE() *PdfActionGoToE {
	_bea := NewPdfAction()
	_fgf := &PdfActionGoToE{}
	_fgf.PdfAction = _bea
	_bea.SetContext(_fgf)
	return _fgf
}

// PdfInfoTrapped specifies pdf trapped information.
type PdfInfoTrapped string

// ColorToRGB verifies that the input color is an RGB color. Method exists in
// order to satisfy the PdfColorspace interface.
func (_aegd *PdfColorspaceDeviceRGB) ColorToRGB(color PdfColor) (PdfColor, error) {
	_cefa, _cdafg := color.(*PdfColorDeviceRGB)
	if !_cdafg {
		_fd.Log.Debug("\u0049\u006e\u0070\u0075\u0074\u0020\u0063\u006f\u006c\u006f\u0072 \u006e\u006f\u0074\u0020\u0064\u0065\u0076\u0069\u0063\u0065 \u0052\u0047\u0042")
		return nil, _gcd.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	return _cefa, nil
}

// PdfColorDeviceGray represents a grayscale color value that shall be represented by a single number in the
// range 0.0 to 1.0 where 0.0 corresponds to black and 1.0 to white.
type PdfColorDeviceGray float64

// SetDSS sets the DSS dictionary (ETSI TS 102 778-4 V1.1.1) of the current
// document revision.
func (_ccce *PdfAppender) SetDSS(dss *DSS) {
	if dss != nil {
		_ccce.updateObjectsDeep(dss.ToPdfObject(), nil)
	}
	_ccce._caae = dss
}
func _bbgcg(_bbae *_agf.PdfObjectDictionary, _aggc *fontCommon) (*pdfFontType3, error) {
	_dbef := _aaba(_aggc)
	_dfefc := _bbae.Get("\u0046i\u0072\u0073\u0074\u0043\u0068\u0061r")
	if _dfefc == nil {
		_dfefc = _agf.MakeInteger(0)
	}
	_dbef.FirstChar = _dfefc
	_beaed, _fgbgd := _agf.GetIntVal(_dfefc)
	if !_fgbgd {
		_fd.Log.Debug("\u0045\u0052\u0052OR\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064 \u0046i\u0072s\u0074C\u0068\u0061\u0072\u0020\u0074\u0079\u0070\u0065\u0020\u0028\u0025\u0054\u0029", _dfefc)
		return nil, _agf.ErrTypeError
	}
	_cbdca := _fcg.CharCode(_beaed)
	_dfefc = _bbae.Get("\u004c\u0061\u0073\u0074\u0043\u0068\u0061\u0072")
	if _dfefc == nil {
		_dfefc = _agf.MakeInteger(255)
	}
	_dbef.LastChar = _dfefc
	_beaed, _fgbgd = _agf.GetIntVal(_dfefc)
	if !_fgbgd {
		_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u004c\u0061\u0073\u0074\u0043h\u0061\u0072\u0020\u0074\u0079\u0070\u0065 \u0028\u0025\u0054\u0029", _dfefc)
		return nil, _agf.ErrTypeError
	}
	_dagdb := _fcg.CharCode(_beaed)
	_dfefc = _bbae.Get("\u0052e\u0073\u006f\u0075\u0072\u0063\u0065s")
	if _dfefc != nil {
		_dbef.Resources = _dfefc
	}
	_dfefc = _bbae.Get("\u0043h\u0061\u0072\u0050\u0072\u006f\u0063s")
	if _dfefc == nil {
		_fd.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0043\u0068\u0061\u0072\u0050\u0072\u006f\u0063\u0073\u0020(%\u0076\u0029", _dfefc)
		return nil, _agf.ErrNotSupported
	}
	_dbef.CharProcs = _dfefc
	_dfefc = _bbae.Get("\u0046\u006f\u006e\u0074\u004d\u0061\u0074\u0072\u0069\u0078")
	if _dfefc == nil {
		_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076a\u006c\u0069\u0064\u0020\u0046\u006f\u006et\u004d\u0061\u0074\u0072\u0069\u0078\u0020\u0028\u0025\u0076\u0029", _dfefc)
		return nil, _agf.ErrNotSupported
	}
	_dbef.FontMatrix = _dfefc
	_dbef._aebef = make(map[_fcg.CharCode]float64)
	_dfefc = _bbae.Get("\u0057\u0069\u0064\u0074\u0068\u0073")
	if _dfefc != nil {
		_dbef.Widths = _dfefc
		_bdaag, _bdebd := _agf.GetArray(_dfefc)
		if !_bdebd {
			_fd.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020W\u0069\u0064t\u0068\u0073\u0020\u0061\u0074\u0074\u0072\u0069b\u0075\u0074\u0065\u0020\u0021\u003d\u0020\u0061\u0072\u0072\u0061\u0079 \u0028\u0025\u0054\u0029", _dfefc)
			return nil, _agf.ErrTypeError
		}
		_cgbd, _gacb := _bdaag.ToFloat64Array()
		if _gacb != nil {
			_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0069\u006e\u0067\u0020\u0077\u0069d\u0074\u0068\u0073\u0020\u0074\u006f\u0020a\u0072\u0072\u0061\u0079")
			return nil, _gacb
		}
		if len(_cgbd) != int(_dagdb-_cbdca+1) {
			_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0077\u0069\u0064\u0074\u0068s\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0021\u003d\u0020\u0025\u0064 \u0028\u0025\u0064\u0029", _dagdb-_cbdca+1, len(_cgbd))
			return nil, _agf.ErrRangeError
		}
		_deafb, _bdebd := _agf.GetArray(_dbef.FontMatrix)
		if !_bdebd {
			_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052:\u0020\u0046\u006f\u006e\u0074\u004d\u0061\u0074\u0072\u0069\u0078\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0021\u003d\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0028\u0025\u0054\u0029", _deafb)
			return nil, _gacb
		}
		_ccda, _gacb := _deafb.ToFloat64Array()
		if _gacb != nil {
			_fd.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020c\u006f\u006ev\u0065\u0072\u0074\u0069\u006e\u0067\u0020\u0046o\u006e\u0074\u004d\u0061\u0074\u0072\u0069\u0078\u0020\u0074\u006f\u0020a\u0072\u0072\u0061\u0079")
			return nil, _gacb
		}
		_gafa := _fba.NewMatrix(_ccda[0], _ccda[1], _ccda[2], _ccda[3], _ccda[4], _ccda[5])
		for _cbba, _ggffa := range _cgbd {
			_fbaa, _ := _gafa.Transform(_ggffa, _ggffa)
			_dbef._aebef[_cbdca+_fcg.CharCode(_cbba)] = _fbaa
		}
	}
	_dbef.Encoding = _agf.TraceToDirectObject(_bbae.Get("\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067"))
	_ggaef := _bbae.Get("\u0054o\u0055\u006e\u0069\u0063\u006f\u0064e")
	if _ggaef != nil {
		_dbef._ebabcd = _agf.TraceToDirectObject(_ggaef)
		_eebba, _egffb := _eaeg(_dbef._ebabcd, &_dbef.fontCommon)
		if _egffb != nil {
			return nil, _egffb
		}
		_dbef._egfbf = _eebba
	}
	if _bdafd := _dbef._egfbf; _bdafd != nil {
		_dbef._gfffe = _fcg.NewCMapEncoder("", nil, _bdafd)
	} else {
		_dbef._gfffe = _fcg.NewPdfDocEncoder()
	}
	return _dbef, nil
}

// ToPdfObject implements interface PdfModel.
func (_fad *PdfActionGoTo3DView) ToPdfObject() _agf.PdfObject {
	_fad.PdfAction.ToPdfObject()
	_caa := _fad._caf
	_fdag := _caa.PdfObject.(*_agf.PdfObjectDictionary)
	_fdag.SetIfNotNil("\u0053", _agf.MakeName(string(ActionTypeGoTo3DView)))
	_fdag.SetIfNotNil("\u0054\u0041", _fad.TA)
	_fdag.SetIfNotNil("\u0056", _fad.V)
	return _caa
}

// EncryptOptions represents encryption options for an output PDF.
type EncryptOptions struct {
	Permissions _bfb.Permissions
	Algorithm   EncryptionAlgorithm
}

// PdfPage represents a page in a PDF document. (7.7.3.3 - Table 30).
type PdfPage struct {
	Parent               _agf.PdfObject
	LastModified         *PdfDate
	Resources            *PdfPageResources
	CropBox              *PdfRectangle
	MediaBox             *PdfRectangle
	BleedBox             *PdfRectangle
	TrimBox              *PdfRectangle
	ArtBox               *PdfRectangle
	BoxColorInfo         _agf.PdfObject
	Contents             _agf.PdfObject
	Rotate               *int64
	Group                _agf.PdfObject
	Thumb                _agf.PdfObject
	B                    _agf.PdfObject
	Dur                  _agf.PdfObject
	Trans                _agf.PdfObject
	AA                   _agf.PdfObject
	Metadata             _agf.PdfObject
	PieceInfo            _agf.PdfObject
	StructParents        _agf.PdfObject
	ID                   _agf.PdfObject
	PZ                   _agf.PdfObject
	SeparationInfo       _agf.PdfObject
	Tabs                 _agf.PdfObject
	TemplateInstantiated _agf.PdfObject
	PresSteps            _agf.PdfObject
	UserUnit             _agf.PdfObject
	VP                   _agf.PdfObject
	Annots               _agf.PdfObject
	_abffa               []*PdfAnnotation
	_ececfb              *_agf.PdfObjectDictionary
	_edegf               *_agf.PdfIndirectObject
	_gabcc               _agf.PdfObjectDictionary
	_ecae                *PdfReader
}

// ToPdfObject implements interface PdfModel.
func (_eddf *PdfAnnotationFileAttachment) ToPdfObject() _agf.PdfObject {
	_eddf.PdfAnnotation.ToPdfObject()
	_abcb := _eddf._aeee
	_bfba := _abcb.PdfObject.(*_agf.PdfObjectDictionary)
	_eddf.PdfAnnotationMarkup.appendToPdfDictionary(_bfba)
	_bfba.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _agf.MakeName("\u0046\u0069\u006c\u0065\u0041\u0074\u0074\u0061\u0063h\u006d\u0065\u006e\u0074"))
	_bfba.SetIfNotNil("\u0046\u0053", _eddf.FS)
	_bfba.SetIfNotNil("\u004e\u0061\u006d\u0065", _eddf.Name)
	return _abcb
}

// SignatureValidationResult defines the response from the signature validation handler.
type SignatureValidationResult struct {

	// List of errors when validating the signature.
	Errors      []string
	IsSigned    bool
	IsVerified  bool
	IsTrusted   bool
	Fields      []*PdfField
	Name        string
	Date        PdfDate
	Reason      string
	Location    string
	ContactInfo string
	DiffResults *_ca.DiffResults

	// GeneralizedTime is the time at which the time-stamp token has been created by the TSA (RFC 3161).
	GeneralizedTime _e.Time
}

// ToPdfObject implements interface PdfModel.
func (_gf *PdfActionMovie) ToPdfObject() _agf.PdfObject {
	_gf.PdfAction.ToPdfObject()
	_cae := _gf._caf
	_bbdf := _cae.PdfObject.(*_agf.PdfObjectDictionary)
	_bbdf.SetIfNotNil("\u0053", _agf.MakeName(string(ActionTypeMovie)))
	_bbdf.SetIfNotNil("\u0041\u006e\u006e\u006f\u0074\u0061\u0074\u0069\u006f\u006e", _gf.Annotation)
	_bbdf.SetIfNotNil("\u0054", _gf.T)
	_bbdf.SetIfNotNil("\u004fp\u0065\u0072\u0061\u0074\u0069\u006fn", _gf.Operation)
	return _cae
}

var _ pdfFont = (*pdfCIDFontType0)(nil)

// GetPageDict converts the Page to a PDF object dictionary.
func (_fbca *PdfPage) GetPageDict() *_agf.PdfObjectDictionary {
	_cggf := _fbca._ececfb
	_cggf.Clear()
	_cggf.Set("\u0054\u0079\u0070\u0065", _agf.MakeName("\u0050\u0061\u0067\u0065"))
	_cggf.Set("\u0050\u0061\u0072\u0065\u006e\u0074", _fbca.Parent)
	if _fbca.LastModified != nil {
		_cggf.Set("\u004c\u0061\u0073t\u004d\u006f\u0064\u0069\u0066\u0069\u0065\u0064", _fbca.LastModified.ToPdfObject())
	}
	if _fbca.Resources != nil {
		_cggf.Set("\u0052e\u0073\u006f\u0075\u0072\u0063\u0065s", _fbca.Resources.ToPdfObject())
	}
	if _fbca.CropBox != nil {
		_cggf.Set("\u0043r\u006f\u0070\u0042\u006f\u0078", _fbca.CropBox.ToPdfObject())
	}
	if _fbca.MediaBox != nil {
		_cggf.Set("\u004d\u0065\u0064\u0069\u0061\u0042\u006f\u0078", _fbca.MediaBox.ToPdfObject())
	}
	if _fbca.BleedBox != nil {
		_cggf.Set("\u0042\u006c\u0065\u0065\u0064\u0042\u006f\u0078", _fbca.BleedBox.ToPdfObject())
	}
	if _fbca.TrimBox != nil {
		_cggf.Set("\u0054r\u0069\u006d\u0042\u006f\u0078", _fbca.TrimBox.ToPdfObject())
	}
	if _fbca.ArtBox != nil {
		_cggf.Set("\u0041\u0072\u0074\u0042\u006f\u0078", _fbca.ArtBox.ToPdfObject())
	}
	_cggf.SetIfNotNil("\u0042\u006f\u0078C\u006f\u006c\u006f\u0072\u0049\u006e\u0066\u006f", _fbca.BoxColorInfo)
	_cggf.SetIfNotNil("\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073", _fbca.Contents)
	if _fbca.Rotate != nil {
		_cggf.Set("\u0052\u006f\u0074\u0061\u0074\u0065", _agf.MakeInteger(*_fbca.Rotate))
	}
	_cggf.SetIfNotNil("\u0047\u0072\u006fu\u0070", _fbca.Group)
	_cggf.SetIfNotNil("\u0054\u0068\u0075m\u0062", _fbca.Thumb)
	_cggf.SetIfNotNil("\u0042", _fbca.B)
	_cggf.SetIfNotNil("\u0044\u0075\u0072", _fbca.Dur)
	_cggf.SetIfNotNil("\u0054\u0072\u0061n\u0073", _fbca.Trans)
	_cggf.SetIfNotNil("\u0041\u0041", _fbca.AA)
	_cggf.SetIfNotNil("\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061", _fbca.Metadata)
	_cggf.SetIfNotNil("\u0050i\u0065\u0063\u0065\u0049\u006e\u0066o", _fbca.PieceInfo)
	_cggf.SetIfNotNil("\u0053\u0074\u0072\u0075\u0063\u0074\u0050\u0061\u0072\u0065\u006e\u0074\u0073", _fbca.StructParents)
	_cggf.SetIfNotNil("\u0049\u0044", _fbca.ID)
	_cggf.SetIfNotNil("\u0050\u005a", _fbca.PZ)
	_cggf.SetIfNotNil("\u0053\u0065\u0070\u0061\u0072\u0061\u0074\u0069\u006fn\u0049\u006e\u0066\u006f", _fbca.SeparationInfo)
	_cggf.SetIfNotNil("\u0054\u0061\u0062\u0073", _fbca.Tabs)
	_cggf.SetIfNotNil("T\u0065m\u0070\u006c\u0061\u0074\u0065\u0049\u006e\u0073t\u0061\u006e\u0074\u0069at\u0065\u0064", _fbca.TemplateInstantiated)
	_cggf.SetIfNotNil("\u0050r\u0065\u0073\u0053\u0074\u0065\u0070s", _fbca.PresSteps)
	_cggf.SetIfNotNil("\u0055\u0073\u0065\u0072\u0055\u006e\u0069\u0074", _fbca.UserUnit)
	_cggf.SetIfNotNil("\u0056\u0050", _fbca.VP)
	if _fbca._abffa != nil {
		_afcd := _agf.MakeArray()
		for _, _eafb := range _fbca._abffa {
			if _beecgd := _eafb.GetContext(); _beecgd != nil {
				_afcd.Append(_beecgd.ToPdfObject())
			} else {
				_afcd.Append(_eafb.ToPdfObject())
			}
		}
		if _afcd.Len() > 0 {
			_cggf.Set("\u0041\u006e\u006e\u006f\u0074\u0073", _afcd)
		}
	} else if _fbca.Annots != nil {
		_cggf.SetIfNotNil("\u0041\u006e\u006e\u006f\u0074\u0073", _fbca.Annots)
	}
	return _cggf
}

// ToWriter creates a new writer from the current reader, based on the specified options.
// If no options are provided, all reader properties are copied to the writer.
func (_eggea *PdfReader) ToWriter(opts *ReaderToWriterOpts) (*PdfWriter, error) {
	_acee := NewPdfWriter()
	if opts == nil {
		opts = &ReaderToWriterOpts{}
	}
	_decbc, _bfaec := _eggea.GetNumPages()
	if _bfaec != nil {
		_fd.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _bfaec)
		return nil, _bfaec
	}
	for _dafa := 1; _dafa <= _decbc; _dafa++ {
		_cbdb, _edfeg := _eggea.GetPage(_dafa)
		if _edfeg != nil {
			_fd.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _edfeg)
			return nil, _edfeg
		}
		if opts.PageProcessCallback != nil {
			_edfeg = opts.PageProcessCallback(_dafa, _cbdb)
			if _edfeg != nil {
				_fd.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _edfeg)
				return nil, _edfeg
			}
		} else if opts.PageCallback != nil {
			opts.PageCallback(_dafa, _cbdb)
		}
		_edfeg = _acee.AddPage(_cbdb)
		if _edfeg != nil {
			_fd.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _edfeg)
			return nil, _edfeg
		}
	}
	_acee._bcdfgg = _eggea.PdfVersion()
	if !opts.SkipInfo {
		_dgcgg, _ggcge := _eggea.GetPdfInfo()
		if _ggcge != nil {
			_fd.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _ggcge)
		} else {
			_acee._eaaaab.PdfObject = _dgcgg.ToPdfObject()
		}
	}
	if !opts.SkipMetadata {
		if _cdfb := _eggea._ceaadd.Get("\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061"); _cdfb != nil {
			if _ffcf := _acee.SetCatalogMetadata(_cdfb); _ffcf != nil {
				return nil, _ffcf
			}
		}
	}
	if !opts.SkipAcroForm {
		_agdf := _acee.SetForms(_eggea.AcroForm)
		if _agdf != nil {
			_fd.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _agdf)
			return nil, _agdf
		}
	}
	if !opts.SkipOutlines {
		_acee.AddOutlineTree(_eggea.GetOutlineTree())
	}
	if !opts.SkipOCProperties {
		_faaff, _bgdc := _eggea.GetOCProperties()
		if _bgdc != nil {
			_fd.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _bgdc)
		} else {
			_bgdc = _acee.SetOCProperties(_faaff)
			if _bgdc != nil {
				_fd.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _bgdc)
			}
		}
	}
	if !opts.SkipPageLabels {
		_fdbe, _aecf := _eggea.GetPageLabels()
		if _aecf != nil {
			_fd.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _aecf)
		} else {
			_aecf = _acee.SetPageLabels(_fdbe)
			if _aecf != nil {
				_fd.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _aecf)
			}
		}
	}
	if !opts.SkipNamedDests {
		_aedaf, _ddbde := _eggea.GetNamedDestinations()
		if _ddbde != nil {
			_fd.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _ddbde)
		} else {
			_ddbde = _acee.SetNamedDestinations(_aedaf)
			if _ddbde != nil {
				_fd.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _ddbde)
			}
		}
	}
	if !opts.SkipNameDictionary {
		_ageba, _ebce := _eggea.GetNameDictionary()
		if _ebce != nil {
			_fd.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _ebce)
		} else {
			_ebce = _acee.SetNameDictionary(_ageba)
			if _ebce != nil {
				_fd.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _ebce)
			}
		}
	}
	if !opts.SkipRotation && _eggea.Rotate != nil {
		if _aedcc := _acee.SetRotation(*_eggea.Rotate); _aedcc != nil {
			_fd.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _aedcc)
		}
	}
	return &_acee, nil
}

// SetContext sets the sub pattern (context).  Either PdfTilingPattern or PdfShadingPattern.
func (_bedad *PdfPattern) SetContext(ctx PdfModel) { _bedad._dfed = ctx }

type pdfCIDFontType2 struct {
	fontCommon
	_efae *_agf.PdfIndirectObject
	_cfbd _fcg.TextEncoder

	// Table 117 – Entries in a CIDFont dictionary (page 269)
	// Dictionary that defines the character collection of the CIDFont (required).
	// See Table 116.
	CIDSystemInfo *_agf.PdfObjectDictionary

	// Glyph metrics fields (optional).
	DW  _agf.PdfObject
	W   _agf.PdfObject
	DW2 _agf.PdfObject
	W2  _agf.PdfObject

	// CIDs to glyph indices mapping (optional).
	CIDToGIDMap _agf.PdfObject
	_egaaf      map[_fcg.CharCode]float64
	_fgecb      float64
	_dbae       map[rune]int
}

func _beeeb(_ecab *_agf.PdfObjectDictionary) *VRI {
	_bbce, _ := _agf.GetString(_ecab.Get("\u0054\u0055"))
	_fbd, _ := _agf.GetString(_ecab.Get("\u0054\u0053"))
	return &VRI{Cert: _cdcfg(_ecab.Get("\u0043\u0065\u0072\u0074")), OCSP: _cdcfg(_ecab.Get("\u004f\u0043\u0053\u0050")), CRL: _cdcfg(_ecab.Get("\u0043\u0052\u004c")), TU: _bbce, TS: _fbd}
}
func (_dcacag Image) getBase() _ged.ImageBase {
	return _ged.NewImageBase(int(_dcacag.Width), int(_dcacag.Height), int(_dcacag.BitsPerComponent), _dcacag.ColorComponents, _dcacag.Data, _dcacag._gdga, _dcacag._abacg)
}
func (_beffa fontCommon) asPdfObjectDictionary(_fgdd string) *_agf.PdfObjectDictionary {
	if _fgdd != "" && _beffa._bcbfd != "" && _fgdd != _beffa._bcbfd {
		_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0061\u0073\u0050\u0064\u0066\u004f\u0062\u006a\u0065\u0063\u0074\u0044\u0069c\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u002e\u0020O\u0076\u0065\u0072\u0072\u0069\u0064\u0069\u006e\u0067\u0020\u0073\u0075\u0062t\u0079\u0070\u0065\u0020\u0074\u006f \u0025\u0023\u0071 \u0025\u0073", _fgdd, _beffa)
	} else if _fgdd == "" && _beffa._bcbfd == "" {
		_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0061s\u0050\u0064\u0066Ob\u006a\u0065\u0063\u0074\u0044\u0069c\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006e\u006f\u0020\u0073\u0075\u0062\u0074y\u0070\u0065\u002e\u0020\u0066\u006f\u006e\u0074=\u0025\u0073", _beffa)
	} else if _beffa._bcbfd == "" {
		_beffa._bcbfd = _fgdd
	}
	_ccedd := _agf.MakeDict()
	_ccedd.Set("\u0054\u0079\u0070\u0065", _agf.MakeName("\u0046\u006f\u006e\u0074"))
	_ccedd.Set("\u0042\u0061\u0073\u0065\u0046\u006f\u006e\u0074", _agf.MakeName(_beffa._fccf))
	_ccedd.Set("\u0053u\u0062\u0074\u0079\u0070\u0065", _agf.MakeName(_beffa._bcbfd))
	if _beffa._dcfcb != nil {
		_ccedd.Set("\u0046\u006f\u006e\u0074\u0044\u0065\u0073\u0063\u0072i\u0070\u0074\u006f\u0072", _beffa._dcfcb.ToPdfObject())
	}
	if _beffa._ebabcd != nil {
		_ccedd.Set("\u0054o\u0055\u006e\u0069\u0063\u006f\u0064e", _beffa._ebabcd)
	} else if _beffa._egfbf != nil {
		_dfeca, _eeadg := _beffa._egfbf.Stream()
		if _eeadg != nil {
			_fd.Log.Debug("\u0057\u0041\u0052\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006eo\u0074\u0020\u0067\u0065\u0074\u0020C\u004d\u0061\u0070\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u002e\u0020\u0065r\u0072\u003d\u0025\u0076", _eeadg)
		} else {
			_ccedd.Set("\u0054o\u0055\u006e\u0069\u0063\u006f\u0064e", _dfeca)
		}
	}
	return _ccedd
}

// Flags returns the field flags for the field accounting for any inherited flags.
func (_cffge *PdfField) Flags() FieldFlag {
	var _eecc FieldFlag
	_dfef, _gfbaa := _cffge.inherit(func(_agbff *PdfField) bool {
		if _agbff.Ff != nil {
			_eecc = FieldFlag(*_agbff.Ff)
			return true
		}
		return false
	})
	if _gfbaa != nil {
		_fd.Log.Debug("\u0045\u0072\u0072o\u0072\u0020\u0065\u0076\u0061\u006c\u0075\u0061\u0074\u0069\u006e\u0067\u0020\u0066\u006c\u0061\u0067\u0073\u0020\u0076\u0069\u0061\u0020\u0069\u006e\u0068\u0065\u0072\u0069t\u0061\u006e\u0063\u0065\u003a\u0020\u0025\u0076", _gfbaa)
	}
	if !_dfef {
		_fd.Log.Trace("N\u006f\u0020\u0066\u0069\u0065\u006cd\u0020\u0066\u006c\u0061\u0067\u0073 \u0066\u006f\u0075\u006e\u0064\u0020\u002d \u0061\u0073\u0073\u0075\u006d\u0065\u0020\u0063\u006c\u0065a\u0072")
	}
	return _eecc
}

// GetAscent returns the Ascent of the font `descriptor`.
func (_cafa *PdfFontDescriptor) GetAscent() (float64, error) {
	return _agf.GetNumberAsFloat(_cafa.Ascent)
}

// GetCatalogMarkInfo gets catalog MarkInfo object.
func (_afba *PdfReader) GetCatalogMarkInfo() (_agf.PdfObject, bool) {
	if _afba._ceaadd == nil {
		return nil, false
	}
	_eedb := _afba._ceaadd.Get("\u004d\u0061\u0072\u006b\u0049\u006e\u0066\u006f")
	return _eedb, _eedb != nil
}

// ColorToRGB converts a CalGray color to an RGB color.
func (_bbaa *PdfColorspaceCalGray) ColorToRGB(color PdfColor) (PdfColor, error) {
	_deede, _ggdf := color.(*PdfColorCalGray)
	if !_ggdf {
		_fd.Log.Debug("\u0049n\u0070\u0075\u0074\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u006eo\u0074\u0020\u0063\u0061\u006c\u0020\u0067\u0072\u0061\u0079")
		return nil, _gcd.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	ANorm := _deede.Val()
	X := _bbaa.WhitePoint[0] * _afb.Pow(ANorm, _bbaa.Gamma)
	Y := _bbaa.WhitePoint[1] * _afb.Pow(ANorm, _bbaa.Gamma)
	Z := _bbaa.WhitePoint[2] * _afb.Pow(ANorm, _bbaa.Gamma)
	_bfa := 3.240479*X + -1.537150*Y + -0.498535*Z
	_eedg := -0.969256*X + 1.875992*Y + 0.041556*Z
	_cdef := 0.055648*X + -0.204043*Y + 1.057311*Z
	_bfa = _afb.Min(_afb.Max(_bfa, 0), 1.0)
	_eedg = _afb.Min(_afb.Max(_eedg, 0), 1.0)
	_cdef = _afb.Min(_afb.Max(_cdef, 0), 1.0)
	return NewPdfColorDeviceRGB(_bfa, _eedg, _cdef), nil
}

// Optimizer is the interface that performs optimization of PDF object structure for output writing.
//
// Optimize receives a slice of input `objects`, performs optimization, including removing, replacing objects and
// output the optimized slice of objects.
type Optimizer interface {
	Optimize(_gdgf []_agf.PdfObject) ([]_agf.PdfObject, error)
}

// NewPdfAnnotationCircle returns a new circle annotation.
func NewPdfAnnotationCircle() *PdfAnnotationCircle {
	_gbe := NewPdfAnnotation()
	_dabd := &PdfAnnotationCircle{}
	_dabd.PdfAnnotation = _gbe
	_dabd.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_gbe.SetContext(_dabd)
	return _dabd
}

// AddPage adds a page to the PDF file. The new page should be an indirect object.
func (_beegdb *PdfWriter) AddPage(page *PdfPage) error {
	const _cefbb = "\u006d\u006f\u0064el\u003a\u0050\u0064\u0066\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0041\u0064\u0064\u0050\u0061\u0067\u0065"
	_ddeeg(page)
	_bdfc := page.ToPdfObject()
	_fd.Log.Trace("\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d")
	_fd.Log.Trace("\u0041p\u0070\u0065\u006e\u0064i\u006e\u0067\u0020\u0074\u006f \u0070a\u0067e\u0020\u006c\u0069\u0073\u0074\u0020\u0025T", _bdfc)
	_gfgce, _gdbcb := _agf.GetIndirect(_bdfc)
	if !_gdbcb {
		return _gcd.New("\u0070\u0061\u0067\u0065\u0020\u0073h\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020\u0069\u006ed\u0069\u0072\u0065\u0063\u0074\u0020\u006fb\u006a\u0065\u0063\u0074")
	}
	_fd.Log.Trace("\u0025\u0073", _gfgce)
	_fd.Log.Trace("\u0025\u0073", _gfgce.PdfObject)
	_dfdbcg, _gdbcb := _agf.GetDict(_gfgce.PdfObject)
	if !_gdbcb {
		return _gcd.New("\u0070\u0061\u0067e \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0068o\u0075l\u0064 \u0062e\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079")
	}
	_gabbd, _gdbcb := _agf.GetName(_dfdbcg.Get("\u0054\u0079\u0070\u0065"))
	if !_gdbcb {
		return _b.Errorf("\u0070\u0061\u0067\u0065\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0068\u0061\u0076\u0065\u0020\u0061\u0020\u0054y\u0070\u0065\u0020\u006b\u0065\u0079\u0020\u0077\u0069t\u0068\u0020\u0061\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u006f\u0066\u0020t\u0079\u0070\u0065\u0020\u006e\u0061m\u0065\u0020\u0028%\u0054\u0029", _dfdbcg.Get("\u0054\u0079\u0070\u0065"))
	}
	if _gabbd.String() != "\u0050\u0061\u0067\u0065" {
		return _gcd.New("\u0066\u0069e\u006c\u0064\u0020\u0054\u0079\u0070\u0065\u0020\u0021\u003d\u0020\u0050\u0061\u0067\u0065\u0020\u0028\u0052\u0065\u0071\u0075\u0069re\u0064\u0029")
	}
	_bbafdc := []_agf.PdfObjectName{"\u0052e\u0073\u006f\u0075\u0072\u0063\u0065s", "\u004d\u0065\u0064\u0069\u0061\u0042\u006f\u0078", "\u0043r\u006f\u0070\u0042\u006f\u0078", "\u0052\u006f\u0074\u0061\u0074\u0065"}
	_accc, _fageb := _agf.GetIndirect(_dfdbcg.Get("\u0050\u0061\u0072\u0065\u006e\u0074"))
	_fd.Log.Trace("P\u0061g\u0065\u0020\u0050\u0061\u0072\u0065\u006e\u0074:\u0020\u0025\u0054\u0020(%\u0076\u0029", _dfdbcg.Get("\u0050\u0061\u0072\u0065\u006e\u0074"), _fageb)
	for _fageb {
		_fd.Log.Trace("\u0050a\u0067e\u0020\u0050\u0061\u0072\u0065\u006e\u0074\u003a\u0020\u0025\u0054", _accc)
		_cgdbc, _fabfe := _agf.GetDict(_accc.PdfObject)
		if !_fabfe {
			return _gcd.New("i\u006e\u0076\u0061\u006cid\u0020P\u0061\u0072\u0065\u006e\u0074 \u006f\u0062\u006a\u0065\u0063\u0074")
		}
		for _, _fabde := range _bbafdc {
			_fd.Log.Trace("\u0046\u0069\u0065\u006c\u0064\u0020\u0025\u0073", _fabde)
			if _dfdbcg.Get(_fabde) != nil {
				_fd.Log.Trace("\u002d \u0070a\u0067\u0065\u0020\u0068\u0061s\u0020\u0061l\u0072\u0065\u0061\u0064\u0079")
				continue
			}
			if _ffbcc := _cgdbc.Get(_fabde); _ffbcc != nil {
				_fd.Log.Trace("\u0049\u006e\u0068\u0065ri\u0074\u0069\u006e\u0067\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0025\u0073", _fabde)
				_dfdbcg.Set(_fabde, _ffbcc)
			}
		}
		_accc, _fageb = _agf.GetIndirect(_cgdbc.Get("\u0050\u0061\u0072\u0065\u006e\u0074"))
		_fd.Log.Trace("\u004ee\u0078t\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u003a\u0020\u0025\u0054", _cgdbc.Get("\u0050\u0061\u0072\u0065\u006e\u0074"))
	}
	_fd.Log.Trace("\u0054\u0072\u0061\u0076\u0065\u0072\u0073\u0061\u006c \u0064\u006f\u006e\u0065")
	_dfdbcg.Set("\u0050\u0061\u0072\u0065\u006e\u0074", _beegdb._dgbbfe)
	_gfgce.PdfObject = _dfdbcg
	_begcb, _gdbcb := _agf.GetDict(_beegdb._dgbbfe.PdfObject)
	if !_gdbcb {
		return _gcd.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0061g\u0065\u0073\u0020\u006f\u0062\u006a\u0020(\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0029")
	}
	_gdgab, _gdbcb := _agf.GetArray(_begcb.Get("\u004b\u0069\u0064\u0073"))
	if !_gdbcb {
		return _gcd.New("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0050\u0061g\u0065\u0073\u0020\u004b\u0069\u0064\u0073\u0020o\u0062\u006a\u0020\u0028\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072\u0061\u0079\u0029")
	}
	_gdgab.Append(_gfgce)
	_beegdb._adec[_dfdbcg] = struct{}{}
	_gcbgd, _gdbcb := _agf.GetInt(_begcb.Get("\u0043\u006f\u0075n\u0074"))
	if !_gdbcb {
		return _gcd.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064 \u0050\u0061\u0067e\u0073\u0020\u0043\u006fu\u006e\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0028\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0029")
	}
	*_gcbgd = *_gcbgd + 1
	if page._ecae == nil {
		_ebaad := _ede.Track(_beegdb._adaaa, _cefbb)
		if _ebaad != nil {
			return _ebaad
		}
	} else {
		_dgegf := _ede.Track(page._ecae._gdfb, _cefbb)
		if _dgegf != nil {
			return _dgegf
		}
	}
	_beegdb.addObject(_gfgce)
	_becb := _beegdb.addObjects(_dfdbcg)
	if _becb != nil {
		return _becb
	}
	return nil
}

// ToPdfObject returns a stream object.
func (_cebeg *XObjectForm) ToPdfObject() _agf.PdfObject {
	_bgfbb := _cebeg._dfeac
	_bggec := _bgfbb.PdfObjectDictionary
	if _cebeg.Filter != nil {
		_bggec = _cebeg.Filter.MakeStreamDict()
		_bgfbb.PdfObjectDictionary = _bggec
	}
	_bggec.Set("\u0054\u0079\u0070\u0065", _agf.MakeName("\u0058O\u0062\u006a\u0065\u0063\u0074"))
	_bggec.Set("\u0053u\u0062\u0074\u0079\u0070\u0065", _agf.MakeName("\u0046\u006f\u0072\u006d"))
	_bggec.SetIfNotNil("\u0046\u006f\u0072\u006d\u0054\u0079\u0070\u0065", _cebeg.FormType)
	_bggec.SetIfNotNil("\u0042\u0042\u006f\u0078", _cebeg.BBox)
	_bggec.SetIfNotNil("\u004d\u0061\u0074\u0072\u0069\u0078", _cebeg.Matrix)
	if _cebeg.Resources != nil {
		_bggec.SetIfNotNil("\u0052e\u0073\u006f\u0075\u0072\u0063\u0065s", _cebeg.Resources.ToPdfObject())
	}
	_bggec.SetIfNotNil("\u0047\u0072\u006fu\u0070", _cebeg.Group)
	_bggec.SetIfNotNil("\u0052\u0065\u0066", _cebeg.Ref)
	_bggec.SetIfNotNil("\u004d\u0065\u0074\u0061\u0044\u0061\u0074\u0061", _cebeg.MetaData)
	_bggec.SetIfNotNil("\u0050i\u0065\u0063\u0065\u0049\u006e\u0066o", _cebeg.PieceInfo)
	_bggec.SetIfNotNil("\u004c\u0061\u0073t\u004d\u006f\u0064\u0069\u0066\u0069\u0065\u0064", _cebeg.LastModified)
	_bggec.SetIfNotNil("\u0053\u0074\u0072u\u0063\u0074\u0050\u0061\u0072\u0065\u006e\u0074", _cebeg.StructParent)
	_bggec.SetIfNotNil("\u0053\u0074\u0072\u0075\u0063\u0074\u0050\u0061\u0072\u0065\u006e\u0074\u0073", _cebeg.StructParents)
	_bggec.SetIfNotNil("\u004f\u0050\u0049", _cebeg.OPI)
	_bggec.SetIfNotNil("\u004f\u0043", _cebeg.OC)
	_bggec.SetIfNotNil("\u004e\u0061\u006d\u0065", _cebeg.Name)
	_bggec.Set("\u004c\u0065\u006e\u0067\u0074\u0068", _agf.MakeInteger(int64(len(_cebeg.Stream))))
	_bgfbb.Stream = _cebeg.Stream
	return _bgfbb
}

// IsValid checks if the given pdf output intent type is valid.
func (_gbcag PdfOutputIntentType) IsValid() bool {
	return _gbcag >= PdfOutputIntentTypeA1 && _gbcag <= PdfOutputIntentTypeX
}

// SetCatalogMetadata sets the catalog metadata (XMP) stream object.
func (_decec *PdfWriter) SetCatalogMetadata(meta _agf.PdfObject) error {
	if meta == nil {
		_decec._bagbb.Remove("\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061")
		return nil
	}
	_baec, _ffecc := _agf.GetStream(meta)
	if !_ffecc {
		return _gcd.New("\u0063\u0061\u0074\u0061\u006c\u006f\u0067\u0020\u006d\u0065\u0074\u0061\u0064a\u0074\u0061\u0020\u006d\u0075\u0073t\u0020\u0062\u0065\u0020\u0061\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0073t\u0072\u0065\u0061\u006d")
	}
	_decec.addObject(_baec)
	_decec._bagbb.Set("\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061", _baec)
	return nil
}

// ToPdfObject returns a stream object.
func (_gffab *XObjectImage) ToPdfObject() _agf.PdfObject {
	_gabcf := _gffab._gdggg
	_ecbgb := _gabcf.PdfObjectDictionary
	if _gffab.Filter != nil {
		_ecbgb = _gffab.Filter.MakeStreamDict()
		_gabcf.PdfObjectDictionary = _ecbgb
	}
	_ecbgb.Set("\u0054\u0079\u0070\u0065", _agf.MakeName("\u0058O\u0062\u006a\u0065\u0063\u0074"))
	_ecbgb.Set("\u0053u\u0062\u0074\u0079\u0070\u0065", _agf.MakeName("\u0049\u006d\u0061g\u0065"))
	_ecbgb.Set("\u0057\u0069\u0064t\u0068", _agf.MakeInteger(*(_gffab.Width)))
	_ecbgb.Set("\u0048\u0065\u0069\u0067\u0068\u0074", _agf.MakeInteger(*(_gffab.Height)))
	if _gffab.BitsPerComponent != nil {
		_ecbgb.Set("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074", _agf.MakeInteger(*(_gffab.BitsPerComponent)))
	}
	if _gffab.ColorSpace != nil {
		_ecbgb.SetIfNotNil("\u0043\u006f\u006c\u006f\u0072\u0053\u0070\u0061\u0063\u0065", _gffab.ColorSpace.ToPdfObject())
	}
	_ecbgb.SetIfNotNil("\u0049\u006e\u0074\u0065\u006e\u0074", _gffab.Intent)
	_ecbgb.SetIfNotNil("\u0049m\u0061\u0067\u0065\u004d\u0061\u0073k", _gffab.ImageMask)
	_ecbgb.SetIfNotNil("\u004d\u0061\u0073\u006b", _gffab.Mask)
	_cebca := _ecbgb.Get("\u0044\u0065\u0063\u006f\u0064\u0065") != nil
	if _gffab.Decode == nil && _cebca {
		_ecbgb.Remove("\u0044\u0065\u0063\u006f\u0064\u0065")
	} else if _gffab.Decode != nil {
		_ecbgb.Set("\u0044\u0065\u0063\u006f\u0064\u0065", _gffab.Decode)
	}
	_ecbgb.SetIfNotNil("I\u006e\u0074\u0065\u0072\u0070\u006f\u006c\u0061\u0074\u0065", _gffab.Interpolate)
	_ecbgb.SetIfNotNil("\u0041\u006c\u0074e\u0072\u006e\u0061\u0074\u0069\u0076\u0065\u0073", _gffab.Alternatives)
	_ecbgb.SetIfNotNil("\u0053\u004d\u0061s\u006b", _gffab.SMask)
	_ecbgb.SetIfNotNil("S\u004d\u0061\u0073\u006b\u0049\u006e\u0044\u0061\u0074\u0061", _gffab.SMaskInData)
	_ecbgb.SetIfNotNil("\u004d\u0061\u0074t\u0065", _gffab.Matte)
	_ecbgb.SetIfNotNil("\u004e\u0061\u006d\u0065", _gffab.Name)
	_ecbgb.SetIfNotNil("\u0053\u0074\u0072u\u0063\u0074\u0050\u0061\u0072\u0065\u006e\u0074", _gffab.StructParent)
	_ecbgb.SetIfNotNil("\u0049\u0044", _gffab.ID)
	_ecbgb.SetIfNotNil("\u004f\u0050\u0049", _gffab.OPI)
	_ecbgb.SetIfNotNil("\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061", _gffab.Metadata)
	_ecbgb.SetIfNotNil("\u004f\u0043", _gffab.OC)
	_ecbgb.Set("\u004c\u0065\u006e\u0067\u0074\u0068", _agf.MakeInteger(int64(len(_gffab.Stream))))
	_gabcf.Stream = _gffab.Stream
	return _gabcf
}
func _bdd(_fdb _agf.PdfObject) (*PdfFilespec, error) {
	if _fdb == nil {
		return nil, nil
	}
	return NewPdfFilespecFromObj(_fdb)
}

// GetContentStreamWithEncoder returns the pattern cell's content stream and its encoder
func (_cgbfb *PdfTilingPattern) GetContentStreamWithEncoder() ([]byte, _agf.StreamEncoder, error) {
	_aagf, _befge := _cgbfb._efed.(*_agf.PdfObjectStream)
	if !_befge {
		_fd.Log.Debug("\u0054\u0069l\u0069\u006e\u0067\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", _cgbfb._efed)
		return nil, nil, _agf.ErrTypeError
	}
	_gcgef, _eaab := _agf.DecodeStream(_aagf)
	if _eaab != nil {
		_fd.Log.Debug("\u0046\u0061\u0069l\u0065\u0064\u0020\u0064e\u0063\u006f\u0064\u0069\u006e\u0067\u0020s\u0074\u0072\u0065\u0061\u006d\u002c\u0020\u0065\u0072\u0072\u003a\u0020\u0025\u0076", _eaab)
		return nil, nil, _eaab
	}
	_begaf, _eaab := _agf.NewEncoderFromStream(_aagf)
	if _eaab != nil {
		_fd.Log.Debug("F\u0061\u0069\u006c\u0065\u0064\u0020f\u0069\u006e\u0064\u0069\u006e\u0067 \u0064\u0065\u0063\u006f\u0064\u0069\u006eg\u0020\u0065\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020%\u0076", _eaab)
		return nil, nil, _eaab
	}
	return _gcgef, _begaf, nil
}
func (_gff *PdfAppender) updateObjectsDeep(_aefa _agf.PdfObject, _adgf map[_agf.PdfObject]struct{}) {
	if _adgf == nil {
		_adgf = map[_agf.PdfObject]struct{}{}
	}
	if _, _dacd := _adgf[_aefa]; _dacd || _aefa == nil {
		return
	}
	_adgf[_aefa] = struct{}{}
	_dee := _agf.ResolveReferencesDeep(_aefa, _gff._eadd)
	if _dee != nil {
		_fd.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _dee)
	}
	switch _efg := _aefa.(type) {
	case *_agf.PdfIndirectObject:
		switch {
		case _efg.GetParser() == _gff._gdeb._egdga:
			return
		case _efg.GetParser() == _gff.Reader._egdga:
			_feae, _ := _gff._gdeb.GetIndirectObjectByNumber(int(_efg.ObjectNumber))
			_cbed, _edeee := _feae.(*_agf.PdfIndirectObject)
			if _edeee && _cbed != nil {
				if _cbed.PdfObject != _efg.PdfObject && _cbed.PdfObject.WriteString() != _efg.PdfObject.WriteString() {
					_gff.addNewObject(_aefa)
					_gff._agc[_aefa] = _efg.ObjectNumber
				}
			}
		default:
			_gff.addNewObject(_aefa)
		}
		_gff.updateObjectsDeep(_efg.PdfObject, _adgf)
	case *_agf.PdfObjectArray:
		for _, _ageb := range _efg.Elements() {
			_gff.updateObjectsDeep(_ageb, _adgf)
		}
	case *_agf.PdfObjectDictionary:
		for _, _gfaff := range _efg.Keys() {
			_gff.updateObjectsDeep(_efg.Get(_gfaff), _adgf)
		}
	case *_agf.PdfObjectStreams:
		if _efg.GetParser() != _gff._gdeb._egdga {
			for _, _ccbf := range _efg.Elements() {
				_gff.updateObjectsDeep(_ccbf, _adgf)
			}
		}
	case *_agf.PdfObjectStream:
		switch {
		case _efg.GetParser() == _gff._gdeb._egdga:
			return
		case _efg.GetParser() == _gff.Reader._egdga:
			if _cge, _gfea := _gff._gdeb._egdga.LookupByReference(_efg.PdfObjectReference); _gfea == nil {
				var _ggfdc bool
				if _cba, _dafe := _agf.GetStream(_cge); _dafe && _gg.Equal(_cba.Stream, _efg.Stream) {
					_ggfdc = true
				}
				if _abfc, _fgdcdb := _agf.GetDict(_cge); _ggfdc && _fgdcdb {
					_ggfdc = _abfc.WriteString() == _efg.PdfObjectDictionary.WriteString()
				}
				if _ggfdc {
					return
				}
			}
			if _efg.ObjectNumber != 0 {
				_gff._agc[_aefa] = _efg.ObjectNumber
			}
		default:
			if _, _gccbc := _gff._gacd[_aefa]; !_gccbc {
				_gff.addNewObject(_aefa)
			}
		}
		_gff.updateObjectsDeep(_efg.PdfObjectDictionary, _adgf)
	}
}

// ToPdfObject recursively builds the Outline tree PDF object.
func (_afee *PdfOutlineItem) ToPdfObject() _agf.PdfObject {
	_cfgbe := _afee._dbac
	_bgffc := _cfgbe.PdfObject.(*_agf.PdfObjectDictionary)
	_bgffc.Set("\u0054\u0069\u0074l\u0065", _afee.Title)
	if _afee.A != nil {
		_bgffc.Set("\u0041", _afee.A)
	}
	if _dfgff := _bgffc.Get("\u0053\u0045"); _dfgff != nil {
		_bgffc.Remove("\u0053\u0045")
	}
	if _afee.C != nil {
		_bgffc.Set("\u0043", _afee.C)
	}
	if _afee.Dest != nil {
		_bgffc.Set("\u0044\u0065\u0073\u0074", _afee.Dest)
	}
	if _afee.F != nil {
		_bgffc.Set("\u0046", _afee.F)
	}
	if _afee.Count != nil {
		_bgffc.Set("\u0043\u006f\u0075n\u0074", _agf.MakeInteger(*_afee.Count))
	}
	if _afee.Next != nil {
		_bgffc.Set("\u004e\u0065\u0078\u0074", _afee.Next.ToPdfObject())
	}
	if _afee.First != nil {
		_bgffc.Set("\u0046\u0069\u0072s\u0074", _afee.First.ToPdfObject())
	}
	if _afee.Prev != nil {
		_bgffc.Set("\u0050\u0072\u0065\u0076", _afee.Prev.GetContext().GetContainingPdfObject())
	}
	if _afee.Last != nil {
		_bgffc.Set("\u004c\u0061\u0073\u0074", _afee.Last.GetContext().GetContainingPdfObject())
	}
	if _afee.Parent != nil {
		_bgffc.Set("\u0050\u0061\u0072\u0065\u006e\u0074", _afee.Parent.GetContext().GetContainingPdfObject())
	}
	return _cfgbe
}

// PdfAnnotationFileAttachment represents FileAttachment annotations.
// (Section 12.5.6.15).
type PdfAnnotationFileAttachment struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	FS   _agf.PdfObject
	Name _agf.PdfObject
}

// GetStandardApplier gets currently used StandardApplier..
func (_bfbfa *PdfWriter) GetStandardApplier() StandardApplier { return _bfbfa._fdfce }

// ColorAt returns the color of the image pixel specified by the x and y coordinates.
func (_fgdb *Image) ColorAt(x, y int) (_ab.Color, error) {
	_feac := _ged.BytesPerLine(int(_fgdb.Width), int(_fgdb.BitsPerComponent), _fgdb.ColorComponents)
	switch _fgdb.ColorComponents {
	case 1:
		return _ged.ColorAtGrayscale(x, y, int(_fgdb.BitsPerComponent), _feac, _fgdb.Data, _fgdb._abacg)
	case 3:
		return _ged.ColorAtNRGBA(x, y, int(_fgdb.Width), _feac, int(_fgdb.BitsPerComponent), _fgdb.Data, _fgdb._gdga, _fgdb._abacg)
	case 4:
		return _ged.ColorAtCMYK(x, y, int(_fgdb.Width), _fgdb.Data, _fgdb._abacg)
	}
	_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 i\u006da\u0067\u0065\u002e\u0020\u0025\u0064\u0020\u0063\u006f\u006d\u0070\u006fn\u0065\u006e\u0074\u0073\u002c\u0020\u0025\u0064\u0020\u0062\u0069\u0074\u0073\u0020\u0070\u0065\u0072 \u0063\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074", _fgdb.ColorComponents, _fgdb.BitsPerComponent)
	return nil, _gcd.New("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0069\u006d\u0061g\u0065 \u0063\u006f\u006c\u006f\u0072\u0073\u0070a\u0063\u0065")
}

// PdfAnnotationRichMedia represents Rich Media annotations.
type PdfAnnotationRichMedia struct {
	*PdfAnnotation
	RichMediaSettings _agf.PdfObject
	RichMediaContent  _agf.PdfObject
}

// AddContentStreamByString adds content stream by string. Puts the content
// string into a stream object and points the content stream towards it.
func (_caged *PdfPage) AddContentStreamByString(contentStr string) error {
	_ggdgb, _bbbfc := _agf.MakeStream([]byte(contentStr), _agf.NewFlateEncoder())
	if _bbbfc != nil {
		return _bbbfc
	}
	if _caged.Contents == nil {
		_caged.Contents = _ggdgb
	} else {
		_bcgff := _agf.TraceToDirectObject(_caged.Contents)
		_aaabba, _bbddd := _bcgff.(*_agf.PdfObjectArray)
		if !_bbddd {
			_aaabba = _agf.MakeArray(_bcgff)
		}
		_aaabba.Append(_ggdgb)
		_caged.Contents = _aaabba
	}
	return nil
}

// ToPdfObject implements interface PdfModel.
func (_gbeb *PdfAnnotationSquare) ToPdfObject() _agf.PdfObject {
	_gbeb.PdfAnnotation.ToPdfObject()
	_ddfe := _gbeb._aeee
	_agad := _ddfe.PdfObject.(*_agf.PdfObjectDictionary)
	if _gbeb.PdfAnnotationMarkup != nil {
		_gbeb.PdfAnnotationMarkup.appendToPdfDictionary(_agad)
	}
	_agad.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _agf.MakeName("\u0053\u0071\u0075\u0061\u0072\u0065"))
	_agad.SetIfNotNil("\u0042\u0053", _gbeb.BS)
	_agad.SetIfNotNil("\u0049\u0043", _gbeb.IC)
	_agad.SetIfNotNil("\u0042\u0045", _gbeb.BE)
	_agad.SetIfNotNil("\u0052\u0044", _gbeb.RD)
	return _ddfe
}

// RunesToCharcodeBytes maps the provided runes to charcode bytes and it
// returns the resulting slice of bytes, along with the number of runes which
// could not be converted. If the number of misses is 0, all runes were
// successfully converted.
func (_gedaf *PdfFont) RunesToCharcodeBytes(data []rune) ([]byte, int) {
	var _bgdda []_fcg.TextEncoder
	var _fafd _fcg.CMapEncoder
	if _faff := _gedaf.baseFields()._egfbf; _faff != nil {
		_fafd = _fcg.NewCMapEncoder("", nil, _faff)
	}
	_cgbc := _gedaf.Encoder()
	if _cgbc != nil {
		switch _aggee := _cgbc.(type) {
		case _fcg.SimpleEncoder:
			_fcae := _aggee.BaseName()
			if _, _ecag := _eddb[_fcae]; _ecag {
				_bgdda = append(_bgdda, _cgbc)
			}
		}
	}
	if len(_bgdda) == 0 {
		if _gedaf.baseFields()._egfbf != nil {
			_bgdda = append(_bgdda, _fafd)
		}
		if _cgbc != nil {
			_bgdda = append(_bgdda, _cgbc)
		}
	}
	var _ecadd _gg.Buffer
	var _fgee int
	for _, _bdbg := range data {
		var _ffbb bool
		for _, _fefc := range _bgdda {
			if _bdde := _fefc.Encode(string(_bdbg)); len(_bdde) > 0 {
				_ecadd.Write(_bdde)
				_ffbb = true
				break
			}
		}
		if !_ffbb {
			_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020f\u0061\u0069\u006ce\u0064\u0020\u0074\u006f \u006d\u0061\u0070\u0020\u0072\u0075\u006e\u0065\u0020\u0060\u0025\u002b\u0071\u0060\u0020\u0074\u006f\u0020\u0063\u0068\u0061\u0072\u0063\u006f\u0064\u0065", _bdbg)
			_fgee++
		}
	}
	if _fgee != 0 {
		_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0020\u0061\u006cl\u0020\u0072\u0075\u006e\u0065\u0073\u0020\u0074\u006f\u0020\u0063\u0068\u0061\u0072c\u006fd\u0065\u0073\u002e\u000a"+"\u0009\u006e\u0075\u006d\u0052\u0075\u006e\u0065\u0073\u003d\u0025d\u0020\u006e\u0075\u006d\u004d\u0069\u0073\u0073\u0065\u0073=\u0025\u0064\u000a"+"\t\u0066\u006f\u006e\u0074=%\u0073 \u0065\u006e\u0063\u006f\u0064e\u0072\u0073\u003d\u0025\u002b\u0076", len(data), _fgee, _gedaf, _bgdda)
	}
	return _ecadd.Bytes(), _fgee
}
func (_effgg *pdfCIDFontType0) getFontDescriptor() *PdfFontDescriptor { return _effgg._dcfcb }

// ToPdfObject returns the PDF representation of the shading dictionary.
func (_fggg *PdfShadingType7) ToPdfObject() _agf.PdfObject {
	_fggg.PdfShading.ToPdfObject()
	_ccdc, _dfgad := _fggg.getShadingDict()
	if _dfgad != nil {
		_fd.Log.Error("\u0055\u006ea\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0061\u0063\u0063\u0065\u0073\u0073\u0020\u0073\u0068\u0061\u0064\u0069\u006e\u0067\u0020di\u0063\u0074")
		return nil
	}
	if _fggg.BitsPerCoordinate != nil {
		_ccdc.Set("\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006f\u0072\u0064i\u006e\u0061\u0074\u0065", _fggg.BitsPerCoordinate)
	}
	if _fggg.BitsPerComponent != nil {
		_ccdc.Set("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074", _fggg.BitsPerComponent)
	}
	if _fggg.BitsPerFlag != nil {
		_ccdc.Set("B\u0069\u0074\u0073\u0050\u0065\u0072\u0046\u006c\u0061\u0067", _fggg.BitsPerFlag)
	}
	if _fggg.Decode != nil {
		_ccdc.Set("\u0044\u0065\u0063\u006f\u0064\u0065", _fggg.Decode)
	}
	if _fggg.Function != nil {
		if len(_fggg.Function) == 1 {
			_ccdc.Set("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e", _fggg.Function[0].ToPdfObject())
		} else {
			_ebbdd := _agf.MakeArray()
			for _, _cfgfde := range _fggg.Function {
				_ebbdd.Append(_cfgfde.ToPdfObject())
			}
			_ccdc.Set("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e", _ebbdd)
		}
	}
	return _fggg._ggbge
}

// WriteString outputs the object as it is to be written to file.
func (_ddgbc *PdfTransformParamsDocMDP) WriteString() string {
	return _ddgbc.ToPdfObject().WriteString()
}

// GetCharMetrics returns the char metrics for character code `code`.
func (_fdcd pdfCIDFontType0) GetCharMetrics(code _fcg.CharCode) (_aa.CharMetrics, bool) {
	_dafbf := _fdcd._efcec
	if _eagagf, _bggc := _fdcd._gdgga[code]; _bggc {
		_dafbf = _eagagf
	}
	return _aa.CharMetrics{Wx: _dafbf}, true
}
func (_cggd *Image) samplesTrimPadding(_dbegb []uint32) []uint32 {
	_eddc := _cggd.ColorComponents * int(_cggd.Width) * int(_cggd.Height)
	if len(_dbegb) == _eddc {
		return _dbegb
	}
	_cddb := make([]uint32, _eddc)
	_fgaf := int(_cggd.Width) * _cggd.ColorComponents
	var _aaea, _bfcag, _dadce, _gdefga int
	_aeecb := _ged.BytesPerLine(int(_cggd.Width), int(_cggd.BitsPerComponent), _cggd.ColorComponents)
	for _aaea = 0; _aaea < int(_cggd.Height); _aaea++ {
		_bfcag = _aaea * int(_cggd.Width)
		_dadce = _aaea * _aeecb
		for _gdefga = 0; _gdefga < _fgaf; _gdefga++ {
			_cddb[_bfcag+_gdefga] = _dbegb[_dadce+_gdefga]
		}
	}
	return _cddb
}
func (_ebbc *PdfWriter) writeAcroFormFields() error {
	if _ebbc._eafgd == nil {
		return nil
	}
	_fd.Log.Trace("\u0057r\u0069t\u0069\u006e\u0067\u0020\u0061c\u0072\u006f \u0066\u006f\u0072\u006d\u0073")
	_fgbgba := _ebbc._eafgd.ToPdfObject()
	_fd.Log.Trace("\u0041\u0063\u0072\u006f\u0046\u006f\u0072\u006d\u003a\u0020\u0025\u002b\u0076", _fgbgba)
	_ebbc._bagbb.Set("\u0041\u0063\u0072\u006f\u0046\u006f\u0072\u006d", _fgbgba)
	_gdgd := _ebbc.addObjects(_fgbgba)
	if _gdgd != nil {
		return _gdgd
	}
	return nil
}

// NewPdfInfoFromObject creates a new PdfInfo from the input core.PdfObject.
func NewPdfInfoFromObject(obj _agf.PdfObject) (*PdfInfo, error) {
	var _eedf PdfInfo
	_ababd, _aabe := obj.(*_agf.PdfObjectDictionary)
	if !_aabe {
		return nil, _b.Errorf("i\u006e\u0076\u0061\u006c\u0069\u0064 \u0070\u0064\u0066\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0074\u0079p\u0065:\u0020\u0025\u0054", obj)
	}
	for _, _gdad := range _ababd.Keys() {
		switch _gdad {
		case "\u0054\u0069\u0074l\u0065":
			_eedf.Title, _ = _agf.GetString(_ababd.Get("\u0054\u0069\u0074l\u0065"))
		case "\u0041\u0075\u0074\u0068\u006f\u0072":
			_eedf.Author, _ = _agf.GetString(_ababd.Get("\u0041\u0075\u0074\u0068\u006f\u0072"))
		case "\u0053u\u0062\u006a\u0065\u0063\u0074":
			_eedf.Subject, _ = _agf.GetString(_ababd.Get("\u0053u\u0062\u006a\u0065\u0063\u0074"))
		case "\u004b\u0065\u0079\u0077\u006f\u0072\u0064\u0073":
			_eedf.Keywords, _ = _agf.GetString(_ababd.Get("\u004b\u0065\u0079\u0077\u006f\u0072\u0064\u0073"))
		case "\u0043r\u0065\u0061\u0074\u006f\u0072":
			_eedf.Creator, _ = _agf.GetString(_ababd.Get("\u0043r\u0065\u0061\u0074\u006f\u0072"))
		case "\u0050\u0072\u006f\u0064\u0075\u0063\u0065\u0072":
			_eedf.Producer, _ = _agf.GetString(_ababd.Get("\u0050\u0072\u006f\u0064\u0075\u0063\u0065\u0072"))
		case "\u0054r\u0061\u0070\u0070\u0065\u0064":
			_eedf.Trapped, _ = _agf.GetName(_ababd.Get("\u0054r\u0061\u0070\u0070\u0065\u0064"))
		case "\u0043\u0072\u0065a\u0074\u0069\u006f\u006e\u0044\u0061\u0074\u0065":
			if _fgda, _dagd := _agf.GetString(_ababd.Get("\u0043\u0072\u0065a\u0074\u0069\u006f\u006e\u0044\u0061\u0074\u0065")); _dagd && _fgda.String() != "" {
				_gefe, _cfab := NewPdfDate(_fgda.String())
				if _cfab != nil {
					return nil, _b.Errorf("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0043\u0072e\u0061\u0074\u0069\u006f\u006e\u0044\u0061t\u0065\u0020\u0066\u0069\u0065\u006c\u0064\u003a\u0020\u0025\u0077", _cfab)
				}
				_eedf.CreationDate = &_gefe
			}
		case "\u004do\u0064\u0044\u0061\u0074\u0065":
			if _afaefe, _cbbdd := _agf.GetString(_ababd.Get("\u004do\u0064\u0044\u0061\u0074\u0065")); _cbbdd && _afaefe.String() != "" {
				_degd, _fabe := NewPdfDate(_afaefe.String())
				if _fabe != nil {
					return nil, _b.Errorf("\u0069n\u0076\u0061\u006c\u0069d\u0020\u004d\u006f\u0064\u0044a\u0074e\u0020f\u0069\u0065\u006c\u0064\u003a\u0020\u0025w", _fabe)
				}
				_eedf.ModifiedDate = &_degd
			}
		default:
			_bege, _ := _agf.GetString(_ababd.Get(_gdad))
			if _eedf._adfbb == nil {
				_eedf._adfbb = _agf.MakeDict()
			}
			_eedf._adfbb.Set(_gdad, _bege)
		}
	}
	return &_eedf, nil
}

// NewLTV returns a new LTV client.
func NewLTV(appender *PdfAppender) (*LTV, error) {
	_fabee := appender.Reader.DSS
	if _fabee == nil {
		_fabee = NewDSS()
	}
	if _bfab := _fabee.generateHashMaps(); _bfab != nil {
		return nil, _bfab
	}
	return &LTV{CertClient: _aaa.NewCertClient(), OCSPClient: _aaa.NewOCSPClient(), CRLClient: _aaa.NewCRLClient(), SkipExisting: true, _daebc: appender, _cbbe: _fabee}, nil
}

// NewPdfAppender creates a new Pdf appender from a Pdf reader.
func NewPdfAppender(reader *PdfReader) (*PdfAppender, error) {
	_ebff := &PdfAppender{_dcac: reader._bggga, Reader: reader, _dafc: reader._egdga, _eadd: reader._eggbg}
	_baf, _fgdcd := _ebff._dcac.Seek(0, _cf.SeekEnd)
	if _fgdcd != nil {
		return nil, _fgdcd
	}
	_ebff._cdf = _baf
	if _, _fgdcd = _ebff._dcac.Seek(0, _cf.SeekStart); _fgdcd != nil {
		return nil, _fgdcd
	}
	_ebff._gdeb, _fgdcd = NewPdfReader(_ebff._dcac)
	if _fgdcd != nil {
		return nil, _fgdcd
	}
	for _, _egdf := range _ebff.Reader.GetObjectNums() {
		if _ebff._bada < _egdf {
			_ebff._bada = _egdf
		}
	}
	_ebff._dafg = _ebff._dafc.GetXrefTable()
	_ebff._aede = _ebff._dafc.GetXrefOffset()
	_ebff._dfaf = append(_ebff._dfaf, _ebff._gdeb.PageList...)
	_ebff._gacd = make(map[_agf.PdfObject]struct{})
	_ebff._agc = make(map[_agf.PdfObject]int64)
	_ebff._abca = make(map[_agf.PdfObject]struct{})
	_ebff._edcb = _ebff._gdeb.AcroForm
	_ebff._caae = _ebff._gdeb.DSS
	return _ebff, nil
}

// ToPdfObject implements interface PdfModel.
func (_dfbd *PdfActionImportData) ToPdfObject() _agf.PdfObject {
	_dfbd.PdfAction.ToPdfObject()
	_fac := _dfbd._caf
	_ebd := _fac.PdfObject.(*_agf.PdfObjectDictionary)
	_ebd.SetIfNotNil("\u0053", _agf.MakeName(string(ActionTypeImportData)))
	if _dfbd.F != nil {
		_ebd.Set("\u0046", _dfbd.F.ToPdfObject())
	}
	return _fac
}

// IsColored specifies if the pattern is colored.
func (_egece *PdfTilingPattern) IsColored() bool {
	if _egece.PaintType != nil && *_egece.PaintType == 1 {
		return true
	}
	return false
}

// ToPdfObject implements interface PdfModel.
func (_ccf *PdfActionRendition) ToPdfObject() _agf.PdfObject {
	_ccf.PdfAction.ToPdfObject()
	_cfe := _ccf._caf
	_ee := _cfe.PdfObject.(*_agf.PdfObjectDictionary)
	_ee.SetIfNotNil("\u0053", _agf.MakeName(string(ActionTypeRendition)))
	_ee.SetIfNotNil("\u0052", _ccf.R)
	_ee.SetIfNotNil("\u0041\u004e", _ccf.AN)
	_ee.SetIfNotNil("\u004f\u0050", _ccf.OP)
	_ee.SetIfNotNil("\u004a\u0053", _ccf.JS)
	return _cfe
}

// NewPdfActionThread returns a new "thread" action.
func NewPdfActionThread() *PdfActionThread {
	_beb := NewPdfAction()
	_abf := &PdfActionThread{}
	_abf.PdfAction = _beb
	_beb.SetContext(_abf)
	return _abf
}

// A returns the value of the A component of the color.
func (_eggf *PdfColorCalRGB) A() float64 { return _eggf[0] }

// PdfAnnotationUnderline represents Underline annotations.
// (Section 12.5.6.10).
type PdfAnnotationUnderline struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	QuadPoints _agf.PdfObject
}

// Decrypt decrypts the PDF file with a specified password.  Also tries to
// decrypt with an empty password.  Returns true if successful,
// false otherwise.
func (_cdea *PdfReader) Decrypt(password []byte) (bool, error) {
	_eceaf, _bdgfc := _cdea._egdga.Decrypt(password)
	if _bdgfc != nil {
		return false, _bdgfc
	}
	if !_eceaf {
		return false, nil
	}
	_bdgfc = _cdea.loadStructure()
	if _bdgfc != nil {
		_fd.Log.Debug("\u0045\u0052\u0052OR\u003a\u0020\u0046\u0061\u0069\u006c\u0020\u0074\u006f \u006co\u0061d\u0020s\u0074\u0072\u0075\u0063\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029", _bdgfc)
		return false, _bdgfc
	}
	return true, nil
}

// ToPdfObject implements interface PdfModel.
func (_egffag *Permissions) ToPdfObject() _agf.PdfObject { return _egffag._gebec }

// ToPdfObject implements interface PdfModel.
func (_edgc *PdfActionGoToR) ToPdfObject() _agf.PdfObject {
	_edgc.PdfAction.ToPdfObject()
	_fgfa := _edgc._caf
	_dce := _fgfa.PdfObject.(*_agf.PdfObjectDictionary)
	_dce.SetIfNotNil("\u0053", _agf.MakeName(string(ActionTypeGoToR)))
	if _edgc.F != nil {
		_dce.Set("\u0046", _edgc.F.ToPdfObject())
	}
	_dce.SetIfNotNil("\u0044", _edgc.D)
	_dce.SetIfNotNil("\u004ee\u0077\u0057\u0069\u006e\u0064\u006fw", _edgc.NewWindow)
	return _fgfa
}

// NewPdfFontFromTTF loads a TTF font and returns a PdfFont type that can be
// used in text styling functions.
// Uses a WinAnsiTextEncoder and loads only character codes 32-255.
// NOTE: For composite fonts such as used in symbolic languages, use NewCompositePdfFontFromTTF.
func NewPdfFontFromTTF(r _cf.ReadSeeker) (*PdfFont, error) {
	const _baeb = _fcg.CharCode(32)
	const _cfdea = _fcg.CharCode(255)
	_fcgb, _dcdec := _gbd.ReadAll(r)
	if _dcdec != nil {
		_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0072\u0065\u0061d\u0020\u0066\u006f\u006e\u0074\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074s\u003a\u0020\u0025\u0076", _dcdec)
		return nil, _dcdec
	}
	_efgf, _dcdec := _aa.TtfParse(_gg.NewReader(_fcgb))
	if _dcdec != nil {
		_fd.Log.Debug("E\u0052\u0052\u004f\u0052\u003a\u0020l\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0054\u0054F\u0020\u0066\u006fn\u0074:\u0020\u0025\u0076", _dcdec)
		return nil, _dcdec
	}
	_ebgga := &pdfFontSimple{_fcad: make(map[_fcg.CharCode]float64), fontCommon: fontCommon{_bcbfd: "\u0054\u0072\u0075\u0065\u0054\u0079\u0070\u0065"}}
	_ebgga._dbgde = _fcg.NewWinAnsiEncoder()
	_ebgga._fccf = _efgf.PostScriptName
	_ebgga.FirstChar = _agf.MakeInteger(int64(_baeb))
	_ebgga.LastChar = _agf.MakeInteger(int64(_cfdea))
	_efbga := 1000.0 / float64(_efgf.UnitsPerEm)
	if len(_efgf.Widths) <= 0 {
		return nil, _gcd.New("\u0045\u0052\u0052O\u0052\u003a\u0020\u004d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065 \u0028\u0057\u0069\u0064\u0074\u0068\u0073\u0029")
	}
	_dfac := _efbga * float64(_efgf.Widths[0])
	_dggfc := make([]float64, 0, _cfdea-_baeb+1)
	for _bgbab := _baeb; _bgbab <= _cfdea; _bgbab++ {
		_egeeb, _bbfa := _ebgga.Encoder().CharcodeToRune(_bgbab)
		if !_bbfa {
			_fd.Log.Debug("\u0052u\u006e\u0065\u0020\u006eo\u0074\u0020\u0066\u006f\u0075n\u0064 \u0028c\u006f\u0064\u0065\u003a\u0020\u0025\u0064)", _bgbab)
			_dggfc = append(_dggfc, _dfac)
			continue
		}
		_acbff, _cgabf := _efgf.Chars[_egeeb]
		if !_cgabf {
			_fd.Log.Debug("R\u0075\u006e\u0065\u0020no\u0074 \u0069\u006e\u0020\u0054\u0054F\u0020\u0043\u0068\u0061\u0072\u0073")
			_dggfc = append(_dggfc, _dfac)
			continue
		}
		_geed := _efbga * float64(_efgf.Widths[_acbff])
		_dggfc = append(_dggfc, _geed)
	}
	_ebgga.Widths = _agf.MakeIndirectObject(_agf.MakeArrayFromFloats(_dggfc))
	if len(_dggfc) < int(_cfdea-_baeb+1) {
		_fd.Log.Debug("E\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u006f\u0066\u0020\u0077\u0069\u0064\u0074\u0068s,\u0020\u0025\u0064 \u003c \u0025\u0064", len(_dggfc), 255-32+1)
		return nil, _agf.ErrRangeError
	}
	for _dgba := _baeb; _dgba <= _cfdea; _dgba++ {
		_ebgga._fcad[_dgba] = _dggfc[_dgba-_baeb]
	}
	_ebgga.Encoding = _agf.MakeName("\u0057i\u006eA\u006e\u0073\u0069\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067")
	_dfdfc := &PdfFontDescriptor{}
	_dfdfc.FontName = _agf.MakeName(_efgf.PostScriptName)
	_dfdfc.Ascent = _agf.MakeFloat(_efbga * float64(_efgf.TypoAscender))
	_dfdfc.Descent = _agf.MakeFloat(_efbga * float64(_efgf.TypoDescender))
	_dfdfc.CapHeight = _agf.MakeFloat(_efbga * float64(_efgf.CapHeight))
	_dfdfc.FontBBox = _agf.MakeArrayFromFloats([]float64{_efbga * float64(_efgf.Xmin), _efbga * float64(_efgf.Ymin), _efbga * float64(_efgf.Xmax), _efbga * float64(_efgf.Ymax)})
	_dfdfc.ItalicAngle = _agf.MakeFloat(_efgf.ItalicAngle)
	_dfdfc.MissingWidth = _agf.MakeFloat(_efbga * float64(_efgf.Widths[0]))
	_edge, _dcdec := _agf.MakeStream(_fcgb, _agf.NewFlateEncoder())
	if _dcdec != nil {
		_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074o\u0020m\u0061\u006b\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u003a\u0020\u0025\u0076", _dcdec)
		return nil, _dcdec
	}
	_edge.PdfObjectDictionary.Set("\u004ce\u006e\u0067\u0074\u0068\u0031", _agf.MakeInteger(int64(len(_fcgb))))
	_dfdfc.FontFile2 = _edge
	if _efgf.Bold {
		_dfdfc.StemV = _agf.MakeInteger(120)
	} else {
		_dfdfc.StemV = _agf.MakeInteger(70)
	}
	_dcfgb := _ccdf
	if _efgf.IsFixedPitch {
		_dcfgb |= _deab
	}
	if _efgf.ItalicAngle != 0 {
		_dcfgb |= _ebfd
	}
	_dfdfc.Flags = _agf.MakeInteger(int64(_dcfgb))
	_ebgga._dcfcb = _dfdfc
	_fdedb := &PdfFont{_effaa: _ebgga}
	return _fdedb, nil
}

// GetRuneMetrics returns the character metrics for the specified rune.
// A bool flag is returned to indicate whether or not the entry was found.
func (_eegg pdfFontType0) GetRuneMetrics(r rune) (_aa.CharMetrics, bool) {
	if _eegg.DescendantFont == nil {
		_fd.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u004e\u006f\u0020\u0064\u0065\u0073\u0063\u0065\u006e\u0064\u0061\u006e\u0074\u002e\u0020\u0066\u006f\u006et=\u0025\u0073", _eegg)
		return _aa.CharMetrics{}, false
	}
	return _eegg.DescendantFont.GetRuneMetrics(r)
}

// Encoder returns the font's text encoder.
func (_bccc *pdfFontSimple) Encoder() _fcg.TextEncoder {
	if _bccc._dbgde != nil {
		return _bccc._dbgde
	}
	if _bccc._eebb != nil {
		return _bccc._eebb
	}
	_aabf, _ := _fcg.NewSimpleTextEncoder("\u0053\u0074a\u006e\u0064\u0061r\u0064\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067", nil)
	return _aabf
}

// ToPdfObject implements interface PdfModel.
func (_gad *PdfActionGoTo) ToPdfObject() _agf.PdfObject {
	_gad.PdfAction.ToPdfObject()
	_gaf := _gad._caf
	_bba := _gaf.PdfObject.(*_agf.PdfObjectDictionary)
	_bba.SetIfNotNil("\u0053", _agf.MakeName(string(ActionTypeGoTo)))
	_bba.SetIfNotNil("\u0044", _gad.D)
	return _gaf
}
func _bcgf(_ddbe _agf.PdfObject) (*PdfColorspaceDeviceN, error) {
	_gfcg := NewPdfColorspaceDeviceN()
	if _aebc, _bccd := _ddbe.(*_agf.PdfIndirectObject); _bccd {
		_gfcg._bddcd = _aebc
	}
	_ddbe = _agf.TraceToDirectObject(_ddbe)
	_baff, _acfce := _ddbe.(*_agf.PdfObjectArray)
	if !_acfce {
		return nil, _b.Errorf("\u0064\u0065\u0076\u0069\u0063\u0065\u004e\u0020\u0043\u0053\u003a \u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006f\u0062j\u0065\u0063\u0074")
	}
	if _baff.Len() != 4 && _baff.Len() != 5 {
		return nil, _b.Errorf("\u0064\u0065\u0076ic\u0065\u004e\u0020\u0043\u0053\u003a\u0020\u0049\u006ec\u006fr\u0072e\u0063t\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u006c\u0065\u006e\u0067\u0074\u0068")
	}
	_ddbe = _baff.Get(0)
	_cgad, _acfce := _ddbe.(*_agf.PdfObjectName)
	if !_acfce {
		return nil, _b.Errorf("\u0064\u0065\u0076i\u0063\u0065\u004e\u0020C\u0053\u003a\u0020\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0066\u0061\u006d\u0069\u006c\u0079\u0020\u006e\u0061\u006d\u0065")
	}
	if *_cgad != "\u0044e\u0076\u0069\u0063\u0065\u004e" {
		return nil, _b.Errorf("\u0064\u0065v\u0069\u0063\u0065\u004e\u0020\u0043\u0053\u003a\u0020\u0077\u0072\u006f\u006e\u0067\u0020\u0066\u0061\u006d\u0069\u006c\u0079\u0020na\u006d\u0065")
	}
	_ddbe = _baff.Get(1)
	_ddbe = _agf.TraceToDirectObject(_ddbe)
	_abd, _acfce := _ddbe.(*_agf.PdfObjectArray)
	if !_acfce {
		return nil, _b.Errorf("\u0064\u0065\u0076i\u0063\u0065\u004e\u0020C\u0053\u003a\u0020\u0049\u006e\u0076\u0061l\u0069\u0064\u0020\u006e\u0061\u006d\u0065\u0073\u0020\u0061\u0072\u0072\u0061\u0079")
	}
	_gfcg.ColorantNames = _abd
	_ddbe = _baff.Get(2)
	_facff, _bgefg := NewPdfColorspaceFromPdfObject(_ddbe)
	if _bgefg != nil {
		return nil, _bgefg
	}
	_gfcg.AlternateSpace = _facff
	_acfcb, _bgefg := _ccedb(_baff.Get(3))
	if _bgefg != nil {
		return nil, _bgefg
	}
	_gfcg.TintTransform = _acfcb
	if _baff.Len() == 5 {
		_dafbc, _gdgc := _ebegf(_baff.Get(4))
		if _gdgc != nil {
			return nil, _gdgc
		}
		_gfcg.Attributes = _dafbc
	}
	return _gfcg, nil
}

// PdfActionLaunch represents a launch action.
type PdfActionLaunch struct {
	*PdfAction
	F         *PdfFilespec
	Win       _agf.PdfObject
	Mac       _agf.PdfObject
	Unix      _agf.PdfObject
	NewWindow _agf.PdfObject
}

// StandardValidator is the interface that is used for the PDF StandardImplementer validation for the PDF document.
// It is using a CompliancePdfReader which is expected to give more Metadata during reading process.
// NOTE: This implementation is in experimental development state.
//
//	Keep in mind that it might change in the subsequent minor versions.
type StandardValidator interface {

	// ValidateStandard checks if the input reader
	ValidateStandard(_cbacc *CompliancePdfReader) error
}

// IsTiling specifies if the pattern is a tiling pattern.
func (_gfegf *PdfPattern) IsTiling() bool { return _gfegf.PatternType == 1 }
func (_gcdeb *PdfPattern) getDict() *_agf.PdfObjectDictionary {
	if _edde, _fagbd := _gcdeb._efed.(*_agf.PdfIndirectObject); _fagbd {
		_gbfag, _egca := _edde.PdfObject.(*_agf.PdfObjectDictionary)
		if !_egca {
			return nil
		}
		return _gbfag
	} else if _gbgbd, _fefbb := _gcdeb._efed.(*_agf.PdfObjectStream); _fefbb {
		return _gbgbd.PdfObjectDictionary
	} else {
		_fd.Log.Debug("\u0054r\u0079\u0069\u006e\u0067\u0020\u0074\u006f a\u0063\u0063\u0065\u0073\u0073\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e\u0020d\u0069\u0063t\u0069\u006f\u006ea\u0072\u0079\u0020\u006f\u0066\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006f\u0062j\u0065\u0063t \u0074\u0079\u0070e\u0020\u0028\u0025\u0054\u0029", _gcdeb._efed)
		return nil
	}
}
func (_fffbc *PdfAnnotationMarkup) appendToPdfDictionary(_befd *_agf.PdfObjectDictionary) {
	_befd.SetIfNotNil("\u0054", _fffbc.T)
	if _fffbc.Popup != nil {
		_befd.Set("\u0050\u006f\u0070u\u0070", _fffbc.Popup.ToPdfObject())
	}
	_befd.SetIfNotNil("\u0043\u0041", _fffbc.CA)
	_befd.SetIfNotNil("\u0052\u0043", _fffbc.RC)
	_befd.SetIfNotNil("\u0043\u0072\u0065a\u0074\u0069\u006f\u006e\u0044\u0061\u0074\u0065", _fffbc.CreationDate)
	_befd.SetIfNotNil("\u0049\u0052\u0054", _fffbc.IRT)
	_befd.SetIfNotNil("\u0053\u0075\u0062\u006a", _fffbc.Subj)
	_befd.SetIfNotNil("\u0052\u0054", _fffbc.RT)
	_befd.SetIfNotNil("\u0049\u0054", _fffbc.IT)
	_befd.SetIfNotNil("\u0045\u0078\u0044\u0061\u0074\u0061", _fffbc.ExData)
}
func (_febd *PdfWriter) addObjects(_ceafa _agf.PdfObject) error {
	_fd.Log.Trace("\u0041d\u0064i\u006e\u0067\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0073\u0021")
	if _ecbfb, _cfgddd := _ceafa.(*_agf.PdfIndirectObject); _cfgddd {
		_fd.Log.Trace("\u0049\u006e\u0064\u0069\u0072\u0065\u0063\u0074")
		_fd.Log.Trace("\u002d \u0025\u0073\u0020\u0028\u0025\u0070)", _ceafa, _ecbfb)
		_fd.Log.Trace("\u002d\u0020\u0025\u0073", _ecbfb.PdfObject)
		if _febd.addObject(_ecbfb) {
			_gadgg := _febd.addObjects(_ecbfb.PdfObject)
			if _gadgg != nil {
				return _gadgg
			}
		}
		return nil
	}
	if _baee, _fggd := _ceafa.(*_agf.PdfObjectStream); _fggd {
		_fd.Log.Trace("\u0053\u0074\u0072\u0065\u0061\u006d")
		_fd.Log.Trace("\u002d \u0025\u0073\u0020\u0025\u0070", _ceafa, _ceafa)
		if _febd.addObject(_baee) {
			_fdee := _febd.addObjects(_baee.PdfObjectDictionary)
			if _fdee != nil {
				return _fdee
			}
		}
		return nil
	}
	if _debd, _abacf := _ceafa.(*_agf.PdfObjectDictionary); _abacf {
		_fd.Log.Trace("\u0044\u0069\u0063\u0074")
		_fd.Log.Trace("\u002d\u0020\u0025\u0073", _ceafa)
		for _, _ddgega := range _debd.Keys() {
			_bfdgf := _debd.Get(_ddgega)
			if _ggfdb, _dfefe := _bfdgf.(*_agf.PdfObjectReference); _dfefe {
				_bfdgf = _ggfdb.Resolve()
				_debd.Set(_ddgega, _bfdgf)
			}
			if _ddgega != "\u0050\u0061\u0072\u0065\u006e\u0074" {
				if _eege := _febd.addObjects(_bfdgf); _eege != nil {
					return _eege
				}
			} else {
				if _, _bbdae := _bfdgf.(*_agf.PdfObjectNull); _bbdae {
					continue
				}
				if _afabf := _febd.hasObject(_bfdgf); !_afabf {
					_fd.Log.Debug("P\u0061\u0072\u0065\u006e\u0074\u0020o\u0062\u006a\u0020\u006e\u006f\u0074 \u0061\u0064\u0064\u0065\u0064\u0020\u0079e\u0074\u0021\u0021\u0020\u0025\u0054\u0020\u0025\u0070\u0020%\u0076", _bfdgf, _bfdgf, _bfdgf)
					_febd._afcfaf[_bfdgf] = append(_febd._afcfaf[_bfdgf], _debd)
				}
			}
		}
		return nil
	}
	if _dcgaed, _afeeg := _ceafa.(*_agf.PdfObjectArray); _afeeg {
		_fd.Log.Trace("\u0041\u0072\u0072a\u0079")
		_fd.Log.Trace("\u002d\u0020\u0025\u0073", _ceafa)
		if _dcgaed == nil {
			return _gcd.New("\u0061\u0072\u0072a\u0079\u0020\u0069\u0073\u0020\u006e\u0069\u006c")
		}
		for _dedbd, _affcd := range _dcgaed.Elements() {
			if _dafaa, _adggd := _affcd.(*_agf.PdfObjectReference); _adggd {
				_affcd = _dafaa.Resolve()
				_dcgaed.Set(_dedbd, _affcd)
			}
			if _fgfeb := _febd.addObjects(_affcd); _fgfeb != nil {
				return _fgfeb
			}
		}
		return nil
	}
	if _, _ccdac := _ceafa.(*_agf.PdfObjectReference); _ccdac {
		_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043\u0061\u006e\u006e\u006f\u0074 \u0062\u0065\u0020\u0061\u0020\u0072e\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u002d\u0020\u0067\u006f\u0074 \u0025\u0023\u0076\u0021", _ceafa)
		return _gcd.New("r\u0065\u0066\u0065\u0072en\u0063e\u0020\u006e\u006f\u0074\u0020a\u006c\u006c\u006f\u0077\u0065\u0064")
	}
	return nil
}

// ToPdfObject returns the PDF representation of the shading dictionary.
func (_egeab *PdfShadingType1) ToPdfObject() _agf.PdfObject {
	_egeab.PdfShading.ToPdfObject()
	_dcebd, _aeffa := _egeab.getShadingDict()
	if _aeffa != nil {
		_fd.Log.Error("\u0055\u006ea\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0061\u0063\u0063\u0065\u0073\u0073\u0020\u0073\u0068\u0061\u0064\u0069\u006e\u0067\u0020di\u0063\u0074")
		return nil
	}
	if _egeab.Domain != nil {
		_dcebd.Set("\u0044\u006f\u006d\u0061\u0069\u006e", _egeab.Domain)
	}
	if _egeab.Matrix != nil {
		_dcebd.Set("\u004d\u0061\u0074\u0072\u0069\u0078", _egeab.Matrix)
	}
	if _egeab.Function != nil {
		if len(_egeab.Function) == 1 {
			_dcebd.Set("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e", _egeab.Function[0].ToPdfObject())
		} else {
			_fcbe := _agf.MakeArray()
			for _, _eebbf := range _egeab.Function {
				_fcbe.Append(_eebbf.ToPdfObject())
			}
			_dcebd.Set("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e", _fcbe)
		}
	}
	return _egeab._ggbge
}

// ImageToRGB convert 1-component grayscale data to 3-component RGB.
func (_fcced *PdfColorspaceDeviceGray) ImageToRGB(img Image) (Image, error) {
	if img.ColorComponents != 1 {
		return img, _gcd.New("\u0074\u0068e \u0070\u0072\u006fv\u0069\u0064\u0065\u0064 im\u0061ge\u0020\u0069\u0073\u0020\u006e\u006f\u0074 g\u0072\u0061\u0079\u0020\u0073\u0063\u0061l\u0065")
	}
	_ecfd, _gffae := _ged.NewImage(int(img.Width), int(img.Height), int(img.BitsPerComponent), img.ColorComponents, img.Data, img._gdga, img._abacg)
	if _gffae != nil {
		return img, _gffae
	}
	_agbab, _gffae := _ged.NRGBAConverter.Convert(_ecfd)
	if _gffae != nil {
		return img, _gffae
	}
	_dfcec := _ddgg(_agbab.Base())
	_fd.Log.Trace("\u0044\u0065\u0076\u0069\u0063\u0065\u0047\u0072\u0061\u0079\u0020\u002d>\u0020\u0052\u0047\u0042")
	_fd.Log.Trace("s\u0061\u006d\u0070\u006c\u0065\u0073\u003a\u0020\u0025\u0076", img.Data)
	_fd.Log.Trace("\u0052G\u0042 \u0073\u0061\u006d\u0070\u006c\u0065\u0073\u003a\u0020\u0025\u0076", _dfcec.Data)
	_fd.Log.Trace("\u0025\u0076\u0020\u002d\u003e\u0020\u0025\u0076", img, _dfcec)
	return _dfcec, nil
}

// GetRevisionNumber returns the version of the current Pdf document
func (_ceeg *PdfReader) GetRevisionNumber() int { return _ceeg._egdga.GetRevisionNumber() }

// GetPrimitiveFromModel returns the primitive object corresponding to the input `model`.
func (_aafec *modelManager) GetPrimitiveFromModel(model PdfModel) _agf.PdfObject {
	_gfcd, _ddcc := _aafec._bggfd[model]
	if !_ddcc {
		return nil
	}
	return _gfcd
}

// NewPdfColorspaceDeviceRGB returns a new RGB colorspace object.
func NewPdfColorspaceDeviceRGB() *PdfColorspaceDeviceRGB { return &PdfColorspaceDeviceRGB{} }

// EncryptionAlgorithm is used in EncryptOptions to change the default algorithm used to encrypt the document.
type EncryptionAlgorithm int

func (_fgg *PdfReader) newPdfActionLaunchFromDict(_edef *_agf.PdfObjectDictionary) (*PdfActionLaunch, error) {
	_ffgc, _fgdc := _bdd(_edef.Get("\u0046"))
	if _fgdc != nil {
		return nil, _fgdc
	}
	return &PdfActionLaunch{Win: _edef.Get("\u0057\u0069\u006e"), Mac: _edef.Get("\u004d\u0061\u0063"), Unix: _edef.Get("\u0055\u006e\u0069\u0078"), NewWindow: _edef.Get("\u004ee\u0077\u0057\u0069\u006e\u0064\u006fw"), F: _ffgc}, nil
}
func (_deac *LTV) validateSig(_cdcff *PdfSignature) error {
	if _cdcff == nil || _cdcff.Contents == nil || len(_cdcff.Contents.Bytes()) == 0 {
		return _b.Errorf("i\u006e\u0076\u0061\u006c\u0069\u0064 \u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065 \u0066\u0069\u0065l\u0064:\u0020\u0025\u0076", _cdcff)
	}
	return nil
}

// GetIndirectObjectByNumber retrieves and returns a specific PdfObject by object number.
func (_gggfd *PdfReader) GetIndirectObjectByNumber(number int) (_agf.PdfObject, error) {
	_bace, _cggcd := _gggfd._egdga.LookupByNumber(number)
	return _bace, _cggcd
}

// ConvertToBinary converts current image into binary (bi-level) format.
// Binary images are composed of single bits per pixel (only black or white).
// If provided image has more color components, then it would be converted into binary image using
// histogram auto threshold function.
func (_ababa *Image) ConvertToBinary() error {
	if _ababa.ColorComponents == 1 && _ababa.BitsPerComponent == 1 {
		return nil
	}
	_egfbd, _egffce := _ababa.ToGoImage()
	if _egffce != nil {
		return _egffce
	}
	_gcab, _egffce := _ged.MonochromeConverter.Convert(_egfbd)
	if _egffce != nil {
		return _egffce
	}
	_ababa.Data = _gcab.Base().Data
	_ababa._gdga, _egffce = _ged.ScaleAlphaToMonochrome(_ababa._gdga, int(_ababa.Width), int(_ababa.Height))
	if _egffce != nil {
		return _egffce
	}
	_ababa.BitsPerComponent = 1
	_ababa.ColorComponents = 1
	_ababa._abacg = nil
	return nil
}

// ToPdfObject returns a PDF object representation of the outline destination.
func (_badff OutlineDest) ToPdfObject() _agf.PdfObject {
	if (_badff.PageObj == nil && _badff.Page < 0) || _badff.Mode == "" {
		return _agf.MakeNull()
	}
	_gdbgg := _agf.MakeArray()
	if _badff.PageObj != nil {
		_gdbgg.Append(_badff.PageObj)
	} else {
		_gdbgg.Append(_agf.MakeInteger(_badff.Page))
	}
	_gdbgg.Append(_agf.MakeName(_badff.Mode))
	switch _badff.Mode {
	case "\u0046\u0069\u0074", "\u0046\u0069\u0074\u0042":
	case "\u0046\u0069\u0074\u0048", "\u0046\u0069\u0074B\u0048":
		_gdbgg.Append(_agf.MakeFloat(_badff.Y))
	case "\u0046\u0069\u0074\u0056", "\u0046\u0069\u0074B\u0056":
		_gdbgg.Append(_agf.MakeFloat(_badff.X))
	case "\u0058\u0059\u005a":
		_gdbgg.Append(_agf.MakeFloat(_badff.X))
		_gdbgg.Append(_agf.MakeFloat(_badff.Y))
		_gdbgg.Append(_agf.MakeFloat(_badff.Zoom))
	default:
		_gdbgg.Set(1, _agf.MakeName("\u0046\u0069\u0074"))
	}
	return _gdbgg
}
func _gcegd(_aacd *fontCommon) *pdfFontType0 { return &pdfFontType0{fontCommon: *_aacd} }
func (_cgca *PdfSignature) extractChainFromCert() ([]*_ed.Certificate, error) {
	var _dedef *_agf.PdfObjectArray
	switch _ggbdf := _cgca.Cert.(type) {
	case *_agf.PdfObjectString:
		_dedef = _agf.MakeArray(_ggbdf)
	case *_agf.PdfObjectArray:
		_dedef = _ggbdf
	default:
		return nil, _b.Errorf("\u0069n\u0076\u0061l\u0069\u0064\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072e\u0020\u0063\u0065\u0072\u0074\u0069f\u0069\u0063\u0061\u0074\u0065\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054", _ggbdf)
	}
	var _ebdbf _gg.Buffer
	for _, _abaa := range _dedef.Elements() {
		_badac, _adabb := _agf.GetString(_abaa)
		if !_adabb {
			return nil, _b.Errorf("\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0065\u0072\u0074\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u0020\u006f\u0062j\u0065\u0063\u0074\u0020\u0074\u0079p\u0065\u0020\u0069\u006e\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065 \u0063\u0065r\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u0063h\u0061\u0069\u006e\u003a\u0020\u0025\u0054", _abaa)
		}
		if _, _dfcbde := _ebdbf.Write(_badac.Bytes()); _dfcbde != nil {
			return nil, _dfcbde
		}
	}
	return _ed.ParseCertificates(_ebdbf.Bytes())
}
func _ddgeg() string { _ecba.Lock(); defer _ecba.Unlock(); return _dedfe }

// ToPdfObject returns the PDF representation of the outline tree node.
func (_gebb *PdfOutlineTreeNode) ToPdfObject() _agf.PdfObject {
	return _gebb.GetContext().ToPdfObject()
}

// RemovePage removes a page by number.
func (_bdec *PdfAppender) RemovePage(pageNum int) {
	_dcfe := pageNum - 1
	_bdec._dfaf = append(_bdec._dfaf[0:_dcfe], _bdec._dfaf[pageNum:]...)
}
func (_abgc *PdfReader) newPdfAnnotationRedactFromDict(_ccfb *_agf.PdfObjectDictionary) (*PdfAnnotationRedact, error) {
	_aacb := PdfAnnotationRedact{}
	_bfgf, _eagfb := _abgc.newPdfAnnotationMarkupFromDict(_ccfb)
	if _eagfb != nil {
		return nil, _eagfb
	}
	_aacb.PdfAnnotationMarkup = _bfgf
	_aacb.QuadPoints = _ccfb.Get("\u0051\u0075\u0061\u0064\u0050\u006f\u0069\u006e\u0074\u0073")
	_aacb.IC = _ccfb.Get("\u0049\u0043")
	_aacb.RO = _ccfb.Get("\u0052\u004f")
	_aacb.OverlayText = _ccfb.Get("O\u0076\u0065\u0072\u006c\u0061\u0079\u0054\u0065\u0078\u0074")
	_aacb.Repeat = _ccfb.Get("\u0052\u0065\u0070\u0065\u0061\u0074")
	_aacb.DA = _ccfb.Get("\u0044\u0041")
	_aacb.Q = _ccfb.Get("\u0051")
	return &_aacb, nil
}
func _dbdfe(_afffe *_agf.PdfObjectDictionary) (*PdfShadingType4, error) {
	_ddeb := PdfShadingType4{}
	_dbead := _afffe.Get("\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006f\u0072\u0064i\u006e\u0061\u0074\u0065")
	if _dbead == nil {
		_fd.Log.Debug("\u0052e\u0071\u0075i\u0072\u0065\u0064 \u0061\u0074\u0074\u0072\u0069\u0062\u0075t\u0065\u0020\u006d\u0069\u0073\u0073i\u006e\u0067\u003a\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072C\u006f\u006f\u0072\u0064\u0069\u006e\u0061\u0074\u0065")
		return nil, ErrRequiredAttributeMissing
	}
	_cfbaf, _afaac := _dbead.(*_agf.PdfObjectInteger)
	if !_afaac {
		_fd.Log.Debug("\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006f\u0072\u0064\u0069\u006e\u0061\u0074\u0065\u0020\u006eo\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", _dbead)
		return nil, _agf.ErrTypeError
	}
	_ddeb.BitsPerCoordinate = _cfbaf
	_dbead = _afffe.Get("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074")
	if _dbead == nil {
		_fd.Log.Debug("\u0052e\u0071\u0075i\u0072\u0065\u0064\u0020a\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u0020\u006d\u0069\u0073\u0073in\u0067\u003a\u0020B\u0069\u0074s\u0050\u0065\u0072\u0043\u006f\u006dp\u006f\u006ee\u006e\u0074")
		return nil, ErrRequiredAttributeMissing
	}
	_cfbaf, _afaac = _dbead.(*_agf.PdfObjectInteger)
	if !_afaac {
		_fd.Log.Debug("B\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065r \u0028\u0067\u006ft\u0020%\u0054\u0029", _dbead)
		return nil, _agf.ErrTypeError
	}
	_ddeb.BitsPerComponent = _cfbaf
	_dbead = _afffe.Get("B\u0069\u0074\u0073\u0050\u0065\u0072\u0046\u006c\u0061\u0067")
	if _dbead == nil {
		_fd.Log.Debug("\u0052\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u0020\u006di\u0073\u0073\u0069\u006e\u0067\u003a\u0020\u0042\u0069\u0074\u0073\u0050\u0065r\u0046\u006c\u0061\u0067")
		return nil, ErrRequiredAttributeMissing
	}
	_cfbaf, _afaac = _dbead.(*_agf.PdfObjectInteger)
	if !_afaac {
		_fd.Log.Debug("B\u0069\u0074\u0073\u0050\u0065\u0072F\u006c\u0061\u0067\u0020\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0074e\u0067\u0065\u0072\u0020\u0028\u0067\u006f\u0074\u0020\u0025T\u0029", _dbead)
		return nil, _agf.ErrTypeError
	}
	_ddeb.BitsPerComponent = _cfbaf
	_dbead = _afffe.Get("\u0044\u0065\u0063\u006f\u0064\u0065")
	if _dbead == nil {
		_fd.Log.Debug("\u0052\u0065\u0071ui\u0072\u0065\u0064\u0020\u0061\u0074\u0074\u0072\u0069b\u0075t\u0065 \u006di\u0073\u0073\u0069\u006e\u0067\u003a\u0020\u0044\u0065\u0063\u006f\u0064\u0065")
		return nil, ErrRequiredAttributeMissing
	}
	_gdggb, _afaac := _dbead.(*_agf.PdfObjectArray)
	if !_afaac {
		_fd.Log.Debug("\u0044\u0065\u0063\u006fd\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072a\u0079\u0020\u0028\u0067\u006f\u0074\u0020%\u0054\u0029", _dbead)
		return nil, _agf.ErrTypeError
	}
	_ddeb.Decode = _gdggb
	_dbead = _afffe.Get("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e")
	if _dbead == nil {
		_fd.Log.Debug("\u0052\u0065q\u0075\u0069\u0072\u0065d\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020m\u0069\u0073\u0073\u0069\u006e\u0067\u003a\u0020\u0020\u0046\u0075\u006ec\u0074\u0069\u006f\u006e")
		return nil, ErrRequiredAttributeMissing
	}
	_ddeb.Function = []PdfFunction{}
	if _gbfgf, _fdgge := _dbead.(*_agf.PdfObjectArray); _fdgge {
		for _, _bbdbf := range _gbfgf.Elements() {
			_dfedg, _cfgcb := _ccedb(_bbdbf)
			if _cfgcb != nil {
				_fd.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e:\u0020\u0025\u0076", _cfgcb)
				return nil, _cfgcb
			}
			_ddeb.Function = append(_ddeb.Function, _dfedg)
		}
	} else {
		_dddcc, _gegdc := _ccedb(_dbead)
		if _gegdc != nil {
			_fd.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e:\u0020\u0025\u0076", _gegdc)
			return nil, _gegdc
		}
		_ddeb.Function = append(_ddeb.Function, _dddcc)
	}
	return &_ddeb, nil
}
func _gefdc(_cfgg _agf.PdfObject) (*PdfFontDescriptor, error) {
	_ebacf := &PdfFontDescriptor{}
	_cfgg = _agf.ResolveReference(_cfgg)
	if _eeabe, _edagb := _cfgg.(*_agf.PdfIndirectObject); _edagb {
		_ebacf._cfgc = _eeabe
		_cfgg = _eeabe.PdfObject
	}
	_fbbe, _dcgd := _agf.GetDict(_cfgg)
	if !_dcgd {
		_fd.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u0046o\u006e\u0074\u0044\u0065\u0073c\u0072\u0069\u0070\u0074\u006f\u0072\u0020\u006e\u006f\u0074\u0020\u0067\u0069\u0076\u0065\u006e\u0020\u0062\u0079\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0054\u0029", _cfgg)
		return nil, _agf.ErrTypeError
	}
	if _edgf := _fbbe.Get("\u0046\u006f\u006e\u0074\u004e\u0061\u006d\u0065"); _edgf != nil {
		_ebacf.FontName = _edgf
	} else {
		_fd.Log.Debug("\u0049n\u0063\u006fm\u0070\u0061\u0074\u0069b\u0069\u006c\u0069t\u0079\u003a\u0020\u0046\u006f\u006e\u0074\u004e\u0061me\u0020\u0028\u0052e\u0071\u0075i\u0072\u0065\u0064\u0029\u0020\u006di\u0073\u0073i\u006e\u0067")
	}
	_fgea, _ := _agf.GetName(_ebacf.FontName)
	if _gcadc := _fbbe.Get("\u0054\u0079\u0070\u0065"); _gcadc != nil {
		_bbccg, _aebe := _gcadc.(*_agf.PdfObjectName)
		if !_aebe || string(*_bbccg) != "\u0046\u006f\u006e\u0074\u0044\u0065\u0073\u0063\u0072i\u0070\u0074\u006f\u0072" {
			_fd.Log.Debug("I\u006e\u0063\u006f\u006d\u0070\u0061\u0074\u0069\u0062\u0069\u006c\u0069\u0074\u0079\u003a\u0020\u0046\u006f\u006e\u0074\u0020\u0064\u0065\u0073\u0063\u0072i\u0070t\u006f\u0072\u0020\u0054y\u0070\u0065 \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0025\u0054\u0029\u0020\u0066\u006f\u006e\u0074\u003d\u0025\u0071\u0020\u0025\u0054", _gcadc, _fgea, _ebacf.FontName)
		}
	} else {
		_fd.Log.Trace("\u0049\u006ec\u006f\u006d\u0070\u0061\u0074i\u0062\u0069\u006c\u0069\u0074y\u003a\u0020\u0054\u0079\u0070\u0065\u0020\u0028\u0052\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0029\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u002e\u0020\u0066\u006f\u006e\u0074\u003d\u0025\u0071\u0020\u0025\u0054", _fgea, _ebacf.FontName)
	}
	_ebacf.FontFamily = _fbbe.Get("\u0046\u006f\u006e\u0074\u0046\u0061\u006d\u0069\u006c\u0079")
	_ebacf.FontStretch = _fbbe.Get("F\u006f\u006e\u0074\u0053\u0074\u0072\u0065\u0074\u0063\u0068")
	_ebacf.FontWeight = _fbbe.Get("\u0046\u006f\u006e\u0074\u0057\u0065\u0069\u0067\u0068\u0074")
	_ebacf.Flags = _fbbe.Get("\u0046\u006c\u0061g\u0073")
	_ebacf.FontBBox = _fbbe.Get("\u0046\u006f\u006e\u0074\u0042\u0042\u006f\u0078")
	_ebacf.ItalicAngle = _fbbe.Get("I\u0074\u0061\u006c\u0069\u0063\u0041\u006e\u0067\u006c\u0065")
	_ebacf.Ascent = _fbbe.Get("\u0041\u0073\u0063\u0065\u006e\u0074")
	_ebacf.Descent = _fbbe.Get("\u0044e\u0073\u0063\u0065\u006e\u0074")
	_ebacf.Leading = _fbbe.Get("\u004ce\u0061\u0064\u0069\u006e\u0067")
	_ebacf.CapHeight = _fbbe.Get("\u0043a\u0070\u0048\u0065\u0069\u0067\u0068t")
	_ebacf.XHeight = _fbbe.Get("\u0058H\u0065\u0069\u0067\u0068\u0074")
	_ebacf.StemV = _fbbe.Get("\u0053\u0074\u0065m\u0056")
	_ebacf.StemH = _fbbe.Get("\u0053\u0074\u0065m\u0048")
	_ebacf.AvgWidth = _fbbe.Get("\u0041\u0076\u0067\u0057\u0069\u0064\u0074\u0068")
	_ebacf.MaxWidth = _fbbe.Get("\u004d\u0061\u0078\u0057\u0069\u0064\u0074\u0068")
	_ebacf.MissingWidth = _fbbe.Get("\u004d\u0069\u0073s\u0069\u006e\u0067\u0057\u0069\u0064\u0074\u0068")
	_ebacf.FontFile = _fbbe.Get("\u0046\u006f\u006e\u0074\u0046\u0069\u006c\u0065")
	_ebacf.FontFile2 = _fbbe.Get("\u0046o\u006e\u0074\u0046\u0069\u006c\u00652")
	_ebacf.FontFile3 = _fbbe.Get("\u0046o\u006e\u0074\u0046\u0069\u006c\u00653")
	_ebacf.CharSet = _fbbe.Get("\u0043h\u0061\u0072\u0053\u0065\u0074")
	_ebacf.Style = _fbbe.Get("\u0053\u0074\u0079l\u0065")
	_ebacf.Lang = _fbbe.Get("\u004c\u0061\u006e\u0067")
	_ebacf.FD = _fbbe.Get("\u0046\u0044")
	_ebacf.CIDSet = _fbbe.Get("\u0043\u0049\u0044\u0053\u0065\u0074")
	if _ebacf.Flags != nil {
		if _cfgdc, _fgca := _agf.GetIntVal(_ebacf.Flags); _fgca {
			_ebacf._babge = _cfgdc
		}
	}
	if _ebacf.MissingWidth != nil {
		if _fbda, _dfged := _agf.GetNumberAsFloat(_ebacf.MissingWidth); _dfged == nil {
			_ebacf._dgag = _fbda
		}
	}
	if _ebacf.FontFile != nil {
		_egea, _dgaa := _facgd(_ebacf.FontFile)
		if _dgaa != nil {
			return _ebacf, _dgaa
		}
		_fd.Log.Trace("f\u006f\u006e\u0074\u0046\u0069\u006c\u0065\u003d\u0025\u0073", _egea)
		_ebacf.fontFile = _egea
	}
	if _ebacf.FontFile2 != nil {
		_dfcae, _dggf := _aa.NewFontFile2FromPdfObject(_ebacf.FontFile2)
		if _dggf != nil {
			return _ebacf, _dggf
		}
		_fd.Log.Trace("\u0066\u006f\u006et\u0046\u0069\u006c\u0065\u0032\u003d\u0025\u0073", _dfcae.String())
		_ebacf._fdddd = &_dfcae
	}
	return _ebacf, nil
}
func (_ggeba *PdfSignature) extractChainFromPKCS7() ([]*_ed.Certificate, error) {
	_cgdac, _babab := _eg.Parse(_ggeba.Contents.Bytes())
	if _babab != nil {
		return nil, _babab
	}
	return _cgdac.Certificates, nil
}

// NewXObjectFormFromStream builds the Form XObject from a stream object.
// TODO: Should this be exposed? Consider different access points.
func NewXObjectFormFromStream(stream *_agf.PdfObjectStream) (*XObjectForm, error) {
	_dddd := &XObjectForm{}
	_dddd._dfeac = stream
	_gfce := *(stream.PdfObjectDictionary)
	_facdcc, _aegde := _agf.NewEncoderFromStream(stream)
	if _aegde != nil {
		return nil, _aegde
	}
	_dddd.Filter = _facdcc
	if _cdcba := _gfce.Get("\u0053u\u0062\u0074\u0079\u0070\u0065"); _cdcba != nil {
		_dcfbe, _fddbd := _cdcba.(*_agf.PdfObjectName)
		if !_fddbd {
			return nil, _gcd.New("\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
		}
		if *_dcfbe != "\u0046\u006f\u0072\u006d" {
			_fd.Log.Debug("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072m\u0020\u0073\u0075\u0062ty\u0070\u0065")
			return nil, _gcd.New("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072m\u0020\u0073\u0075\u0062ty\u0070\u0065")
		}
	}
	if _fegg := _gfce.Get("\u0046\u006f\u0072\u006d\u0054\u0079\u0070\u0065"); _fegg != nil {
		_dddd.FormType = _fegg
	}
	if _cbegd := _gfce.Get("\u0042\u0042\u006f\u0078"); _cbegd != nil {
		_dddd.BBox = _cbegd
	}
	if _efgee := _gfce.Get("\u004d\u0061\u0074\u0072\u0069\u0078"); _efgee != nil {
		_dddd.Matrix = _efgee
	}
	if _bcacbb := _gfce.Get("\u0052e\u0073\u006f\u0075\u0072\u0063\u0065s"); _bcacbb != nil {
		_bcacbb = _agf.TraceToDirectObject(_bcacbb)
		_ggbca, _cbfdfb := _bcacbb.(*_agf.PdfObjectDictionary)
		if !_cbfdfb {
			_fd.Log.Debug("\u0049\u006e\u0076\u0061\u006ci\u0064\u0020\u0058\u004f\u0062j\u0065c\u0074\u0020\u0046\u006f\u0072\u006d\u0020\u0052\u0065\u0073\u006f\u0075\u0072\u0063\u0065\u0073\u0020\u006f\u0062j\u0065\u0063\u0074\u002c\u0020\u0070\u006f\u0069\u006e\u0074\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u006e\u006f\u006e\u002d\u0064\u0069\u0063t\u0069\u006f\u006e\u0061\u0072\u0079")
			return nil, _agf.ErrTypeError
		}
		_feedd, _cefee := NewPdfPageResourcesFromDict(_ggbca)
		if _cefee != nil {
			_fd.Log.Debug("\u0046\u0061i\u006c\u0065\u0064\u0020\u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u006d\u0020\u0072\u0065\u0073\u006f\u0075rc\u0065\u0073")
			return nil, _cefee
		}
		_dddd.Resources = _feedd
		_fd.Log.Trace("\u0046\u006f\u0072\u006d r\u0065\u0073\u006f\u0075\u0072\u0063\u0065\u0073\u003a\u0020\u0025\u0023\u0076", _dddd.Resources)
	}
	_dddd.Group = _gfce.Get("\u0047\u0072\u006fu\u0070")
	_dddd.Ref = _gfce.Get("\u0052\u0065\u0066")
	_dddd.MetaData = _gfce.Get("\u004d\u0065\u0074\u0061\u0044\u0061\u0074\u0061")
	_dddd.PieceInfo = _gfce.Get("\u0050i\u0065\u0063\u0065\u0049\u006e\u0066o")
	_dddd.LastModified = _gfce.Get("\u004c\u0061\u0073t\u004d\u006f\u0064\u0069\u0066\u0069\u0065\u0064")
	_dddd.StructParent = _gfce.Get("\u0053\u0074\u0072u\u0063\u0074\u0050\u0061\u0072\u0065\u006e\u0074")
	_dddd.StructParents = _gfce.Get("\u0053\u0074\u0072\u0075\u0063\u0074\u0050\u0061\u0072\u0065\u006e\u0074\u0073")
	_dddd.OPI = _gfce.Get("\u004f\u0050\u0049")
	_dddd.OC = _gfce.Get("\u004f\u0043")
	_dddd.Name = _gfce.Get("\u004e\u0061\u006d\u0065")
	_dddd.Stream = stream.Stream
	return _dddd, nil
}

type pdfSignDictionary struct {
	*_agf.PdfObjectDictionary
	_adfab  *SignatureHandler
	_ecaged *PdfSignature
	_deebd  int64
	_cbfbge int
	_dbdbd  int
	_bgdee  int
	_dbeeb  int
}

// ReplacePage replaces the original page to a new page.
func (_ggdbg *PdfAppender) ReplacePage(pageNum int, page *PdfPage) {
	_ddaf := pageNum - 1
	for _dbfa := range _ggdbg._dfaf {
		if _dbfa == _ddaf {
			_affb := page.Duplicate()
			_ddeeg(_affb)
			_ggdbg._dfaf[_dbfa] = _affb
		}
	}
}
func (_deeff *PdfWriter) writeString(_gaaed string) {
	if _deeff._ccdaa != nil {
		return
	}
	_cfcgc, _gbffef := _deeff._eafee.WriteString(_gaaed)
	_deeff._fdce += int64(_cfcgc)
	_deeff._ccdaa = _gbffef
}

// PdfWriter handles outputing PDF content.
type PdfWriter struct {
	_eccfaf         *_agf.PdfIndirectObject
	_dgbbfe         *_agf.PdfIndirectObject
	_adec           map[_agf.PdfObject]struct{}
	_dgbd           []_agf.PdfObject
	_ccbbf          map[_agf.PdfObject]struct{}
	_fdfbd          []*_agf.PdfIndirectObject
	_dfcbdg         *PdfOutlineTreeNode
	_bagbb          *_agf.PdfObjectDictionary
	_ebca           []_agf.PdfObject
	_eaaaab         *_agf.PdfIndirectObject
	_eafee          *_be.Writer
	_fdce           int64
	_ccdaa          error
	_cecgd          *_agf.PdfCrypt
	_ccebfc         *_agf.PdfObjectDictionary
	_gdcbf          *_agf.PdfIndirectObject
	_fcgdbd         *_agf.PdfObjectArray
	_bcdfgg         _agf.Version
	_cbbed          *bool
	_afcfaf         map[_agf.PdfObject][]*_agf.PdfObjectDictionary
	_eafgd          *PdfAcroForm
	_dafgfa         Optimizer
	_fdfce          StandardApplier
	_ddcg           map[int]crossReference
	_gdfa           int64
	ObjNumOffset    int
	_accad          bool
	_gcec           _agf.XrefTable
	_bdcea          int64
	_dbafe          int64
	_efgaf          map[_agf.PdfObject]int64
	_gbgbad         map[_agf.PdfObject]struct{}
	_adaaa          string
	_ageec          []*PdfOutputIntent
	_gcbdb          bool
	_bedbef, _daddd string
}

// NewPdfColorspaceFromPdfObject loads a PdfColorspace from a PdfObject.  Returns an error if there is
// a failure in loading.
func NewPdfColorspaceFromPdfObject(obj _agf.PdfObject) (PdfColorspace, error) {
	if obj == nil {
		return nil, nil
	}
	var _egbc *_agf.PdfIndirectObject
	var _acfc *_agf.PdfObjectName
	var _fbfab *_agf.PdfObjectArray
	if _efgc, _cbdf := obj.(*_agf.PdfIndirectObject); _cbdf {
		_egbc = _efgc
	}
	obj = _agf.TraceToDirectObject(obj)
	switch _aadc := obj.(type) {
	case *_agf.PdfObjectArray:
		_fbfab = _aadc
	case *_agf.PdfObjectName:
		_acfc = _aadc
	}
	if _acfc != nil {
		switch *_acfc {
		case "\u0044\u0065\u0076\u0069\u0063\u0065\u0047\u0072\u0061\u0079":
			return NewPdfColorspaceDeviceGray(), nil
		case "\u0044e\u0076\u0069\u0063\u0065\u0052\u0047B":
			return NewPdfColorspaceDeviceRGB(), nil
		case "\u0044\u0065\u0076\u0069\u0063\u0065\u0043\u004d\u0059\u004b":
			return NewPdfColorspaceDeviceCMYK(), nil
		case "\u0050a\u0074\u0074\u0065\u0072\u006e":
			return NewPdfColorspaceSpecialPattern(), nil
		default:
			_fd.Log.Debug("\u0045\u0052\u0052\u004fR\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020c\u006fl\u006f\u0072\u0073\u0070\u0061\u0063\u0065 \u0025\u0073", *_acfc)
			return nil, _cffa
		}
	}
	if _fbfab != nil && _fbfab.Len() > 0 {
		var _fffd _agf.PdfObject = _egbc
		if _egbc == nil {
			_fffd = _fbfab
		}
		if _ebge, _cfed := _agf.GetName(_fbfab.Get(0)); _cfed {
			switch _ebge.String() {
			case "\u0044\u0065\u0076\u0069\u0063\u0065\u0047\u0072\u0061\u0079":
				if _fbfab.Len() == 1 {
					return NewPdfColorspaceDeviceGray(), nil
				}
			case "\u0044e\u0076\u0069\u0063\u0065\u0052\u0047B":
				if _fbfab.Len() == 1 {
					return NewPdfColorspaceDeviceRGB(), nil
				}
			case "\u0044\u0065\u0076\u0069\u0063\u0065\u0043\u004d\u0059\u004b":
				if _fbfab.Len() == 1 {
					return NewPdfColorspaceDeviceCMYK(), nil
				}
			case "\u0043a\u006c\u0047\u0072\u0061\u0079":
				return _aaaf(_fffd)
			case "\u0043\u0061\u006c\u0052\u0047\u0042":
				return _edfg(_fffd)
			case "\u004c\u0061\u0062":
				return _bafd(_fffd)
			case "\u0049\u0043\u0043\u0042\u0061\u0073\u0065\u0064":
				return _gegee(_fffd)
			case "\u0050a\u0074\u0074\u0065\u0072\u006e":
				return _ffaa(_fffd)
			case "\u0049n\u0064\u0065\u0078\u0065\u0064":
				return _cbca(_fffd)
			case "\u0053\u0065\u0070\u0061\u0072\u0061\u0074\u0069\u006f\u006e":
				return _gagg(_fffd)
			case "\u0044e\u0076\u0069\u0063\u0065\u004e":
				return _bcgf(_fffd)
			default:
				_fd.Log.Debug("A\u0072\u0072\u0061\u0079\u0020\u0077i\u0074\u0068\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u006e\u0061m\u0065:\u0020\u0025\u0073", *_ebge)
			}
		}
	}
	_fd.Log.Debug("\u0050\u0044\u0046\u0020\u0046i\u006c\u0065\u0020\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0043\u006f\u006co\u0072\u0073\u0070\u0061\u0063\u0065\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0073", obj.String())
	return nil, ErrTypeCheck
}

// SetPdfSubject sets the Subject attribute of the output PDF.
func SetPdfSubject(subject string) { _ecba.Lock(); defer _ecba.Unlock(); _dbdce = subject }

// Y returns the value of the yellow component of the color.
func (_aeba *PdfColorDeviceCMYK) Y() float64 { return _aeba[2] }

// PdfColorspaceDeviceCMYK represents a CMYK32 colorspace.
type PdfColorspaceDeviceCMYK struct{}

// NewXObjectForm creates a brand new XObject Form. Creates a new underlying PDF object stream primitive.
func NewXObjectForm() *XObjectForm {
	_bgdfg := &XObjectForm{}
	_eaec := &_agf.PdfObjectStream{}
	_eaec.PdfObjectDictionary = _agf.MakeDict()
	_bgdfg._dfeac = _eaec
	return _bgdfg
}
func (_dcfa *PdfColorspaceSpecialSeparation) String() string {
	return "\u0053\u0065\u0070\u0061\u0072\u0061\u0074\u0069\u006f\u006e"
}

var (
	CourierName              = _aa.CourierName
	CourierBoldName          = _aa.CourierBoldName
	CourierObliqueName       = _aa.CourierObliqueName
	CourierBoldObliqueName   = _aa.CourierBoldObliqueName
	HelveticaName            = _aa.HelveticaName
	HelveticaBoldName        = _aa.HelveticaBoldName
	HelveticaObliqueName     = _aa.HelveticaObliqueName
	HelveticaBoldObliqueName = _aa.HelveticaBoldObliqueName
	SymbolName               = _aa.SymbolName
	ZapfDingbatsName         = _aa.ZapfDingbatsName
	TimesRomanName           = _aa.TimesRomanName
	TimesBoldName            = _aa.TimesBoldName
	TimesItalicName          = _aa.TimesItalicName
	TimesBoldItalicName      = _aa.TimesBoldItalicName
)

// VRI represents a Validation-Related Information dictionary.
// The VRI dictionary contains validation data in the form of
// certificates, OCSP and CRL information, for a single signature.
// See ETSI TS 102 778-4 V1.1.1 for more information.
type VRI struct {
	Cert []*_agf.PdfObjectStream
	OCSP []*_agf.PdfObjectStream
	CRL  []*_agf.PdfObjectStream
	TU   *_agf.PdfObjectString
	TS   *_agf.PdfObjectString
}
type pdfFontSimple struct {
	fontCommon
	_gfbgf *_agf.PdfIndirectObject
	_fcad  map[_fcg.CharCode]float64
	_dbgde _fcg.TextEncoder
	_eebb  _fcg.TextEncoder
	_cfggc *PdfFontDescriptor

	// Encoding is subject to limitations that are described in 9.6.6, "Character Encoding".
	// BaseFont is derived differently.
	FirstChar _agf.PdfObject
	LastChar  _agf.PdfObject
	Widths    _agf.PdfObject
	Encoding  _agf.PdfObject
	_fbgbg    *_aa.RuneCharSafeMap
}

func (_fcbbf *PdfWriter) checkLicense() error {
	// _bdbff := _ede.GetLicenseKey()
	// if (_bdbff == nil || !_bdbff.IsLicensed()) && !_aecab {
	// 	_b.Printf("\u0055\u006e\u006c\u0069\u0063\u0065\u006e\u0073\u0065\u0064\u0020c\u006f\u0070\u0079\u0020\u006f\u0066\u0020\u0055\u006e\u0069P\u0044\u0046\u000a")
	// 	_b.Println("-\u0020\u0047\u0065\u0074\u0020\u0061\u0020\u0066\u0072e\u0065\u0020\u0074\u0072\u0069\u0061\u006c l\u0069\u0063\u0065\u006es\u0065\u0020\u006f\u006e\u0020\u0068\u0074\u0074\u0070s:\u002f\u002fu\u006e\u0069\u0064\u006f\u0063\u002e\u0069\u006f")
	// 	return _gcd.New("\u0075\u006e\u0069\u0070d\u0066\u0020\u006c\u0069\u0063\u0065\u006e\u0073\u0065\u0020c\u006fd\u0065\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0064")
	// }
	return nil
}
func _gegee(_bdbf _agf.PdfObject) (*PdfColorspaceICCBased, error) {
	_ebac := &PdfColorspaceICCBased{}
	if _daaf, _dcde := _bdbf.(*_agf.PdfIndirectObject); _dcde {
		_ebac._cecae = _daaf
	}
	_bdbf = _agf.TraceToDirectObject(_bdbf)
	_cfb, _cdcf := _bdbf.(*_agf.PdfObjectArray)
	if !_cdcf {
		return nil, _b.Errorf("\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	if _cfb.Len() != 2 {
		return nil, _b.Errorf("i\u006e\u0076\u0061\u006c\u0069\u0064 \u0049\u0043\u0043\u0042\u0061\u0073\u0065\u0064\u0020c\u006f\u006c\u006fr\u0073p\u0061\u0063\u0065")
	}
	_bdbf = _agf.TraceToDirectObject(_cfb.Get(0))
	_agge, _cdcf := _bdbf.(*_agf.PdfObjectName)
	if !_cdcf {
		return nil, _b.Errorf("\u0049\u0043\u0043B\u0061\u0073\u0065\u0064 \u006e\u0061\u006d\u0065\u0020\u006e\u006ft\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074")
	}
	if *_agge != "\u0049\u0043\u0043\u0042\u0061\u0073\u0065\u0064" {
		return nil, _b.Errorf("\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0049\u0043\u0043\u0042a\u0073\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0073p\u0061\u0063\u0065")
	}
	_bdbf = _cfb.Get(1)
	_agfee, _cdcf := _agf.GetStream(_bdbf)
	if !_cdcf {
		_fd.Log.Error("I\u0043\u0043\u0042\u0061\u0073\u0065d\u0020\u006e\u006f\u0074\u0020\u0070o\u0069\u006e\u0074\u0069\u006e\u0067\u0020t\u006f\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u003a\u0020%\u0054", _bdbf)
		return nil, _b.Errorf("\u0049\u0043\u0043Ba\u0073\u0065\u0064\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064")
	}
	_abee := _agfee.PdfObjectDictionary
	_gdebb, _cdcf := _abee.Get("\u004e").(*_agf.PdfObjectInteger)
	if !_cdcf {
		return nil, _b.Errorf("I\u0043\u0043\u0042\u0061\u0073\u0065d\u0020\u006d\u0069\u0073\u0073\u0069n\u0067\u0020\u004e\u0020\u0066\u0072\u006fm\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0069c\u0074")
	}
	if *_gdebb != 1 && *_gdebb != 3 && *_gdebb != 4 {
		return nil, _b.Errorf("\u0049\u0043\u0043\u0042\u0061s\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063\u0065 \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u004e\u0020\u0028\u006e\u006f\u0074\u0020\u0031\u002c\u0033\u002c\u0034\u0029")
	}
	_ebac.N = int(*_gdebb)
	if _eafd := _abee.Get("\u0041l\u0074\u0065\u0072\u006e\u0061\u0074e"); _eafd != nil {
		_bcggd, _bbdc := NewPdfColorspaceFromPdfObject(_eafd)
		if _bbdc != nil {
			return nil, _bbdc
		}
		_ebac.Alternate = _bcggd
	}
	if _eabeg := _abee.Get("\u0052\u0061\u006eg\u0065"); _eabeg != nil {
		_eabeg = _agf.TraceToDirectObject(_eabeg)
		_eaaf, _gacc := _eabeg.(*_agf.PdfObjectArray)
		if !_gacc {
			return nil, _b.Errorf("I\u0043\u0043\u0042\u0061\u0073\u0065d\u0020\u0052\u0061\u006e\u0067\u0065\u0020\u006e\u006ft\u0020\u0061\u006e \u0061r\u0072\u0061\u0079")
		}
		if _eaaf.Len() != 2*_ebac.N {
			return nil, _b.Errorf("\u0049\u0043\u0043\u0042\u0061\u0073\u0065\u0064\u0020\u0052\u0061\u006e\u0067e\u0020\u0077\u0072\u006f\u006e\u0067 \u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006f\u0066\u0020\u0065\u006c\u0065m\u0065\u006e\u0074\u0073")
		}
		_ccee, _gccac := _eaaf.GetAsFloat64Slice()
		if _gccac != nil {
			return nil, _gccac
		}
		_ebac.Range = _ccee
	} else {
		_ebac.Range = make([]float64, 2*_ebac.N)
		for _bedd := 0; _bedd < _ebac.N; _bedd++ {
			_ebac.Range[2*_bedd] = 0.0
			_ebac.Range[2*_bedd+1] = 1.0
		}
	}
	if _dffb := _abee.Get("\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061"); _dffb != nil {
		_bfbfd, _ggee := _dffb.(*_agf.PdfObjectStream)
		if !_ggee {
			return nil, _b.Errorf("\u0049\u0043\u0043\u0042\u0061\u0073\u0065\u0064\u0020\u004de\u0074\u0061\u0064\u0061\u0074\u0061\u0020n\u006f\u0074\u0020\u0061\u0020\u0073\u0074\u0072\u0065\u0061\u006d")
		}
		_ebac.Metadata = _bfbfd
	}
	_ggbd, _dfca := _agf.DecodeStream(_agfee)
	if _dfca != nil {
		return nil, _dfca
	}
	_ebac.Data = _ggbd
	_ebac._gbcdd = _agfee
	return _ebac, nil
}
func _ebegf(_cgc _agf.PdfObject) (*PdfColorspaceDeviceNAttributes, error) {
	_bcdef := &PdfColorspaceDeviceNAttributes{}
	var _cffg *_agf.PdfObjectDictionary
	switch _bccdc := _cgc.(type) {
	case *_agf.PdfIndirectObject:
		_bcdef._dea = _bccdc
		var _ggda bool
		_cffg, _ggda = _bccdc.PdfObject.(*_agf.PdfObjectDictionary)
		if !_ggda {
			_fd.Log.Error("\u0044\u0065\u0076\u0069c\u0065\u004e\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075t\u0065 \u0074\u0079\u0070\u0065\u0020\u0065\u0072r\u006f\u0072")
			return nil, _gcd.New("\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
		}
	case *_agf.PdfObjectDictionary:
		_cffg = _bccdc
	case *_agf.PdfObjectReference:
		_gfbbb := _bccdc.Resolve()
		return _ebegf(_gfbbb)
	default:
		_fd.Log.Error("\u0044\u0065\u0076\u0069c\u0065\u004e\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075t\u0065 \u0074\u0079\u0070\u0065\u0020\u0065\u0072r\u006f\u0072")
		return nil, _gcd.New("\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	if _gfbc := _cffg.Get("\u0053u\u0062\u0074\u0079\u0070\u0065"); _gfbc != nil {
		_fbec, _dgfcg := _agf.TraceToDirectObject(_gfbc).(*_agf.PdfObjectName)
		if !_dgfcg {
			_fd.Log.Error("\u0044\u0065vi\u0063\u0065\u004e \u0061\u0074\u0074\u0072ibu\u0074e \u0053\u0075\u0062\u0074\u0079\u0070\u0065 t\u0079\u0070\u0065\u0020\u0065\u0072\u0072o\u0072")
			return nil, _gcd.New("\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
		}
		_bcdef.Subtype = _fbec
	}
	if _ggegc := _cffg.Get("\u0043o\u006c\u006f\u0072\u0061\u006e\u0074s"); _ggegc != nil {
		_bcdef.Colorants = _ggegc
	}
	if _cfba := _cffg.Get("\u0050r\u006f\u0063\u0065\u0073\u0073"); _cfba != nil {
		_bcdef.Process = _cfba
	}
	if _dgeba := _cffg.Get("M\u0069\u0078\u0069\u006e\u0067\u0048\u0069\u006e\u0074\u0073"); _dgeba != nil {
		_bcdef.MixingHints = _dgeba
	}
	return _bcdef, nil
}
func _cegad(_agdg *_agf.PdfObjectDictionary) (*PdfShadingType3, error) {
	_dddbf := PdfShadingType3{}
	_fagad := _agdg.Get("\u0043\u006f\u006f\u0072\u0064\u0073")
	if _fagad == nil {
		_fd.Log.Debug("\u0052\u0065\u0071ui\u0072\u0065\u0064\u0020\u0061\u0074\u0074\u0072\u0069b\u0075t\u0065 \u006di\u0073\u0073\u0069\u006e\u0067\u003a\u0020\u0043\u006f\u006f\u0072\u0064\u0073")
		return nil, ErrRequiredAttributeMissing
	}
	_acebc, _acbea := _fagad.(*_agf.PdfObjectArray)
	if !_acbea {
		_fd.Log.Debug("\u0043\u006f\u006f\u0072d\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072a\u0079\u0020\u0028\u0067\u006f\u0074\u0020%\u0054\u0029", _fagad)
		return nil, _agf.ErrTypeError
	}
	if _acebc.Len() != 6 {
		_fd.Log.Debug("\u0043\u006f\u006f\u0072d\u0073\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074 \u0036\u0020\u0028\u0067\u006f\u0074\u0020%\u0064\u0029", _acebc.Len())
		return nil, ErrInvalidAttribute
	}
	_dddbf.Coords = _acebc
	if _aaeb := _agdg.Get("\u0044\u006f\u006d\u0061\u0069\u006e"); _aaeb != nil {
		_aaeb = _agf.TraceToDirectObject(_aaeb)
		_ccbb, _efddc := _aaeb.(*_agf.PdfObjectArray)
		if !_efddc {
			_fd.Log.Debug("\u0044\u006f\u006d\u0061i\u006e\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072a\u0079\u0020\u0028\u0067\u006f\u0074\u0020%\u0054\u0029", _aaeb)
			return nil, _agf.ErrTypeError
		}
		_dddbf.Domain = _ccbb
	}
	_fagad = _agdg.Get("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e")
	if _fagad == nil {
		_fd.Log.Debug("\u0052\u0065q\u0075\u0069\u0072\u0065d\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020m\u0069\u0073\u0073\u0069\u006e\u0067\u003a\u0020\u0020\u0046\u0075\u006ec\u0074\u0069\u006f\u006e")
		return nil, ErrRequiredAttributeMissing
	}
	_dddbf.Function = []PdfFunction{}
	if _dbgdf, _acbgc := _fagad.(*_agf.PdfObjectArray); _acbgc {
		for _, _baabb := range _dbgdf.Elements() {
			_dbcdg, _cdfge := _ccedb(_baabb)
			if _cdfge != nil {
				_fd.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e:\u0020\u0025\u0076", _cdfge)
				return nil, _cdfge
			}
			_dddbf.Function = append(_dddbf.Function, _dbcdg)
		}
	} else {
		_gfdga, _ceae := _ccedb(_fagad)
		if _ceae != nil {
			_fd.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e:\u0020\u0025\u0076", _ceae)
			return nil, _ceae
		}
		_dddbf.Function = append(_dddbf.Function, _gfdga)
	}
	if _bfecd := _agdg.Get("\u0045\u0078\u0074\u0065\u006e\u0064"); _bfecd != nil {
		_bfecd = _agf.TraceToDirectObject(_bfecd)
		_fageg, _gdbgb := _bfecd.(*_agf.PdfObjectArray)
		if !_gdbgb {
			_fd.Log.Debug("\u004d\u0061\u0074\u0072i\u0078\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072a\u0079\u0020\u0028\u0067\u006f\u0074\u0020%\u0054\u0029", _bfecd)
			return nil, _agf.ErrTypeError
		}
		if _fageg.Len() != 2 {
			_fd.Log.Debug("\u0045\u0078\u0074\u0065n\u0064\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074 \u0032\u0020\u0028\u0067\u006f\u0074\u0020%\u0064\u0029", _fageg.Len())
			return nil, ErrInvalidAttribute
		}
		_dddbf.Extend = _fageg
	}
	return &_dddbf, nil
}

var _fbgb = map[string]struct{}{"\u0046\u0054": {}, "\u004b\u0069\u0064\u0073": {}, "\u0054": {}, "\u0054\u0055": {}, "\u0054\u004d": {}, "\u0046\u0066": {}, "\u0056": {}, "\u0044\u0056": {}, "\u0041\u0041": {}, "\u0044\u0041": {}, "\u0051": {}, "\u0044\u0053": {}, "\u0052\u0056": {}}

// GetContainingPdfObject returns the container of the image object (indirect object).
func (_agggff *XObjectImage) GetContainingPdfObject() _agf.PdfObject { return _agggff._gdggg }

var ImageHandling ImageHandler = DefaultImageHandler{}

// NewPdfColorspaceDeviceN returns an initialized PdfColorspaceDeviceN.
func NewPdfColorspaceDeviceN() *PdfColorspaceDeviceN {
	_eefbe := &PdfColorspaceDeviceN{}
	return _eefbe
}
func (_decf *DSS) addCerts(_bcced [][]byte) ([]*_agf.PdfObjectStream, error) {
	return _decf.add(&_decf.Certs, _decf._agbeg, _bcced)
}
func _fcga(_ggfad *_agf.PdfObjectDictionary) {
	_dbbce, _dgcgc := _agf.GetArray(_ggfad.Get("\u0057\u0069\u0064\u0074\u0068\u0073"))
	_gefa, _aedab := _agf.GetIntVal(_ggfad.Get("\u0046i\u0072\u0073\u0074\u0043\u0068\u0061r"))
	_fbce, _afaga := _agf.GetIntVal(_ggfad.Get("\u004c\u0061\u0073\u0074\u0043\u0068\u0061\u0072"))
	if _dgcgc && _aedab && _afaga {
		_bgbaa := _dbbce.Len()
		if _bgbaa != _fbce-_gefa+1 {
			_fd.Log.Debug("\u0055\u006e\u0065x\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0057\u0069\u0064\u0074\u0068\u0073\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0025\u0076\u002c\u0020\u004c\u0061\u0073t\u0043\u0068\u0061\u0072\u003a\u0020\u0025\u0076", _bgbaa, _fbce)
			_cgce := _agf.PdfObjectInteger(_gefa + _bgbaa - 1)
			_ggfad.Set("\u004c\u0061\u0073\u0074\u0043\u0068\u0061\u0072", &_cgce)
		}
	}
}

// SetImage updates XObject Image with new image data.
func (_ccbbd *XObjectImage) SetImage(img *Image, cs PdfColorspace) error {
	_ccbbd.Filter.UpdateParams(img.GetParamsDict())
	_cgdcc, _ebcbb := _ccbbd.Filter.EncodeBytes(img.Data)
	if _ebcbb != nil {
		return _ebcbb
	}
	_ccbbd.Stream = _cgdcc
	_gecca := img.Width
	_ccbbd.Width = &_gecca
	_dgbge := img.Height
	_ccbbd.Height = &_dgbge
	_cacba := img.BitsPerComponent
	_ccbbd.BitsPerComponent = &_cacba
	if cs == nil {
		if img.ColorComponents == 1 {
			_ccbbd.ColorSpace = NewPdfColorspaceDeviceGray()
		} else if img.ColorComponents == 3 {
			_ccbbd.ColorSpace = NewPdfColorspaceDeviceRGB()
		} else if img.ColorComponents == 4 {
			_ccbbd.ColorSpace = NewPdfColorspaceDeviceCMYK()
		} else {
			return _gcd.New("c\u006fl\u006f\u0072\u0073\u0070\u0061\u0063\u0065\u0020u\u006e\u0064\u0065\u0066in\u0065\u0064")
		}
	} else {
		_ccbbd.ColorSpace = cs
	}
	return nil
}

const (
	_ PdfOutputIntentType = iota
	PdfOutputIntentTypeA1
	PdfOutputIntentTypeA2
	PdfOutputIntentTypeA3
	PdfOutputIntentTypeA4
	PdfOutputIntentTypeX
)

// XObjectImage (Table 89 in 8.9.5.1).
// Implements PdfModel interface.
type XObjectImage struct {

	// ColorSpace       PdfObject
	Width            *int64
	Height           *int64
	ColorSpace       PdfColorspace
	BitsPerComponent *int64
	Filter           _agf.StreamEncoder
	Intent           _agf.PdfObject
	ImageMask        _agf.PdfObject
	Mask             _agf.PdfObject
	Matte            _agf.PdfObject
	Decode           _agf.PdfObject
	Interpolate      _agf.PdfObject
	Alternatives     _agf.PdfObject
	SMask            _agf.PdfObject
	SMaskInData      _agf.PdfObject
	Name             _agf.PdfObject
	StructParent     _agf.PdfObject
	ID               _agf.PdfObject
	OPI              _agf.PdfObject
	Metadata         _agf.PdfObject
	OC               _agf.PdfObject
	Stream           []byte
	_gdggg           *_agf.PdfObjectStream
}

// PdfBorderStyle represents a border style dictionary (12.5.4 Border Styles p. 394).
type PdfBorderStyle struct {
	W      *float64
	S      *BorderStyle
	D      *[]int
	_eegdd _agf.PdfObject
}

// PdfColorspaceLab is a L*, a*, b* 3 component colorspace.
type PdfColorspaceLab struct {
	WhitePoint []float64
	BlackPoint []float64
	Range      []float64
	_aegc      *_agf.PdfIndirectObject
}

// PdfFilespec represents a file specification which can either refer to an external or embedded file.
type PdfFilespec struct {
	Type  _agf.PdfObject
	FS    _agf.PdfObject
	F     _agf.PdfObject
	UF    _agf.PdfObject
	DOS   _agf.PdfObject
	Mac   _agf.PdfObject
	Unix  _agf.PdfObject
	ID    _agf.PdfObject
	V     _agf.PdfObject
	EF    _agf.PdfObject
	RF    _agf.PdfObject
	Desc  _agf.PdfObject
	CI    _agf.PdfObject
	_bfdc _agf.PdfObject
}

// GetExtGState gets the ExtGState specified by keyName. Returns a bool
// indicating whether it was found or not.
func (_affec *PdfPageResources) GetExtGState(keyName _agf.PdfObjectName) (_agf.PdfObject, bool) {
	if _affec.ExtGState == nil {
		return nil, false
	}
	_cbdcc, _dfaed := _agf.TraceToDirectObject(_affec.ExtGState).(*_agf.PdfObjectDictionary)
	if !_dfaed {
		_fd.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064 \u0045\u0078\u0074\u0047\u0053\u0074\u0061\u0074\u0065\u0020\u0065\u006e\u0074\u0072\u0079\u0020\u002d\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", _affec.ExtGState)
		return nil, false
	}
	if _dgfbd := _cbdcc.Get(keyName); _dgfbd != nil {
		return _dgfbd, true
	}
	return nil, false
}

// FieldFlattenOpts defines a set of options which can be used to configure
// the field flattening process.
type FieldFlattenOpts struct {

	// FilterFunc allows filtering the form fields used in the flattening
	// process. If the filter function returns true, the field is flattened,
	// otherwise it is skipped.
	// If a non-terminal field is discarded, all of its children (the fields
	// present in the Kids array) are discarded as well.
	// Non-terminal fields are kept in the AcroForm if one or more of their
	// child fields have not been selected for flattening.
	// If a filter function is not provided, all form fields are flattened.
	FilterFunc FieldFilterFunc

	// AnnotFilterFunc allows filtering the annotations in the flattening
	// process. If the filter function returns true, the annotation is flattened,
	// otherwise it is skipped.
	AnnotFilterFunc AnnotFilterFunc
}

// NewPdfAnnotationFreeText returns a new free text annotation.
func NewPdfAnnotationFreeText() *PdfAnnotationFreeText {
	_fgb := NewPdfAnnotation()
	_eag := &PdfAnnotationFreeText{}
	_eag.PdfAnnotation = _fgb
	_eag.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_fgb.SetContext(_eag)
	return _eag
}

// PdfColorspaceSpecialSeparation is a Separation colorspace.
// At the moment the colour space is set to a Separation space, the conforming reader shall determine whether the
// device has an available colorant (e.g. dye) corresponding to the name of the requested space. If so, the conforming
// reader shall ignore the alternateSpace and tintTransform parameters; subsequent painting operations within the
// space shall apply the designated colorant directly, according to the tint values supplied.
//
// Format: [/Separation name alternateSpace tintTransform]
type PdfColorspaceSpecialSeparation struct {
	ColorantName   *_agf.PdfObjectName
	AlternateSpace PdfColorspace
	TintTransform  PdfFunction
	_abeb          *_agf.PdfIndirectObject
}

// GetOutlines returns a high-level Outline object, based on the outline tree
// of the reader.
func (_cbaf *PdfReader) GetOutlines() (*Outline, error) {
	if _cbaf == nil {
		return nil, _gcd.New("\u0063\u0061n\u006e\u006f\u0074\u0020c\u0072\u0065a\u0074\u0065\u0020\u006f\u0075\u0074\u006c\u0069n\u0065\u0020\u0066\u0072\u006f\u006d\u0020\u006e\u0069\u006c\u0020\u0072e\u0061\u0064\u0065\u0072")
	}
	_gfef := _cbaf.GetOutlineTree()
	if _gfef == nil {
		return nil, _gcd.New("\u0074\u0068\u0065\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064\u0020\u0072\u0065\u0061\u0064e\u0072\u0020\u0064\u006f\u0065\u0073\u0020n\u006f\u0074\u0020\u0068\u0061\u0076\u0065\u0020\u0061\u006e\u0020o\u0075\u0074\u006c\u0069\u006e\u0065\u0020\u0074\u0072\u0065\u0065")
	}
	var _afaee func(_ebfdd *PdfOutlineTreeNode, _effgea *[]*OutlineItem)
	_afaee = func(_ccegg *PdfOutlineTreeNode, _cceddf *[]*OutlineItem) {
		if _ccegg == nil {
			return
		}
		if _ccegg._cgaaa == nil {
			_fd.Log.Debug("\u0045\u0052RO\u0052\u003a\u0020m\u0069\u0073\u0073\u0069ng \u006fut\u006c\u0069\u006e\u0065\u0020\u0065\u006etr\u0079\u0020\u0063\u006f\u006e\u0074\u0065x\u0074")
			return
		}
		var _gdge *OutlineItem
		if _gbffe, _cagabf := _ccegg._cgaaa.(*PdfOutlineItem); _cagabf {
			_bfedd := _gbffe.Dest
			if (_bfedd == nil || _agf.IsNullObject(_bfedd)) && _gbffe.A != nil {
				if _agcgc, _ebde := _agf.GetDict(_gbffe.A); _ebde {
					if _ddag, _bfcfg := _agf.GetArray(_agcgc.Get("\u0044")); _bfcfg {
						_bfedd = _ddag
					} else {
						_cedgb, _fgaba := _agf.GetString(_agcgc.Get("\u0044"))
						if !_fgaba {
							return
						}
						_acedd, _fgaba := _cbaf._ceaadd.Get("\u004e\u0061\u006de\u0073").(*_agf.PdfObjectReference)
						if !_fgaba {
							return
						}
						_egggc, _decgg := _cbaf._egdga.LookupByReference(*_acedd)
						if _decgg != nil {
							_fd.Log.Debug("\u0045\u0052\u0052O\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072\u0065\u0061\u0064\u0020\u006e\u0061\u006d\u0065\u0073\u0020\u0072\u0065\u0066\u0065\u0072e\u006e\u0063\u0065\u0020\u0028\u0025\u0073\u0029", _decgg.Error())
							return
						}
						_efbfb, _fgaba := _egggc.(*_agf.PdfIndirectObject)
						if !_fgaba {
							return
						}
						_cccbf := map[_agf.PdfObject]struct{}{}
						_decgg = _cbaf.buildNameNodes(_efbfb, _cccbf)
						if _decgg != nil {
							_fd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0062\u0075\u0069\u006c\u0064\u0020\u006ea\u006d\u0065\u0020\u006e\u006fd\u0065\u0073 \u0028\u0025\u0073\u0029", _decgg.Error())
							return
						}
						for _ccebf := range _cccbf {
							_ebfce, _bdfbc := _agf.GetDict(_ccebf)
							if !_bdfbc {
								continue
							}
							_fcaeg, _bdfbc := _agf.GetArray(_ebfce.Get("\u004e\u0061\u006de\u0073"))
							if !_bdfbc {
								continue
							}
							for _efgde, _bfgdg := range _fcaeg.Elements() {
								switch _bfgdg.(type) {
								case *_agf.PdfObjectString:
									if _bfgdg.String() == _cedgb.String() {
										if _adgad := _fcaeg.Get(_efgde + 1); _adgad != nil {
											if _ddfeae, _dedca := _agf.GetDict(_adgad); _dedca {
												_bfedd = _ddfeae.Get("\u0044")
												break
											}
										}
									}
								}
							}
						}
					}
				}
			}
			var _cfdee OutlineDest
			if _bfedd != nil && !_agf.IsNullObject(_bfedd) {
				if _afbba, _fgffc := _dgcfd(_bfedd, _cbaf); _fgffc == nil {
					_cfdee = *_afbba
				} else {
					_fd.Log.Debug("\u0057\u0041\u0052\u004e\u003a\u0020\u0063o\u0075\u006c\u0064 \u006e\u006f\u0074\u0020p\u0061\u0072\u0073\u0065\u0020\u006f\u0075\u0074\u006c\u0069\u006e\u0065\u0020\u0064\u0065\u0073\u0074\u0020\u0028\u0025\u0076\u0029\u003a\u0020\u0025\u0076", _bfedd, _fgffc)
				}
			}
			_gdge = NewOutlineItem(_gbffe.Title.Decoded(), _cfdee)
			*_cceddf = append(*_cceddf, _gdge)
			if _gbffe.Next != nil {
				_afaee(_gbffe.Next, _cceddf)
			}
		}
		if _ccegg.First != nil {
			if _gdge != nil {
				_cceddf = &_gdge.Entries
			}
			_afaee(_ccegg.First, _cceddf)
		}
	}
	_fbfc := NewOutline()
	_afaee(_gfef, &_fbfc.Entries)
	return _fbfc, nil
}

// NewXObjectImage returns a new XObjectImage.
func NewXObjectImage() *XObjectImage {
	_bcfde := &XObjectImage{}
	_fcfead := &_agf.PdfObjectStream{}
	_fcfead.PdfObjectDictionary = _agf.MakeDict()
	_bcfde._gdggg = _fcfead
	return _bcfde
}

// ToPdfObject implements interface PdfModel.
func (_gfbg *PdfAnnotationStrikeOut) ToPdfObject() _agf.PdfObject {
	_gfbg.PdfAnnotation.ToPdfObject()
	_dgcd := _gfbg._aeee
	_geac := _dgcd.PdfObject.(*_agf.PdfObjectDictionary)
	_gfbg.PdfAnnotationMarkup.appendToPdfDictionary(_geac)
	_geac.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _agf.MakeName("\u0053t\u0072\u0069\u006b\u0065\u004f\u0075t"))
	_geac.SetIfNotNil("\u0051\u0075\u0061\u0064\u0050\u006f\u0069\u006e\u0074\u0073", _gfbg.QuadPoints)
	return _dgcd
}

// PdfActionGoTo represents a GoTo action.
type PdfActionGoTo struct {
	*PdfAction
	D _agf.PdfObject
}

// PageProcessCallback callback function used in page loading
// that could be used to modify the page content.
//
// If an error is returned, the `ToWriter` process would fail.
//
// This callback, if defined, will take precedence over `PageCallback` callback.
type PageProcessCallback func(_bcag int, _gfbdg *PdfPage) error

func _cbace(_bggff, _beae string) string {
	if _gc.Contains(_bggff, "\u002b") {
		_faeg := _gc.Split(_bggff, "\u002b")
		if len(_faeg) == 2 {
			_bggff = _faeg[1]
		}
	}
	return _beae + "\u002b" + _bggff
}

// Hasher is the interface that wraps the basic Write method.
type Hasher interface {
	Write(_bbfbe []byte) (_fcedf int, _fbeca error)
}

func _cfffg() string { _ecba.Lock(); defer _ecba.Unlock(); return _bebbe }

// LTV represents an LTV (Long-Term Validation) client. It is used to LTV
// enable signatures by adding validation and revocation data (certificate,
// OCSP and CRL information) to the DSS dictionary of a PDF document.
//
// LTV is added through the DSS by:
//   - Adding certificates, OCSP and CRL information in the global scope of the
//     DSS. The global data is used for validating any of the signatures present
//     in the document.
//   - Adding certificates, OCSP and CRL information for a single signature,
//     through an entry in the VRI dictionary of the DSS. The added data is used
//     for validating that particular signature only. This is the recommended
//     method for adding validation data for a signature. However, this is not
//     is not possible in the same revision the signature is applied. Validation
//     data for a signature is added based on the Contents entry of the signature,
//     which is known only after the revision is written. Even if the Contents
//     are known (e.g. when signing externally), updating the DSS at that point
//     would invalidate the calculated signature. As a result, if adding LTV
//     in the same revision is a requirement, use the first method.
//     See LTV.EnableChain.
//
// The client applies both methods, when possible.
//
// If `LTV.SkipExisting` is set to true (the default), validations are
// not added for signatures which are already present in the VRI entry of the
// document's DSS dictionary.
type LTV struct {

	// CertClient is the client used to retrieve certificates.
	CertClient *_aaa.CertClient

	// OCSPClient is the client used to retrieve OCSP validation information.
	OCSPClient *_aaa.OCSPClient

	// CRLClient is the client used to retrieve CRL validation information.
	CRLClient *_aaa.CRLClient

	// SkipExisting specifies whether existing signature validations
	// should be skipped.
	SkipExisting bool
	_daebc       *PdfAppender
	_cbbe        *DSS
}

// SetXObjectFormByName adds the provided XObjectForm to the page resources.
// The added XObjectForm is identified by the specified name.
func (_fgcaca *PdfPageResources) SetXObjectFormByName(keyName _agf.PdfObjectName, xform *XObjectForm) error {
	_gcaeb := xform.ToPdfObject().(*_agf.PdfObjectStream)
	_gfecb := _fgcaca.SetXObjectByName(keyName, _gcaeb)
	return _gfecb
}
