//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_g "bytes";_bf "lgo/unipdf/common";_f "lgo/unipdf/internal/jbig2/bitmap";_bff "lgo/unipdf/internal/jbig2/errors";_b "io";);var _bda =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
func (_dc *Encoder )EncodeBitmap (bm *_f .Bitmap ,duplicateLineRemoval bool )error {_bf .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );
var (_bfd ,_dg uint8 ;_cb ,_ada ,_bde uint16 ;_ge ,_bcf ,_geg byte ;_ee ,_dga ,_gd int ;_de ,_df []byte ;);for _ff :=0;_ff < bm .Height ;_ff ++{_ge ,_bcf =0,0;if _ff >=2{_ge =bm .Data [(_ff -2)*bm .RowStride ];};if _ff >=1{_bcf =bm .Data [(_ff -1)*bm .RowStride ];
if duplicateLineRemoval {_dga =_ff *bm .RowStride ;_de =bm .Data [_dga :_dga +bm .RowStride ];_gd =(_ff -1)*bm .RowStride ;_df =bm .Data [_gd :_gd +bm .RowStride ];if _g .Equal (_de ,_df ){_dg =_bfd ^1;_bfd =1;}else {_dg =_bfd ;_bfd =0;};};};if duplicateLineRemoval {if _fd :=_dc .encodeBit (_dc ._gbc ,_gbb ,_dg );
_fd !=nil {return _fd ;};if _bfd !=0{continue ;};};_geg =bm .Data [_ff *bm .RowStride ];_cb =uint16 (_ge >>5);_ada =uint16 (_bcf >>4);_ge <<=3;_bcf <<=4;_bde =0;for _ee =0;_ee < bm .Width ;_ee ++{_ed :=uint32 (_cb <<11|_ada <<4|_bde );_cc :=(_geg &0x80)>>7;
_fga :=_dc .encodeBit (_dc ._gbc ,_ed ,_cc );if _fga !=nil {return _fga ;};_cb <<=1;_ada <<=1;_bde <<=1;_cb |=uint16 ((_ge &0x80)>>7);_ada |=uint16 ((_bcf &0x80)>>7);_bde |=uint16 (_cc );_bea :=_ee %8;_eea :=_ee /8+1;if _bea ==4&&_ff >=2{_ge =0;if _eea < bm .RowStride {_ge =bm .Data [(_ff -2)*bm .RowStride +_eea ];
};}else {_ge <<=1;};if _bea ==3&&_ff >=1{_bcf =0;if _eea < bm .RowStride {_bcf =bm .Data [(_ff -1)*bm .RowStride +_eea ];};}else {_bcf <<=1;};if _bea ==7{_geg =0;if _eea < bm .RowStride {_geg =bm .Data [_ff *bm .RowStride +_eea ];};}else {_geg <<=1;};_cb &=31;
_ada &=127;_bde &=15;};};return nil ;};func (_e Class )String ()string {switch _e {case IAAI :return "\u0049\u0041\u0041\u0049";case IADH :return "\u0049\u0041\u0044\u0048";case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";
case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";case IAIT :return "\u0049\u0041\u0049\u0054";case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";
case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";};};const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;
IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);func (_ec *codingContext )mps (_eg uint32 )int {return int (_ec ._caf [_eg ])};func (_eff *Encoder )encodeIAID (_ddfg ,_egf int )error {if _eff ._bb ==nil {_eff ._bb =_gb (1<<uint (_ddfg ));};_cg :=uint32 (1<<uint32 (_ddfg +1))-1;
_egf <<=uint (32-_ddfg );_cae :=uint32 (1);for _edc :=0;_edc < _ddfg ;_edc ++{_abe :=_cae &_cg ;_fc :=uint8 ((uint32 (_egf )&0x80000000)>>31);if _fcd :=_eff .encodeBit (_eff ._bb ,_abe ,_fc );_fcd !=nil {return _fcd ;};_cae =(_cae <<1)|uint32 (_fc );_egf <<=1;
};return nil ;};func (_ggad *Encoder )rBlock (){if _ggad ._caa >=0{_ggad .emit ();};_ggad ._caa ++;_ggad ._gf =uint8 (_ggad ._af >>20);_ggad ._af &=0xfffff;_ggad ._be =7;};func (_ab *Encoder )Init (){_ab ._gbc =_gb (_gggf );_ab ._ga =0x8000;_ab ._af =0;
_ab ._be =12;_ab ._caa =-1;_ab ._gf =0;_ab ._bgd =0;_ab ._bee =make ([]byte ,_aa );for _fg :=0;_fg < len (_ab ._bc );_fg ++{_ab ._bc [_fg ]=_gb (512);};_ab ._bb =nil ;};func (_efb *Encoder )code1 (_cbe *codingContext ,_gegd uint32 ,_gbbe uint16 ,_dbg byte ){if _cbe .mps (_gegd )==1{_efb .codeMPS (_cbe ,_gegd ,_gbbe ,_dbg );
}else {_efb .codeLPS (_cbe ,_gegd ,_gbbe ,_dbg );};};func (_eac *Encoder )emit (){if _eac ._bgd ==_aa {_eac ._bef =append (_eac ._bef ,_eac ._bee );_eac ._bee =make ([]byte ,_aa );_eac ._bgd =0;};_eac ._bee [_eac ._bgd ]=_eac ._gf ;_eac ._bgd ++;};func (_fda *Encoder )dataSize ()int {return _aa *len (_fda ._bef )+_fda ._bgd };
func (_aeg *Encoder )encodeInteger (_dfb Class ,_dcd int )error {const _cba ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";if _dcd > 2000000000||_dcd < -2000000000{return _bff .Errorf (_cba ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_dcd );
};_beb :=_aeg ._bc [_dfb ];_dbga :=uint32 (1);var _afe int ;for ;;_afe ++{if _ca [_afe ]._eb <=_dcd &&_ca [_afe ]._cf >=_dcd {break ;};};if _dcd < 0{_dcd =-_dcd ;};_dcd -=int (_ca [_afe ]._bd );_fge :=_ca [_afe ]._d ;for _gfc :=uint8 (0);_gfc < _ca [_afe ]._dd ;
_gfc ++{_caac :=_fge &1;if _dcf :=_aeg .encodeBit (_beb ,_dbga ,_caac );_dcf !=nil {return _bff .Wrap (_dcf ,_cba ,"");};_fge >>=1;if _dbga &0x100> 0{_dbga =(((_dbga <<1)|uint32 (_caac ))&0x1ff)|0x100;}else {_dbga =(_dbga <<1)|uint32 (_caac );};};_dcd <<=32-_ca [_afe ]._a ;
for _gaf :=uint8 (0);_gaf < _ca [_afe ]._a ;_gaf ++{_cce :=uint8 ((uint32 (_dcd )&0x80000000)>>31);if _bce :=_aeg .encodeBit (_beb ,_dbga ,_cce );_bce !=nil {return _bff .Wrap (_bce ,_cba ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");
};_dcd <<=1;if _dbga &0x100!=0{_dbga =(((_dbga <<1)|uint32 (_cce ))&0x1ff)|0x100;}else {_dbga =(_dbga <<1)|uint32 (_cce );};};return nil ;};func (_cafc *Encoder )Refine (iTemp ,iTarget *_f .Bitmap ,ox ,oy int )error {for _dec :=0;_dec < iTarget .Height ;
_dec ++{var _bcb int ;_cag :=_dec +oy ;var (_ddf ,_bgf ,_ccd ,_abc ,_bfg uint16 ;_bcd ,_geb ,_cab ,_fb ,_gg byte ;);if _cag >=1&&(_cag -1)< iTemp .Height {_bcd =iTemp .Data [(_cag -1)*iTemp .RowStride ];};if _cag >=0&&_cag < iTemp .Height {_geb =iTemp .Data [_cag *iTemp .RowStride ];
};if _cag >=-1&&_cag +1< iTemp .Height {_cab =iTemp .Data [(_cag +1)*iTemp .RowStride ];};if _dec >=1{_fb =iTarget .Data [(_dec -1)*iTarget .RowStride ];};_gg =iTarget .Data [_dec *iTarget .RowStride ];_bbe :=uint (6+ox );_ddf =uint16 (_bcd >>_bbe );_bgf =uint16 (_geb >>_bbe );
_ccd =uint16 (_cab >>_bbe );_abc =uint16 (_fb >>6);_ebf :=uint (2-ox );_bcd <<=_ebf ;_geb <<=_ebf ;_cab <<=_ebf ;_fb <<=2;for _bcb =0;_bcb < iTarget .Width ;_bcb ++{_gae :=(_ddf <<10)|(_bgf <<7)|(_ccd <<4)|(_abc <<1)|_bfg ;_ea :=_gg >>7;_gac :=_cafc .encodeBit (_cafc ._gbc ,uint32 (_gae ),_ea );
if _gac !=nil {return _gac ;};_ddf <<=1;_bgf <<=1;_ccd <<=1;_abc <<=1;_ddf |=uint16 (_bcd >>7);_bgf |=uint16 (_geb >>7);_ccd |=uint16 (_cab >>7);_abc |=uint16 (_fb >>7);_bfg =uint16 (_ea );_cbg :=_bcb %8;_gda :=_bcb /8+1;if _cbg ==5+ox {_bcd ,_geb ,_cab =0,0,0;
if _gda < iTemp .RowStride &&_cag >=1&&(_cag -1)< iTemp .Height {_bcd =iTemp .Data [(_cag -1)*iTemp .RowStride +_gda ];};if _gda < iTemp .RowStride &&_cag >=0&&_cag < iTemp .Height {_geb =iTemp .Data [_cag *iTemp .RowStride +_gda ];};if _gda < iTemp .RowStride &&_cag >=-1&&(_cag +1)< iTemp .Height {_cab =iTemp .Data [(_cag +1)*iTemp .RowStride +_gda ];
};}else {_bcd <<=1;_geb <<=1;_cab <<=1;};if _cbg ==5&&_dec >=1{_fb =0;if _gda < iTarget .RowStride {_fb =iTarget .Data [(_dec -1)*iTarget .RowStride +_gda ];};}else {_fb <<=1;};if _cbg ==7{_gg =0;if _gda < iTarget .RowStride {_gg =iTarget .Data [_dec *iTarget .RowStride +_gda ];
};}else {_gg <<=1;};_ddf &=7;_bgf &=7;_ccd &=7;_abc &=7;};};return nil ;};func (_bfgc *Encoder )codeMPS (_gca *codingContext ,_afb uint32 ,_dce uint16 ,_ecb byte ){_bfgc ._ga -=_dce ;if _bfgc ._ga &0x8000!=0{_bfgc ._af +=uint32 (_dce );return ;};if _bfgc ._ga < _dce {_bfgc ._ga =_dce ;
}else {_bfgc ._af +=uint32 (_dce );};_gca ._ad [_afb ]=_bda [_ecb ]._ffgg ;_bfgc .renormalize ();};func (_ef *codingContext )flipMps (_adg uint32 ){_ef ._caf [_adg ]=1-_ef ._caf [_adg ]};func (_dgfa *Encoder )byteOut (){if _dgfa ._gf ==0xff{_dgfa .rBlock ();
return ;};if _dgfa ._af < 0x8000000{_dgfa .lBlock ();return ;};_dgfa ._gf ++;if _dgfa ._gf !=0xff{_dgfa .lBlock ();return ;};_dgfa ._af &=0x7ffffff;_dgfa .rBlock ();};func (_cgg *Encoder )flush (){_cgg .setBits ();_cgg ._af <<=_cgg ._be ;_cgg .byteOut ();
_cgg ._af <<=_cgg ._be ;_cgg .byteOut ();_cgg .emit ();if _cgg ._gf !=0xff{_cgg ._caa ++;_cgg ._gf =0xff;_cgg .emit ();};_cgg ._caa ++;_cgg ._gf =0xac;_cgg ._caa ++;_cgg .emit ();};const _gbb =0x9b25;func (_dbb *Encoder )EncodeOOB (proc Class )(_fdf error ){_bf .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );
if _fdf =_dbb .encodeOOB (proc );_fdf !=nil {return _bff .Wrap (_fdf ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};func (_db *Encoder )EncodeIAID (symbolCodeLength ,value int )(_aba error ){_bf .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );
if _aba =_db .encodeIAID (symbolCodeLength ,value );_aba !=nil {return _bff .Wrap (_aba ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};func (_dgf *Encoder )Flush (){_dgf ._bgd =0;_dgf ._bef =nil ;_dgf ._caa =-1};func (_add *Encoder )encodeBit (_gge *codingContext ,_ag uint32 ,_cbgg uint8 )error {const _bga ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";
_add ._bg ++;if _ag >=uint32 (len (_gge ._ad )){return _bff .Errorf (_bga ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_ag );
};_fbc :=_gge ._ad [_ag ];_gga :=_gge .mps (_ag );_fa :=_bda [_fbc ]._cbad ;_bf .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_add ._bg ,_cbgg ,_fbc ,_gga ,_fa ,_add ._ga ,_add ._af ,_add ._be ,_add ._gf ,_add ._caa );
if _cbgg ==0{_add .code0 (_gge ,_ag ,_fa ,_fbc );}else {_add .code1 (_gge ,_ag ,_fa ,_fbc );};return nil ;};type Encoder struct{_af uint32 ;_ga uint16 ;_be ,_gf uint8 ;_caa int ;_bg int ;_bef [][]byte ;_bee []byte ;_bgd int ;_gbc *codingContext ;_bc [13]*codingContext ;
_bb *codingContext ;};func (_ggg *Encoder )WriteTo (w _b .Writer )(int64 ,error ){const _fba ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";var _ae int64 ;for _gaa ,_gc :=range _ggg ._bef {_eec ,_dde :=w .Write (_gc );
if _dde !=nil {return 0,_bff .Wrapf (_dde ,_fba ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_gaa );};_ae +=int64 (_eec );};_ggg ._bee =_ggg ._bee [:_ggg ._bgd ];
_ecd ,_da :=w .Write (_ggg ._bee );if _da !=nil {return 0,_bff .Wrap (_da ,_fba ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_ae +=int64 (_ecd );return _ae ,nil ;};func (_gdg *Encoder )Final (){_gdg .flush ()};
var _ca =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};
func (_ffg *Encoder )code0 (_fbe *codingContext ,_dda uint32 ,_gffg uint16 ,_efd byte ){if _fbe .mps (_dda )==0{_ffg .codeMPS (_fbe ,_dda ,_gffg ,_efd );}else {_ffg .codeLPS (_fbe ,_dda ,_gffg ,_efd );};};func (_ega *Encoder )renormalize (){for {_ega ._ga <<=1;
_ega ._af <<=1;_ega ._be --;if _ega ._be ==0{_ega .byteOut ();};if (_ega ._ga &0x8000)!=0{break ;};};};type codingContext struct{_ad []byte ;_caf []byte ;};type intEncRangeS struct{_eb ,_cf int ;_d ,_dd uint8 ;_bd uint16 ;_a uint8 ;};func _gb (_cd int )*codingContext {return &codingContext {_ad :make ([]byte ,_cd ),_caf :make ([]byte ,_cd )};
};var _ _b .WriterTo =&Encoder {};type Class int ;func (_gff *Encoder )DataSize ()int {return _gff .dataSize ()};func (_edg *Encoder )setBits (){_cagc :=_edg ._af +uint32 (_edg ._ga );_edg ._af |=0xffff;if _edg ._af >=_cagc {_edg ._af -=0x8000;};};const (_gggf =65536;
_aa =20*1024;);func (_ecea *Encoder )lBlock (){if _ecea ._caa >=0{_ecea .emit ();};_ecea ._caa ++;_ecea ._gf =uint8 (_ecea ._af >>19);_ecea ._af &=0x7ffff;_ecea ._be =8;};func (_gec *Encoder )EncodeInteger (proc Class ,value int )(_bfb error ){_bf .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );
if _bfb =_gec .encodeInteger (proc ,value );_bfb !=nil {return _bff .Wrap (_bfb ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};func New ()*Encoder {_ba :=&Encoder {};_ba .Init ();return _ba };func (_cfe *Encoder )encodeOOB (_gege Class )error {_cac :=_cfe ._bc [_gege ];
_gde :=_cfe .encodeBit (_cac ,1,1);if _gde !=nil {return _gde ;};_gde =_cfe .encodeBit (_cac ,3,0);if _gde !=nil {return _gde ;};_gde =_cfe .encodeBit (_cac ,6,0);if _gde !=nil {return _gde ;};_gde =_cfe .encodeBit (_cac ,12,0);if _gde !=nil {return _gde ;
};return nil ;};func (_bbg *Encoder )Reset (){_bbg ._ga =0x8000;_bbg ._af =0;_bbg ._be =12;_bbg ._caa =-1;_bbg ._gf =0;_bbg ._bb =nil ;_bbg ._gbc =_gb (_gggf );};func (_bcc *Encoder )codeLPS (_ebfb *codingContext ,_eef uint32 ,_cbd uint16 ,_ece byte ){_bcc ._ga -=_cbd ;
if _bcc ._ga < _cbd {_bcc ._af +=uint32 (_cbd );}else {_bcc ._ga =_cbd ;};if _bda [_ece ]._afed ==1{_ebfb .flipMps (_eef );};_ebfb ._ad [_eef ]=_bda [_ece ]._effg ;_bcc .renormalize ();};type state struct{_cbad uint16 ;_ffgg ,_effg uint8 ;_afed uint8 ;
};