之前本地有写过挺多的开发代码，如今长时间不用，作删除处理，记录一下。

首先是各种打印，各种校验，各种链接，各种测试，比如 chan 获取值退出打印

```
var ch = make(chan int, 10)

func main() {
	ch <- 23
	ch <- 21
	ch <- 22
	ch <- 2
	res := GetData(ch)
	fmt.Println("res: ", res)
}

func GetData(ch chan int) int {
	var res int
	for {
		select {
		case v, ok := <-ch:
			if ok && v%2 == 0 {
				res = v
				goto Exist
			}
		}
	}
Exist:
	return res
}
```

比如多态打印

```
package main

import "fmt"

type S struct {
}

func NewS() SI {
	return &S{}
}

func (c *S) Sum(a, b int) int {
	return a + b
}

func (c *S) Pt(a int) {
	fmt.Println("num: ", a)
}

type SI interface {
	Sum(a, b int) int
	Pt(a int)
}

func main() {
	i := NewS()
	sr := i.Sum(1, 2)
	fmt.Println("res: ", sr)
	i.Pt(3)
}
```

比如二分查找

```
package main

import "fmt"

func main() {
	ErFenDo()
}

func ErFenDo() {
	// 1- 100 ，获取33，使用二分法

	dest := 33
	mid := 0
	start := 0
	end := 100

	for start < end {
		mid = (start + end) / 2
		fmt.Println(mid)
		if mid == dest {
			break
		}
		if mid > dest {
			end = mid
		} else {
			start = mid
		}
	}
}
```

比如任务流程处理

```
package main

import (
	"fmt"
	"sync"
	"time"
)

func main() {
	PublishStart()
	defer PublishStop()
	for {
		select {}
	}
}

type publishCheckSrv struct {
	stop        chan bool
	waitChan    chan checkNode // 等待发布
	waitNodeMap map[uint64]checkNode
	waitMtx     *sync.Mutex
	pubChan     chan checkNode // 发布
	pubNodeMap  map[uint64]checkNode
	pubMtx      *sync.Mutex
	doneChan    chan uint64 // 完成发布id
}
type checkNode struct {
	pubID       uint64    // pubID
	SuccessTime time.Time // 发布时间 （发布时间不能早于该时间）
}

func NewPublishCheckSrv() *publishCheckSrv {
	return &publishCheckSrv{
		stop:        make(chan bool),
		waitChan:    make(chan checkNode, 30),
		waitNodeMap: make(map[uint64]checkNode),
		waitMtx:     &sync.Mutex{},
		pubChan:     make(chan checkNode, 30),
		pubNodeMap:  make(map[uint64]checkNode),
		pubMtx:      &sync.Mutex{},
		doneChan:    make(chan uint64, 30),
	}
}

var (
	PubCheckSrv = NewPublishCheckSrv()
)

// PublishStart 开始
func PublishStart() error {
	go PubCheckSrv.check()
	go PubCheckSrv.batchMessageReceive()
	return nil
}

func PublishStop() {
	PubCheckSrv.stop <- true
	<-PubCheckSrv.stop
}

func (s *publishCheckSrv) AddWait(node checkNode) {
	/*
		指定时间段前加入等待任务，正常代码中 该处用于获取要处理的任务
	*/
	if time.Now().UnixNano()/1e6 > 1693380260000 {
		return
	}
	if node.pubID <= 0 {
		node.pubID = uint64(time.Now().UnixNano() / 1e6)
		node.SuccessTime = time.Now().Add(time.Second * 5)
	}
	fmt.Printf("---------- 加入等待: %v, 等待完成时间: %v\r\n", node.pubID, node.SuccessTime.Format("2006-01-02 15:04:05"))
	s.waitChan <- node
	return
}

func (s *publishCheckSrv) RemoveWait(id uint64) {
	if id <= 0 {
		return
	}
	s.waitMtx.Lock()
	delete(s.waitNodeMap, id)
	s.waitMtx.Unlock()
	return
}

func (s *publishCheckSrv) AddPub(node checkNode, isWithTime bool) {
	if !isWithTime {
		node.SuccessTime = time.Now().Add(time.Second * 5)
	}
	fmt.Printf("-=-=-=-=-=-=-= 加入发布: %v, 发布完成时间：%v\r\n", node.pubID, node.SuccessTime.Format("2006-01-02 15:04:05"))
	s.pubChan <- node
	return
}

func (s *publishCheckSrv) RemovePub(id uint64) {
	if id <= 0 {
		return
	}
	s.pubMtx.Lock()
	delete(s.pubNodeMap, id)
	s.pubMtx.Unlock()
	return
}

func (s *publishCheckSrv) AddDone(cid uint64) {
	fmt.Println("=================== 加入完成: ", cid)
	s.doneChan <- cid
	return
}

func (c *publishCheckSrv) batchMessageReceive() {
	for {
		select {
		case msg := <-c.waitChan:
			c.waitMtx.Lock()
			c.waitNodeMap[msg.pubID] = msg
			c.waitMtx.Unlock()
		case msg := <-c.pubChan:
			c.pubMtx.Lock()
			c.pubNodeMap[msg.pubID] = msg
			c.pubMtx.Unlock()
		}
	}
}

func (s *publishCheckSrv) check() {
	tickWaitAdd, tickPubAdd, tickCheckPub := time.NewTicker(time.Second*3), time.NewTicker(time.Second*3), time.NewTicker(time.Second*4)
	for {
		select {
		case <-s.stop:
			{
				goto EXIT
			}

		case <-tickWaitAdd.C:
			{
				s.AddWait(checkNode{})
			}
		case <-tickPubAdd.C:
			s.CheckWait()
		case <-tickCheckPub.C:
			s.CheckPub()
		case id, ok := <-s.doneChan:
			{
				if ok == false {
					continue
				}
				s.printDone(id)
			}
		}
	}
EXIT:
	tickWaitAdd.Stop()
	tickCheckPub.Stop()
	s.stop <- true
	fmt.Println("publish check service stop...")
}

func (s *publishCheckSrv) CheckWait() {
	nodeMap := s.waitNodeMap
	for _, node := range nodeMap {
		sub := node.SuccessTime.Sub(time.Now()).Seconds()
		fmt.Printf("node id %v 距离加入发布还有 %v 秒\r\n", node.pubID, -sub)
		if sub > 0 {
			s.AddPub(checkNode{pubID: node.pubID}, false)
			s.RemoveWait(node.pubID)
		}
	}
}

func (s *publishCheckSrv) CheckPub() {
	nodeMap := s.pubNodeMap
	for _, node := range nodeMap {
		sub := node.SuccessTime.Sub(time.Now()).Seconds()
		fmt.Printf("node id %v 距离发布完成还有 %v 秒\r\n", node.pubID, sub)
		if sub > 0 {
			s.AddDone(node.pubID)
			s.RemovePub(node.pubID)
		}
	}
}

func (s *publishCheckSrv) printDone(cid uint64) {
	fmt.Printf("**************** hasDone %v **********************\n", cid)
	return
}
```

定时器打印

```
package main

import (
	"fmt"
	"github.com/robfig/cron/v3"
	"log"
	"os"
	"time"
)

func RunCron() {
	c := cron.New(cron.WithSeconds(), cron.WithChain(cron.SkipIfStillRunning(cron.DefaultLogger)), cron.WithLogger(
		cron.VerbosePrintfLogger(log.New(os.Stdout, "cron: ", log.LstdFlags))))
	i := 1
	EntryID, err := c.AddFunc("*/5 * * * * *", func() {
		fmt.Println(time.Now(), "每5s一次----------------", i)
		//time.Sleep(time.Second * 6)
		i++
	})
	fmt.Println(time.Now(), EntryID, err)

	c.Start()
	select {}
}

func main() {
	RunCron()
}
```

回调函数，闭包函数

```
 type CallBack func(x,y int) int

  func adder(x,y int) int {
      return x + y
  }

  func minux(x,y int) int  {
     return  x -y
  }
  
  func testCallBack(x,y int, CB CallBack) int  {
     return CB(x,y)
  }
  
  
  func main(){
      testCallBack(1,2,adder)
      testCallBack(1,2,minux)
  }
  
  -------------------------------------
  	l := bT01()("hah")
    fmt.Println("length:",l)


    func bT01() func(s string) int {
        return func(s string) int {
            length := len(s)
            return length
        }
    }
```



redis-queue, sm3,md5字符串加密，图片，文本爬取，grpc-conn,http-conn,websocket, 密码本，加密文件小工具 等
